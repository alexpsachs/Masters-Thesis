{
    "getaaron": "\"is a `nil`\" should just be \"is `nil`\".\n. \"is a `nil`\" should just be \"is `nil`\".\n. ",
    "jklausa": "Thanks!\n. Thanks!\n. ",
    "radex": "Looks good! Thanks @jklausa @getaaron \n. Great stuff! \ud83c\udf89 Thanks @maximkhatskevich!\n. FYI @maximkhatskevich I'm still recommending to just copy the project's file to your project over CocoaPods because: a) Swift support in CocoaPods isn't shipped yet, and b) it won't work on iOS 7 AFAIK.\n. This is a consequence of how objectForKey works. Integers, doubles and booleans are all encoded as NSNumber. There is no API to check for user defaults type (it is held _somewhere_, as you can see by trying `defaults read-type ...`, but it's not exposed to NSUserDefaults).\n\nSo, 100 == true, and 0 == false, because that's what NSNumber does.\n\nDo you think it's a good idea to make \"true\", \"false\", \"1\", \"0\" convertible to bool? How does `boolForKey` react to those values?\n. Does it work reliably though? The last time I looked into this, NSNumber did _not_ promise (at all) that the representation of booleans would be explicitly as booleans. It just thought it's the same as ints\u2026\n. Hm. It's super annoying, though, because internally, defaults does store the type \u2014 it's just that NSNumber doesn't, and AFAIK there's no API to check for key's type :( \n. With http://radex.io/swift/nsuserdefaults/static/ and the `next` branch, I'd rather have people define the defaults keys they want to use statically, explicitly stating the type they want to use, and not rely on dynamic casting behavior. So this doesn't matter much anymore.\n. Thanks @picciano, but this is too magic and implicit for my taste. I share your dislike for the inconsistency (with bool/int/double), but I don't think this is the solution.\n. Thanks @narfdotpl!\n\nAny specific reason why you wrote `.map { $0 as! NSObject }` instead of `as! NSObject?` or `as? NSObject`?\n. Right. `.map { $0 as! NSObject }`, AFAICT, has the exact same behavior as `as! NSObject?`. It could crash if the cast failed, but it won't fail ;)\n\nI liked `as NSObject?`, but now that the exclamation mark is shouting \"DANGER\" at me, I think `as? NSObject` is best here.\n. Looks great. Thank you @narfdotpl! \u2728\ud83c\udf89\n. Type `pod --version` in your command line. It should say something like \"0.36.0.beta1\". If it says \"0.35.0\", you have an old version of CocoaPods that doesn't support Swift pods.\n. That's odd. I'm sorry, but I don't know how to help :( \n. Have you tried other Swift-based pods? Does the same issue occur? Try looking for or asking about this on Stack Overflow\u2026\n. Not sure why you'd prefer to check for nil instead of using `hasKey`, but try this:\n\n`Defaults[\"firstInstallDate\"].object == nil`\n\nThe subscript itself always returns a `NSUserDefaults.Proxy`, so it will never be nil.\n. Very interesting! Thanks @phimage. Not sure I understand, though, what's the benefit of writing `Defaults[\"foo\"][\"bar\"]` over `Defaults[\"foo.bar\"]`?\n. I don't understand why prefix your defaults with something like a bundle name? I mean, the standardUserDefaults are already scoped to your app only.\n. Hm. That's a fair point, though I would say it's the 3rd party frameworks' responsibility to prefix the stuff they save in my user defaults\u2026\n\nLet me think about this\u2026\n. You're right! I'll merge it in later today :)\n. Alright, done! I merged to master and cut a new release: 1.1.0. I haven't tested it with CocoaPods but it should work just fine.\n\nThanks for the reminded @jschmid!\n\nPS. \"later today\", LOL.\n. I appologize for not replying before. I couldn't reproduce your problem.\n\nCould you try it again with CocoaPods 0.37.1?\n. Great, glad to hear that!\n. Carthage support would be great, but I'm not familiar with the system myself\u2026 I'd definitely be willing to merge it in if someone prepared a pull request.\n. Added by @alec-c4 via #14 :)\n. Apologies to have kept you waiting. I'll do my best to properly test your code in the weekend (I don't have experience with Carthage) and unless there's some issue, I'll merge it in :)\n. Hey @alec-c4 . I haven't forgot about it, I'm just terribly, _embarrassingly_ bad at side projects and keeping commitments related to them.\n\nI took a look at your changes, played with Carthage, and it all looks great. Thank you for your work and sorry I kept you waiting so long.\n. I'm not familiar with using NSKeyedArchiver with NSUserDefaults \u2014 I'm not sure if it's a common pattern or not.\n\nIf it is, I'd be definitely happy to add a pair of helpers for writing/accessing archived objects to the user defaults.\n\n**If anyone is interested in this feature, please give your feedback below \u263a\ufe0f**\n. Cool. @pellekrogholt @tbaranes @katopz any specific suggestions as for the API you'd like to see for (de)serializing NSObjects?\n. @katopz @pellekrogholt @tbaranes Thanks for bringing this to my attention. I think I have a pretty great solution on the `next` branch. Check out http://radex.io/swift/nsuserdefaults/static/ for more background and explanation. Let me know what you think!\n. Thanks @rad3ks, but #14 already added Carthage support (it just took me a while to get it merged).\n\nCould you elaborate about why `XCTAssert` is better than `assert`? I mean, I know the latter doesn't integrate with Xcode, but for the purposes of this project, it works fine. What do you mean about running for \"each platform individually\"?\n. No, the only issue is `println` in the test target. \n. Still, surprising we didn't need any changes really in this library :)\n. Sorry, I forgot to push a new release. Should work now.\n\n(FWIW, the new tag only introduces Carthage support, so v1.1 is functionally the same)\n. That _does_ look useful. Not sure about `NSDate()` since it represents the current, not \"empty\" date, but 0, [], [:], \"\", etc. often do make sense.\n. Still don't know about this\u2026 Is 1970 a natural, obvious \"null value\" that we want people to use, implicitly?\n. Hm, I'll think about this.\n\nNot merging this PR just yet, but I will ;)\n. Merged. Thanks.\n\nI removed `objectValue` and `dateValue` before merging. I'm not convinced of the usefulness of their default value behavior. I'd rather people do this explicitly.\n\n(If people complain about this and make a convincing argument for it, I'll put it back.)\n. Thanks. I'll take a look at this in spare time.\n. Thanks for the pull request, Xavi.\n\nTwo notes:\n1. I wish you hadn't reordered tests the way you did. Grouping them by SwiftyUserDefaults' function makes more sense than grouping them by a user default type.\n2. Clearing of the user defaults was done in setUp on purpose. Yes, it's good to clean up after yourself, but we don't want garbage from _previous_ tests interfering with our tests. So it should definitely be done before tests.\n. No specific reason as far as I can remember. \n. Thanks @kaunteya. I intend to merge this, but I'm going to hold off until a 2.0 release, since changing the return types might break things.\n. Thanks again. Sorry for not responding for so long. I originally merged those changes to `next`, but the end, I don't think I want to change it. The reason why is because I think the new approach in the `next` (2.0) branch is much better (give this a read for more info: http://radex.io/swift/nsuserdefaults/static/) and I want to promote that instead. I'm going to treat the `Proxy`-based API as legacy, probably deprecate it eventually, and so I'd rather just not change anything.\n. Thanks! Glad you like it. \n. Oops, thanks. \n. Thank you! I merged your changes into the `next` branch here: https://github.com/radex/SwiftyUserDefaults/commit/d2b749109ae47404e678144a74d31194bfedd5a5\n. Thanks @kohtenko, but the `++` and `+=` operators in SwiftyUserDefaults have really confusing and potentially dangerous semantics. I don't like them anymore.\n\nCheck out http://radex.io/swift/nsuserdefaults/static/ and the `next` branch. Swift's `--` and `-=` just work out of the box with the new approach.\n. Please be more specific. Why do you want to override the Proxy class? Real world examples, please. \n. I'm going to close this now. Let me know if you have a good argument for making it public.\n. Thanks for the PR. Having URL support would certainly make sense.\n\nCan you elaborate on the `?=` problem you're describing? `?=` shouldn't be used with `nil` \u2014 it just doesn't make sense to assign a `nil` to something when it's `nil`\u2026\n. That sounds like a Swift bug. Have you filed a radar?\n. Okay, thanks for letting me know. I'll think about it. I just don't want to make it look like you're supposed to pass an optional to `?=` \u2014 you're not.\n. I added `NSURL` support on the `next` branch. Thanks again!\n. You must be using the old version of the library\n. It should be 1.3.0\n. Have you tried running pod update?\n. Thank you! I merged that into the `next` branch \u2014 can you verify it works?\n. This is `NSUserDefaults` concern \u2014 SwiftyUserDefaults is just a wrapper around this. Hopefully, people are now dropping support for iOS 7 ahead of iOS 9 and this won't matter anymore. Thanks.\n. Done on the `next` branch. Thanks!\n. Hey @IdoBn, thanks for this, check out the `next` branch for Swift 2 compatibility and some cool new stuff :)\n. That's what I get for changing things in the last minute. Thanks!\n. Thanks.\n. That would be more confusing than helpful. \"Right now\" is not an obvious, universally-correct default value for a date. I'd rather have you use `?? NSDate()` explicitly if that's what you want.\n. 0 is \"empty\", `false` is empty, `\"\"` is empty\u2026 \"right now\" isn't empty.\n. Exactly the kind of thing I'm worried about. Seems faaaaar less likely to do such a mistake with default values for other types. \n. What a perfect piece of evidence that accidental `NSDate`/`NSData` typos happen ;)\n. Thanks @jschmid!\n. I guess the way I'd do it is:\n\n```\nfor (key, _) in Defaults.dictionaryRepresentation() {\n            Defaults.removeObjectForKey(key)\n}\n```\n\nbut yeah, it wouldn't be too bad to have a shortcut for that in SwiftyUserDefaults.\n. I added `Defaults.removeAll()` in 1ac8701. Hope this solves it.\n. no, that's a mistake\u2026 Should support 10.9 and up\u2026\n. Soon. I want to ship the 2.0 tonight. \n. Fixed, thanks for letting me know about this!\n. I did mention it in the post. Subscripts don't support generic constraints in Swift 2. Which makes me very sad. (But from API consumer point of view, I still like this better than the alternative)\n. Also a cool approach, but I like SUD's syntax better, and some of the semantics and safety with getting/setting ;)\n. Do it and I'll merge it ;)\n. @staticdreams that'd be great \u2014 if you don't mind making a PR, I'll merge it :) \n. Thanks @Antoine4011 @mathiasnagler! I'm closing this PR as #53 is newer :) \n. Thanks!\n. A few reasons:\n1. Syntax. I like the dictionary-like feel of `Defaults[.prop]` vs `Defaults.prop.value`.\n2. And it's a little bit shorter\n3. And that it feels like it makes a bit more sense with you subscripting a collection, not calling \"value\" on the key itself\n4. If you're not using the standard user defaults, but some other NSUserDefaults (e.g. shared defaults in an app group), you can just subscript a different defaults object \u2014 the key object only describes the key, not the collection\n\nYeah, it's kind of an implementation PITA, but I'm not concerned with that in this project \u2014 it's not an approach I would usually take, but I slightly prefer this approach to what you're suggesting. I'm cool with magic.\n. This is a problem with the underlying Apple framework, not my code.\n\nThe synchronize stuff only matters in iOS 7. You're not supposed to use it in later versions. \n. It should be. \n. It doesn't. Do it yourself if you need to support iOS 7. Otherwise, do nothing. \n. Why do you want to use `Float` and not `Double`?\n. Hm. Lack of support for floats was a deliberate decision -- Swift strongly recommends just using Double everywhere. The fact that UISlider reports Float -- I consider that an interop limitation. \n. Nope. Swift encourages people to just use Int and Double. Float is great when you **need** the efficiency \u2014 that is, when you have significant arrays of them (SCNVector3 is probably a good use case, I think). Otherwise, it just doesn't matter.\n. I don't want to teach people bad habits. It's not difficult to cast to/from Double :) . > ld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.1.sdk/Developer/Library/Frameworks'\n\n@mrahmiao do you still have this problem? The other warnings are working as designed.\n. Ah, nevermind, I see the same warning. Not sure what's the cause but I'll accept a fix.\n. @ton03 I'll accept a patch.\n. @ton03 I no longer reproduce any warnings except for deprecation warnings (working as intended) while updating with carthage. I'm closing this issue, but let me know if you can still see the problem.\n. > This code which is recommended does not autocomplete:\n\nOh well. Xcode\u2014Swift integration is not yet as good as I'd like it to be. This sort of thing generally auto-completes (with enum cases and all), but apparently not here. (Not yet, anyway)\n\n> Obviously there is a bad design decision on the name. Please change it so it is clear what Keys and Key does.\n\nThe only purpose for both classes existing is to work around compiler limitations. Explained here: http://radex.io/swift/nsuserdefaults/static/\n\n> This works and autocompletes:\n> \n>    var userDefault = Defaults[DefaultsKeys.userId]\n> But, this does not work:\n\nWorks for me \u2014 what's the DefaultsKeys.userId implementation?\n\n> Maybe some shortcut like:\n> var userDefault = Defaults[Defs.userId]\n> might be useful\n\nGo ahead, define a `Defs` struct \u2014 also an approach I'm cool with (again: http://radex.io/swift/nsuserdefaults/static/). There's nothing magical about `DefaultsKeys` except for the fact that it allows for the shortcut `.foo`. If you don't like the dot-shortcut syntax because it doesn't play well with autocompletion, you don't have to use it.\n. Having statically-defined default values would be very nice indeed. I need to consider more closely if there's a nice way to achieve that given current Swift limitations (no generic subscripts, no extending generic types, etc...)\n\nCould you explain this bit?\n\n```\nDefaultsKey<String, UIColor>([\"color\": UIColor.grayColor()])\n```\n\nWhy does it have two type params and a dictionary \u2014 I don't get it?\n. Thanks!\n. Thanks @mathiasnagler!\n. That was quick, thanks!\n. Extend DefaultsKeys, not DefaultsKey -- the whole purpose of the former is to work around this compiler limitation\n. Thanks :)\n. @staticdreams Apologies for not doing it months ago. I've just released v2.1.0\n. Awesome work!\n\nOne thing annoys me, API design-wise: so far, we used optionals in the type parameter `String` vs `String?` to convey whether a key should be returned as optional or with a default value.\n\nAdding custom default values makes this possibly confusing a bit, because it doesn't make any sense to have a `T?` defaults key with a custom default value defined.\n\nI want to think of ways to clarify this if possible and disallow the behavior that doesn't make any sense.\n\nIdeas? Discussion welcome.\n. I would do a quick crash, as this should just be illegal (IMHO). Would be best to have this checked at compile-time, but I'm not sure what's the best approach. Don't like the idea of subclassing DefaultsKey much.\n. Hm, is there no way to do this without defining a new protocol?\n\nAlso: you should use precondition()\n. Agree, it makes sense. I would call the protocol `OptionalType`, for consistency with other protocol names. (Not that it makes a huge difference \u2014\u00a0it's private anyway).\n\nAlso, what I meant by using `precondition` was to drop the `guard` altogether:\n\n```\nprecondition(!(defaultValue is OptionalType), \"Failure message\")\n```\n. Yes, a more versatile solution would be great \n. Alright all:\n1. I would be happy to add support for easy serialization of `RawRepresentable` values. Indeed, this would be great for enums\n2. I would also be cool with adding a protocol like `SwiftyUserDefaultsSerializable` for (un)archiving of any custom, Swift-only type. (Unless someone has a better idea of how to solve it).\n\nPR-s are very welcome.\n. @staticdreams Yes, but not directly. If your enum is RawRepresentable, you can store the underlying value via `.rawValue`, then recreate it when reading using `init?(rawValue:)`.\n\nYou can quite easily extend `NSUserDefaults` to add a subscript for `DefaultsKey<YourEnumType>` that does this behind the scenes for you.\n\nThis should be simpler.\n. \u2705 Added easy RawRepresentable support in SwiftyUserDefaults 2.2\n\nStill no `SwiftyUserDefaultsSerializable`, because then you have to write _both_ an NSUserDefaults extension _and_ an extension on your own type. Until we can get the proper subscripts automatically (maybe Swift 3), it's not really much better\u2026 I could, however, document how to add support for completely custom types\u2026\n. > I guess the other warnings are not meant to be resolved?\n\nIf they're coming from my code then no.\n. Thanks \u2014 I hope this actually compiles ;)\n. This is a cool idea, but out of scope for this library.\n. Yeah, that should be simpler, but swift compiler limitations don't allow me. \n. Thank you.\n. @ajaysinghthakur Please use Stack Overflow in the future, as this isn't an appropriate place to ask this kind of questions.\n\n@ed-mejia is right, this code will work:\n\n``` swift\nfor (key, _) in Defaults.dictionaryRepresentation() {\n     Defaults.removeObjectForKey(key)\n }\n```\n. @ajaysinghthakur there is a tag: http://stackoverflow.com/questions/tagged/swiftyuserdefaults\n. > I just got that error too. I assume the library doesn't support multidimensional arrays?\n\nNo, it doesn't. Until Swift becomes more powerful, you can only define and use `DefaultsKey` on one of the supported types. You can, however, quite easily extend `NSUserDefaults` and add support for a given DefaultsKey type.\n. @toshi0383 Very cool! I understand this works regardless of whether or not SwiftyUserDefaults is used? i.e. if someone sets a value using plain old NSUserDefaults API, this will still work?\n. Thanks \u2014 I'll review it more closely when I have more time, but could you explain to me the design of this code in the meantime? Like, why are there three `observe*` methods, what's the purpose of BlockDisposable and RecursiveLock?\n. Beginning iOS 9.3, you can actually observe changes made to your user defaults from outside the app:\n\nhttps://twitter.com/Catfish_Man/status/711972673367052288\n\nVery cool.\n. Nice. The problem is \u2014 why should `[[Bool]]` be the special exception?\n\nUntil we can express automatic support for any reasonable key type in Swift, I suggest:\n- we drop the [[Bool]] support\n- we add `getTwoDimensionalArray` a user can use\n- add a note to README as for how to add support for additional types like this.\n\nI would be happy to merge that.\n\nAnd if you were inclined to also add support for arbitrary dictionaries the same way (only `[String: AnyObject]` is supported out of the box), that would be awesome.\n. > We should be able to have automatic support for the common keys, I am not sure how that will work.\n\nNot possible without generic subscripts.\n. No, this really doesn't work. https://bugs.swift.org/browse/SR-115 tracks this issue. \n. @MaxHasADHD I don't understand what you're trying to say \u2014 can you elaborate?\n. OK, got it. #59 was proposing an alternative to using `registerDefaults`, instead, embedding the default value in the DefaultsKey definition.\n\nThe latter definitely seems cleaner, but `registerDefaults` has the advantage of working across NSUserDefaults, whether or not you actually use SwiftyUserDefaults **and** those key values.\n. Please **do not** store sensitive data in user defaults. It's not meant for it, and it's unsafe to do so.\n\nI have no plans for encryption. SwiftyUserDefaults is a Swifty API for NSUserDefaults, nothing more.\n. I'm not really comfortable extending the `Proxy` getters, because I think the way to go forward is to use statically-typed keys instead of the old stringly-typed API...\n\nI think I can merge it anyway, but please open a pull request.\n. Done thanks to valentinknabel.\n. @BalestraPatrick did the work to prepare travis config, but I still have to set it up on my end.\n. boom, works! Thanks again, @BalestraPatrick!\n. Awesome, thank you Patrick!\n. Thank you!\n. When I try it out (I ran `swift build` from the gist folder), I get this:\n\n> 8bbef2f345adfe2724d8-582ed4741b0e88b3ee25e292fde1a333657ae0ca \u00bb swift build                                                                                                                         ~/Downloads/8bbef2f345adfe2724d8-582ed4741b0e88b3ee25e292fde1a333657ae0ca\n> Cloning Packages/SwiftyUserDefaults\n> /Users/radex/Downloads/8bbef2f345adfe2724d8-582ed4741b0e88b3ee25e292fde1a333657ae0ca/Packages/SwiftyUserDefaults/Package.swift:4:22: error: incorrect argument label in call (have 'exclude:dependencies:', expected 'name:dependencies:')\n> let package = Package(\n>                      ^\n> swift-build: exit(1): [\"/Library/Developer/Toolchains/swift-2.2-SNAPSHOT-2015-12-01-a.xctoolchain/usr/bin/swiftc\", \"--driver-mode=swift\", \"-I\", \"/Library/Developer/Toolchains/swift-2.2-SNAPSHOT-2015-12-01-a.xctoolchain/usr/lib/swift/pm\", \"-L\", \"/Library/Developer/Toolchains/swift-2.2-SNAPSHOT-2015-12-01-a.xctoolchain/usr/lib/swift/pm\", \"-lPackageDescription\", \"-target\", \"x86_64-apple-macosx10.10\", \"/Users/radex/Downloads/8bbef2f345adfe2724d8-582ed4741b0e88b3ee25e292fde1a333657ae0ca/Packages/SwiftyUserDefaults/Package.swift\"]\n\nAny clues? Apologies if I'm doing something totally dumb \u2014 I've never used swift pm before\n. Okay, I must be completely blind, my PATH was pointing at a December snapshot of swift\n. IT WORKS :D Thank you @valentinknabel.\n. Thanks.\n. Let me know if I need to cut a new version for this to work automatically \u2014 I don't know much about Carthage.\n. Okay, I think https://github.com/radex/SwiftyUserDefaults/pull/77 fixes just this issue \u2014 can you verify it? I think I have to cut a new release tag.\n. Regarding deprecations: people still use those. I would have to cut a 3.0 to remove them. I could also lose the warnings if I removed tests for them, but hey, again, people still use them. I wish I could silence Swift deprecation warnings, but I don't think I can. (the deprecations, after all, are meant for the users, not my test target)\n. OK, I just pushed 2.1.3 with the fix and also found a way to suppress deprecation warnings. Let me know if there's still a problem.\n. One way is to just define in your app:\n\n`var SomeOtherDefaults = NSUserDefaults(...)`\n\nand use that instead of `Defaults`.\n\nWould that fix it for you? Or do you need the ability to quickly switch between arbitrary suites?\n. > I think it'd be handy to set global suiteName once, somewhere early (e.g. in AppDelegate):\n> Defaults.suiteName = \"group.my.appGroup\"\n\nI'd much prefer the declarative version:\n\n```\nvar Defaults = NSUserDefaults(suiteName: ...)\n```\n\nThis is cleaner to me, and has the advantage that you can put it in a separate file you can share between targets...\n. >  you may loose data saved to defaults unless you manually call Defaults.synchronize() each time you change something because the system may kill the process suddenly, to the best of my understanding (and in the case of running from Xcode, if you stop the project just at the right time, it won't save either).\n\nYou could be right, but all I keep hearing (from @Catfish-Man on Twitter, mostly) is that calling `synchronize()` is simply not necessary.\n. @Catfish-Man Thank you for the info!\n. Ok, so:\n- synchronize seems to be unnecessary save for some very extreme conditions, so I don't see a reason to add it to SUD\n- you can define a `var Defaults = NSUserDefaults(suiteName: ...)` in your own module to shadow the `Defaults` shortcut defined by the library.\n\nI'm closing this for now, but let me know if I missed something from the discussion.\n. Very cool work. I have reservations about this, because using a plist to register defaults means you don't get any type checking by the compiler \u2014 i.e. no way to verify correctness of your registered defaults. For example if you try to rename a default during development, but forget to change your plist, you'll have created a bug.\n\nI think the approach I would prefer to promote is a statically typed one, like so:\n\n```\nDefaults.register([\n     .userName: 'radex',\n     .launchCount: 0,\n])\n```\n\n(The actual implementation and syntax would be trickier, but I think you get the point.)\n\nWhat do you think about that?\n. > The reason I leaned on the plist is because it's easier to control the defaults when distributing multiple apps, i.e. code stays the same across apps with differences only in the plist.\n\nGood observation, but you can do the same with Swift, no?\n\n```\n// UserDefaults.swift\n\nextension DefaultsKeys {\n     static let userName = DefaultsKey<String>(\"userName\")\n}\n\nvar Defaults = NSUserDefaults(defaults: [\n     .userName: 'radex',\n])\n```\n. Great, thank you for working on this!\n. > If we're not going to read from plist, then I prefer to set default values in the DefaultKeys extension \n\nBut this way, the default values won't be visible to non-Swifty NSUserDefaults users. Unless you specifically register those DefaultsKey objects, but at that point it's better to do the whole default registering separately.\n\n> otherwise a race condition can be introduced\n\ncould you explain?\n. > In this example, viewDidLoad can be called before didFinishLaunchingWithOptions as discussed here. That means the screen will display a blank username, before the defaults are registered.\n\nWhoa, this is crazy! Thanks\u00a0\u2014\u00a0I didn't know it.\n\nOne idea: make people register their defaults while initializing their Defaults object:\n\n```\nvar Defaults = NSUserDefaults(defaults: [\n     .userName: 'radex',\n])\n```\n\nThis ensures defaults registering happens before first Defaults access.\n. So I've been thinking about how to actually implement this statically-typed defaults dictionary.\n\nNow, we can't actually do it as a dictionary, because we need the requirement for the value to be T matching key's DefaultsKey<T> AND the ability to have key/value pairs of different types. There's no way to express that in Swift.\n\nYou could do it as tuples, i.e. `[ (.userName, \"radex\"), (.launchCount, 0) ]`, but that would make the array `[(DefaultsKeys, Any)]`, an there's no compile-time type check. Sigh.\n\nSo I have two concepts that might be possible to implement.\n\nOne would be a builder DSL:\n\n```\nregisterDefaults(.userName, \"radex\")\n    .and(.launchCount, 10)\n    .and(.this, that)\n```\n\n`registerDefaults()` would be `<T>(DefaultsKey<T>, T)`, and would return something like `DefaultsBuilder`, which would have a method `and` with the same signature.\n\nAnother option would be something like:\n\n```\nregisterDefaults([\n    .key(.userName, \"radex\"),\n    .key(.launchCount, 10),\n])\n```\n\nregisterDefaults would take an array of `DefaultsKeyValue` (name tbd), which would have a static func `key` (also looking for a better name) \u2014\u00a0essentially a factory method returning the same type. The method would be `<T>(DefaultsKey<T>, T)` to type-check the passed stuff.\n\nNot super in love with either concept. Do you have better ideas?\n. @stephencelis very nice! The second option, with subscripts, doesn't work because I'd have to duplicate all the (non-generic) subscripts. The first option is really nice, though.\n\n@basememara this is syntactically superior but has two problems:\n- it saves a new value, instead of registering a default\n- static lets are lazily evaluated IIRC, so if someone accesses user defaults outside of DefaultsKey, the default registering won't work. \n. Actually just realized registering defaults in a global `var Defaults = ...` has the same issue \u2014 it will be evaluated lazily :(\n\nIdeas? If applicationFinishedLaunching... isn't a good place to do it, then perhaps init is?\n. Nice catch!\n. Hey, thank you for bringing this to my attention. Can you narrow down the memory leak to a test case? I can't think of a legitimate reason a leak could happen in the subscript setter\u2026\n\nMaybe it's a Swift bug, and when you pass an array to the setter (which gets converted to NSArray), a leak happens there\u2026\n\nHave you tested on Xcode 7.3?\n. Have you seen the issue since then @goktugyil?. That's so strange. Why would there be array appends? SwiftyUserDefaults doesn't maintain any internal array state\u2026 are you doing any setting of arrays? Perhaps there's something wonky going on during casting when you do that?. Explain rationale?\n. OK, I'm cool with this change, but would you mind adding a `/// ...` documentation comment to explain the method? A small test case wouldn't hurt either.\n. Thanks!\n. Personally not a fan of observing user defaults, I think generally there are better ways than this. But I'm pretty sure you can do KVO on NSUserDefaults. (Since iOS 9.3, this even works if changes are made outside of your app's process)\n. Sorry, no plans for ObjC support, but you're more than welcome to fork the project or try to re-implement the API in ObjC.\n. yeah, travis isn't configured with Xcode 8 so tests won't pass...\n. > Browsing through the changes, I notice that NSDate and NSData have been changed to Date and Data respectively, which left me wondering if the same should happen to NSArray and NSDictionary for consistency in returning value types?\n> \n> Edit: Or whether in fact it's more desirable to keep NSDate and NSData for reference types. But I guess that the NS-reference stuff is less swifty?\n\nI want to avoid changing the API of `UserDefaults.Proxy` because I consider it a legacy API \u2014 and I strongly want to encourage people to use the new, static key-based API. In the latter, it's definitely desirable to change NSDate etc to new types. (But maybe still makes sense to keep the old one as deprecated to ease the transition? Just like I've kept `DefaultsKey<NSArray>` if it's easier for someone to use that...)\n. btw. thanks everyone for chiming in this discussion! I definitely intend to take a closer look and start an official `swift3` branch sometime soon!\n. > I looked at making a single code base that could compile in both environments but I don't think the code complexity would be worth it. Better to just make a hard fork.\n\nI agree as far as Swift 2/3 compatibility is concerned. The shipping version of SwiftyUserDefaults compiles just fine with Swift 2.3, so people can keep using that for as long as they need. Next version will be Swift 3-only.\n\nAside from that though, I want to make API transitions in the library itself as smooth as possible. Otherwise people get frustrated, stop updating, and in the end everyone's worse off. That's why there are still things in the codebase marked as \"deprecated\", but not removed completely.\n. > @radex when would you like to new swift 3.0 support branch\n\nAs soon as possible, sorry, just couldn't find time to do it just yet.\n. Thank you @askari01 for submitting this pull request and everyone for chiming in!\n\nI merged this PR into `swift3` branch: https://github.com/radex/SwiftyUserDefaults/tree/swift3\n\nI will merge this into master when Swift 3 is out.\n\nBe sure to submit pull requests if there's any issues on Swift 3, or if the library can be improved with Swift 3 changes! Thanks!\n. For now, feel free to use the branch from https://github.com/radex/SwiftyUserDefaults/pull/91 :) \n. On `swift3` branch. Thanks for your patience!\n. Thank you!\n. I converted most of the README to use Swift 3 names and syntax and to account for changes made in #105.\n\nhttps://github.com/radex/SwiftyUserDefaults/blob/swift3/README.md\n\nWould really appreciate if someone took a second close look!\n. No, only deprecated with `Defaults[\"foo\"]++`. When using static keys, it's fine. Different mechanism.\n. Ah, duh! Thanks.\n. Thanks @arthurhammer \u2014 fixed.\n. #98 fixed this, thanks again to @BalestraPatrick :)\n. This is awesome, thank you!\n. If it fixes it (I don't use Carthage), you should totally open a PR adding SWIFT_VERSION=2.3 to the project file :)\n. Thank you!\n. thanks\n. Ha! Very cool. Shame we can't (not without generic subscripts) make it work more broadly out of the box. This addition might be useful for someone, but they have to know they can use it to implement their own subscript...\n\nWhat's your motivation to store, say, CGSize, like this? Why not store it as a `[\"width\": 10, \"height\": 10]`. That's how I imagine I would probably do it\u2026 Simpler, because you only have to deal with one user defaults key...\n. Oops. Done.\n. Happy to accept PRs\n. Done in #106.\n. > @radex Updated to address your comments. It looks like there is a way to check for [Any] == [Any] by doing something like:\n> \n> XCTAssertEqual(a as NSArray, b as NSArray)\n\nUgh, that's awful :(\n\n> It seems very hacky that we have to go through ObjC classes though. In the meantime, I updated the tests to have more thorough asserts by checking for equality of each members. Let me know if you want me to use the NSArray/NSDictionary cast in tests.\n\nNo, let's stick to your one-by-one checks, at least for now. We'll see how the behavior of `[Any]` evolves in Swift 3.x\u2026\n. OK, thank you again @ldiqual! If you could just revert the archive/unarchive implementation to what I suggested in the inline comment, I'll merge the PR right away \ud83d\udc4d\n. That's weird...\n. Okay, I went ahead and made the changes myself. Thank you @ldiqual for the great work! And apologies for everyone observing that it took so long.\n. If someone sent a PR for this, I'd be very grateful! \u2764\ufe0f . Started playing with this here: https://github.com/radex/SwiftyUserDefaults/blob/travis-fix/.travis.yml but not sure I can figure it out myself\u2026 \n. I will release it officially when Xcode 8 is out. For now, you'd have to specify SwiftyUserDefaults by pointing to the branch\n. Oh. I'll try to release it tomorrow or the day after that, then.\n. @kylebrowning I'm working on it, but having issues with CocoaPods: https://twitter.com/radexp/status/776191981831778309\n. @kylebrowning @brightsider OK, this should be out now! Can you verify and let me know if this works for you? Thanks!\n. The approach I would recommend is to have a struct type representing your value and then extend UserDefaults with a `subscript(key: DefaultsKey<MyStruct>) -> MyStruct` that can (de)serialize the struct to a dictionary.\n\n> Defaults[.myStoredValue.maxScore]\n\nSadly this syntax is not possible.\n. Thank you @asowers1. Can you explain why this change is needed? Does it not compile, or throw warnings? CocoaPods, Carthage?\n. Thanks for the report!\n. Thanks!\n. @max-potapov done!\n. Hey, the best way for you is to extend `UserDefaults` and add the right subscript yourself \u2014 it's not difficult.\n\nThose types are not built in by design \u2014 in 99% cases, one should just use Int and Double.\n. I have no idea what the question is.\n. Oops, typo! Nice catch @DivineDominion. Care to send a quick PR?. @Eitot does it still not work? Have you verified it's a SwiftyUserDefault issue and not an old version of SPM?. Hmm, that sounds like SPM wants to use the `Tests/` files but shouldn't\u2026 I don't use SPM myself \u2014 if you could take a look a this an submit a PR that would be \ud83d\udcaf . I'm closing this. @rjcristy if you care to explain the issue, I'll reopen.. Exactly. Thank you @iDurian for the PR, but calling `synchronize` every time after set is a cargo cult of sorts. David Smith said so himself in some other PR/issue on this repo.. Thanks @DivineDominion !. Thank you! I'll try to take a look at this next week and tag a new version :). I haven't really dealt with NSArchiver before. What's the advantage/use of this over NSCoder?. Why not just save the two values of a CGRect as an array under one key?. Fair enough.. Thank you @humblehacker!. The method already exists, and it's `Defaults.synchronize()`. Note that it's not recommended to use it in normal circumstances. But if you need to ensure synchronization for testing reasons, there you go. Good stuff, thank you! I will check it out soon :). Thanks!. I don't believe array of enums is compatible with NSCoding. You have to encode by mapping to rawValue, and decode by reinstatiating from rawValue..... Looks good! Thanks @jklausa @getaaron \n. Great stuff! \ud83c\udf89 Thanks @maximkhatskevich!\n. FYI @maximkhatskevich I'm still recommending to just copy the project's file to your project over CocoaPods because: a) Swift support in CocoaPods isn't shipped yet, and b) it won't work on iOS 7 AFAIK.\n. This is a consequence of how objectForKey works. Integers, doubles and booleans are all encoded as NSNumber. There is no API to check for user defaults type (it is held _somewhere_, as you can see by trying `defaults read-type ...`, but it's not exposed to NSUserDefaults).\n\nSo, 100 == true, and 0 == false, because that's what NSNumber does.\n\nDo you think it's a good idea to make \"true\", \"false\", \"1\", \"0\" convertible to bool? How does `boolForKey` react to those values?\n. Does it work reliably though? The last time I looked into this, NSNumber did _not_ promise (at all) that the representation of booleans would be explicitly as booleans. It just thought it's the same as ints\u2026\n. Hm. It's super annoying, though, because internally, defaults does store the type \u2014 it's just that NSNumber doesn't, and AFAIK there's no API to check for key's type :( \n. With http://radex.io/swift/nsuserdefaults/static/ and the `next` branch, I'd rather have people define the defaults keys they want to use statically, explicitly stating the type they want to use, and not rely on dynamic casting behavior. So this doesn't matter much anymore.\n. Thanks @picciano, but this is too magic and implicit for my taste. I share your dislike for the inconsistency (with bool/int/double), but I don't think this is the solution.\n. Thanks @narfdotpl!\n\nAny specific reason why you wrote `.map { $0 as! NSObject }` instead of `as! NSObject?` or `as? NSObject`?\n. Right. `.map { $0 as! NSObject }`, AFAICT, has the exact same behavior as `as! NSObject?`. It could crash if the cast failed, but it won't fail ;)\n\nI liked `as NSObject?`, but now that the exclamation mark is shouting \"DANGER\" at me, I think `as? NSObject` is best here.\n. Looks great. Thank you @narfdotpl! \u2728\ud83c\udf89\n. Type `pod --version` in your command line. It should say something like \"0.36.0.beta1\". If it says \"0.35.0\", you have an old version of CocoaPods that doesn't support Swift pods.\n. That's odd. I'm sorry, but I don't know how to help :( \n. Have you tried other Swift-based pods? Does the same issue occur? Try looking for or asking about this on Stack Overflow\u2026\n. Not sure why you'd prefer to check for nil instead of using `hasKey`, but try this:\n\n`Defaults[\"firstInstallDate\"].object == nil`\n\nThe subscript itself always returns a `NSUserDefaults.Proxy`, so it will never be nil.\n. Very interesting! Thanks @phimage. Not sure I understand, though, what's the benefit of writing `Defaults[\"foo\"][\"bar\"]` over `Defaults[\"foo.bar\"]`?\n. I don't understand why prefix your defaults with something like a bundle name? I mean, the standardUserDefaults are already scoped to your app only.\n. Hm. That's a fair point, though I would say it's the 3rd party frameworks' responsibility to prefix the stuff they save in my user defaults\u2026\n\nLet me think about this\u2026\n. You're right! I'll merge it in later today :)\n. Alright, done! I merged to master and cut a new release: 1.1.0. I haven't tested it with CocoaPods but it should work just fine.\n\nThanks for the reminded @jschmid!\n\nPS. \"later today\", LOL.\n. I appologize for not replying before. I couldn't reproduce your problem.\n\nCould you try it again with CocoaPods 0.37.1?\n. Great, glad to hear that!\n. Carthage support would be great, but I'm not familiar with the system myself\u2026 I'd definitely be willing to merge it in if someone prepared a pull request.\n. Added by @alec-c4 via #14 :)\n. Apologies to have kept you waiting. I'll do my best to properly test your code in the weekend (I don't have experience with Carthage) and unless there's some issue, I'll merge it in :)\n. Hey @alec-c4 . I haven't forgot about it, I'm just terribly, _embarrassingly_ bad at side projects and keeping commitments related to them.\n\nI took a look at your changes, played with Carthage, and it all looks great. Thank you for your work and sorry I kept you waiting so long.\n. I'm not familiar with using NSKeyedArchiver with NSUserDefaults \u2014 I'm not sure if it's a common pattern or not.\n\nIf it is, I'd be definitely happy to add a pair of helpers for writing/accessing archived objects to the user defaults.\n\n**If anyone is interested in this feature, please give your feedback below \u263a\ufe0f**\n. Cool. @pellekrogholt @tbaranes @katopz any specific suggestions as for the API you'd like to see for (de)serializing NSObjects?\n. @katopz @pellekrogholt @tbaranes Thanks for bringing this to my attention. I think I have a pretty great solution on the `next` branch. Check out http://radex.io/swift/nsuserdefaults/static/ for more background and explanation. Let me know what you think!\n. Thanks @rad3ks, but #14 already added Carthage support (it just took me a while to get it merged).\n\nCould you elaborate about why `XCTAssert` is better than `assert`? I mean, I know the latter doesn't integrate with Xcode, but for the purposes of this project, it works fine. What do you mean about running for \"each platform individually\"?\n. No, the only issue is `println` in the test target. \n. Still, surprising we didn't need any changes really in this library :)\n. Sorry, I forgot to push a new release. Should work now.\n\n(FWIW, the new tag only introduces Carthage support, so v1.1 is functionally the same)\n. That _does_ look useful. Not sure about `NSDate()` since it represents the current, not \"empty\" date, but 0, [], [:], \"\", etc. often do make sense.\n. Still don't know about this\u2026 Is 1970 a natural, obvious \"null value\" that we want people to use, implicitly?\n. Hm, I'll think about this.\n\nNot merging this PR just yet, but I will ;)\n. Merged. Thanks.\n\nI removed `objectValue` and `dateValue` before merging. I'm not convinced of the usefulness of their default value behavior. I'd rather people do this explicitly.\n\n(If people complain about this and make a convincing argument for it, I'll put it back.)\n. Thanks. I'll take a look at this in spare time.\n. Thanks for the pull request, Xavi.\n\nTwo notes:\n1. I wish you hadn't reordered tests the way you did. Grouping them by SwiftyUserDefaults' function makes more sense than grouping them by a user default type.\n2. Clearing of the user defaults was done in setUp on purpose. Yes, it's good to clean up after yourself, but we don't want garbage from _previous_ tests interfering with our tests. So it should definitely be done before tests.\n. No specific reason as far as I can remember. \n. Thanks @kaunteya. I intend to merge this, but I'm going to hold off until a 2.0 release, since changing the return types might break things.\n. Thanks again. Sorry for not responding for so long. I originally merged those changes to `next`, but the end, I don't think I want to change it. The reason why is because I think the new approach in the `next` (2.0) branch is much better (give this a read for more info: http://radex.io/swift/nsuserdefaults/static/) and I want to promote that instead. I'm going to treat the `Proxy`-based API as legacy, probably deprecate it eventually, and so I'd rather just not change anything.\n. Thanks! Glad you like it. \n. Oops, thanks. \n. Thank you! I merged your changes into the `next` branch here: https://github.com/radex/SwiftyUserDefaults/commit/d2b749109ae47404e678144a74d31194bfedd5a5\n. Thanks @kohtenko, but the `++` and `+=` operators in SwiftyUserDefaults have really confusing and potentially dangerous semantics. I don't like them anymore.\n\nCheck out http://radex.io/swift/nsuserdefaults/static/ and the `next` branch. Swift's `--` and `-=` just work out of the box with the new approach.\n. Please be more specific. Why do you want to override the Proxy class? Real world examples, please. \n. I'm going to close this now. Let me know if you have a good argument for making it public.\n. Thanks for the PR. Having URL support would certainly make sense.\n\nCan you elaborate on the `?=` problem you're describing? `?=` shouldn't be used with `nil` \u2014 it just doesn't make sense to assign a `nil` to something when it's `nil`\u2026\n. That sounds like a Swift bug. Have you filed a radar?\n. Okay, thanks for letting me know. I'll think about it. I just don't want to make it look like you're supposed to pass an optional to `?=` \u2014 you're not.\n. I added `NSURL` support on the `next` branch. Thanks again!\n. You must be using the old version of the library\n. It should be 1.3.0\n. Have you tried running pod update?\n. Thank you! I merged that into the `next` branch \u2014 can you verify it works?\n. This is `NSUserDefaults` concern \u2014 SwiftyUserDefaults is just a wrapper around this. Hopefully, people are now dropping support for iOS 7 ahead of iOS 9 and this won't matter anymore. Thanks.\n. Done on the `next` branch. Thanks!\n. Hey @IdoBn, thanks for this, check out the `next` branch for Swift 2 compatibility and some cool new stuff :)\n. That's what I get for changing things in the last minute. Thanks!\n. Thanks.\n. That would be more confusing than helpful. \"Right now\" is not an obvious, universally-correct default value for a date. I'd rather have you use `?? NSDate()` explicitly if that's what you want.\n. 0 is \"empty\", `false` is empty, `\"\"` is empty\u2026 \"right now\" isn't empty.\n. Exactly the kind of thing I'm worried about. Seems faaaaar less likely to do such a mistake with default values for other types. \n. What a perfect piece of evidence that accidental `NSDate`/`NSData` typos happen ;)\n. Thanks @jschmid!\n. I guess the way I'd do it is:\n\n```\nfor (key, _) in Defaults.dictionaryRepresentation() {\n            Defaults.removeObjectForKey(key)\n}\n```\n\nbut yeah, it wouldn't be too bad to have a shortcut for that in SwiftyUserDefaults.\n. I added `Defaults.removeAll()` in 1ac8701. Hope this solves it.\n. no, that's a mistake\u2026 Should support 10.9 and up\u2026\n. Soon. I want to ship the 2.0 tonight. \n. Fixed, thanks for letting me know about this!\n. I did mention it in the post. Subscripts don't support generic constraints in Swift 2. Which makes me very sad. (But from API consumer point of view, I still like this better than the alternative)\n. Also a cool approach, but I like SUD's syntax better, and some of the semantics and safety with getting/setting ;)\n. Do it and I'll merge it ;)\n. @staticdreams that'd be great \u2014 if you don't mind making a PR, I'll merge it :) \n. Thanks @Antoine4011 @mathiasnagler! I'm closing this PR as #53 is newer :) \n. Thanks!\n. A few reasons:\n1. Syntax. I like the dictionary-like feel of `Defaults[.prop]` vs `Defaults.prop.value`.\n2. And it's a little bit shorter\n3. And that it feels like it makes a bit more sense with you subscripting a collection, not calling \"value\" on the key itself\n4. If you're not using the standard user defaults, but some other NSUserDefaults (e.g. shared defaults in an app group), you can just subscript a different defaults object \u2014 the key object only describes the key, not the collection\n\nYeah, it's kind of an implementation PITA, but I'm not concerned with that in this project \u2014 it's not an approach I would usually take, but I slightly prefer this approach to what you're suggesting. I'm cool with magic.\n. This is a problem with the underlying Apple framework, not my code.\n\nThe synchronize stuff only matters in iOS 7. You're not supposed to use it in later versions. \n. It should be. \n. It doesn't. Do it yourself if you need to support iOS 7. Otherwise, do nothing. \n. Why do you want to use `Float` and not `Double`?\n. Hm. Lack of support for floats was a deliberate decision -- Swift strongly recommends just using Double everywhere. The fact that UISlider reports Float -- I consider that an interop limitation. \n. Nope. Swift encourages people to just use Int and Double. Float is great when you **need** the efficiency \u2014 that is, when you have significant arrays of them (SCNVector3 is probably a good use case, I think). Otherwise, it just doesn't matter.\n. I don't want to teach people bad habits. It's not difficult to cast to/from Double :) . > ld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.1.sdk/Developer/Library/Frameworks'\n\n@mrahmiao do you still have this problem? The other warnings are working as designed.\n. Ah, nevermind, I see the same warning. Not sure what's the cause but I'll accept a fix.\n. @ton03 I'll accept a patch.\n. @ton03 I no longer reproduce any warnings except for deprecation warnings (working as intended) while updating with carthage. I'm closing this issue, but let me know if you can still see the problem.\n. > This code which is recommended does not autocomplete:\n\nOh well. Xcode\u2014Swift integration is not yet as good as I'd like it to be. This sort of thing generally auto-completes (with enum cases and all), but apparently not here. (Not yet, anyway)\n\n> Obviously there is a bad design decision on the name. Please change it so it is clear what Keys and Key does.\n\nThe only purpose for both classes existing is to work around compiler limitations. Explained here: http://radex.io/swift/nsuserdefaults/static/\n\n> This works and autocompletes:\n> \n>    var userDefault = Defaults[DefaultsKeys.userId]\n> But, this does not work:\n\nWorks for me \u2014 what's the DefaultsKeys.userId implementation?\n\n> Maybe some shortcut like:\n> var userDefault = Defaults[Defs.userId]\n> might be useful\n\nGo ahead, define a `Defs` struct \u2014 also an approach I'm cool with (again: http://radex.io/swift/nsuserdefaults/static/). There's nothing magical about `DefaultsKeys` except for the fact that it allows for the shortcut `.foo`. If you don't like the dot-shortcut syntax because it doesn't play well with autocompletion, you don't have to use it.\n. Having statically-defined default values would be very nice indeed. I need to consider more closely if there's a nice way to achieve that given current Swift limitations (no generic subscripts, no extending generic types, etc...)\n\nCould you explain this bit?\n\n```\nDefaultsKey<String, UIColor>([\"color\": UIColor.grayColor()])\n```\n\nWhy does it have two type params and a dictionary \u2014 I don't get it?\n. Thanks!\n. Thanks @mathiasnagler!\n. That was quick, thanks!\n. Extend DefaultsKeys, not DefaultsKey -- the whole purpose of the former is to work around this compiler limitation\n. Thanks :)\n. @staticdreams Apologies for not doing it months ago. I've just released v2.1.0\n. Awesome work!\n\nOne thing annoys me, API design-wise: so far, we used optionals in the type parameter `String` vs `String?` to convey whether a key should be returned as optional or with a default value.\n\nAdding custom default values makes this possibly confusing a bit, because it doesn't make any sense to have a `T?` defaults key with a custom default value defined.\n\nI want to think of ways to clarify this if possible and disallow the behavior that doesn't make any sense.\n\nIdeas? Discussion welcome.\n. I would do a quick crash, as this should just be illegal (IMHO). Would be best to have this checked at compile-time, but I'm not sure what's the best approach. Don't like the idea of subclassing DefaultsKey much.\n. Hm, is there no way to do this without defining a new protocol?\n\nAlso: you should use precondition()\n. Agree, it makes sense. I would call the protocol `OptionalType`, for consistency with other protocol names. (Not that it makes a huge difference \u2014\u00a0it's private anyway).\n\nAlso, what I meant by using `precondition` was to drop the `guard` altogether:\n\n```\nprecondition(!(defaultValue is OptionalType), \"Failure message\")\n```\n. Yes, a more versatile solution would be great \n. Alright all:\n1. I would be happy to add support for easy serialization of `RawRepresentable` values. Indeed, this would be great for enums\n2. I would also be cool with adding a protocol like `SwiftyUserDefaultsSerializable` for (un)archiving of any custom, Swift-only type. (Unless someone has a better idea of how to solve it).\n\nPR-s are very welcome.\n. @staticdreams Yes, but not directly. If your enum is RawRepresentable, you can store the underlying value via `.rawValue`, then recreate it when reading using `init?(rawValue:)`.\n\nYou can quite easily extend `NSUserDefaults` to add a subscript for `DefaultsKey<YourEnumType>` that does this behind the scenes for you.\n\nThis should be simpler.\n. \u2705 Added easy RawRepresentable support in SwiftyUserDefaults 2.2\n\nStill no `SwiftyUserDefaultsSerializable`, because then you have to write _both_ an NSUserDefaults extension _and_ an extension on your own type. Until we can get the proper subscripts automatically (maybe Swift 3), it's not really much better\u2026 I could, however, document how to add support for completely custom types\u2026\n. > I guess the other warnings are not meant to be resolved?\n\nIf they're coming from my code then no.\n. Thanks \u2014 I hope this actually compiles ;)\n. This is a cool idea, but out of scope for this library.\n. Yeah, that should be simpler, but swift compiler limitations don't allow me. \n. Thank you.\n. @ajaysinghthakur Please use Stack Overflow in the future, as this isn't an appropriate place to ask this kind of questions.\n\n@ed-mejia is right, this code will work:\n\n``` swift\nfor (key, _) in Defaults.dictionaryRepresentation() {\n     Defaults.removeObjectForKey(key)\n }\n```\n. @ajaysinghthakur there is a tag: http://stackoverflow.com/questions/tagged/swiftyuserdefaults\n. > I just got that error too. I assume the library doesn't support multidimensional arrays?\n\nNo, it doesn't. Until Swift becomes more powerful, you can only define and use `DefaultsKey` on one of the supported types. You can, however, quite easily extend `NSUserDefaults` and add support for a given DefaultsKey type.\n. @toshi0383 Very cool! I understand this works regardless of whether or not SwiftyUserDefaults is used? i.e. if someone sets a value using plain old NSUserDefaults API, this will still work?\n. Thanks \u2014 I'll review it more closely when I have more time, but could you explain to me the design of this code in the meantime? Like, why are there three `observe*` methods, what's the purpose of BlockDisposable and RecursiveLock?\n. Beginning iOS 9.3, you can actually observe changes made to your user defaults from outside the app:\n\nhttps://twitter.com/Catfish_Man/status/711972673367052288\n\nVery cool.\n. Nice. The problem is \u2014 why should `[[Bool]]` be the special exception?\n\nUntil we can express automatic support for any reasonable key type in Swift, I suggest:\n- we drop the [[Bool]] support\n- we add `getTwoDimensionalArray` a user can use\n- add a note to README as for how to add support for additional types like this.\n\nI would be happy to merge that.\n\nAnd if you were inclined to also add support for arbitrary dictionaries the same way (only `[String: AnyObject]` is supported out of the box), that would be awesome.\n. > We should be able to have automatic support for the common keys, I am not sure how that will work.\n\nNot possible without generic subscripts.\n. No, this really doesn't work. https://bugs.swift.org/browse/SR-115 tracks this issue. \n. @MaxHasADHD I don't understand what you're trying to say \u2014 can you elaborate?\n. OK, got it. #59 was proposing an alternative to using `registerDefaults`, instead, embedding the default value in the DefaultsKey definition.\n\nThe latter definitely seems cleaner, but `registerDefaults` has the advantage of working across NSUserDefaults, whether or not you actually use SwiftyUserDefaults **and** those key values.\n. Please **do not** store sensitive data in user defaults. It's not meant for it, and it's unsafe to do so.\n\nI have no plans for encryption. SwiftyUserDefaults is a Swifty API for NSUserDefaults, nothing more.\n. I'm not really comfortable extending the `Proxy` getters, because I think the way to go forward is to use statically-typed keys instead of the old stringly-typed API...\n\nI think I can merge it anyway, but please open a pull request.\n. Done thanks to valentinknabel.\n. @BalestraPatrick did the work to prepare travis config, but I still have to set it up on my end.\n. boom, works! Thanks again, @BalestraPatrick!\n. Awesome, thank you Patrick!\n. Thank you!\n. When I try it out (I ran `swift build` from the gist folder), I get this:\n\n> 8bbef2f345adfe2724d8-582ed4741b0e88b3ee25e292fde1a333657ae0ca \u00bb swift build                                                                                                                         ~/Downloads/8bbef2f345adfe2724d8-582ed4741b0e88b3ee25e292fde1a333657ae0ca\n> Cloning Packages/SwiftyUserDefaults\n> /Users/radex/Downloads/8bbef2f345adfe2724d8-582ed4741b0e88b3ee25e292fde1a333657ae0ca/Packages/SwiftyUserDefaults/Package.swift:4:22: error: incorrect argument label in call (have 'exclude:dependencies:', expected 'name:dependencies:')\n> let package = Package(\n>                      ^\n> swift-build: exit(1): [\"/Library/Developer/Toolchains/swift-2.2-SNAPSHOT-2015-12-01-a.xctoolchain/usr/bin/swiftc\", \"--driver-mode=swift\", \"-I\", \"/Library/Developer/Toolchains/swift-2.2-SNAPSHOT-2015-12-01-a.xctoolchain/usr/lib/swift/pm\", \"-L\", \"/Library/Developer/Toolchains/swift-2.2-SNAPSHOT-2015-12-01-a.xctoolchain/usr/lib/swift/pm\", \"-lPackageDescription\", \"-target\", \"x86_64-apple-macosx10.10\", \"/Users/radex/Downloads/8bbef2f345adfe2724d8-582ed4741b0e88b3ee25e292fde1a333657ae0ca/Packages/SwiftyUserDefaults/Package.swift\"]\n\nAny clues? Apologies if I'm doing something totally dumb \u2014 I've never used swift pm before\n. Okay, I must be completely blind, my PATH was pointing at a December snapshot of swift\n. IT WORKS :D Thank you @valentinknabel.\n. Thanks.\n. Let me know if I need to cut a new version for this to work automatically \u2014 I don't know much about Carthage.\n. Okay, I think https://github.com/radex/SwiftyUserDefaults/pull/77 fixes just this issue \u2014 can you verify it? I think I have to cut a new release tag.\n. Regarding deprecations: people still use those. I would have to cut a 3.0 to remove them. I could also lose the warnings if I removed tests for them, but hey, again, people still use them. I wish I could silence Swift deprecation warnings, but I don't think I can. (the deprecations, after all, are meant for the users, not my test target)\n. OK, I just pushed 2.1.3 with the fix and also found a way to suppress deprecation warnings. Let me know if there's still a problem.\n. One way is to just define in your app:\n\n`var SomeOtherDefaults = NSUserDefaults(...)`\n\nand use that instead of `Defaults`.\n\nWould that fix it for you? Or do you need the ability to quickly switch between arbitrary suites?\n. > I think it'd be handy to set global suiteName once, somewhere early (e.g. in AppDelegate):\n> Defaults.suiteName = \"group.my.appGroup\"\n\nI'd much prefer the declarative version:\n\n```\nvar Defaults = NSUserDefaults(suiteName: ...)\n```\n\nThis is cleaner to me, and has the advantage that you can put it in a separate file you can share between targets...\n. >  you may loose data saved to defaults unless you manually call Defaults.synchronize() each time you change something because the system may kill the process suddenly, to the best of my understanding (and in the case of running from Xcode, if you stop the project just at the right time, it won't save either).\n\nYou could be right, but all I keep hearing (from @Catfish-Man on Twitter, mostly) is that calling `synchronize()` is simply not necessary.\n. @Catfish-Man Thank you for the info!\n. Ok, so:\n- synchronize seems to be unnecessary save for some very extreme conditions, so I don't see a reason to add it to SUD\n- you can define a `var Defaults = NSUserDefaults(suiteName: ...)` in your own module to shadow the `Defaults` shortcut defined by the library.\n\nI'm closing this for now, but let me know if I missed something from the discussion.\n. Very cool work. I have reservations about this, because using a plist to register defaults means you don't get any type checking by the compiler \u2014 i.e. no way to verify correctness of your registered defaults. For example if you try to rename a default during development, but forget to change your plist, you'll have created a bug.\n\nI think the approach I would prefer to promote is a statically typed one, like so:\n\n```\nDefaults.register([\n     .userName: 'radex',\n     .launchCount: 0,\n])\n```\n\n(The actual implementation and syntax would be trickier, but I think you get the point.)\n\nWhat do you think about that?\n. > The reason I leaned on the plist is because it's easier to control the defaults when distributing multiple apps, i.e. code stays the same across apps with differences only in the plist.\n\nGood observation, but you can do the same with Swift, no?\n\n```\n// UserDefaults.swift\n\nextension DefaultsKeys {\n     static let userName = DefaultsKey<String>(\"userName\")\n}\n\nvar Defaults = NSUserDefaults(defaults: [\n     .userName: 'radex',\n])\n```\n. Great, thank you for working on this!\n. > If we're not going to read from plist, then I prefer to set default values in the DefaultKeys extension \n\nBut this way, the default values won't be visible to non-Swifty NSUserDefaults users. Unless you specifically register those DefaultsKey objects, but at that point it's better to do the whole default registering separately.\n\n> otherwise a race condition can be introduced\n\ncould you explain?\n. > In this example, viewDidLoad can be called before didFinishLaunchingWithOptions as discussed here. That means the screen will display a blank username, before the defaults are registered.\n\nWhoa, this is crazy! Thanks\u00a0\u2014\u00a0I didn't know it.\n\nOne idea: make people register their defaults while initializing their Defaults object:\n\n```\nvar Defaults = NSUserDefaults(defaults: [\n     .userName: 'radex',\n])\n```\n\nThis ensures defaults registering happens before first Defaults access.\n. So I've been thinking about how to actually implement this statically-typed defaults dictionary.\n\nNow, we can't actually do it as a dictionary, because we need the requirement for the value to be T matching key's DefaultsKey<T> AND the ability to have key/value pairs of different types. There's no way to express that in Swift.\n\nYou could do it as tuples, i.e. `[ (.userName, \"radex\"), (.launchCount, 0) ]`, but that would make the array `[(DefaultsKeys, Any)]`, an there's no compile-time type check. Sigh.\n\nSo I have two concepts that might be possible to implement.\n\nOne would be a builder DSL:\n\n```\nregisterDefaults(.userName, \"radex\")\n    .and(.launchCount, 10)\n    .and(.this, that)\n```\n\n`registerDefaults()` would be `<T>(DefaultsKey<T>, T)`, and would return something like `DefaultsBuilder`, which would have a method `and` with the same signature.\n\nAnother option would be something like:\n\n```\nregisterDefaults([\n    .key(.userName, \"radex\"),\n    .key(.launchCount, 10),\n])\n```\n\nregisterDefaults would take an array of `DefaultsKeyValue` (name tbd), which would have a static func `key` (also looking for a better name) \u2014\u00a0essentially a factory method returning the same type. The method would be `<T>(DefaultsKey<T>, T)` to type-check the passed stuff.\n\nNot super in love with either concept. Do you have better ideas?\n. @stephencelis very nice! The second option, with subscripts, doesn't work because I'd have to duplicate all the (non-generic) subscripts. The first option is really nice, though.\n\n@basememara this is syntactically superior but has two problems:\n- it saves a new value, instead of registering a default\n- static lets are lazily evaluated IIRC, so if someone accesses user defaults outside of DefaultsKey, the default registering won't work. \n. Actually just realized registering defaults in a global `var Defaults = ...` has the same issue \u2014 it will be evaluated lazily :(\n\nIdeas? If applicationFinishedLaunching... isn't a good place to do it, then perhaps init is?\n. Nice catch!\n. Hey, thank you for bringing this to my attention. Can you narrow down the memory leak to a test case? I can't think of a legitimate reason a leak could happen in the subscript setter\u2026\n\nMaybe it's a Swift bug, and when you pass an array to the setter (which gets converted to NSArray), a leak happens there\u2026\n\nHave you tested on Xcode 7.3?\n. Have you seen the issue since then @goktugyil?. That's so strange. Why would there be array appends? SwiftyUserDefaults doesn't maintain any internal array state\u2026 are you doing any setting of arrays? Perhaps there's something wonky going on during casting when you do that?. Explain rationale?\n. OK, I'm cool with this change, but would you mind adding a `/// ...` documentation comment to explain the method? A small test case wouldn't hurt either.\n. Thanks!\n. Personally not a fan of observing user defaults, I think generally there are better ways than this. But I'm pretty sure you can do KVO on NSUserDefaults. (Since iOS 9.3, this even works if changes are made outside of your app's process)\n. Sorry, no plans for ObjC support, but you're more than welcome to fork the project or try to re-implement the API in ObjC.\n. yeah, travis isn't configured with Xcode 8 so tests won't pass...\n. > Browsing through the changes, I notice that NSDate and NSData have been changed to Date and Data respectively, which left me wondering if the same should happen to NSArray and NSDictionary for consistency in returning value types?\n> \n> Edit: Or whether in fact it's more desirable to keep NSDate and NSData for reference types. But I guess that the NS-reference stuff is less swifty?\n\nI want to avoid changing the API of `UserDefaults.Proxy` because I consider it a legacy API \u2014 and I strongly want to encourage people to use the new, static key-based API. In the latter, it's definitely desirable to change NSDate etc to new types. (But maybe still makes sense to keep the old one as deprecated to ease the transition? Just like I've kept `DefaultsKey<NSArray>` if it's easier for someone to use that...)\n. btw. thanks everyone for chiming in this discussion! I definitely intend to take a closer look and start an official `swift3` branch sometime soon!\n. > I looked at making a single code base that could compile in both environments but I don't think the code complexity would be worth it. Better to just make a hard fork.\n\nI agree as far as Swift 2/3 compatibility is concerned. The shipping version of SwiftyUserDefaults compiles just fine with Swift 2.3, so people can keep using that for as long as they need. Next version will be Swift 3-only.\n\nAside from that though, I want to make API transitions in the library itself as smooth as possible. Otherwise people get frustrated, stop updating, and in the end everyone's worse off. That's why there are still things in the codebase marked as \"deprecated\", but not removed completely.\n. > @radex when would you like to new swift 3.0 support branch\n\nAs soon as possible, sorry, just couldn't find time to do it just yet.\n. Thank you @askari01 for submitting this pull request and everyone for chiming in!\n\nI merged this PR into `swift3` branch: https://github.com/radex/SwiftyUserDefaults/tree/swift3\n\nI will merge this into master when Swift 3 is out.\n\nBe sure to submit pull requests if there's any issues on Swift 3, or if the library can be improved with Swift 3 changes! Thanks!\n. For now, feel free to use the branch from https://github.com/radex/SwiftyUserDefaults/pull/91 :) \n. On `swift3` branch. Thanks for your patience!\n. Thank you!\n. I converted most of the README to use Swift 3 names and syntax and to account for changes made in #105.\n\nhttps://github.com/radex/SwiftyUserDefaults/blob/swift3/README.md\n\nWould really appreciate if someone took a second close look!\n. No, only deprecated with `Defaults[\"foo\"]++`. When using static keys, it's fine. Different mechanism.\n. Ah, duh! Thanks.\n. Thanks @arthurhammer \u2014 fixed.\n. #98 fixed this, thanks again to @BalestraPatrick :)\n. This is awesome, thank you!\n. If it fixes it (I don't use Carthage), you should totally open a PR adding SWIFT_VERSION=2.3 to the project file :)\n. Thank you!\n. thanks\n. Ha! Very cool. Shame we can't (not without generic subscripts) make it work more broadly out of the box. This addition might be useful for someone, but they have to know they can use it to implement their own subscript...\n\nWhat's your motivation to store, say, CGSize, like this? Why not store it as a `[\"width\": 10, \"height\": 10]`. That's how I imagine I would probably do it\u2026 Simpler, because you only have to deal with one user defaults key...\n. Oops. Done.\n. Happy to accept PRs\n. Done in #106.\n. > @radex Updated to address your comments. It looks like there is a way to check for [Any] == [Any] by doing something like:\n> \n> XCTAssertEqual(a as NSArray, b as NSArray)\n\nUgh, that's awful :(\n\n> It seems very hacky that we have to go through ObjC classes though. In the meantime, I updated the tests to have more thorough asserts by checking for equality of each members. Let me know if you want me to use the NSArray/NSDictionary cast in tests.\n\nNo, let's stick to your one-by-one checks, at least for now. We'll see how the behavior of `[Any]` evolves in Swift 3.x\u2026\n. OK, thank you again @ldiqual! If you could just revert the archive/unarchive implementation to what I suggested in the inline comment, I'll merge the PR right away \ud83d\udc4d\n. That's weird...\n. Okay, I went ahead and made the changes myself. Thank you @ldiqual for the great work! And apologies for everyone observing that it took so long.\n. If someone sent a PR for this, I'd be very grateful! \u2764\ufe0f . Started playing with this here: https://github.com/radex/SwiftyUserDefaults/blob/travis-fix/.travis.yml but not sure I can figure it out myself\u2026 \n. I will release it officially when Xcode 8 is out. For now, you'd have to specify SwiftyUserDefaults by pointing to the branch\n. Oh. I'll try to release it tomorrow or the day after that, then.\n. @kylebrowning I'm working on it, but having issues with CocoaPods: https://twitter.com/radexp/status/776191981831778309\n. @kylebrowning @brightsider OK, this should be out now! Can you verify and let me know if this works for you? Thanks!\n. The approach I would recommend is to have a struct type representing your value and then extend UserDefaults with a `subscript(key: DefaultsKey<MyStruct>) -> MyStruct` that can (de)serialize the struct to a dictionary.\n\n> Defaults[.myStoredValue.maxScore]\n\nSadly this syntax is not possible.\n. Thank you @asowers1. Can you explain why this change is needed? Does it not compile, or throw warnings? CocoaPods, Carthage?\n. Thanks for the report!\n. Thanks!\n. @max-potapov done!\n. Hey, the best way for you is to extend `UserDefaults` and add the right subscript yourself \u2014 it's not difficult.\n\nThose types are not built in by design \u2014 in 99% cases, one should just use Int and Double.\n. I have no idea what the question is.\n. Oops, typo! Nice catch @DivineDominion. Care to send a quick PR?. @Eitot does it still not work? Have you verified it's a SwiftyUserDefault issue and not an old version of SPM?. Hmm, that sounds like SPM wants to use the `Tests/` files but shouldn't\u2026 I don't use SPM myself \u2014 if you could take a look a this an submit a PR that would be \ud83d\udcaf . I'm closing this. @rjcristy if you care to explain the issue, I'll reopen.. Exactly. Thank you @iDurian for the PR, but calling `synchronize` every time after set is a cargo cult of sorts. David Smith said so himself in some other PR/issue on this repo.. Thanks @DivineDominion !. Thank you! I'll try to take a look at this next week and tag a new version :). I haven't really dealt with NSArchiver before. What's the advantage/use of this over NSCoder?. Why not just save the two values of a CGRect as an array under one key?. Fair enough.. Thank you @humblehacker!. The method already exists, and it's `Defaults.synchronize()`. Note that it's not recommended to use it in normal circumstances. But if you need to ensure synchronization for testing reasons, there you go. Good stuff, thank you! I will check it out soon :). Thanks!. I don't believe array of enums is compatible with NSCoding. You have to encode by mapping to rawValue, and decode by reinstatiating from rawValue..... ",
    "maximkhatskevich": "You are welcome!\n. @radex agree with you. And you are right, the way CocoaPods can integrate Swift-based pods is as framework, but third-party frameworks require iOS8+. The purpose was to try the technology, despite it has some limitations right now :)\n. You are welcome!\n. @radex agree with you. And you are right, the way CocoaPods can integrate Swift-based pods is as framework, but third-party frameworks require iOS8+. The purpose was to try the technology, despite it has some limitations right now :)\n. ",
    "picciano": "I put in a pull request with a possible addition. See if it makes sense to add it.\n. I put in a pull request with a possible addition. See if it makes sense to add it.\n. ",
    "zrzka": "If you'd like to check for a `BOOL` in `NSNumber`, there're two ways ...\n1. Compare `[NSNumber objCType]` with `@encode(BOOL)`\n2. Get number type via `CFNumberType numberType = CFNumberGetType((CFNumberRef)someNSNumber)`, `BOOL` is `kCFNumberCharType`\n. Did work when I was playing with it. But documentation says this:\n\n> If you ask a number for its objCType, however, the returned type does not necessarily match the method the receiver was created with.\n\nWhich means that we have no clue what's going on internally and it can be whatever anytime Apple decides to change it.\n\nIn other words, there's no reliable and 100% working way to do this unless you would like to break compatibility (replacing SwiftyUserDefaults with something else). I mean, you can encode types by adding some prefix to keys internally, checking these prefixes when getting values back or storing custom data. But it's not worth it IMHO unless you would like to achieve - when I store anything other then Bool, I can't get back true under any circumstances, always false.\n. If you'd like to check for a `BOOL` in `NSNumber`, there're two ways ...\n1. Compare `[NSNumber objCType]` with `@encode(BOOL)`\n2. Get number type via `CFNumberType numberType = CFNumberGetType((CFNumberRef)someNSNumber)`, `BOOL` is `kCFNumberCharType`\n. Did work when I was playing with it. But documentation says this:\n\n> If you ask a number for its objCType, however, the returned type does not necessarily match the method the receiver was created with.\n\nWhich means that we have no clue what's going on internally and it can be whatever anytime Apple decides to change it.\n\nIn other words, there's no reliable and 100% working way to do this unless you would like to break compatibility (replacing SwiftyUserDefaults with something else). I mean, you can encode types by adding some prefix to keys internally, checking these prefixes when getting values back or storing custom data. But it's not worth it IMHO unless you would like to achieve - when I store anything other then Bool, I can't get back true under any circumstances, always false.\n. ",
    "narfdotpl": "Just direct translation of my thought process: if not nil (`map`) cast or crash.\n\n`.map { $0 as! NSObject }` and `as! NSObject?` will crash if the cast fails, `as? NSObject` will return `nil`:\n\n``` swift\nimport Cocoa\n\n\nclass Foo {\n}\n\n\nlet x: AnyObject? = Foo()\n\nlet a = x.map { $0 as! NSObject }\nlet b = x as! NSObject?\nlet c = x as? NSObject\n```\n. Agreed that in the case of `NSUserDefaults`, `as? NSObject` is better as it wont render a false positive when \"auditing for `!`\". Changed in e467e0f.\n. +1 for Carthage as well, SwiftyUserDefaults is the only dependency in my project that is not managed by Carthage.\n\nTo support Carthage, you have to have an Xcode project with a framework target (as in \"Xcode > File > New > Project > iOS > Framework & Library > Cocoa Touch Framework\") and this project's scheme has to have the \"Shared\" checkbox checked.  As SwiftyUserDefaults is cross-platform (iOS + OS X), the tricky part is adding an OS X framework target to the iOS framework project and having both of the frameworks have the same name.\n\nI did that for [SwiftyStateMachine](https://github.com/macoscope/SwiftyStateMachine) but I didn't document the steps. :/ I tried repeating this yesterday for SwiftyUserDefaults but I failed.\n. :sparkles: \n. FWIW I think that \"now\" is a wrong default for \"no value\".\n\nSilly example:\n\n``` swift\n// if we never set `last_update_date`, we never perform update\nif Defaults[\"last_update_date\"].dateValue.timeIntervalSinceNow < -2.days {\n    performUpdate()\n}\n```\n. Just direct translation of my thought process: if not nil (`map`) cast or crash.\n\n`.map { $0 as! NSObject }` and `as! NSObject?` will crash if the cast fails, `as? NSObject` will return `nil`:\n\n``` swift\nimport Cocoa\n\n\nclass Foo {\n}\n\n\nlet x: AnyObject? = Foo()\n\nlet a = x.map { $0 as! NSObject }\nlet b = x as! NSObject?\nlet c = x as? NSObject\n```\n. Agreed that in the case of `NSUserDefaults`, `as? NSObject` is better as it wont render a false positive when \"auditing for `!`\". Changed in e467e0f.\n. +1 for Carthage as well, SwiftyUserDefaults is the only dependency in my project that is not managed by Carthage.\n\nTo support Carthage, you have to have an Xcode project with a framework target (as in \"Xcode > File > New > Project > iOS > Framework & Library > Cocoa Touch Framework\") and this project's scheme has to have the \"Shared\" checkbox checked.  As SwiftyUserDefaults is cross-platform (iOS + OS X), the tricky part is adding an OS X framework target to the iOS framework project and having both of the frameworks have the same name.\n\nI did that for [SwiftyStateMachine](https://github.com/macoscope/SwiftyStateMachine) but I didn't document the steps. :/ I tried repeating this yesterday for SwiftyUserDefaults but I failed.\n. :sparkles: \n. FWIW I think that \"now\" is a wrong default for \"no value\".\n\nSilly example:\n\n``` swift\n// if we never set `last_update_date`, we never perform update\nif Defaults[\"last_update_date\"].dateValue.timeIntervalSinceNow < -2.days {\n    performUpdate()\n}\n```\n. ",
    "steilerDev": "I got 0.36.0.rc.1.\n. Maybe it's a bug in either CocoaPods or in xCode. They both are still in beta so this could be very possible.\n. I am using [Locksmith](https://github.com/matthewpalmer/Locksmith) without any problems\n. Edit: Sorry I just noticed that Locksmith generates the same error, so it is not a bug of your program but rather of cocoapods or xcode, I will try to contact cocoapods first.\n. I have submitted a [new issue](https://github.com/CocoaPods/CocoaPods/issues/3200) to the CocoaPod's project.\n\n Thank you for your kind support!\n. I got 0.36.0.rc.1.\n. Maybe it's a bug in either CocoaPods or in xCode. They both are still in beta so this could be very possible.\n. I am using [Locksmith](https://github.com/matthewpalmer/Locksmith) without any problems\n. Edit: Sorry I just noticed that Locksmith generates the same error, so it is not a bug of your program but rather of cocoapods or xcode, I will try to contact cocoapods first.\n. I have submitted a [new issue](https://github.com/CocoaPods/CocoaPods/issues/3200) to the CocoaPod's project.\n\n Thank you for your kind support!\n. ",
    "perforator85": "You're absolutely right \u2026 I somehow missed the \".object\" call. Sorry -> CLOSED\n. You're absolutely right \u2026 I somehow missed the \".object\" call. Sorry -> CLOSED\n. ",
    "phimage": "The benefit is some organisation\nAn other way is to use Dictonnary\n\nAll my user defaults property are prefixed by the same word,\nfor instance:  \"io.radex.myapplicationname.\", same as apple do with \"com.apple....\" to avoid name collision with other api\n\nSo instead of use 'Default', I use an other variable \n\n``` swift\nlet AppDefault : NSUserDefaults.Proxy = Default[\"io.radex.myapplicationname\"] // or Default[\"io\"][\"radex\"][\u201dmyapplicationname\"]\n...\nAppDefault[\"myproperty\"]\n```\n. You can embed frameworks from third party that save values in your 'standardUserDefaults' too\n. To do so, a 3rd party framework can have dependency on 'SwiftyUserDefaults' to manage the standardUserDefaults and add prefix if needed\n( all swift projects must depend on 'SwiftyUserDefaults'!! ;) )\n. The benefit is some organisation\nAn other way is to use Dictonnary\n\nAll my user defaults property are prefixed by the same word,\nfor instance:  \"io.radex.myapplicationname.\", same as apple do with \"com.apple....\" to avoid name collision with other api\n\nSo instead of use 'Default', I use an other variable \n\n``` swift\nlet AppDefault : NSUserDefaults.Proxy = Default[\"io.radex.myapplicationname\"] // or Default[\"io\"][\"radex\"][\u201dmyapplicationname\"]\n...\nAppDefault[\"myproperty\"]\n```\n. You can embed frameworks from third party that save values in your 'standardUserDefaults' too\n. To do so, a 3rd party framework can have dependency on 'SwiftyUserDefaults' to manage the standardUserDefaults and add prefix if needed\n( all swift projects must depend on 'SwiftyUserDefaults'!! ;) )\n. ",
    "aradhell": "I solved it with cocoapods 0.37 also i forgot to post here, thank you\n. I solved it with cocoapods 0.37 also i forgot to post here, thank you\n. ",
    "alec-c4": "+1\n. https://github.com/Carthage/Carthage#share-your-xcode-schemes\n\nAs i understand - you simply need to include .xcodeproj to your project. But you also can use prebuild binaries \n. Will be replaced with new one\n. hey :) you've forget about merging branch :(\n. Thanks a lot!!! Have a nice day!!!\n. +1\n. https://github.com/Carthage/Carthage#share-your-xcode-schemes\n\nAs i understand - you simply need to include .xcodeproj to your project. But you also can use prebuild binaries \n. Will be replaced with new one\n. hey :) you've forget about merging branch :(\n. Thanks a lot!!! Have a nice day!!!\n. ",
    "duemunk": "I tried making two new targets in the current project, adding the source, and sharing the scheme. Couldn't get it to work. I don't know if it's because SwiftyUserDefaults is mainly an extension on NSUserDefaults. I'm not that in to modules and frameworks. \n. I tried making two new targets in the current project, adding the source, and sharing the scheme. Couldn't get it to work. I don't know if it's because SwiftyUserDefaults is mainly an extension on NSUserDefaults. I'm not that in to modules and frameworks. \n. ",
    "tbaranes": "I agree with @katopz, I'm also using `NSKeyedArchiver with NSUserDefaults` in some cases, so that will be great to have a shorter syntax for these too :)\n\n+1 for this!\n. I agree with @katopz, I'm also using `NSKeyedArchiver with NSUserDefaults` in some cases, so that will be great to have a shorter syntax for these too :)\n\n+1 for this!\n. ",
    "pellekrogholt": "+1 from me as well\n\nbut should admit my usecase was a bit awkward: storing a UILocalNotification in user defaults (long story http://stackoverflow.com/questions/25948037/ios-8-uiapplication-sharedapplication-scheduledlocalnotifications-empty) \n. +1 from me as well\n\nbut should admit my usecase was a bit awkward: storing a UILocalNotification in user defaults (long story http://stackoverflow.com/questions/25948037/ios-8-uiapplication-sharedapplication-scheduledlocalnotifications-empty) \n. ",
    "katopz": "It should be simple like \n\n``` swift\nDefaults.archive[\"foo\"] = [bar:NSDate()]\nprintln(Defaults.archive[\"foo\"].bar)\n// or maybe just\nArchive[\"foo\"] = [bar:NSDate()]\nprintln(Archive[\"foo\"].bar)\n```\n\nAnd let people do casting them self.\n\nCheers\n. It should be simple like \n\n``` swift\nDefaults.archive[\"foo\"] = [bar:NSDate()]\nprintln(Defaults.archive[\"foo\"].bar)\n// or maybe just\nArchive[\"foo\"] = [bar:NSDate()]\nprintln(Archive[\"foo\"].bar)\n```\n\nAnd let people do casting them self.\n\nCheers\n. ",
    "rad3ks": "Oh thanks, didn't check if there is already a pending PR with Carthage support.\n\nI used `XCTAssert` because I moved tests to `XCTestCase`, this is the only reason.\n\nFor each platform individually, because I added separate framework targets for iOS and OS X. This was just a quick PR so I can move on with my own job (need only iOS platform) and I couldn't figure out how to build all architectures from a single framework target (had some issues - don't remember specifics). \n\nThanks for merging that other PR :+1: \n. Oh thanks, didn't check if there is already a pending PR with Carthage support.\n\nI used `XCTAssert` because I moved tests to `XCTestCase`, this is the only reason.\n\nFor each platform individually, because I added separate framework targets for iOS and OS X. This was just a quick PR so I can move on with my own job (need only iOS platform) and I couldn't figure out how to build all architectures from a single framework target (had some issues - don't remember specifics). \n\nThanks for merging that other PR :+1: \n. ",
    "CalQL8ed-K-OS": "the auto conversion doesn't pop up any issues whatsoever.\nif by **updating** you mean utilizing some of the cool new features, then sign me up for helping you out on this :smiley:\n. ah, my PR #20 for XCTest removes that `println`, that's why i thought it wasn't needed :smile: \n. i think I agree on both counts.\n\nI probably wrote the tests by type because it was easier, and I was just focusing on the mechanical transcribing from main.swift into XCTest.\n\nI felt the removal belonged in cleanup, but I concede to your argument, and definitely feel it's a minor point.\n\nthe good news is we should be able to hook this up to Travis.CI and make those changes whenever :D\n. the auto conversion doesn't pop up any issues whatsoever.\nif by **updating** you mean utilizing some of the cool new features, then sign me up for helping you out on this :smiley:\n. ah, my PR #20 for XCTest removes that `println`, that's why i thought it wasn't needed :smile: \n. i think I agree on both counts.\n\nI probably wrote the tests by type because it was easier, and I was just focusing on the mechanical transcribing from main.swift into XCTest.\n\nI felt the removal belonged in cleanup, but I concede to your argument, and definitely feel it's a minor point.\n\nthe good news is we should be able to hook this up to Travis.CI and make those changes whenever :D\n. ",
    "dmyers": "Oh okay. Thanks! :+1: \n. Oh okay. Thanks! :+1: \n. ",
    "kohtenko": "I agree, made this value 0 in unixtime on 3b9c29b\n. I believe this value is \"default enough\" :) If someone wants to make sure about null value - there is `date` and `hasKey` methods.\nunixtime 0 always been debatable value, but everyone knows that this is 01.01.1970\n. I agree, made this value 0 in unixtime on 3b9c29b\n. I believe this value is \"default enough\" :) If someone wants to make sure about null value - there is `date` and `hasKey` methods.\nunixtime 0 always been debatable value, but everyone knows that this is 01.01.1970\n. ",
    "kaunteya": "No problem.\n`next` looks very promising. `Stringly Typed` was a real big problem. Loved the static approach !!!\n. Yes, you can say that. But it striked to me because `NSDate()` initializes to `now`.\nSo it is accepted convention that NSDate when created with no information passed, initializes to `now`.\nAs per current implementation, we are any ways using `Bool()`, `Int()`, 'Double()`,`String()` etc as default values.\n\n#### Concluding\n\nI would say that if `Bool()` initializing  to false, `Int()` initializing to 0 (and so on) is obvious then even `NSDate()` initializing to now would be pretty obvious, as far as Cocoa community is concerned\n. Ok. Pretty much convinced now. TY @narfdotpl & @radex \n. It does not have any syntactical significance. I coined it without giving much thought.\nYes, the dictionary does not makes sense. Tuple could have been better I guess, but might have limitations.\n. @delba \nThe solution you've suggested may work well, but IMHO we should first have a clear idea regarding how this feature must be `designed`. So I suggest we discuss first on design and then on code.\n. No problem.\n`next` looks very promising. `Stringly Typed` was a real big problem. Loved the static approach !!!\n. Yes, you can say that. But it striked to me because `NSDate()` initializes to `now`.\nSo it is accepted convention that NSDate when created with no information passed, initializes to `now`.\nAs per current implementation, we are any ways using `Bool()`, `Int()`, 'Double()`,`String()` etc as default values.\n\n#### Concluding\n\nI would say that if `Bool()` initializing  to false, `Int()` initializing to 0 (and so on) is obvious then even `NSDate()` initializing to now would be pretty obvious, as far as Cocoa community is concerned\n. Ok. Pretty much convinced now. TY @narfdotpl & @radex \n. It does not have any syntactical significance. I coined it without giving much thought.\nYes, the dictionary does not makes sense. Tuple could have been better I guess, but might have limitations.\n. @delba \nThe solution you've suggested may work well, but IMHO we should first have a clear idea regarding how this feature must be `designed`. So I suggest we discuss first on design and then on code.\n. ",
    "Candyroot": "If assigning a variable whose type is Any  with an optional value, the variable cannot be converted to the original value. For example:\n\n``` swift\nvar a: String? = \"abc\"\nvar b: Any = a\nif let v = b as? String {\n    println(\"b is String\")\n} else {\n    println(\"b is not String\")\n}\n```\n\n\"b is not String\" is printed.\n\nSo, if I put an optional value after ?= operator, the value will be considered invalid. That is confused.\nFor example, write something like this:\n\n``` swift\nlet string: String? = \"abc\"\nDefaults[\"string\"] ?= string\n```\n\n`assertionFailure(\"Invalid value type\")` will be triggered.\n. Yes, I filed one. No response yet.\n. If assigning a variable whose type is Any  with an optional value, the variable cannot be converted to the original value. For example:\n\n``` swift\nvar a: String? = \"abc\"\nvar b: Any = a\nif let v = b as? String {\n    println(\"b is String\")\n} else {\n    println(\"b is not String\")\n}\n```\n\n\"b is not String\" is printed.\n\nSo, if I put an optional value after ?= operator, the value will be considered invalid. That is confused.\nFor example, write something like this:\n\n``` swift\nlet string: String? = \"abc\"\nDefaults[\"string\"] ?= string\n```\n\n`assertionFailure(\"Invalid value type\")` will be triggered.\n. Yes, I filed one. No response yet.\n. ",
    "kayvink": "I just ran `pod install` again and got `Using SwiftyUserDefaults (1.2.0)`, the problem remains. I Also asked someone else to check, he got the same error.\n. Ah, okay! I'm just running `pod 'SwiftyUserDefaults'`, could it be that the podspec hasn't been updated?\n. Yeah fixed it. Thanks. \ud83d\udc4d\ud83c\udffb\n. I just ran `pod install` again and got `Using SwiftyUserDefaults (1.2.0)`, the problem remains. I Also asked someone else to check, he got the same error.\n. Ah, okay! I'm just running `pod 'SwiftyUserDefaults'`, could it be that the podspec hasn't been updated?\n. Yeah fixed it. Thanks. \ud83d\udc4d\ud83c\udffb\n. ",
    "goktugyil": "https://github.com/radex/SwiftyUserDefaults/pull/47\n\nhere it is\n. Very informing article :+1: \n\nI tried to come up with a better method and failed.\n\nThe only way to make it easier, at least cognitively is to change the name of `DefaultsKey` to something like `SwiftyKey`, example:\n\n```\npublic class SwiftyKey<ValueType>: DefaultsKeys {\n    // TODO: Can we use protocols to ensure ValueType is a compatible type?\n    public let _key: String\n\n    public init(_ key: String) {\n        self._key = key\n    }\n}\n\nextension NSUserDefaults {\n    func set<T>(key: SwiftyKey<T>, _ value: Any?) {\n        self[key._key] = value\n    }\n}\n```\n\nBut that still would mean users editing their extension class. Not sure if its worth it.\n. I just got that error too. I assume the library doesn't support multidimensional arrays?\n. DefaultsKey<[String: Bool, String: Bool]> also can't do this or this: [Bool, Bool]\n. I agree that [[Bool]] shouldn't be the special exception. I needed that in my project, I added the functionality and sent a PR. \n\nWe should be able to have automatic support for the common keys, I am not sure how that will work. If it doesn't we can just manually add everything too.\n. http://stackoverflow.com/questions/26228619/generic-in-subscript-for-swift \nWorth a try\n. What about, manual add everything method?\n. This is great stuff, you should send a pull request if radex also wants it. Also array of arrays will be useful\n. Yes this is tested on 7.3 only. I'll narrow it down to a test case the next time I'm debugging memory bugs\n. Because it didn't cause a big problem in my app I didn't dive into this. There were a lot more serious problems. I'll test this again to see if its still around. . Here are some screenshots I took:\r\n\r\nhttp://prnt.sc/elfcyb\r\nhttp://prnt.sc/elfd7d\r\nhttp://prnt.sc/elfdhy\r\nhttp://prnt.sc/elfk33\r\n\r\nThere seems to be something wrong while writing. I'm guessing this probably happens to everyone, because I only use the standard features of the library.. I think those might be steps before. I'm not sure on how to read this data. \r\n\r\nI have a lot of stuff stored in arrays. \r\n\r\nExample: \r\n\r\n    struct DBSlot1Keys {\r\n\r\n         static let playerRecipeIds = DefaultsKey<[String]>(\"playerRecipeIds\")\r\n    }\r\n\r\n    let recipeIds = Defaults[DBSlot1Keys.playerRecipeIds] //load\r\n    Defaults[DBSlot1Keys.playerRecipeIds] = recipeIdArray //save\r\n\r\n. http://prntscr.com/at1muu\n\nI'm using it to extend your repo\n. I don't think a test case would help much. The functionality is very straight forward, instead of a test method, protecting user from bad inputs may be useful. I can't think of inputs that will crash this atm but I am sure there are some.\n. https://github.com/radex/SwiftyUserDefaults/pull/47\n\nhere it is\n. Very informing article :+1: \n\nI tried to come up with a better method and failed.\n\nThe only way to make it easier, at least cognitively is to change the name of `DefaultsKey` to something like `SwiftyKey`, example:\n\n```\npublic class SwiftyKey<ValueType>: DefaultsKeys {\n    // TODO: Can we use protocols to ensure ValueType is a compatible type?\n    public let _key: String\n\n    public init(_ key: String) {\n        self._key = key\n    }\n}\n\nextension NSUserDefaults {\n    func set<T>(key: SwiftyKey<T>, _ value: Any?) {\n        self[key._key] = value\n    }\n}\n```\n\nBut that still would mean users editing their extension class. Not sure if its worth it.\n. I just got that error too. I assume the library doesn't support multidimensional arrays?\n. DefaultsKey<[String: Bool, String: Bool]> also can't do this or this: [Bool, Bool]\n. I agree that [[Bool]] shouldn't be the special exception. I needed that in my project, I added the functionality and sent a PR. \n\nWe should be able to have automatic support for the common keys, I am not sure how that will work. If it doesn't we can just manually add everything too.\n. http://stackoverflow.com/questions/26228619/generic-in-subscript-for-swift \nWorth a try\n. What about, manual add everything method?\n. This is great stuff, you should send a pull request if radex also wants it. Also array of arrays will be useful\n. Yes this is tested on 7.3 only. I'll narrow it down to a test case the next time I'm debugging memory bugs\n. Because it didn't cause a big problem in my app I didn't dive into this. There were a lot more serious problems. I'll test this again to see if its still around. . Here are some screenshots I took:\r\n\r\nhttp://prnt.sc/elfcyb\r\nhttp://prnt.sc/elfd7d\r\nhttp://prnt.sc/elfdhy\r\nhttp://prnt.sc/elfk33\r\n\r\nThere seems to be something wrong while writing. I'm guessing this probably happens to everyone, because I only use the standard features of the library.. I think those might be steps before. I'm not sure on how to read this data. \r\n\r\nI have a lot of stuff stored in arrays. \r\n\r\nExample: \r\n\r\n    struct DBSlot1Keys {\r\n\r\n         static let playerRecipeIds = DefaultsKey<[String]>(\"playerRecipeIds\")\r\n    }\r\n\r\n    let recipeIds = Defaults[DBSlot1Keys.playerRecipeIds] //load\r\n    Defaults[DBSlot1Keys.playerRecipeIds] = recipeIdArray //save\r\n\r\n. http://prntscr.com/at1muu\n\nI'm using it to extend your repo\n. I don't think a test case would help much. The functionality is very straight forward, instead of a test method, protecting user from bad inputs may be useful. I can't think of inputs that will crash this atm but I am sure there are some.\n. ",
    "hemezh": "This is not documented anywhere. Added this in https://github.com/radex/SwiftyUserDefaults/pull/94/commits/39e122d828d7937a3a82f1c6d199d06191f9a6c3.\n. This is not documented anywhere. Added this in https://github.com/radex/SwiftyUserDefaults/pull/94/commits/39e122d828d7937a3a82f1c6d199d06191f9a6c3.\n. ",
    "romaincointepas": "Cool! Any ETA for a fix? (release planned soon and I'm using the `next` branch)\n. Thanks for the fix! (Sweet 2.0 by the way)\n\nRomain (from a phone)\n\n> On Sep 18, 2015, at 3:18 PM, Radek Pietruszewski notifications@github.com wrote:\n> \n> Fixed, thanks for letting me know about this!\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Cool! Any ETA for a fix? (release planned soon and I'm using the `next` branch)\n. Thanks for the fix! (Sweet 2.0 by the way)\n\nRomain (from a phone)\n\n> On Sep 18, 2015, at 3:18 PM, Radek Pietruszewski notifications@github.com wrote:\n> \n> Fixed, thanks for letting me know about this!\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "mathiasnagler": "I went ahead and added tvOS support. \n. I think it's unnecessary to disable a unit test using `#if !os(tvOS)`. The only problem with the test on tvOS is that there is no `NSColor`. In my PR #53 I kept the test intact by a typealias `typealias NSColor = UIColor` that is only active when running on a platform that is not OS X. This way, all the unit tests can be kept active across all the supported targets.\n. Done in #55\n. I went ahead and added tvOS support. \n. I think it's unnecessary to disable a unit test using `#if !os(tvOS)`. The only problem with the test on tvOS is that there is no `NSColor`. In my PR #53 I kept the test intact by a typealias `typealias NSColor = UIColor` that is only active when running on a platform that is not OS X. This way, all the unit tests can be kept active across all the supported targets.\n. Done in #55\n. ",
    "staticdreams": "podspec file is still missing tvOS support. Care to update it so we can use it with cocoapods?\n. @radex Done :)\n. So, at this point is it at all possible to store enum's case in SwiftyUserDefaults?\n. podspec file is still missing tvOS support. Care to update it so we can use it with cocoapods?\n. @radex Done :)\n. So, at this point is it at all possible to store enum's case in SwiftyUserDefaults?\n. ",
    "andreyvit": "Actually this looks like a dup of #40. Would be interested to hear your arguments for a subscripting approach.\n. Actually this looks like a dup of #40. Would be interested to hear your arguments for a subscripting approach.\n. ",
    "confilemg": "So this error is gone in ios 8 and above?\n. So this error is gone in ios 8 and above?\n. ",
    "pixlwave": "To save and restore from `UISlider.value` which I'm using to create SCNVector3 objects?\n. Oh, that's a surprise. I'd have thought for mobile Apple would've encouraged float for memory efficiency when precision wasn't needed. Never mind then.\n. Browsing through the changes, I notice that `NSDate` and `NSData` have been changed to `Date` and `Data` respectively, which left me wondering if the same should happen to `NSArray` and `NSDictionary` for consistency in returning value types?\n\nEdit: Or whether in fact it's more desirable to keep NSDate and NSData for reference types. But I guess that the NS-reference stuff is less swifty?\n. To save and restore from `UISlider.value` which I'm using to create SCNVector3 objects?\n. Oh, that's a surprise. I'd have thought for mobile Apple would've encouraged float for memory efficiency when precision wasn't needed. Never mind then.\n. Browsing through the changes, I notice that `NSDate` and `NSData` have been changed to `Date` and `Data` respectively, which left me wondering if the same should happen to `NSArray` and `NSDictionary` for consistency in returning value types?\n\nEdit: Or whether in fact it's more desirable to keep NSDate and NSData for reference types. But I guess that the NS-reference stuff is less swifty?\n. ",
    "bill350": "Hmm, I have the same use case as @pixlwave, a `UISlider` preference. \r\nSo @radex, you think there is definitely no need to save a `Float` in `UserDefaults` ? \r\nYes it is recommended to use `Double`, but it is always possible to use `Float` in our apps.... Ok, no problem ;). Hmm, I have the same use case as @pixlwave, a `UISlider` preference. \r\nSo @radex, you think there is definitely no need to save a `Float` in `UserDefaults` ? \r\nYes it is recommended to use `Double`, but it is always possible to use `Float` in our apps.... Ok, no problem ;). ",
    "ton03": "Hello,\n\nI still get a warning for stuff like:\n\n```\nCarthage/Checkouts/SwiftyUserDefaults/SwiftyUserDefaultsTests/SwiftyUserDefaultsTests.swift:44:23: warning: '?=' is deprecated\n...\nld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.2.sdk/Developer/Library/Frameworks'\nld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.2.sdk/Developer/Library/Frameworks'\n```\n. Hello,\n\nI still get a warning for stuff like:\n\n```\nCarthage/Checkouts/SwiftyUserDefaults/SwiftyUserDefaultsTests/SwiftyUserDefaultsTests.swift:44:23: warning: '?=' is deprecated\n...\nld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.2.sdk/Developer/Library/Frameworks'\nld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.2.sdk/Developer/Library/Frameworks'\n```\n. ",
    "markcleonard": "I receive quite a lot of deprecation warnings when building through carthage.\n. I receive quite a lot of deprecation warnings when building through carthage.\n. ",
    "thellimist": "this feature would be great.\n. this feature would be great.\n. ",
    "efremidze": ":+1: \n. :+1: \n. ",
    "basememara": "Check out my pull request (#81) and see if that works for everyone (including @MaxHasADHD too). It adds an extended version of `registerDefaults`. I updated the readme docs and added a ton of unit tests for it. You'd use it like this:\n\n```\nlet Defaults = NSUserDefaults.registerDefaults(\"Settings.plist\")\nlet Defaults2 = NSUserDefaults.registerDefaults(\"Settings.plist\", suiteName: \"io.radex.SwiftyUserDefaults\")\nlet Defaults3 = NSUserDefaults.registerDefaults(bundleName: \"Settings\")\n\nlet key1 = DefaultsKey<String>(\"MyString1\")\nDefaults[key1] == \"My string value 1.\" // true\n```\n\nAnd the `plist` would look something like this:\n<img width=\"562\" alt=\"capturfiles_296\" src=\"https://cloud.githubusercontent.com/assets/892152/13509992/854b5f6e-e15c-11e5-9853-36215ccd0e05.png\">\n. Why doesn't it make sense that optionals can have a default value? The default value should be stored during the initialization of the storage key. Something like `if key doesn't exist, then create storage with default value`, but after that it would still make sense to store `nil` in there.\n\n**Edit:** On second thought #69 would probably take care of this then you can just do this for optionals discussed here: `DefaultsKey<String?>(\"username\") ?? \"some default\"`\n. Hey, not sure if this is somewhat related or useful here, but I was able to get an array of dictionaries to work:\n\n```\npublic extension NSUserDefaults {\n    public subscript(key: DefaultsKey<[[String: AnyObject]]>) -> [[String: AnyObject]] {\n        get {\n            return arrayForKey(key._key) as? [[String: AnyObject]] ?? [[:]]\n        }\n        set { set(key, newValue) }\n    }\n\n    func set<T>(key: DefaultsKey<T>, _ value: [[String: AnyObject]]?) {\n        self[key._key] = value\n    }\n}\n```\n\nThen I can use it like this:\n\n```\npublic extension DefaultsKeys {\n    public static let categories = DefaultsKey<[[String: AnyObject]]>(\"categories\")\n}\n\n// get value\nguard let value = Defaults[.categories][3][\"title\"] as? String else { return }\nprint(\"Forth category title: \\(value)\") // Health\n\n// set value\nDefaults[.categories][3][\"title\"] = \"Health and Fitness\"\n```\n\nTo put things into perspective, the structure looks something like this:\n<img width=\"428\" alt=\"capturfiles_339\" src=\"https://cloud.githubusercontent.com/assets/892152/15036277/b4f79ca8-125a-11e6-959f-bc056655e80c.png\">\n\nIt seems to work well for `get` and `set`. I hope this helps.\n. Cool, glad it makes sense. Here's the pull request to take a further look, which has an updated readme and unit test: #88\n. Ah I didn't realize `Defaults` is a global variable created for convenience. Do you think in the source code we'll have to add `synchronize()` after the `switch` in the `set`?:\n\n```\n    public subscript(key: String) -> Any? {\n        get {\n            // return untyped Proxy\n            // (make sure we don't fall into infinite loop)\n            let proxy: Proxy = self[key]\n            return proxy\n        }\n        set {\n            switch newValue {\n            case let v as Int: setInteger(v, forKey: key)\n            case let v as Double: setDouble(v, forKey: key)\n            case let v as Bool: setBool(v, forKey: key)\n            case let v as NSURL: setURL(v, forKey: key)\n            case let v as NSObject: setObject(v, forKey: key)\n            case nil: removeObjectForKey(key)\n            default: assertionFailure(\"Invalid value type\")\n            }\n            synchronize()\n        }\n    }\n```\n\nFrom my experience, it won't hurt to call `synchronize()` even if the user defaults is not using a `suiteName`.\n. Your suggested version is very nice and would be very handy! I like!\n\nThe reason I leaned on the plist is because it's easier to control the defaults when distributing multiple apps, i.e. code stays the same across apps with differences only in the plist. There is some level of type checking in the plist though, since when choosing the type in the \"Type\" column, Xcode will not allow you to put a string in a number type for example.\n. Wait I think I understand what you're saying, if I change the type later in the plist, things will crash. Hmmm, I'll give it more thought. I do still like your suggestion.\n. Yes, I think you are right. A `.plist` or `.swift` file is just semantics but can work just the same if you want a single place to control across various apps. My thoughts were the `.plist` files were designed to control app settings, but it might be worth the trade for compiler checks if putting in a `.swift` file instead.\n\nI'll give it more thought if there are any other benefits we're missing for `.plist` vs `.swift` file for defaults and will take another stab at it using your suggestion.\n. If we're not going to read from `plist`, then I prefer to set default values in the `DefaultKeys` extension so it's all in one place like in #59, otherwise a race condition can be introduced. I'll piggyback on the #59 branch and see if I can contribute anything there. I think that's the right idea if we're going to go the `.swift` file route for defaults.\n. I see about the non-SwiftyUserDefaults users not getting to those values. Because that branch is not actually saving to NSUserDefaults, but it should be updated to do that. That is a good catch.\n\nThe race condition I'm concerned about is something like:\n\n```\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {\n        Defaults.register([\n            .userName: 'radex',\n            .launchCount: 0,\n            ])\n\n        return true\n    }\n```\n\nThen in one of your view controllers you do this:\n\n```\nclass FirstViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        someLabel.text = Defaults[.userName]\n    }\n}\n```\n\nIn this example, `viewDidLoad` can be called before `didFinishLaunchingWithOptions` as [discussed here](http://stackoverflow.com/questions/7030635/ios-viewdidload-is-being-called-before-the-didfinishlaunchingwithoptions-deleg). That means the screen will display a blank username, before the defaults are registered.\n. Ya it's depressing, it's almost as if there's no good place to put code that initializes before your views.\n\nSweet, I like the convince init you suggest - better than the original. Thanks for the input again :D\n. Something hit me from something you said about @delba's implementation that might simplify everything. How about just adding this `convenience init` to `DefaultKeys`:\n\n```\npublic class DefaultsKey<ValueType>: DefaultsKeys {\n    public let _key: String\n\n    public init(_ key: String) {\n        self._key = key\n    }\n\n    public convenience init(_ key: String, _ defaultValue: ValueType) {\n        self.init(key)\n\n        if !Defaults.hasKey(key) {\n            Defaults[key] = defaultValue\n        }\n    }\n}\n```\n\nThat's all the code update we need since all it's doing is storing the value into `NSUserDefaults`. And because the value is persisted first thing, everything after in `SwiftyUserDefaults` follows the natural flow as it did before without further code changes needed.\n\nWhat I like about this is there is no race conditions introduced and the code change is super minimal. Also, a big benefit is all defaults are packaged in the declaration of the `DefaultKeys` in one place. It would look like this:\n\n```\nextension DefaultsKeys {\n    public static let someString1 = DefaultsKey<String>(\"SomeString1\")\n    static let someString2 = DefaultsKey<String>(\"SomeString2\", \"abc\") // default added\n    static let someNumber1 = DefaultsKey<Int>(\"SomeNumber1\")\n    static let someNumber2 = DefaultsKey<Int>(\"SomeNumber2\", 888) // default added\n    static let someBool1 = DefaultsKey<Bool>(\"SomeBool1\")\n    static let someBool2 = DefaultsKey<Bool>(\"SomeBool2\", true)\n    static let someDate1 = DefaultsKey<NSDate>(\"SomeDate1\")\n    static let someDate2 = DefaultsKey<NSDate>(\"SomeDate2\", NSDate()) // default added\n}\n```\n\nThe only thing we'd have to resolve is the `suiteName` situation since this is under the assumption that `Defaults` should always be `NSUserDefaults.standardUserDefaults()`. But this is another topic that is ongoing in another thread.\n. I had a break-thru in regards to this discussion that I'd like to document here. Apparently, the best place to register defaults is indeed in `AppDelegate.init`:\n\n```\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    var window: UIWindow?\n\n    override init() {\n        super.init()\n        Defaults.registerDefaults([\n            \"userName\": \"radex\",\n            \"launchCount\": 10\n        ])\n    }\n\n    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {\n          ...\n    }\n}\n```\n\nNote that the native `registerDefaults` function will register the values to your `UserDefaults` for the entire lifecycle of your app; it will not persist to it. Once your app terminates and start up again in the future, those values will not be in your `UserDefaults` anymore unless you keep registering the defaults in the beginning of your app (or before you need them).\n. BTW I believe all these are related to the same topic and would be great if we can consolidate them somehow: #51, #59, #69, #81\n. I agree the `set` should be made public. In the readme you say that you can create [custom types](https://github.com/radex/SwiftyUserDefaults#custom-types), but this is not possible unless you redefine the `set` function in the consuming side.\n\nFor testing this, in `TestHelper` you are already defining custom types that use that same `set` function which still work. The only way to really test this is to create a module outside of the workspace, consume `SwiftyUserDefaults`, then define custom types without having to explicitly recreate the `set` function.\n\nI just tried this in my app by consuming `SwiftyUserDefaults` via Carthage, adding the checkout to my workspace, and modify the source code to make the `set` public. I was able to define my own custom types without having to redefine the `set` function \ud83d\udc4d \n. Check this out: https://twitter.com/johnsundell/status/855713943809032192\r\n\r\n![c-absshxuaa_9gi jpg-small](https://cloud.githubusercontent.com/assets/892152/25874866/8a0f2596-34e2-11e7-9a43-a572c764799a.jpeg)\r\n. The long awaited generic subscript is here. This should reduce the code base tremendously.. Sorry, missed the many PR's regarding Swift 4 updates.. Check out my pull request (#81) and see if that works for everyone (including @MaxHasADHD too). It adds an extended version of `registerDefaults`. I updated the readme docs and added a ton of unit tests for it. You'd use it like this:\n\n```\nlet Defaults = NSUserDefaults.registerDefaults(\"Settings.plist\")\nlet Defaults2 = NSUserDefaults.registerDefaults(\"Settings.plist\", suiteName: \"io.radex.SwiftyUserDefaults\")\nlet Defaults3 = NSUserDefaults.registerDefaults(bundleName: \"Settings\")\n\nlet key1 = DefaultsKey<String>(\"MyString1\")\nDefaults[key1] == \"My string value 1.\" // true\n```\n\nAnd the `plist` would look something like this:\n<img width=\"562\" alt=\"capturfiles_296\" src=\"https://cloud.githubusercontent.com/assets/892152/13509992/854b5f6e-e15c-11e5-9853-36215ccd0e05.png\">\n. Why doesn't it make sense that optionals can have a default value? The default value should be stored during the initialization of the storage key. Something like `if key doesn't exist, then create storage with default value`, but after that it would still make sense to store `nil` in there.\n\n**Edit:** On second thought #69 would probably take care of this then you can just do this for optionals discussed here: `DefaultsKey<String?>(\"username\") ?? \"some default\"`\n. Hey, not sure if this is somewhat related or useful here, but I was able to get an array of dictionaries to work:\n\n```\npublic extension NSUserDefaults {\n    public subscript(key: DefaultsKey<[[String: AnyObject]]>) -> [[String: AnyObject]] {\n        get {\n            return arrayForKey(key._key) as? [[String: AnyObject]] ?? [[:]]\n        }\n        set { set(key, newValue) }\n    }\n\n    func set<T>(key: DefaultsKey<T>, _ value: [[String: AnyObject]]?) {\n        self[key._key] = value\n    }\n}\n```\n\nThen I can use it like this:\n\n```\npublic extension DefaultsKeys {\n    public static let categories = DefaultsKey<[[String: AnyObject]]>(\"categories\")\n}\n\n// get value\nguard let value = Defaults[.categories][3][\"title\"] as? String else { return }\nprint(\"Forth category title: \\(value)\") // Health\n\n// set value\nDefaults[.categories][3][\"title\"] = \"Health and Fitness\"\n```\n\nTo put things into perspective, the structure looks something like this:\n<img width=\"428\" alt=\"capturfiles_339\" src=\"https://cloud.githubusercontent.com/assets/892152/15036277/b4f79ca8-125a-11e6-959f-bc056655e80c.png\">\n\nIt seems to work well for `get` and `set`. I hope this helps.\n. Cool, glad it makes sense. Here's the pull request to take a further look, which has an updated readme and unit test: #88\n. Ah I didn't realize `Defaults` is a global variable created for convenience. Do you think in the source code we'll have to add `synchronize()` after the `switch` in the `set`?:\n\n```\n    public subscript(key: String) -> Any? {\n        get {\n            // return untyped Proxy\n            // (make sure we don't fall into infinite loop)\n            let proxy: Proxy = self[key]\n            return proxy\n        }\n        set {\n            switch newValue {\n            case let v as Int: setInteger(v, forKey: key)\n            case let v as Double: setDouble(v, forKey: key)\n            case let v as Bool: setBool(v, forKey: key)\n            case let v as NSURL: setURL(v, forKey: key)\n            case let v as NSObject: setObject(v, forKey: key)\n            case nil: removeObjectForKey(key)\n            default: assertionFailure(\"Invalid value type\")\n            }\n            synchronize()\n        }\n    }\n```\n\nFrom my experience, it won't hurt to call `synchronize()` even if the user defaults is not using a `suiteName`.\n. Your suggested version is very nice and would be very handy! I like!\n\nThe reason I leaned on the plist is because it's easier to control the defaults when distributing multiple apps, i.e. code stays the same across apps with differences only in the plist. There is some level of type checking in the plist though, since when choosing the type in the \"Type\" column, Xcode will not allow you to put a string in a number type for example.\n. Wait I think I understand what you're saying, if I change the type later in the plist, things will crash. Hmmm, I'll give it more thought. I do still like your suggestion.\n. Yes, I think you are right. A `.plist` or `.swift` file is just semantics but can work just the same if you want a single place to control across various apps. My thoughts were the `.plist` files were designed to control app settings, but it might be worth the trade for compiler checks if putting in a `.swift` file instead.\n\nI'll give it more thought if there are any other benefits we're missing for `.plist` vs `.swift` file for defaults and will take another stab at it using your suggestion.\n. If we're not going to read from `plist`, then I prefer to set default values in the `DefaultKeys` extension so it's all in one place like in #59, otherwise a race condition can be introduced. I'll piggyback on the #59 branch and see if I can contribute anything there. I think that's the right idea if we're going to go the `.swift` file route for defaults.\n. I see about the non-SwiftyUserDefaults users not getting to those values. Because that branch is not actually saving to NSUserDefaults, but it should be updated to do that. That is a good catch.\n\nThe race condition I'm concerned about is something like:\n\n```\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {\n        Defaults.register([\n            .userName: 'radex',\n            .launchCount: 0,\n            ])\n\n        return true\n    }\n```\n\nThen in one of your view controllers you do this:\n\n```\nclass FirstViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        someLabel.text = Defaults[.userName]\n    }\n}\n```\n\nIn this example, `viewDidLoad` can be called before `didFinishLaunchingWithOptions` as [discussed here](http://stackoverflow.com/questions/7030635/ios-viewdidload-is-being-called-before-the-didfinishlaunchingwithoptions-deleg). That means the screen will display a blank username, before the defaults are registered.\n. Ya it's depressing, it's almost as if there's no good place to put code that initializes before your views.\n\nSweet, I like the convince init you suggest - better than the original. Thanks for the input again :D\n. Something hit me from something you said about @delba's implementation that might simplify everything. How about just adding this `convenience init` to `DefaultKeys`:\n\n```\npublic class DefaultsKey<ValueType>: DefaultsKeys {\n    public let _key: String\n\n    public init(_ key: String) {\n        self._key = key\n    }\n\n    public convenience init(_ key: String, _ defaultValue: ValueType) {\n        self.init(key)\n\n        if !Defaults.hasKey(key) {\n            Defaults[key] = defaultValue\n        }\n    }\n}\n```\n\nThat's all the code update we need since all it's doing is storing the value into `NSUserDefaults`. And because the value is persisted first thing, everything after in `SwiftyUserDefaults` follows the natural flow as it did before without further code changes needed.\n\nWhat I like about this is there is no race conditions introduced and the code change is super minimal. Also, a big benefit is all defaults are packaged in the declaration of the `DefaultKeys` in one place. It would look like this:\n\n```\nextension DefaultsKeys {\n    public static let someString1 = DefaultsKey<String>(\"SomeString1\")\n    static let someString2 = DefaultsKey<String>(\"SomeString2\", \"abc\") // default added\n    static let someNumber1 = DefaultsKey<Int>(\"SomeNumber1\")\n    static let someNumber2 = DefaultsKey<Int>(\"SomeNumber2\", 888) // default added\n    static let someBool1 = DefaultsKey<Bool>(\"SomeBool1\")\n    static let someBool2 = DefaultsKey<Bool>(\"SomeBool2\", true)\n    static let someDate1 = DefaultsKey<NSDate>(\"SomeDate1\")\n    static let someDate2 = DefaultsKey<NSDate>(\"SomeDate2\", NSDate()) // default added\n}\n```\n\nThe only thing we'd have to resolve is the `suiteName` situation since this is under the assumption that `Defaults` should always be `NSUserDefaults.standardUserDefaults()`. But this is another topic that is ongoing in another thread.\n. I had a break-thru in regards to this discussion that I'd like to document here. Apparently, the best place to register defaults is indeed in `AppDelegate.init`:\n\n```\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    var window: UIWindow?\n\n    override init() {\n        super.init()\n        Defaults.registerDefaults([\n            \"userName\": \"radex\",\n            \"launchCount\": 10\n        ])\n    }\n\n    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {\n          ...\n    }\n}\n```\n\nNote that the native `registerDefaults` function will register the values to your `UserDefaults` for the entire lifecycle of your app; it will not persist to it. Once your app terminates and start up again in the future, those values will not be in your `UserDefaults` anymore unless you keep registering the defaults in the beginning of your app (or before you need them).\n. BTW I believe all these are related to the same topic and would be great if we can consolidate them somehow: #51, #59, #69, #81\n. I agree the `set` should be made public. In the readme you say that you can create [custom types](https://github.com/radex/SwiftyUserDefaults#custom-types), but this is not possible unless you redefine the `set` function in the consuming side.\n\nFor testing this, in `TestHelper` you are already defining custom types that use that same `set` function which still work. The only way to really test this is to create a module outside of the workspace, consume `SwiftyUserDefaults`, then define custom types without having to explicitly recreate the `set` function.\n\nI just tried this in my app by consuming `SwiftyUserDefaults` via Carthage, adding the checkout to my workspace, and modify the source code to make the `set` public. I was able to define my own custom types without having to redefine the `set` function \ud83d\udc4d \n. Check this out: https://twitter.com/johnsundell/status/855713943809032192\r\n\r\n![c-absshxuaa_9gi jpg-small](https://cloud.githubusercontent.com/assets/892152/25874866/8a0f2596-34e2-11e7-9a43-a572c764799a.jpeg)\r\n. The long awaited generic subscript is here. This should reduce the code base tremendously.. Sorry, missed the many PR's regarding Swift 4 updates.. ",
    "DivineDominion": "This looks cool. Any issues so far, or would this be merge-able?. That looks awesome! I wonder if the `Disposable` requirement makes observing _N_ keys a hassle. I'm working on observing user defaults to push updates to the app state ([ReSwift](https://github.com/ReSwift/ReSwift)).. Sure thing, though it sounds more cumbersome for you :). I shot too quick: after I dabbled with the available settings some more, I found that CocoaBindings can work with `NSKeyedArchiver`, too. That means the default `archive`/`unarchive` calls will do just fine \ud83d\udc4d\r\n\r\nBtw, `NSArchiver` seems to be the predecessor to `NSKeyedArchiver`. Both depend on `NSCoding` and are subclasses of `NSCoder`.. This looks cool. Any issues so far, or would this be merge-able?. That looks awesome! I wonder if the `Disposable` requirement makes observing _N_ keys a hassle. I'm working on observing user defaults to push updates to the app state ([ReSwift](https://github.com/ReSwift/ReSwift)).. Sure thing, though it sounds more cumbersome for you :). I shot too quick: after I dabbled with the available settings some more, I found that CocoaBindings can work with `NSKeyedArchiver`, too. That means the default `archive`/`unarchive` calls will do just fine \ud83d\udc4d\r\n\r\nBtw, `NSArchiver` seems to be the predecessor to `NSKeyedArchiver`. Both depend on `NSCoding` and are subclasses of `NSCoder`.. ",
    "pixyzehn": ":+1: \n. :+1: \n. ",
    "delba": "> it doesn't make any sense to have a T? defaults key\n\nYes indeed. That's why the default is only used with the non-optional types.\nMaybe we could print a warning in the `init`? Not ideal...\n. Something like [this](https://github.com/delba/SwiftyUserDefaults/commit/8f543168239b2f2b0f2edb596e66c3398f3f8b91) ?\n\nIt's kind of painful to check if a generic is an optional...\n. Other ways to check if a generic is an optional:\n- `String(value.dynamicType).hasPrefix(\"Optional\")`\n- `Mirror(reflecting: value).displayStyle! == .Optional`\n\nI hope there are others but I haven't found them yet :(\n\n@kaunteya yes, of course! This is WIP and shouldn't expected to be merged as it is now (if ever)\n. @radex I amended the latest commit.\n\nI used `preconditionFailure` with an error message, renamed `AnOptional` to `OptionalValue`, marked the public `init` as convenient initializers and created a designated one.\n\nCreating a private protocol to check if a generic is an optional is still better than any of the solutions above IMO:\n- the `\"Optional\"` prefix may change with Swift versions (I think that in `1.x` it was `Swift.Optional`)\n- checking the `displayStyle` feels really, really hackish\n\nFeedback welcome :smile:\n. @radex Done!\n. > it doesn't make any sense to have a T? defaults key\n\nYes indeed. That's why the default is only used with the non-optional types.\nMaybe we could print a warning in the `init`? Not ideal...\n. Something like [this](https://github.com/delba/SwiftyUserDefaults/commit/8f543168239b2f2b0f2edb596e66c3398f3f8b91) ?\n\nIt's kind of painful to check if a generic is an optional...\n. Other ways to check if a generic is an optional:\n- `String(value.dynamicType).hasPrefix(\"Optional\")`\n- `Mirror(reflecting: value).displayStyle! == .Optional`\n\nI hope there are others but I haven't found them yet :(\n\n@kaunteya yes, of course! This is WIP and shouldn't expected to be merged as it is now (if ever)\n. @radex I amended the latest commit.\n\nI used `preconditionFailure` with an error message, renamed `AnOptional` to `OptionalValue`, marked the public `init` as convenient initializers and created a designated one.\n\nCreating a private protocol to check if a generic is an optional is still better than any of the solutions above IMO:\n- the `\"Optional\"` prefix may change with Swift versions (I think that in `1.x` it was `Swift.Optional`)\n- checking the `displayStyle` feels really, really hackish\n\nFeedback welcome :smile:\n. @radex Done!\n. ",
    "damianesteban": "Is it possible to serialize reference types, i.e. a class named `Dog`?  Can this be accomplished by writing an extension for `NSUserDefaults` as demonstrated in the documentation?\n. I originally posted that I received an error, however I forgot to add the extension to `NSUserDefaults` to enable the subscript.  It works great :neckbeard: \n\nThe class:\n\n```\nclass Superman: NSObject, NSCoding {\n\n    var name: String?\n    var superpowers: [String]?\n\n    override var description: String {\n        return \"Superman's real name is \\(name) and his powers are \\(superpowers)\"\n    }\n\n    init(name: String?, superpowers: [String]?) {\n        self.name = name\n        self.superpowers = superpowers\n    }\n\n    required init(coder aDecoder: NSCoder) {\n        name = aDecoder.decodeObjectForKey(\"name\") as? String\n        superpowers = aDecoder.decodeObjectForKey(\"superpowers\") as? [String]\n    }\n\n    func encodeWithCoder(aCoder: NSCoder) {\n        aCoder.encodeObject(name, forKey: \"name\")\n        aCoder.encodeObject(superpowers, forKey: \"superpowers\")\n    }\n}\n```\n\nthe extension:\n\n```\nextension NSUserDefaults {\n    subscript(key: DefaultsKey<Superman?>) -> Superman? {\n        get { return unarchive(key) }\n        set { archive(key, newValue) }\n    }\n}\n\nextension DefaultsKeys {\n    static let superman = DefaultsKey<Superman?>(\"superman\")\n}\n```\n. Is it possible to serialize reference types, i.e. a class named `Dog`?  Can this be accomplished by writing an extension for `NSUserDefaults` as demonstrated in the documentation?\n. I originally posted that I received an error, however I forgot to add the extension to `NSUserDefaults` to enable the subscript.  It works great :neckbeard: \n\nThe class:\n\n```\nclass Superman: NSObject, NSCoding {\n\n    var name: String?\n    var superpowers: [String]?\n\n    override var description: String {\n        return \"Superman's real name is \\(name) and his powers are \\(superpowers)\"\n    }\n\n    init(name: String?, superpowers: [String]?) {\n        self.name = name\n        self.superpowers = superpowers\n    }\n\n    required init(coder aDecoder: NSCoder) {\n        name = aDecoder.decodeObjectForKey(\"name\") as? String\n        superpowers = aDecoder.decodeObjectForKey(\"superpowers\") as? [String]\n    }\n\n    func encodeWithCoder(aCoder: NSCoder) {\n        aCoder.encodeObject(name, forKey: \"name\")\n        aCoder.encodeObject(superpowers, forKey: \"superpowers\")\n    }\n}\n```\n\nthe extension:\n\n```\nextension NSUserDefaults {\n    subscript(key: DefaultsKey<Superman?>) -> Superman? {\n        get { return unarchive(key) }\n        set { archive(key, newValue) }\n    }\n}\n\nextension DefaultsKeys {\n    static let superman = DefaultsKey<Superman?>(\"superman\")\n}\n```\n. ",
    "samritchie": "Yes, arbitrary reference types can be serialised by implementing `NSCoding` - I think you\u2019ll need `@objc` or to subclass `NSObject` though.\n. Yes, arbitrary reference types can be serialised by implementing `NSCoding` - I think you\u2019ll need `@objc` or to subclass `NSObject` though.\n. ",
    "bcylin": ":beers: \n. :beers: \n. ",
    "klevison": "+1\n. +1\n. ",
    "matthewcheok": "Should have extended `DefaultKeys` not `DefaultKey`. \n. Should have extended `DefaultKeys` not `DefaultKey`. \n. ",
    "sattinos": "Any possible plan that swift compiler might support this in the future ?. Any possible plan that swift compiler might support this in the future ?. ",
    "ed-mejia": "please check this: https://github.com/radex/SwiftyUserDefaults/pull/47\n\nresetAllKeys method was Added, should be available.\n. mmmm, didn't check that #47 is a pull request and not yet merged :hushed:\n\nYou could just make an extension and will work the same way. \n. please check this: https://github.com/radex/SwiftyUserDefaults/pull/47\n\nresetAllKeys method was Added, should be available.\n. mmmm, didn't check that #47 is a pull request and not yet merged :hushed:\n\nYou could just make an extension and will work the same way. \n. ",
    "ajaysinghthakur": "thank you for your support  and i checked stack overflow there is no answers using tag(SwiftyUserDefaults)\n. thank you for your support  and i checked stack overflow there is no answers using tag(SwiftyUserDefaults)\n. ",
    "GabrielCartier": "The problem is with your definition of the key type. Is there a reason why you have two square brackets? You need an array of dictionary? \nWhen you get this error it's because the compiler can't assume the type is correct.\nTry works for example:\n\n```\nextension DefaultsKeys {\nstatic let latestProjects = DefaultsKey<[String: AnyObject]?>(\"latestProjects\")\n}\nlet test : [String: AnyObject]? = [\"Test\": 1]\nDefaults[.latestProjects] = test\n```\n. Not sure, I've played around a bit, it seems like a compiler issue.\n. The problem is with your definition of the key type. Is there a reason why you have two square brackets? You need an array of dictionary? \nWhen you get this error it's because the compiler can't assume the type is correct.\nTry works for example:\n\n```\nextension DefaultsKeys {\nstatic let latestProjects = DefaultsKey<[String: AnyObject]?>(\"latestProjects\")\n}\nlet test : [String: AnyObject]? = [\"Test\": 1]\nDefaults[.latestProjects] = test\n```\n. Not sure, I've played around a bit, it seems like a compiler issue.\n. ",
    "RahulKatariya": "Yes the problem is only with [[String: AnyObject]]. Other types are working fine. Could you tell me what is the problem as i need to store array of dictionaries. Am i doing something wrong ?\n. Yes the problem is only with [[String: AnyObject]]. Other types are working fine. Could you tell me what is the problem as i need to store array of dictionaries. Am i doing something wrong ?\n. ",
    "toshi0383": "Improved `handler`s management in d35c05d9c3d2f6583f0d18f36106be7320e1b1b5 .\n. @radex Yea, that would work. I can add a test for it, I guess.\n. @radex Added a test ! 0ab1568\n. Also rebased to master.\n. Thanks for reviewing !\n\nBlockDisposable is kindof [copied from ReactiveKit](https://github.com/ReactiveKit/ReactiveKit/blob/3940fb043e52c46a751e8bfa4f215d941828bc59/ReactiveKit/Disposables/BlockDisposable.swift). I just wanted the handlers to be disposable, so this library doesn't waste any memory.\nRecursiveLock is also from ReactiveKit, and I use it to make sure the handler registration is thread-safe.\n\n`observeValueForKeyPath` is plain KVO delegate. The first two `observe` methods are the public APIs for users (of this library). Users can observe key-value changes using either plain String or DefaultsKey<T>.\n. Outside.. you mean iCloud, right ? That's great !\n. Improved `handler`s management in d35c05d9c3d2f6583f0d18f36106be7320e1b1b5 .\n. @radex Yea, that would work. I can add a test for it, I guess.\n. @radex Added a test ! 0ab1568\n. Also rebased to master.\n. Thanks for reviewing !\n\nBlockDisposable is kindof [copied from ReactiveKit](https://github.com/ReactiveKit/ReactiveKit/blob/3940fb043e52c46a751e8bfa4f215d941828bc59/ReactiveKit/Disposables/BlockDisposable.swift). I just wanted the handlers to be disposable, so this library doesn't waste any memory.\nRecursiveLock is also from ReactiveKit, and I use it to make sure the handler registration is thread-safe.\n\n`observeValueForKeyPath` is plain KVO delegate. The first two `observe` methods are the public APIs for users (of this library). Users can observe key-value changes using either plain String or DefaultsKey<T>.\n. Outside.. you mean iCloud, right ? That's great !\n. ",
    "MaxHasADHD": "NSUserDefaults has a function named `registerDefaults` that is faster to use on launch to set initial defaults without checking if it exists and setting it. I would like a way to use Swifty Defaults with this function, currently I have to use the full default key like `Defaults.registerDefaults([\n            DefaultsKeys.AskedToEnableNotificationsKey._key: false])`.\n\nSo really, I just want a way so its cleaner and I can just use the short syntax without the `DefaultsKeys` and `._key`. To use a `DefaultKey` in a dictionary though, it needs to conform to Hashable and Equatable. I have tried to add this myself but I can't get it to be generic, so I can have all bools or all ints registered but not any type. \n. NSUserDefaults has a function named `registerDefaults` that is faster to use on launch to set initial defaults without checking if it exists and setting it. I would like a way to use Swifty Defaults with this function, currently I have to use the full default key like `Defaults.registerDefaults([\n            DefaultsKeys.AskedToEnableNotificationsKey._key: false])`.\n\nSo really, I just want a way so its cleaner and I can just use the short syntax without the `DefaultsKeys` and `._key`. To use a `DefaultKey` in a dictionary though, it needs to conform to Hashable and Equatable. I have tried to add this myself but I can't get it to be generic, so I can have all bools or all ints registered but not any type. \n. ",
    "dlpigpen": "Thanks @radex \n. Thanks @radex \n. ",
    "vknabel": "You can test it with the following gist:\nhttps://gist.github.com/valentinknabel/8bbef2f345adfe2724d8\n. You can test it with the following gist:\nhttps://gist.github.com/valentinknabel/8bbef2f345adfe2724d8\n. ",
    "bojan": "It works fine now with Carthage.\n. It works fine now with Carthage.\n. ",
    "phamquochoan": "Nice, thanks for the quick fix :+1: \n. Nice, thanks for the quick fix :+1: \n. ",
    "rinatkhanov": "I think it'd be handy to set global `suiteName` once, somewhere early (e.g.  in `AppDelegate`):\n`Defaults.suiteName = \"group.my.appGroup\"`\n\nAnd all consecutive calls to `Defaults` would then return `NSUserDefaults` object created for this specific suite. From my experience, you rarely need to keep multiple different sets of user defaults (and when you want that, @radex's method of introducing another global variable is probably the best). \n\nBut for most use cases (e.g. sharing Defaults with app extensions), I believe juggling with two different Defaults objects is suboptimal because it's possible to end up with wrong defaults object which may be a source of obscure bugs.\n\nA technical note, I don't think this would be possible without subclassing `NSUserDefaults` which is not as elegant as having `Defaults` as a global variable and _may_ introduce a set of other issues.\n. Similarly, `Defaults.synchronizeOnChange = true/false` would be awesome. Calling synchronize on every change all the time may introduce performance issues in certain cases because it actually saves to disk behind the scenes. But when you run in the debug mode or in the app extension, you may loose data saved to defaults unless you manually call `Defaults.synchronize()` each time you change something because the system may kill the process suddenly, to the best of my understanding (and in the case of running from Xcode, if you stop the project just at the right time, it won't save either). \n\nSo, giving this option to the user would be more elegant than synchronizing manually.\n. I think it'd be handy to set global `suiteName` once, somewhere early (e.g.  in `AppDelegate`):\n`Defaults.suiteName = \"group.my.appGroup\"`\n\nAnd all consecutive calls to `Defaults` would then return `NSUserDefaults` object created for this specific suite. From my experience, you rarely need to keep multiple different sets of user defaults (and when you want that, @radex's method of introducing another global variable is probably the best). \n\nBut for most use cases (e.g. sharing Defaults with app extensions), I believe juggling with two different Defaults objects is suboptimal because it's possible to end up with wrong defaults object which may be a source of obscure bugs.\n\nA technical note, I don't think this would be possible without subclassing `NSUserDefaults` which is not as elegant as having `Defaults` as a global variable and _may_ introduce a set of other issues.\n. Similarly, `Defaults.synchronizeOnChange = true/false` would be awesome. Calling synchronize on every change all the time may introduce performance issues in certain cases because it actually saves to disk behind the scenes. But when you run in the debug mode or in the app extension, you may loose data saved to defaults unless you manually call `Defaults.synchronize()` each time you change something because the system may kill the process suddenly, to the best of my understanding (and in the case of running from Xcode, if you stop the project just at the right time, it won't save either). \n\nSo, giving this option to the user would be more elegant than synchronizing manually.\n. ",
    "Catfish-Man": "Yes, synchronize is mostly a relic of a bygone age. These days, setting a value immediately calls xpc_connection_send_message() with the data, so you'd have to be _really_ fast on the stop button to lose it.\n. Yes, synchronize is mostly a relic of a bygone age. These days, setting a value immediately calls xpc_connection_send_message() with the data, so you'd have to be _really_ fast on the stop button to lose it.\n. ",
    "antonioreyna": "so for example on the init of my viewcontroller i just need to do `var Defaults = NSUserDefaults(suiteName: ...)` on each viewcontroller or class that needs the access to the userdefaults?\n. i see a method named `.addSuiteNamed` can i just use that on the appdelegate?\n. Yes now its working thanks!\n. so for example on the init of my viewcontroller i just need to do `var Defaults = NSUserDefaults(suiteName: ...)` on each viewcontroller or class that needs the access to the userdefaults?\n. i see a method named `.addSuiteNamed` can i just use that on the appdelegate?\n. Yes now its working thanks!\n. ",
    "stephencelis": "Maybe some kind of builder?\n\n``` swift\nregisterDefaults { set in\n    set(.userName, \"radex\")\n    set(.launchCount, 10)\n}\n\nregisterDefaults {\n    $0[.userName] = \"radex\"\n    $0[.launchCount] += 1\n}\n```\n. Maybe some kind of builder?\n\n``` swift\nregisterDefaults { set in\n    set(.userName, \"radex\")\n    set(.launchCount, 10)\n}\n\nregisterDefaults {\n    $0[.userName] = \"radex\"\n    $0[.launchCount] += 1\n}\n```\n. ",
    "gereons": "I've recently converted one of my apps to use SwiftyUserDefaults and also wanted to be able to use registerDefaults in a type-safe manner. As I only have about 20 settings that require specific defaults (mostly for enums) I've done this:\r\n\r\n````\r\nextension UserDefaults {\r\n    func registerDefault<T: RawRepresentable>(_ key: DefaultsKey<T>, _ value: T) {\r\n        Defaults.register(defaults: [ key._key: value.rawValue ])\r\n    }\r\n\r\n    func registerDefault<T>(_ key: DefaultsKey<T>, _ value: T) {\r\n        Defaults.register(defaults: [ key._key: value ])\r\n    }\r\n}\r\n````\r\n\r\nwhich allows me to use e.g. `Defaults.registerDefault(.myBoolKey, true)`. . I've recently converted one of my apps to use SwiftyUserDefaults and also wanted to be able to use registerDefaults in a type-safe manner. As I only have about 20 settings that require specific defaults (mostly for enums) I've done this:\r\n\r\n````\r\nextension UserDefaults {\r\n    func registerDefault<T: RawRepresentable>(_ key: DefaultsKey<T>, _ value: T) {\r\n        Defaults.register(defaults: [ key._key: value.rawValue ])\r\n    }\r\n\r\n    func registerDefault<T>(_ key: DefaultsKey<T>, _ value: T) {\r\n        Defaults.register(defaults: [ key._key: value ])\r\n    }\r\n}\r\n````\r\n\r\nwhich allows me to use e.g. `Defaults.registerDefault(.myBoolKey, true)`. . ",
    "akio0911": "thank you for merge \ud83d\ude03\n. thank you for merge \ud83d\ude03\n. ",
    "mortyccp": "Maybe it is related to this [swift bug](https://bugs.swift.org/browse/SR-1205?jql=text%20~%20%22casting%20leak%22)?\n. Maybe it is related to this [swift bug](https://bugs.swift.org/browse/SR-1205?jql=text%20~%20%22casting%20leak%22)?\n. ",
    "mhtranbn": "me too!\n. me too!\n. ",
    "anilgoktas": "I've just copied 2.2.0 version and changed classes and extensions with NSUbiquitousKeyValueStore, worked well for my application. [NSUbiquitousKeyValueStore-Swifty](https://github.com/anilgoktas/NSUbiquitousKeyValueStore-Swifty)\n\nI hope NSUbiquitousKeyValueStore support will be added to this repository also.\n\nYou can use it with \"iCloudDefaults\" global variable instead of \"Defaults\"\n`iCloudDefaults[.someKeyDefault]`\n. I've just copied 2.2.0 version and changed classes and extensions with NSUbiquitousKeyValueStore, worked well for my application. [NSUbiquitousKeyValueStore-Swifty](https://github.com/anilgoktas/NSUbiquitousKeyValueStore-Swifty)\n\nI hope NSUbiquitousKeyValueStore support will be added to this repository also.\n\nYou can use it with \"iCloudDefaults\" global variable instead of \"Defaults\"\n`iCloudDefaults[.someKeyDefault]`\n. ",
    "rudedogg": "I think this is something I'm running into due to sandboxing. I thought I removed the user defaults plist (which stored the .theme as a string - before I switched to enums).\n\nGoing to look around and figure out how to clear the user defaults properly when sandboxed.\n\nI'll re-open if I think it's a problem with SwiftyUserDefaults - but you have a test to check that non-nil enums work, etc - so I think it's on my end.\n\nThanks.\n. Incase someone else stumbles onto this - I needed to kill cfprefsd - it was still using the user defaults file after I moved it to the trash:\nhttp://stackoverflow.com/a/36501012/1575489\n. I think this is something I'm running into due to sandboxing. I thought I removed the user defaults plist (which stored the .theme as a string - before I switched to enums).\n\nGoing to look around and figure out how to clear the user defaults properly when sandboxed.\n\nI'll re-open if I think it's a problem with SwiftyUserDefaults - but you have a test to check that non-nil enums work, etc - so I think it's on my end.\n\nThanks.\n. Incase someone else stumbles onto this - I needed to kill cfprefsd - it was still using the user defaults file after I moved it to the trash:\nhttp://stackoverflow.com/a/36501012/1575489\n. ",
    "pbassut": "Could you take a look at why the tests are failing?\nMaybe then we could get this merged.\n. Just noticed there's an [open PR](https://github.com/radex/SwiftyUserDefaults/pull/91)\n. Could you take a look at why the tests are failing?\nMaybe then we could get this merged.\n. Just noticed there's an [open PR](https://github.com/radex/SwiftyUserDefaults/pull/91)\n. ",
    "askari01": "![screen shot 2016-06-24 at 10 39 08 am](https://cloud.githubusercontent.com/assets/6830947/16329141/f5f497e4-39f9-11e6-87b5-490ec01f13b7.png)\n![screen shot 2016-06-24 at 10 43 57 am](https://cloud.githubusercontent.com/assets/6830947/16329142/f64eba76-39f9-11e6-9f95-c92634f8b00c.png)\n![screen shot 2016-06-24 at 10 44 11 am](https://cloud.githubusercontent.com/assets/6830947/16329143/f6530dec-39f9-11e6-8cd3-1357032c001d.png)\n![screen shot 2016-06-24 at 10 44 22 am](https://cloud.githubusercontent.com/assets/6830947/16329144/f6543140-39f9-11e6-96ef-816f6bf893c7.png)\n\nits mostly syntax errors \n. ![screen shot 2016-06-24 at 10 39 08 am](https://cloud.githubusercontent.com/assets/6830947/16329141/f5f497e4-39f9-11e6-87b5-490ec01f13b7.png)\n![screen shot 2016-06-24 at 10 43 57 am](https://cloud.githubusercontent.com/assets/6830947/16329142/f64eba76-39f9-11e6-9f95-c92634f8b00c.png)\n![screen shot 2016-06-24 at 10 44 11 am](https://cloud.githubusercontent.com/assets/6830947/16329143/f6530dec-39f9-11e6-8cd3-1357032c001d.png)\n![screen shot 2016-06-24 at 10 44 22 am](https://cloud.githubusercontent.com/assets/6830947/16329144/f6543140-39f9-11e6-96ef-816f6bf893c7.png)\n\nits mostly syntax errors \n. ",
    "nicholas-lonsinger": "Looks like Travis does have an Xcode8 beta option: https://docs.travis-ci.com/user/osx-ci-environment/#OS-X-Version\n\n`osx_image: xcode8`\n. Travis CI made the updates on Monday, so this can be revisited. https://twitter.com/travisci/status/752704816116293632\n. This code isn't going to be backward compatible, so I would say take the hit and make everything as swiftly as possible (this was a goal of the core swift team as well).\n\nI looked at making a single code base that could compile in both environments but I don't think the code complexity would be worth it. Better to just make a hard fork.\n. You have an optional array of Int. So the `.append` is never even being called since `Defaults[.favorites]` is nil to start out. If you want the array to automatically exist without having to initialize it yourself change your extension to be non-nil:\n\n`static let favorites = DefaultsKey<[Int]>(\"favorites\")`\n\nFrom the documentation page: \n\n> You can mark a type as optional to get nil if the key doesn't exist. Otherwise, you'll get a default value that makes sense for a given type.\n. Looks like Travis does have an Xcode8 beta option: https://docs.travis-ci.com/user/osx-ci-environment/#OS-X-Version\n\n`osx_image: xcode8`\n. Travis CI made the updates on Monday, so this can be revisited. https://twitter.com/travisci/status/752704816116293632\n. This code isn't going to be backward compatible, so I would say take the hit and make everything as swiftly as possible (this was a goal of the core swift team as well).\n\nI looked at making a single code base that could compile in both environments but I don't think the code complexity would be worth it. Better to just make a hard fork.\n. You have an optional array of Int. So the `.append` is never even being called since `Defaults[.favorites]` is nil to start out. If you want the array to automatically exist without having to initialize it yourself change your extension to be non-nil:\n\n`static let favorites = DefaultsKey<[Int]>(\"favorites\")`\n\nFrom the documentation page: \n\n> You can mark a type as optional to get nil if the key doesn't exist. Otherwise, you'll get a default value that makes sense for a given type.\n. ",
    "uny": "There is nothing to do for test failing now.\nThis proposal is worth being accepted. (I would like to use it.)\n\nBut I think it should not be merged into master branch, but into the new branch: `swift3` like these.\nhttps://github.com/Alamofire/Alamofire/tree/swift3\nhttps://github.com/SwiftyJSON/SwiftyJSON/tree/swift3\n. I checked it, and I found it is for Xcode 8 beta 1, not for beta 2.\nCurrently, we cannot build on Xcode 8 beta 2.\n\n``` swift\n// Now\npublic let Defaults = UserDefaults.standard()\n\n// Should be\npublic let Defaults = UserDefaults.standard\n```\n\nI can fix it soon. https://github.com/uny/SwiftyUserDefaults\nCould someone create new branch: `swift3`?\n. https://github.com/uny/SwiftyUserDefaults/blob/master/.travis.yml\nMaybe this will work.\n. There is nothing to do for test failing now.\nThis proposal is worth being accepted. (I would like to use it.)\n\nBut I think it should not be merged into master branch, but into the new branch: `swift3` like these.\nhttps://github.com/Alamofire/Alamofire/tree/swift3\nhttps://github.com/SwiftyJSON/SwiftyJSON/tree/swift3\n. I checked it, and I found it is for Xcode 8 beta 1, not for beta 2.\nCurrently, we cannot build on Xcode 8 beta 2.\n\n``` swift\n// Now\npublic let Defaults = UserDefaults.standard()\n\n// Should be\npublic let Defaults = UserDefaults.standard\n```\n\nI can fix it soon. https://github.com/uny/SwiftyUserDefaults\nCould someone create new branch: `swift3`?\n. https://github.com/uny/SwiftyUserDefaults/blob/master/.travis.yml\nMaybe this will work.\n. ",
    "looseyi": "@radex  when would you like to new swift 3.0 support branch\n. @radex  when would you like to new swift 3.0 support branch\n. ",
    "SanjoDeundiak": "Need it as well\n. Need it as well\n. ",
    "devloe": "Fixed it. I thought I was initializing the variable somewhere.\n. Fixed it. I thought I was initializing the variable somewhere.\n. ",
    "arthurhammer": "What about `Defaults[.launchCount]++` since `++` is deprecated. Or is this a custom operator?\n. Oh, I meant `++` was removed from Swift 3. For \n\n```\nextension DefaultsKeys { static let launchCount = DefaultsKey<Int>(\"\") }\nDefaults[.launchCount]++\n```\n\n I get the error: `'++' is unavailable: it has been removed in Swift 3`.\n. What about `Defaults[.launchCount]++` since `++` is deprecated. Or is this a custom operator?\n. Oh, I meant `++` was removed from Swift 3. For \n\n```\nextension DefaultsKeys { static let launchCount = DefaultsKey<Int>(\"\") }\nDefaults[.launchCount]++\n```\n\n I get the error: `'++' is unavailable: it has been removed in Swift 3`.\n. ",
    "BalestraPatrick": "@radex I guess it's fixed now. The script is not the cleanest version possible but at least it doesn't fail \ud83d\ude04 \n. @radex I guess it's fixed now. The script is not the cleanest version possible but at least it doesn't fail \ud83d\ude04 \n. ",
    "KevinVitale": "@radex: yep, not a problem. incoming...\n. @radex: yep, not a problem. incoming...\n. ",
    "humblehacker": "Thanks for the feedback.  I need to compose from two values because the back-end system where these values originate from can only handle primitive types, and trying to enforce a particular format strictly by convention could be error-prone.\n\nI'm not completely sold on this solution however, since it's currently limited to types composed of values of a single type, and the order of the contained values is not enforced (too easy to accidentally swap `width` and `height`. I'm investigating solutions, and welcome any ideas.\n. I'm thinking now that this is a case of premature generalization.  Explicit key classes take up just as much code and are safer to deal with.  Example:\n\n```\nextension DefaultsKeys\n{\n    public static let mapRegion = MKCoordinateRegionDefaultsKey(lat: \"mapLatitude\", long: \"mapLongitude\", latDelta: \"mapLatitudeDelta\", longDelta: \"mapLongitudeDelta\")\n}\n\npublic\nclass MKCoordinateRegionDefaultsKey: DefaultsKeys\n{\n    public let _centerLongitudeKey: DefaultsKey<CLLocationDegrees>\n    public let _centerLatitudeKey:  DefaultsKey<CLLocationDegrees>\n    public let _spanLongitudeKey:   DefaultsKey<CLLocationDegrees>\n    public let _spanLatitudeKey:    DefaultsKey<CLLocationDegrees>\n\n    public\n    init(lat: String, long: String, latDelta: String, longDelta: String)\n    {\n        _centerLatitudeKey  = DefaultsKey<CLLocationDegrees>(lat)\n        _centerLongitudeKey = DefaultsKey<CLLocationDegrees>(long)\n        _spanLatitudeKey    = DefaultsKey<CLLocationDegrees>(latDelta)\n        _spanLongitudeKey   = DefaultsKey<CLLocationDegrees>(longDelta)\n    }\n}\n\npublic\nextension NSUserDefaults\n{\n    public\n    subscript(key: MKCoordinateRegionDefaultsKey) -> MKCoordinateRegion\n    {\n        get\n        {\n            var region = MKCoordinateRegion()\n            region.center.latitude     = self[ key._centerLatitudeKey ]\n            region.center.longitude    = self[ key._centerLongitudeKey ]\n            region.span.latitudeDelta  = self[ key._spanLatitudeKey ]\n            region.span.longitudeDelta = self[ key._spanLongitudeKey ]\n            return region\n        }\n        set\n        {\n            self[key._centerLatitudeKey] = newValue.center.latitude\n            self[key._centerLongitudeKey] = newValue.center.longitude\n            self[key._spanLatitudeKey] = newValue.span.latitudeDelta\n            self[key._spanLongitudeKey] = newValue.span.longitudeDelta\n        }\n    }\n}\n```\n\nUnfortunately, this fails to compile outside of `SwiftyUserDefaults.swift` because the `DefaultsKeys` initializer is private.\n\nCan we lift that restriction? Or can you think of another way to work around it?\n\n**Edit** Workaround 1: Subclass `DefaultsKey` instead of `DefaultsKeys`.  This works, but is hacky because the `_key` property is unnecessary and ignored.\n. ```swift\r\nopen\r\nclass CGSizeDefaultsKey: DefaultsKey<CGRect>\r\n{\r\n    open let _widthKey:  DefaultsKey<CGFloat>\r\n    open let _heightKey: DefaultsKey<CGFloat>\r\n\r\n    public\r\n    init(widthKey: String, heightKey: String)\r\n    {\r\n        _widthKey = DefaultsKey(widthKey)\r\n        _heightKey = DefaultsKey(heightKey)\r\n        super.init(\"\")\r\n    }\r\n}\r\n```. What about types composed of values of disparate types?  Like:\r\n\r\n```swift\r\npublic struct MKCoordinateRegion {\r\n    public var center: CLLocationCoordinate2D\r\n    public var span: MKCoordinateSpan\r\n    ...\r\n}\r\n```. What's the reservation about opening up `DefaultsKey`?  Before Swift 3 it was subclassable, and is even documented in the comments as such.. Thanks for the feedback.  I need to compose from two values because the back-end system where these values originate from can only handle primitive types, and trying to enforce a particular format strictly by convention could be error-prone.\n\nI'm not completely sold on this solution however, since it's currently limited to types composed of values of a single type, and the order of the contained values is not enforced (too easy to accidentally swap `width` and `height`. I'm investigating solutions, and welcome any ideas.\n. I'm thinking now that this is a case of premature generalization.  Explicit key classes take up just as much code and are safer to deal with.  Example:\n\n```\nextension DefaultsKeys\n{\n    public static let mapRegion = MKCoordinateRegionDefaultsKey(lat: \"mapLatitude\", long: \"mapLongitude\", latDelta: \"mapLatitudeDelta\", longDelta: \"mapLongitudeDelta\")\n}\n\npublic\nclass MKCoordinateRegionDefaultsKey: DefaultsKeys\n{\n    public let _centerLongitudeKey: DefaultsKey<CLLocationDegrees>\n    public let _centerLatitudeKey:  DefaultsKey<CLLocationDegrees>\n    public let _spanLongitudeKey:   DefaultsKey<CLLocationDegrees>\n    public let _spanLatitudeKey:    DefaultsKey<CLLocationDegrees>\n\n    public\n    init(lat: String, long: String, latDelta: String, longDelta: String)\n    {\n        _centerLatitudeKey  = DefaultsKey<CLLocationDegrees>(lat)\n        _centerLongitudeKey = DefaultsKey<CLLocationDegrees>(long)\n        _spanLatitudeKey    = DefaultsKey<CLLocationDegrees>(latDelta)\n        _spanLongitudeKey   = DefaultsKey<CLLocationDegrees>(longDelta)\n    }\n}\n\npublic\nextension NSUserDefaults\n{\n    public\n    subscript(key: MKCoordinateRegionDefaultsKey) -> MKCoordinateRegion\n    {\n        get\n        {\n            var region = MKCoordinateRegion()\n            region.center.latitude     = self[ key._centerLatitudeKey ]\n            region.center.longitude    = self[ key._centerLongitudeKey ]\n            region.span.latitudeDelta  = self[ key._spanLatitudeKey ]\n            region.span.longitudeDelta = self[ key._spanLongitudeKey ]\n            return region\n        }\n        set\n        {\n            self[key._centerLatitudeKey] = newValue.center.latitude\n            self[key._centerLongitudeKey] = newValue.center.longitude\n            self[key._spanLatitudeKey] = newValue.span.latitudeDelta\n            self[key._spanLongitudeKey] = newValue.span.longitudeDelta\n        }\n    }\n}\n```\n\nUnfortunately, this fails to compile outside of `SwiftyUserDefaults.swift` because the `DefaultsKeys` initializer is private.\n\nCan we lift that restriction? Or can you think of another way to work around it?\n\n**Edit** Workaround 1: Subclass `DefaultsKey` instead of `DefaultsKeys`.  This works, but is hacky because the `_key` property is unnecessary and ignored.\n. ```swift\r\nopen\r\nclass CGSizeDefaultsKey: DefaultsKey<CGRect>\r\n{\r\n    open let _widthKey:  DefaultsKey<CGFloat>\r\n    open let _heightKey: DefaultsKey<CGFloat>\r\n\r\n    public\r\n    init(widthKey: String, heightKey: String)\r\n    {\r\n        _widthKey = DefaultsKey(widthKey)\r\n        _heightKey = DefaultsKey(heightKey)\r\n        super.init(\"\")\r\n    }\r\n}\r\n```. What about types composed of values of disparate types?  Like:\r\n\r\n```swift\r\npublic struct MKCoordinateRegion {\r\n    public var center: CLLocationCoordinate2D\r\n    public var span: MKCoordinateSpan\r\n    ...\r\n}\r\n```. What's the reservation about opening up `DefaultsKey`?  Before Swift 3 it was subclassable, and is even documented in the comments as such.. ",
    "ldiqual": "@radex Updated to address your comments. It looks like there is a way to check for `[Any] == [Any]` by doing something like:\n\n```\nXCTAssertEqual(a as NSArray, b as NSArray)\n```\n\nIt seems very hacky that we have to go through ObjC classes though. In the meantime, I updated the tests to have more thorough asserts by checking for equality of each members. Let me know if you want me to use the NSArray/NSDictionary cast in tests.\n. @radex Sorry for the big delays on this one, Github notifications somehow ended up in my spam inbox :/ Thanks for making the changes and merging!\n. @radex Updated to address your comments. It looks like there is a way to check for `[Any] == [Any]` by doing something like:\n\n```\nXCTAssertEqual(a as NSArray, b as NSArray)\n```\n\nIt seems very hacky that we have to go through ObjC classes though. In the meantime, I updated the tests to have more thorough asserts by checking for equality of each members. Let me know if you want me to use the NSArray/NSDictionary cast in tests.\n. @radex Sorry for the big delays on this one, Github notifications somehow ended up in my spam inbox :/ Thanks for making the changes and merging!\n. ",
    "danielrhodes": "@radex Not sure why it doesn't reflect in the Files Changed, but when I grab the @ldiqual swift3 branch, that NSCoding stuff is not in there.\n. @radex Not sure why it doesn't reflect in the Files Changed, but when I grab the @ldiqual swift3 branch, that NSCoding stuff is not in there.\n. ",
    "DisobedientMedia": "Just had this, make sure you do a build in xcode, then the import statement will autocomplete and you can use the module\n. Just had this, make sure you do a build in xcode, then the import statement will autocomplete and you can use the module\n. ",
    "ddddxxx": "All you need to do is generate the project with SMP.\r\n\r\nrun the following from the project directory:\r\n```\r\n$ swift package generate-xcodeproj\r\n```\r\n\r\nresult:\r\n<img width=\"557\" alt=\"2017-05-22 11 14 05\" src=\"https://cloud.githubusercontent.com/assets/11691433/26291274/c5e203de-3edf-11e7-8757-979e885ca3f3.png\">. All you need to do is generate the project with SMP.\r\n\r\nrun the following from the project directory:\r\n```\r\n$ swift package generate-xcodeproj\r\n```\r\n\r\nresult:\r\n<img width=\"557\" alt=\"2017-05-22 11 14 05\" src=\"https://cloud.githubusercontent.com/assets/11691433/26291274/c5e203de-3edf-11e7-8757-979e885ca3f3.png\">. ",
    "brightsider": "Okay \ud83d\udc4d \nPodspec don't allow to use branches :(\n. @radex yeah! Thanks \ud83d\udc4d \n. Okay \ud83d\udc4d \nPodspec don't allow to use branches :(\n. @radex yeah! Thanks \ud83d\udc4d \n. ",
    "kylebrowning": "Any update on this? You've updated the branch, but it appears you haven't pushed to cocoapods.\n. @radex OKay great, will stay tuned!\n. Works!\n. Any update on this? You've updated the branch, but it appears you haven't pushed to cocoapods.\n. @radex OKay great, will stay tuned!\n. Works!\n. ",
    "DesmondPang": "It works. Thanks\n. It works. Thanks\n. ",
    "alapergola": "Shame...\nBut thanks for your support anyhow! \n. Shame...\nBut thanks for your support anyhow! \n. ",
    "muruganandham": "```\nextension DefaultsKeys {\n  static let maxDistances = DefaultsKey<[String: Any]>(\"maxDistances\")\n}\n\n```\n\nI have changed `<NSDictionary>` to `<[String: Any]>`. Now working with out any issues \n. ```\nextension DefaultsKeys {\n  static let maxDistances = DefaultsKey<[String: Any]>(\"maxDistances\")\n}\n\n```\n\nI have changed `<NSDictionary>` to `<[String: Any]>`. Now working with out any issues \n. ",
    "asowers1": "Np @radex \ud83d\udc4b Actually, after looking at this, it seems I just needed to re-run `carthage update` to compile for Swift 3.0.1 after upgrading to Xcode 8.1.\n. I'm curious to see an example of why you use subclassed DefaultsKey.. Np @radex \ud83d\udc4b Actually, after looking at this, it seems I just needed to re-run `carthage update` to compile for Swift 3.0.1 after upgrading to Xcode 8.1.\n. I'm curious to see an example of why you use subclassed DefaultsKey.. ",
    "max-potapov": "@radex could please you bump patch version in tag?\n. @radex could please you bump patch version in tag?\n. ",
    "mortenholmgaard": "Found the problem - it was do to `DefaultsKey <=> DefaultsKeys`\r\n`Defaults[DefaultsKey.Styling.BackgroundType] => Defaults[DefaultsKeys.Styling.BackgroundType]`. @radex Please take a look at this!. Found the problem - it was do to `DefaultsKey <=> DefaultsKeys`\r\n`Defaults[DefaultsKey.Styling.BackgroundType] => Defaults[DefaultsKeys.Styling.BackgroundType]`. @radex Please take a look at this!. ",
    "indivisable": "var Defaults = UserDefaults(suiteName: \"com.my.app\")!. var Defaults = UserDefaults(suiteName: \"com.my.app\")!. ",
    "minuscorp": "Easy!\r\n\r\n```swift\r\n// In your AppnoObject class...\r\nclass func store(_ object: AppnoObject?, key: String) {\r\n    if let object = object {\r\n        let encoded = NSKeyedArchiver(withRootObject: archive)\r\n        Defaults.set(encoded, forKey: key)\r\n    }\r\n    else {\r\n         Defaults.set(nil, forKey: key)\r\n    }\r\n}\r\nclass func retrieve(_ key: String) -> AppnoObject? {\r\n    guard let data = Defaults.object(forKey: key) as? Data else { return nil }\r\n    guard let decoded = NSKeyedUnarchiver.unarchiveObject(with: data) as? AppnoObject else { return nil }\r\n    return decoded\r\n}\r\n```\r\n\r\nAnd extend as follows:\r\n\r\n```swift\r\nextension DefaultsKeys {\r\n    static let appnoObject = DefaultsKey<AppnoObject?>(\"yourUniqueKey\")\r\n}\r\n\r\nextension UserDefaults {\r\n    subscript(key: DefaultsKey<AppnoObject?>) -> AppnoObject? {\r\n        get {\r\n             return AppnoObject.retrieve(key._key)\r\n        }\r\n        set {\r\n            AppnoObject.store(newValue, key: key_key)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd that's it!. Ah! I misread that, If you want to store an array of objects you should build a parent object that conforms to `NSCoding` and it should have a property of your `[AppnoObject]`. That parent object should act as a wrapper for your array, nothing more nothing less. . Easy!\r\n\r\n```swift\r\n// In your AppnoObject class...\r\nclass func store(_ object: AppnoObject?, key: String) {\r\n    if let object = object {\r\n        let encoded = NSKeyedArchiver(withRootObject: archive)\r\n        Defaults.set(encoded, forKey: key)\r\n    }\r\n    else {\r\n         Defaults.set(nil, forKey: key)\r\n    }\r\n}\r\nclass func retrieve(_ key: String) -> AppnoObject? {\r\n    guard let data = Defaults.object(forKey: key) as? Data else { return nil }\r\n    guard let decoded = NSKeyedUnarchiver.unarchiveObject(with: data) as? AppnoObject else { return nil }\r\n    return decoded\r\n}\r\n```\r\n\r\nAnd extend as follows:\r\n\r\n```swift\r\nextension DefaultsKeys {\r\n    static let appnoObject = DefaultsKey<AppnoObject?>(\"yourUniqueKey\")\r\n}\r\n\r\nextension UserDefaults {\r\n    subscript(key: DefaultsKey<AppnoObject?>) -> AppnoObject? {\r\n        get {\r\n             return AppnoObject.retrieve(key._key)\r\n        }\r\n        set {\r\n            AppnoObject.store(newValue, key: key_key)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd that's it!. Ah! I misread that, If you want to store an array of objects you should build a parent object that conforms to `NSCoding` and it should have a property of your `[AppnoObject]`. That parent object should act as a wrapper for your array, nothing more nothing less. . ",
    "minerva1129": "Sorry, I didn't read carefully... I want to save not `AppnoObject?`, but `[AppnoObject]`.. Sorry, I didn't read carefully... I want to save not `AppnoObject?`, but `[AppnoObject]`.. ",
    "wouterwisselink": "@Tom29 How did you solved this problem?. @Tom29 How did you solved this problem?. ",
    "aaveidt": "@wouterwisselink It doesn't support `AnyObject` type anymore. Change it to `Any` and it will work.\r\n. @wouterwisselink It doesn't support `AnyObject` type anymore. Change it to `Any` and it will work.\r\n. ",
    "Eitot": "Swift version:\r\n```\r\nApple Swift version 3.0.2 (swiftlang-800.0.63 clang-800.0.42.1)\r\nTarget: x86_64-apple-macosx10.9\r\n```\r\n\r\nJust tested again with a test project:\r\n```bash\r\n$ mkdir testproject\r\n$ cd testproject\r\n$ swift package init\r\n```\r\n\r\nPackage.swift looks like this:\r\n```swift\r\nimport PackageDescription\r\n\r\nlet package = Package(\r\n    name: \"testproject\",\r\n    dependencies: [\r\n\t.Package(url: \"https://github.com/radex/SwiftyUserDefaults.git\", majorVersion: 3)\r\n    ]\r\n)\r\n```\r\n\r\nThen trying to fetch:\r\n```\r\n$ swift package fetch\r\nCloning https://github.com/radex/SwiftyUserDefaults.git\r\nHEAD is now at cfcf2b8 Bump to 3.0.1\r\nResolved version: 3.0.1\r\nerror: the package has an unsupported layout, unexpected source file(s) found: /Users/[user]/Developer/testproject/Packages/SwiftyUserDefaults-3.0.1/Tests/SwiftyUserDefaultsTests.swift, /Users/[user]/Developer/testproject/Packages/SwiftyUserDefaults-3.0.1/Tests/TestHelper.swift\r\nfix: move the file(s) inside a module\r\n```. Swift version:\r\n```\r\nApple Swift version 3.0.2 (swiftlang-800.0.63 clang-800.0.42.1)\r\nTarget: x86_64-apple-macosx10.9\r\n```\r\n\r\nJust tested again with a test project:\r\n```bash\r\n$ mkdir testproject\r\n$ cd testproject\r\n$ swift package init\r\n```\r\n\r\nPackage.swift looks like this:\r\n```swift\r\nimport PackageDescription\r\n\r\nlet package = Package(\r\n    name: \"testproject\",\r\n    dependencies: [\r\n\t.Package(url: \"https://github.com/radex/SwiftyUserDefaults.git\", majorVersion: 3)\r\n    ]\r\n)\r\n```\r\n\r\nThen trying to fetch:\r\n```\r\n$ swift package fetch\r\nCloning https://github.com/radex/SwiftyUserDefaults.git\r\nHEAD is now at cfcf2b8 Bump to 3.0.1\r\nResolved version: 3.0.1\r\nerror: the package has an unsupported layout, unexpected source file(s) found: /Users/[user]/Developer/testproject/Packages/SwiftyUserDefaults-3.0.1/Tests/SwiftyUserDefaultsTests.swift, /Users/[user]/Developer/testproject/Packages/SwiftyUserDefaults-3.0.1/Tests/TestHelper.swift\r\nfix: move the file(s) inside a module\r\n```. ",
    "Uupis": "According to David Smith, one of the engineers spending countless hours keeping Cocoa running, calling synchronize is virtually never necessary. http://dscoder.com/defaults.html\r\n\r\nIn my experience, it has only been necessary during development, when I kill the app immediately after doing something with NSUserDefaults.. According to David Smith, one of the engineers spending countless hours keeping Cocoa running, calling synchronize is virtually never necessary. http://dscoder.com/defaults.html\r\n\r\nIn my experience, it has only been necessary during development, when I kill the app immediately after doing something with NSUserDefaults.. ",
    "Dschee": "Travis needs to be configured to work with Xcode 9 in order for the tests to pass. They are all passing in Xcode 9 but Travis is using Xcode 8 which does not recognize the Swift settings from Xcode 9.. Travis needs to be configured to work with Xcode 9 in order for the tests to pass. They are all passing in Xcode 9 but Travis is using Xcode 8 which does not recognize the Swift settings from Xcode 9.. ",
    "anfriis": "Please fix this! . Please fix this! . ",
    "mkismy": "@radex Any updates on this?. @radex Any updates on this?. ",
    "ghost": "Yes, I have to do that! Thank you!. Yes, I have to do that! Thank you!. ",
    "andrey-zelenin": "When the release is planned? Thanks. When the release is planned? Thanks. ",
    "suyashgupta25": "Please plan a release for Swift 4. Please plan a release for Swift 4. ",
    "RayPS": "#135 . #135 . ",
    "mman": "What is the ``SentenceBunch`` and ``StoryPathDirection``? There are restrictions on what the index types are allowed to be.... Well it\u2019s obvious that they are your own types, but they need to follow the rules specified in the section Custom Types in README. Please crosschck that your types follow the archiving/unarchiving requirements or post the code here so that we can take a look.\r\n\r\nIn essence, anything you use as a ``DefaultsKey`` needs to be in the end convertible into a ``String`` so that it can be used to store data into ``NSUserDefaults``.. What is the ``SentenceBunch`` and ``StoryPathDirection``? There are restrictions on what the index types are allowed to be.... Well it\u2019s obvious that they are your own types, but they need to follow the rules specified in the section Custom Types in README. Please crosschck that your types follow the archiving/unarchiving requirements or post the code here so that we can take a look.\r\n\r\nIn essence, anything you use as a ``DefaultsKey`` needs to be in the end convertible into a ``String`` so that it can be used to store data into ``NSUserDefaults``.. ",
    "peterdruska": "`SentenceBunch` is my own class and `StoryPathDirection` is enum.. `SentenceBunch` is my own class and `StoryPathDirection` is enum.. "
}