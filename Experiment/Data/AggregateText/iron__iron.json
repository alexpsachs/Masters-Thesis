{
    "reem": "Can you update `.travis.yml` to use this?\n. Ideally, we'd have a way to specify the build command also, but at that point we're basically creating a simple package manager - which is pretty out of scope. I think this should be as extensible as necessary to make getting started with Iron as simple as:\n\n``` bash\ngit clone iron/iron\n./configure\nmake\n```\n\nbut we shouldn't spend _too_ much time on it. V2.0 will definitely use Cargo, assuming it's ready by then.\n. Update: anymap is a great example of this. We want to manage that dependency using this script, but it's build command is just `make`.\n. Can you edit the travis command also, so we don't have to do that in a separate branch and we can remove the redundancy?\n\nUPDATE: The travis failure for this PR is because of changes in rust-nightly, specifically removing ~[T] from the language completely, so sort of don't worry about it.\n. Could you squash these commits or just remove the first one? Considering this pull is actually to delete the paragraph it doesn't make sense to include it.\n. We will doc this explicitly later.\n. Actually, on second thought, can you close this PR and make a new one to a doc/ingot branch on iron itself, so we can both work on this? I have lots to add to the Ingot explanation.\n. We should write a tool to automate this.\n. I agree. If someone wanted to become a `sed` guru that would be cool but otherwise I think we might need something a bit more powerful (I'm thinking lo-dash template and gulp).\n. This is more trouble than it's worth. Closing.\n. Awesome.\n. Fixed in #13 \n. Is it also possible to break out the change to `listen` and the `Iron` struct itself into a different PR?\n. @zzmp Merging this now because you aren't here to make the PR.\n. Can you make this change in all those places?\n. Well, the lifetime we are transmuting to is definitely `'static`, which is certainly longer than the lifetime that it has. However we lose access to the pointer at the same time that the destructor of the underlying memory is destroyed, so everything is fine.\n\n+1 to close, for now at least.\n. Tagged as wontfix.\n. Fixed :)\n. Make doc pull requests to doc/doc-all, which will then be pull requested into master.\n. Done.\n. Can you rebase this against doc/doc-all?\n. I'm calling this low priority for now. There is basically no competition in that space and we have already dedicated to move to Teepee later. This refactor should probably happen during that wave of breaking changes.\n. Closing this as we have moved to structs for Request and Response.\n. Rebase time!\n. I'm not convinced yet that this needs to be in core. I think this belongs in an \"iron-common\" style repo that offers Iron bundled with many common middleware and trait extensions.\n. It is possible to extend Response outside of core - this functionality could be implemented outside of Iron. I think that is where it belongs. The majority of users would then use Iron-Common, which would come bundled with this and other functionality.\n\nSee: https://github.com/koajs/koala\n. I'm willing to bend on this. Can you rename send to send_file?\n. Can you rebase this in a way that it can be merged without #49? I'd like to make this change, but I'm not convinced on the value of #49 yet.\n. Commit 3db02ac should probably be prefixed (fix) not (feat)\n. It's unlikely that mount can use this, but I will definitely make this change as part of my refactor of Router.\n. If you come up with more utility methods, I can refactor to a more common trait name and add more heavy-use-case methods.\n. I like. I'll implement that refactor.\n. @zzmp I disagree. I think that makes the common use case (sending a status code + body) more annoying for the uncommon case which might as well just be `res.write(data.as_bytes())`. We'd be creating a function that saves a single method call.\n. Done.\n. It should be after I refactor Router.\n. Merge?\n. This is now the canonical way to implement simple, throwaway middleware. I\u2019ll include a response-time example that uses a multi-directional middleware.\n. Closing for now in favor of a refactor to Chain.\n. I hadn't considered the need to `use iron::Chain`. That makes me less happy about this. Any thoughts from the rest of @iron/dev-team?\n. @theptrk That's a good point I didn't consider. I'm saying this is accepted in lieu of merging it, just to give all existing PRs in middleware a day to get sorted out.\n\nI'll merge this before I leave tonight and we can fix it as part of our daily \"fix what broke yesterday\" sprint.\n. This is now out of the scope of this repo, since the code generation moved to a different repo in #111 \n. This is a BREAKING CHANGE because all other ./configure installs of Iron will immediately stop working. I will be making PRs to all middleware to add Cargo to them soon after I get this working.\n. @zzmp Merge?\n. Can you swap ResponseTime for Hello World, or something else at least slightly non-trivial? It's pretty boring to see a really simple Hello World for this.\n. It's unnecessary to have both _..._ in the example AND have a 'abbreviated for clarity' note.\n. @zzmp Hello World -> ResponseTime and I'll merge.\n. Especially with the current fn Clone madness.\n. This is a serious problem. We have a _lot_ of existing code that relies on fn's being Cloneable.\n. This seems outside of our ability to fix.\n\nI'm going to create a FromFn struct, which would be usable like so: \n`server.chain.link(FromFn::new(hello_world_fn))`\n. Putting it in `iron::middleware::FromFn`\n. We aren't sure. We think it's a bug with trait detection related to some new logic in the compiler for type checking traits.\n\nFromFn is intentionally bare-bones so it can be easily deleted when this gets resolved.\n. @zzmp it's impossible right now because if you have a generic impl for a trait you can't have any other impls for that trait, which is a known issue.\n\nBasically, if you had `impl<T: Copy> Clone for T { fn clone(&self) -> T { *self } }` then you couldn't `impl Clone` for any type that _wasn't already Copy_ which is basically the entire point.\n\nThis is also why we have `impl Middleware for Box<Chain>` instead of `impl<C: Chain> Middleware for C`.\n. We are just going with wrk.\n. @cburgdorf As long as we are still doing codegen, I'd like to keep it behind a strong veil, however @zzmp wrote most of the file-serving logic, so I'll let him make the call.\n. There are actually no more of these, so closing.\n. @mavdi @zzmp I'm merging this because I need the change to debug other issues re: cargo and travis and it's a clear win.\n. Yes, unfortunately once you have written to the body you can no longer write any headers. Until we get around to creating our own abstraction layer over rust-http's Request objects or switch to a new backend this isn't something we can support. :/\n. We should really have some sort of error mechanism for detecting this case and warning you, so that it doesn't just silently fail.\n. @emk This is a really good point. I'll be adding this feature later today.\n. A quick examination leads me to believe that this might be a bit harder than I thought. How do I tell if no middleware has handled a request? In Express it's as easy as \"did a request make it all the way through the stack\" but in Iron, which allows bidirectional middleware, it's unclear what the condition is for modifying a request and setting it to be a 404 is.\n. That seems like a reasonable approach. \n\nI think there might be a bit of refactoring to be done regarding the control flow around Middleware. Right now it's impossible to distinguish between `Unwind` as in \"I'm done, so don't continue\" and `Unwind` as in \"there is an error, so don't continue.\"\n\nWe were discussing adding a third variant to the `Status` enum of `Error(Box<Show>)` or something similar that would call a separate handler than `Unwind`. I think I might take a crack at it later today and see if I can make the entire scheme more convenient.\n. This problem is in fact very easy to solve! Middleware just aren't shared. Instead, the chain is cloned for each request and on a new thread, meaning that there are in fact two different instances of ResponseTime for the two different requests, solving this problem nicely.\n\nThis is slightly inefficient, but we think it presents a very nice-looking API and hasn't been a source of performance problems for us.\n. Thanks for this list @killercup. Fixed via several PRs.\n. @cengizIO unfortunately `ab` is a bit weird, I got these numbers benchmarking using `wrk`. Weirdness surrounding benchmarking is on our todo list. Some kind of script would probably be the best way to do it.\n. @cengizIO This is awesome. Thanks!\n. @cengizIO You're killing it. Thanks.\n. @zzmp @theptrk @mcreinhard Is this something we definitely want?\n. We already have an explicit dependency through our use of serve_forever in listen. This is nothing new.Thanks,\n         Jonathan Reem\n\nOn Thu, Jul 24, 2014 at 1:48 PM, Zach Pomerantz notifications@github.com\nwrote:\n\n> This relies explicitly on the `rust-http` implementation, specifically, https://github.com/chris-morgan/rust-http/blob/master/src/http/server/mod.rs#L56\n> \n> ## @reem, I'm fine merging this, but could you make note of the explicit dependency in a comment so that we don't lose track of it?\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/pull/108#issuecomment-50075900\n. @zzmp Yes, we are still slightly dependent, but users of our library are no longer exposed to that. Merge?\n. @zzmp Actually, specifically regarding files, this new scheme is significantly more memory efficient as it doesn't read the entire file into memory except to send it to the client in write_back. serve_file only creates a reader for that file, it doesn't actually read it.\n\nIt very rarely makes sense to crudely concatenate multiple chunks of data in different controllers. There's almost no time that makes sense and if it did (which I bet is extremely rarely) you can just store a Reader/Writer in alloy and replace body with it later.\n. @zzmp Updates and fixes.\n. @zzmp Updated. 404 logic will be changed in the Response PR.\n. This is pretty much what I had in mind. It would probably be best to wait for rust-http to stop using liburl and then use the servo url object instead. I'd also love it if it was https compatible, but that may be asking a little much until we have a better base than rust-http.\n. @michaelsproul Now that rust-http uses the new rust-url (great job!) we can probably update this to use it too.\n. @michaelsproul It's been fixed.\n. @michaelsproul This is pretty awesome. Can you do me a favor and update the doc-comment for the url field to just specify a few common access fields and/or tell users where they can find more info on that struct.\n. This is fantastic! Where would you like to me to put feedback? (Here, Github issues, etc.)\n\nThere isn't a great place for us to have a repository of middleware right now, but in the near future (hopefully) Cargo will have a central repository and we can just tag things iron-middleware or something along those lines.\n\nYou can _usually_ find me on the #iron irc channel.\n. #119 Implements this change, and I'll merge it later.\n. Closed via. #119 \n. @michaelsproul Feel free! That'd be awesome. I'm going to merge in #119 and start fixing middleware later today (soon).\n. @michaelsproul Thanks.\n. This is awesome. Thanks.\n. This is tricky, because we'd like the method to be implemented on `Response` but access some form of app-global configuration - you'd set up the templating by adding a Middleware with some options on it like the templating engine and template directories, but I'm not sure how that information gets to res.render.\n\nThis are good thoughts to be having, but I'm not sure what the answer is.\n. I think it's cleaner to just provide a `Templating` trait that any template engine could implement, then you provide an instance of that trait to the templating middleware and it uses that for `res.render`. My main concern is that `res.render` would have no access to the `Alloy` and therefore no access to any configuration.\n\nThis is solvable by placing a second `Alloy` in Response, but I'm not sure if that's the way to go. I think there is a better, more general way to do app-wide configuration than this, but I'm not sure how yet.\n\nMaybe the best way would be to add a global-configuration Alloy on each _Iron_ instance - then provide a &-reference to the app in both request and response? This is fast but also quite convenient, and could in fact be made memory efficient by storing the global Alloy behind an Arc, so it is not cloned for each request.\n. I'm only concerned that adding a reference to the app in `Request` and `Response` makes testing trickier - right now I've managed to create a small mocking library for `Request` and `Response` that does not have to resort to unsafe anywhere (https://github.com/reem/iron-test) but an app reference may make that trickier.\n. There's way too much of `std::mem::unitialized` in our tests right now, so that would be great to fix.\n\nI'd _really_ rather not fall back to an environment variable. Maybe, instead of a global persistent reference to Iron, we could just have a global persistent reference to some sort of global preferences object that only coincidentally happens to be stored on `Iron`.\n\nI think that we'll find, however, that there may be a need for a general-purpose Alloy-like structure on Response.\n. I think there needs to be a dedicated way to immutably access shared global configuration. More thoughts to come.\n. I think the solution is to include a `config: Arc<AnyMap>` in both Request and Response. This allows easy global configuration and is pretty easy to mock in tests.\n. I think providing access to config in both places is perfectly fine.\n. The configuration problem is mostly solved through the `Read` variant in `Persistent` and the interface it exposes.\n. You can definitely do this with a syntax extension, or even without one if you are willing to lose a bit of expressiveness. However, I think that's probably the domain of a templating engine, not this middleware.\n. @aochagavia They have done much of the work that we'd like to do, but I'd much rather be templating engine agnostic and support a richer interface - notably nickels `.render` only allows `HashMap<&'static str, &'static str>` which means that you can't render a template with dynamic data, like from a database.\n. Agreed. There could be some really cool work to be done in making a crazy syntax extensions for creating templates.\n. @allan-simon I also just recently started learning about syntax extensions. If you want an example of a (hopefully) well written one: https://github.com/reem/stainless \n. @allan-simon I think it would probably be best to adopt an existing templating standard and possibly just make changes to it, rather than starting from scratch.\n\nThe most ideal situation is that I can create `static` or `const` templates which are aware of the types they must be passed to be rendered, then I can get nice type errors if I try to pass incompatible things as the pieces of the template.\n. Just a note, but its Yehuda Katz, aka wycats. :)\n. Possibly obsoleted by better ideas, but not sure yet.\n. @SuprDewd this is good work. We need to make lots of changes in this vein, to make Iron more robust, friendlier, and actually usable for a real application server.\n. A struct that looks like this would probably do it:\n\n``` rust\nstruct Url<'a> {\n   port: u32,\n   username: Option<&'a str>,\n   password: Option<&'a str>,\n   host: url::Host,\n   path: &'a [String],\n   query: Option<&'a str>,\n   fragment: Option<&'a str>\n}\n```\n\nOr maybe...\n\n``` rust\nstruct Url {\n   port: u32,\n   username: Option<String>,\n   password: Option<String>,\n   host: url::Host,\n   path: Vec<String>,\n   query: HashMap<String, String>,\n   fragment: Option<String>\n}\n```\n. Plugins of that kind are very in flux right now. I was talking to @wycats today about a whole new scheme for lazily-computed plugins.\n\nThe advantage of fields over methods is there is no `url.path_mut()` and `url.path()` annoyance.\n. The problem with representing things as enums is that they you often end up exposing to your users situations where they have to match to get at the contents of the enum even if you are 100% sure that only one variant is valid. Always-Some Options are just one tiny instance of this. \n\nI'd much rather have a NonRelativeSchemeUrl than an enum, one of whose variants is a NonRelativeSchemeUrl.\n. That seems like a reasonable approach. If you want to take a stab at implementing this I'd be glad to code review. I'm a tiny bit swamped right now with other refactors, so I can't take it on fully right now.\n. It would be nice if we could implement show - it makes lots of things nicer, but, don't worry about it for now, just get something up and running and we will see if we need it later.\n. I'd rather rename rust-url, as that is never exported/exposed in any way.\n. Otherwise this looks really solid. I much prefer this as an abstraction to what we had earlier. Thanks again for your continued work on Iron, as you can see it really makes a difference.\n. I was going to do it, but if you want to, go ahead! I have some time today, so I'm going to sit down and refactor router to be better.\n. @iron/dev-team @brycefisher @michaelsproul Can I get any of your thoughts on this? Does this seem like a good idea? What problems still need to be solved?\n. The primary advantage over just adding traits is that this guarantees a consistent API and prevents people from having to implement and re-implement the functionality of `get` and `get_ref`.\n\nBasically:\n\n``` rust\nstruct Request {\n  body: String\n  extensions: AnyMap\n}\n\nimpl Extensible for Request { etc. }\n\n// Stupid example.\nstruct BodyLength { len: uint }\n\n// Implementation is much simpler, you only deal with construction.\nimpl PluginFor<Request> for BodyLength {\n  fn construct(req: &Request) -> BodyLength {\n    BodyLength { len: req.len() }\n  }\n}\n\n// Usage site\n// Safe, namespaced, typesafe, guaranteed interface\nlet body_length = req.get::<BodyLength>();\n\n// Middleware alternative:\n\nstruct BodyLength { len: uint };\n\nimpl Middleware for BodyLength {\n  fn enter(req: &Request) -> Result<(), Box<Show>> {\n    req.extensions.insert(BodyLength { req.len() });\n    Ok(());\n  }\n}\n\ntrait BodyLength { fn body_length(&self) -> uint }\n\nimpl BodyLength for Request {\n  fn body_length(&self) -> uint {\n    self.extensions.find::<BodyLength>().unwrap().len\n  }\n}\n\n// Insert into server in the correct order! (error prone/not-safe)\nserver.whatever(BodyLength)\n\n// Usage site \n// Additional problem here is that there's no requirement to expose & and an &mut vs.\n// by value etc. Every middleware has its own naming convention and methods easily\n// will clash name-spaces.\nlet body_length = req.body_length()\n```\n\nThis does not obsolete the need for Mixins as an approach - templating still needs `Response::render` but it removes the need to duplicate this basic API - this is very nice for a large variety of things and can still be used internally by Mixins which expose other things. The major idea is it is automatically correctly lazy, correctly order-independent, and correctly matching with best style.\n\nThis additionally does not solve the configuration problem, which is still looking for a rock-solid solution.\n. There is no method overloading. You could just have a `get_unconditional` method, but then you also need `get_unconditional_ref` and `get_unconditonal_mut` method... I think it's best to just force people to deal with the failure.\n\nA real implementation would probably use `Result` instead of `Option`, once we decide on a standard Error type I can refactor rust-plugin to be generic in the error type and then we can just re-export as `RequestPlugin` and `ResponsePlugin`.\n. I'm currently implementing a trie-based router. I'm opening a separate issue for discussion of an Iron-universal error type, which is a blocker for this to be actually implemented.\n. I'm attempting this right now using https://github.com/reem/rust-error, which I believe meets all of our criteria.\n\nIt is:\n- Generic\n- Recoverable\n- Convertible\n- Extensible\n\nand most importantly it allows third-party errors to get the same treatment as first-part ones, which is critically important.\n. I've made further refactors to rust-error and will be rolling this change into a huge PR in the near future.\n. Here's an outline of my thought process on this: https://medium.com/@jreem/what-should-you-get-from-an-error-6704dbdc4895\n. Done.\n. Oops. I accidentally rolled this in to #136 \n\nAnyway, #136 needs this change so I'll just leave it in that PR.\n. Actually, this just implements the change suggested in #135, as that is a pre-requisite for this change.\n\nThis PR also deprecates Alloy as an alias, but should not break any existing code yet. (Just introduce deprecation warnings).\n. @iron/dev-team @michaelsproul @brycefisher If you guys want to look this over, go ahead. I'll merge tomorrow barring any resistance, but this seems like a straightforward change to me.\n. This has been partly addressed by `iron/params`.\n. With a test too. Fantastic.\n. @brycefisher I believe this is useful for you.\n. Oops. Thanks for catching this.\n. This should be \"Compile common\" so no, because several middleware still do not compile.\n. @ProtectedMode I agree completely. Recently it's been a challenge to keep just Iron itself compiling, but now that things are calming down a bit I think we get back to stability (and getting everything compiling).\n. This issue is pointless and outdated, obviously we want things to compile, but there is no need to track everything here.\n. Can you update the Cargo.toml to be the updated upstreams?\n. The field and method won't clash, especially as first-class-methods are not supported yet, so we should have both so users don't have to use Extensible to get access to extensions.\n\nFor similar reasons we should re-export typemap.\n. That's cool. We don't need to export Assoc - if you're making a Plugin you need it but then you should just be depending on rust-plugin directly.\n. Nice. Good job with this.\n. An AroundMiddleware either calls the internal handler to get a response and modifies it or creates its own response, if you ignore the return value of the internal handler... that's just your problem.\n. @iron/contributors @iron/dev-team Anyone else have comments?\n. @zzmp Bump. I added an overview of Middleware. Probably needs heavy editing.\n. @brycefisher fixed all your catches\n\n@michaelsproul renamed to AroundMiddleware::with_handler and clarified in the docs for it. Does this clear up your concern?\n\nBarring any further questions, I will be merging this, publishing my blog post, and beginning to fix and refactor middleware tomorrow.\n. Candidate: https://github.com/duelinmarkers/todo-backend-rust-iron\n. That sounds like a really good skeleton. Do you have any ideas for the content of something like that?\n. @duelinmarkers I saw your `After` struct for generating `AfterMiddleware` from bare functions and thought that `AfterMiddleware` should just be impled for bare functions in iron itself.\n. I considered this when creating the trait and I haven't settled on a better way. Primarily, the problem is that you'd like to be able to construct the AroundMiddleware however it is supposed to be constructed (it's constructor might take many arguments, for instance) but you do not have access to the handler at construction time.\n\nThe alternative is to have `AroundMiddleware::from_handler` and rely on `persistent::Read` for all configuration. I don't love this approach, because it means that we will have to use `Read` _a lot_, and it is already used for configuring Plugins.\n. Hmm, I do use one of those internally to implement `ChainBuilder::around` safely, but I think it's probably best to instead change the `AroundMiddleware` trait to look more like this:\n\n``` rust\npub trait AroundMiddleware {\n    fn from_handler<H>(self, H) -> Box<Handler + Send + Sync> where H: Handler;\n}\n```\n\nNotice that the `: Handler` bound on AroundMiddleware itself is gone, `from_handler` now takes `self` (so might want to be renamed) and produces a _new_ Handler, which could be made from self or could be a different type completely. \n\nI think this makes AroundMiddleware significantly more ergonomic to use, even if their implementation is a bit weird. It also makes them usable outside of a Chain. For instance, we could do something like:\n\n``` rust\nIron::new(Logger::new().from_handler(whatever))\n```\n\nDirectly, to avoid issues with \"you must link first and last\" etc.\n. ``` rust\npub trait AroundMiddleware {\n    fn around<H>(self, H) -> Box<Handler + Send + Sync> where H: Handler;\n}\n\npub struct Logger { format: String }\n\nimpl Logger {\n    // All initialization and configuration logic goes here.\n    // If the work done by this is particularly complex, you can put functionality here\n    // and call it through LoggerHandler::logger or equivalent.\n}\n\n// Private, as nobody interacts with this except through a trait object.\nstruct LoggerHandler<H> { logger: Logger, handler: H; }\n\nimpl AroundMiddleware for Logger {\n   // Takes self by-value, so it's also clearer that this is only called once.\n   fn around<H>(self, handler: H) -> Box<Handler + Send + Sync> where H: Handler {\n     // Unfortunately have to add another level of indirection here until we get unboxed abstract return types \n     box LoggerHandler { \n          logger: self,\n          handler: handler\n      } as Box<Handler + Send + Sync>\n   }\n}\n\nimpl Handler for LoggerHandler {\n   fn call(&self, req: &mut Request) -> IronResult<Response> {\n       let entry = time::precise_time_ns();\n       let res = self.handler.call(req);\n       // This logic would probably be in Logger, but is here for simplicity.\n       println!(\"{}, took: {}\", self.logger.format, time::precise_time_ns() - entry);\n       res\n   }\n}\n\n// Use it\nfn main() { Iron::new(Logger::new().around(my_handler)).listen(Ipv4Addr(127, 0, 0, 1), 3000); }\n```\n. You can use a NoOp, I even defined and use one in the implementation of `ChainBuilder::around` but I think that this actually represents a much better approach. \n\nEven though it adds a tiny bit of code to the implementation of an AroundMiddleware, it makes their use significantly more ergonomic - especially because you can easily use them without a Chain for things like Logger.\n\nI'm going to make a version of this in a branch and we'll see how it goes. I'll write up a few examples to see how this compares to the old system and which is better in both implementation and usage.\n\nIf we do go with the current approach, we should definitely expose a NoOp Handler that just returns 200 OK\n. Looks great. I'd love if we could lift the IoResult into IronResult so this could be easily used with try! within middleware etc. but that is out of scope for this PR.\n\nI think `serve` can also be removed, will file.\n. Hmmm.. Restarted travis, appears fixed. Thanks for looking into it. I probably would've given up long before reaching out to travis support.\n. `let x: Option<Status> = FromPrimitive::from_u16(200);`\n\nThe method is on the `FromPrimitive` trait, not on the Status struct. I was under the impression this enables `as` conversions, but I guess not.\n. As with the removal of `Response::serve` this change is in line with the new method of working with Responses, i.e. that Response is created in a Handler just once, and future AfterMiddleware have rights to modify, but usually should not replace, an existing Response.\n\nDefaultErrors should probably either re-implement the logic in `from_file`, which is ugly I know (but at least it's just 3 or 4 lines), or get the body out of a fake Response generated with `from_file`. I regret that it is unergonomic, but I think it is ok for it to be this way as most AfterMiddleware should not be replacing the Response wholesale, just doing postprocressing.\n\nDefaultErrors seems like an exception to the rule, so is unfortunately not as easy to create. There might be merit to a less opinionated method, but it seems that it is simple enough to implement in any crate which absolutely needs it and might not be something we want to encourage.\n. Repeatedly returning `Err(UnitializedHandler)` is basically the same as repeated `Option::unwrap` just with a tiny bit more reporting.\n\nWe should either fail fast by actually `fail!`ing or we should provide an infallible mechanism for creating handlers, which this provides. In this system, badly initialized handlers fail once and immediately before the server even starts running, which is _much_ better than repeated crashes on incoming requests.\n\nPersonally, I much prefer the infallible systems and avoiding `fail!` when possible, hence this PR.\n. This could actually be made much simpler to work with with the impl of Handler for `|&:` closures, since you can just return one instead of creating a new type specifically for your Handler, given that impl, the example from the other thread would just be:\n\n``` rust\npub struct Logger { format: String }\n\nimpl Logger {\n    // All initialization and configuration logic goes here.\n    // If the work done by this is particularly complex, you can put functionality here\n    // and call it through LoggerHandler::logger or equivalent.\n}\n\nimpl AroundMiddleware for Logger {\n   // Takes self by-value, so it's also clearer that this is only called once.\n   fn around<H>(self, handler: H) -> Box<Handler + Send + Sync> where H: Handler {\n       // Theoretically using an impl of F: Fn Handler for F. Right now requires double box :/\n       box() ( |&: _| {       \n           let entry = time::precise_time_ns();\n           let res = self.handler.call(req);\n           // This logic would probably be in Logger, but is here for simplicity.\n           println!(\"{}, took: {}\", self.logger.format, time::precise_time_ns() - entry);\n           res\n       }) as Box<Handler + Send + Sync>\n   }\n}\n\n// Use it\nfn main() { Iron::new(Logger::new().around(my_handler)).listen(Ipv4Addr(127, 0, 0, 1), 3000); }\n```\n\nThis PR also has the advantage of making us able to implement AroundMiddleware for `|:` closures.\n. Keep in mind that this is relying on several yet-to-be-implemented features in rust, mainly multidispatch and higher-ranked lifetimes, and assuming they iron out the many bugs in unboxed closures. Until then you will have to define a 2nd struct or deal with writing:\n\n``` rust\nbox() \n    (box() (|&: _| closure body) \n     as Box<Fn<(&mut Request,), IronResult<Response>> + Send + Sync>)\nas Box<Handler + Send + Sync>\n```\n\nbecause we can only implement Handler for Box<Fn<..>> instead of F: Fn<..>\n. I am feverishly awaiting those so I can make our Hello World just:\n\n```\nIron::new(|&: _| Ok(Response::with(status::Ok, \"Hello World!\"))).listen(Ipv4Addr(127, 0, 0, 1), 3000)\n```\n\nAlas, not yet :(\n. I think the consensus is that this is a good thing. I'm going to merge this when travis passes.\n. Should do this for Before, After, and Around Middleware, and add alternative impls for catch variants of all three and Handler. Should make working with Iron waaaay better.\n. There are ICE's everywhere when trying to actually use this in examples -.-. I'll keep working at this in a branch, but there are many things that need to change in rust before this is nice, working, and ergonomic.\n. Closing for now. Will revisit in a bit when unboxed closures stabilize and we get multidispatch.\n. Fails due to rust-http build failures, but compiles when using my fork, which compiles in the temp branch.\n. That sounds like a good workflow. This depends on whether you are creating a test for BeforeMiddleware, AroundMiddleware, Handlers, or AfterMiddleware.\n\nIn lieu of better docs (I'm working on it, promise :)) the general strategy I would take for each is:\n\nFor all: use https://github.com/reem/iron-test to mock Request and Response.\n\nBefore: Create a Request, pass in an &mut reference to it, check if it has the state you want afterwards.\n\nHandlers: Create a Request, pass in an &mut reference to it, check if the Response looks the way you want.\n\nAfter: Create a Request and Response, pass in &mut references to both of them, check if they have the state you want afterwards.\n\nAround: Create a mock Handler, create a Request, initialize the AroundMiddleware, then do the same thing as for testing handlers.\n\nI'll keep this issue open as there should really be better docs/examples surrounding this. (middleware in the iron org should also be tested much more than they are now).\n. 1. Gives us more control over concurrency strategy\n2. Faster\n3. Better representations of Request and Response, including a much better header representation\n4. Less painful to implement for, as it is designed much more deliberately.\n5. Exposes a safe streaming response abstraction\n   etc.\n. I do to. Chris Morgan is very smart, but he's also very busy. Hyper is a sort of splinter-project from Teepeee. seanmonstar started it because he wanted to move a bit faster and I've been contributing recently to make it even better.\n. Fixed through #173 \n\nThanks for reporting.\n. Haha I had already made the PR 40 minutes ago, was just waiting for travis :).\n. Oooh, linker errors, my favorite :P\n\nUnfortunately, I can't really help you anymore than saying it looks like you don't have a dependency of some kind, or your library path is not set right, or.. it could be a lot of things. I don't think it's a problem with Iron itself, because it builds fine on my machine. Are you sure you have the dependencies that it is looking for?\n. I believe they are the same. Try setting `LD_LIBRARY_PATH=LD_LIBRARY_PATH=/usr/local/lib:/usr/local/lib/rustlib/x86_64-unknown-linux-gnu/lib/`\n. Weird... Can you reach out on the IRC? I don't really know what else to tell you, sorry :/\n. That might be worth having on the rust-http README as well. If you want to make a PR to either/both, I would merge :)\n. Linking to rust-openssl would probably be best, both here and in rust-http.\n. This can be mostly accomplished through the use of https://github.com/reem/watch and a small custom bash script which does the steps above.\n\nI'll try to put something together tomorrow that does at least some of this.\n. A workaround for this is to just use `cargo run` and write mounting paths and such so that they are relative to the place where the executable is run from.\n. Thanks for this fix. Weird that this was not turned on before.\n. I'm getting insanely weird errors trying to make this compile - adding these re-exports explodes random things.\n. I used a different fix in #181 to do the same thing. Thanks for contributing!\n. Apparently building with `--release` on the same machine led to over _95k_ requests per second. I'm flabbergasted at those results and am very curious if we can repeat that anywhere else.\n. Makes sense, that is likely to be most of the overhead of making any request.\n. I'm going to close this, it's good to have but there's not really an action item.\n. You need to update your rust, the syntax for unboxed closures was recently changed. Pinning versions doesn't help right now since rust changes in ways that make versioning slightly useless.\n. This issue is showing up on travis too, but I don't know what's going on or how to fix it, unfortunately.\n\nI'll update this issue if I make any progress fixing this.\n. Fixed!\n. Fixes one issue. Still fails with a linker error in cargo test.\n. Ugh, I'm having a hard time fixing this since I can't reproduce on my machine. `cargo build && cargo test` runs without error for me...\n. Hmm.. The source of this error seems to be rust-http-content-type, specifically it's generator. Will investigate further.\n. That's alright. I am getting this error now but not sure how to figure it out.\n. Fixed!\n. This is an error in phf_mac, made a pr to fix as https://github.com/sfackler/rust-phf/pulls/18\n. There was a bug, but it is fixed now!\n. Unfortunately this is a bug in one of our dependencies... I'll try and track it down ASAP.\n. @jacek99 Can you try this again with the latest nightly and `cargo update`? This builds fine for me.\n. Oh sorry I misread your earlier comment. Iron core doesn't build right now because some of its dependentcies aren't updated for later iron. In the meantime I suggest pulling iron/iron and grabbing any other middleware you need one by one.\n\nIf they don't work you could open issues in their respective repos and I would try to fix them.\n. @jacek99 I'm closing this issue, but feel free to open others (in fact I encourage you too!).\n. This issue could be made in iron/core, and that recommendation should likely be changed until all the parts are building again.\n. This should probably be tied to the 302 status code.\n. @michaelsproul You're right. That said, I think we should still find a way to tie this to a subset of status codes, since it really only makes semantic sense with those three.\n. On second thought I think we need a general solution to this problem, but I'm not sure what it is. For now, let's just go with any status.\n\nHowever, the second parameter should definitely be changed to accept a `Url`, not an `&str`.\n. This should probably use `iron::Url`, importable through `use {Url}`.\n\n@michaelsproul what do you think?\n. Also, if you're going to make another edit anyway, can you rename the commit to something like:\n\n`(feat) Added a redirect constructor to Response.`\n. That should probably be a method on Iron's Url, but the above works as a stop-gap.\n. @gaudecker Awesome! Thanks for all this work.\n. Looks great.\n. Perfect. Thank you.\n. I'm a little worried about the possible combinatorial explosion of constructors here. Perhaps a series of builder-esque methods would be better, like:\n\n``` rust\nResponse::with(status::Ok, \"whatever\").type(JsonMediaType)\n```\n\nEDIT: ugh type is a keyword, how about `.media`?\n. @plcstpierre It's a bit tricky, because you can't have a builder method that works for both `self` and `&mut self`. In this case, we really want `(self) -> Response`, but for AfterMiddleware `&mut self` would be convenient.\n\nIn this case what you would do is add another method which takes `self`, modifies it, then eventually returns it.\n. @plcstpierre I think a nice API for this on Response would probably be best.\n. @jedahan Agreed. I think our marketing of Iron's features/design could use a little TLC.\n. I implemented part of this in rust-http and tested locally, this improves the performance by Iron by over 80%! I would really like to land this, but alas upstream rust is borked.\n. Actually this works fine on latest Iron and boosts our req/sec up to 84k!\n. I filed an issue in rust-Lang/rust about my frustration there.\n\nOn a separate note, @huonw pointed out that there was a glaring unsafety in set_mut, so I had to change the implementation, meaning this needs some fixes before it is merged.\n. Rebased and updated for latest rust-modifier.\n. Yup. Thanks!\n. This is not in nightly yet, so travis fails, but this is correct.\n. It seems like the best thing would be to implement stuff for Iron here https://github.com/swagger-api/swagger-codegen? Honestly I am not sure as I have never used Swagger.\n. From the discussion it looks like this can be done out of core, so I'm closing.\n\nFeel free to rekindle discussion elsewhere or try to convince me that this needs to go in iron proper and I should reopen.\n. This is very interesting. It looks like there are two panics here, where the second happened during unwinding, causing the whole server to abort whereas panics would usually be enclosed in a single task.\n. Is the source code for your server public? Looking into this, it's likely the initial panic came from use code as opposed to code within Iron. I think I've figured out what's causing this.\n. I am trying to tackle this with a new panic-resistant task pool that I just wrote here: https://github.com/reem/rust-resistant-taskpool but I have to do a lot more testing to find out if it's solid enough for use.\n. Fixed by the new task pool in master.\n. You can always call `MediaType::new` yourself and pass it to the `ContentType` tuple constructor. This is just a convenience method.\n. Ya, `MediaType` also has a `new` method to make this easier.\n. @torhve does this address your concern, or do you think calling `MediaType::new` is too inconvenient?\n. Merging because Cargo is broken but this does work.\n. Same cargo bug.\n. cc #171 #203\n. Major topics to hit:\n- Handlers\n- Middleware System\n- Plugins\n- Modifiers\n- Streaming/Write strategy\n- Headers\n- Testing\n. Unfortunately I never got around to completing this, but I did write one chapter in this repo: https://github.com/iron/byexample\r\n\r\nI agree it is extremely important and I would be extraordinarily grateful if anyone contributes further chapters addressing any of the other topics I listed above.. Unrelated failures because of enum namespacing so merging anyway. Thanks for taking care of this.\n. This needs one hell of a rebase.\n. Awesome! This is failing due to an OpenSSL problem. I'll look into it then merge.\n. Great success!\n. It's green! It's green!\n. Not exactly, but if you assign a Reader to body then it will be streamed in parts.\n. Closing since there's not a huge action item for us here. Feel free to comment if you think there's more to say here.\n. Just fixed in #227!\n. Just merged #231, so should be fixed now. Thanks for the PR anyway.\n. Thanks for the fix.\n. We are thinking about the best way to publish iron middleware on crates, and I'll probably get around to it in the next few days.\n. This is mostly done.\n. Fixed a while back.\n. Should be fixed now, thanks for filing! \n. Ya I've narrowed the issue and am working on a fix.\n. It's because of a misuse of the host header on my part. I am working on a fix.\n. Thanks!\n. There is a slight regression here due to port not being properly used, but that should be fixable separately.\n. This is filed in hyper already as https://github.com/hyperium/hyper/issues/148, it's just a bit of over-eager logging and doesn't mean there is really an error.\n. Try updating your rust version, it works for me.\n. You can pretty easily implement this behavior as a custom Handler, similar to the way Router and Mount work, that wrap many Handlers and add additional behavior. I think this would probably be the best way to go around this.\n\nI actually looked into implementing this sort of handler, but embarrassingly enough I actually deleted the folder by accident since I was sure I had it on github (I didn't).\n. What I mean is that you can write a middleware that is _like_ router or mount, which can take many handlers and do what you want with them (basically all this: https://github.com/rustless/rustless/blob/master/src/middleware.rs#L49-L98) can just go in the implementation of Handler for some type.\n. Closing, unless you have a further action item.\n. This is actually what we used to do internally, but I transitioned away from a regex-based router because it lead to poor performance, a very complex implementation, and several other such problems.\n\nWe could write a custom matcher to match string globs _and_ regexes, but there would be a _huge_ increase in implementation complexity.\n. The current approach is much faster and has a simpler implementation (from Iron's perspective), so I doubt this change will be made. If you have any killer reasons or examples of why regex based routing is needed over our current glob and param matching, I might be convinced, but otherwise closing as wontfix.\n. Usually it's actually fastest to work on the latest versions of dependencies so a version update isn't necessary every time a dependency breaks and pushes a fix (many updates are because of compiler changes, so pinning versions will just get you broken versions).\n\nThis breakage is my fault, since I pushed a new version of error and haven't had time to fix Iron yet - however, I do want to fix Iron ASAP, so will be pushing a fix for error 0.0.3 instead of merging this later tonight.\n. @graue it's possible we could do that. I would love to have less breakage, but there's a lot of additional maintenance burden for me if I have to maintain working `0.0.*` and `0.1.*` versions of all of Iron's dependencies. (There are a lot of packages involved here)\n. It hasn't happened that much, anyway, Iron has been fixed in the meantime.\n. This was fixed a while back, so closing.\n. This gets us compiling again, but doesn't fix the immediate-exit problem, which requires an update to hyper, which I am also working on.\n. Rolled this in another PR that fixes a wide variety of issues. Thanks anyway.\n. When you run `cargo run --release --example hello` cargo ignores the `--release` flag when you set `--example`, which is why you are seeing poor performance. Build iron with `cargo build --release` and then compile `hello.rs` manually using `rustc --opt-level=3 examples/hello.rs -L target/release -L target/release/deps -C lto --cfg ndebug` to get a fully optimized binary to test with.\n. It's probably because of the VM, I just ran the same thing and got 85k. Closing.\n. Thanks.\n. I merged that fix to modifier but haven't updated crates.io. This is all sort of moot until hyper gets updated anyway, which is what I'm working on now.\n. Iron will continue to track nightly (like the rest of the ecosystem) until\n1.0 stable, when it will split to have two branches, one for 1.0 stable and\none for 1.0 nightlies. This will continue into 1.X versions.\n\nEventually Iron itself will hit 1.0 and adopt a similar versioning scheme\nto Rust itself, but that's a while off.\nOn Tue, Jan 13, 2015 at 9:23 PM Daniel notifications@github.com wrote:\n\n> Also failing on 1.0.0-alpha. Any plans to support alpha (and later\n> beta/stable)?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/iron/iron/issues/255#issuecomment-69812906.\n. Fixed.\n. @pzol Thanks for this, but I ended up needing to make a bunch of other unrelated changes, so I just rolled everything into #257 instead.\n. Examples are ICEing, nothing that can be done right now so merging.\n. @iho unfortunately this is the current situation, Iron will continue to track nightlies until 1.0 stable, where a solution for cases like this will be devised (perhaps some kind of switch for stable/unstable channels).\n\nAs a result, I'm going to close this, since nothing can really be done right now.\n. Nope, this isn't your fault at all. A dependency of one of Iron's dependencies, mucell, hasn't been updated for the latest version of rustc so it's broken right now. This should be fixed in the very near future, hang in there :).\n. Ya, that's a difference ICE in rustc, but that should be fixed in the next nightly.\n. I submitted a pull request to mucell to fix the build failure.\n. @jihokoo Great, then we're just waiting for the mucell fix to be merged.\n. Fixed!\n. @heynemann, it looks like your rust install is borked, since it can't find `core` or `std` which are the internal and external std libs respectively. Try to uninstall and reinstall using the rustup.sh script.\n. Nope, I'm on OS X too. This happens every once in a while, just uninstall and reinstall and that usually fixes it.\n. @heynemann run `cargo update` to get the latest versions of all the dependencies, including mucell.\n\nDon't be sorry! It's no problem.\n. @heynemann Did you compile with optimizations or are you running on a VM? Make sure that when you benchmark you use the `--release` flag with cargo, i.e. `cargo run --release --example hello`.\n. Ugh ya, benchmarking with `ab` is super borked and I've never really been able to figure it out. Try using `wrk` instead, that tends to work much better.\n. I agree completely. I haven't really felt the need to do this yet since everything is still in flux and hyper is the only real option right now, but eventually I think there should be a protocol/trait layer between hyper and Iron so that you can swap out the hyper back end.\n. It's possible that `Request` could be changed to allow streaming of the input data. I've thought about it and the issues that come up with direct `Response` streaming aren't really an issue for `Request`, since there is only one state (i.e. no \"status line written\", \"headers written\", \"nothing written\" etc.). \n\nThe major issue I anticipate is that this makes testing a bit trickier, but from my memory of the internals of Hyper I think it's actually pretty easy to mock an `HttpWriter` with whatever data you want. This also has the side-effect of making `Request` no longer `'static` or `Send` (since `HttpWriter` is given to us by Hyper with a lifetime), which can be a pain.\n. I can take a crack at making this change tomorrow (newtype `&'a mut HttpWriter` and change `Request::body` to use that), but it's not too complex a change and probably interesting if either of you wants to give it a try first.\n. We now allow streaming the request body, so Iron should now be able to support this use case well.\n. cc @s-panferov @cybergeek94\n\nI had some free time so I just made the change. Thoughts on the approach? Do you think `Request` should implement `Reader` itself, or is the current isolation to the `body` field appropriate?\n. @cybergeek94 I think it would actually be the role of a Plugin to properly read the request body and transform it into whatever form a Handler can actually use and storing it in the request extensions, whether that's reading the whole thing and parsing it into JSON or parsing it using multipart or whatnot. It should be rare for the Handler to be responsible for dealing with a raw request body directly.\n\nBeforeMiddleware used to fill this role, but the lazily-evaluated and cached nature of Plugins actually makes them ideal for dealing with this sort of one-shot data.\n\nA badly written BeforeMiddleware can already cause all sorts of havoc by setting properties on Request to nonsensical values - providing the body as a reader doesn't change that.\n. Updated for #275, landing.\n. This appears to already be done: https://github.com/iron/iron/blob/master/src/middleware.rs#L279\n\nIs there something else that this doesn't cover?\n. This is now done via the new body abstraction, it is now possible to write to the body using a normal `io::Write` interface.\n. @ProtectedMode Awesome.\n. @untitaker rust-ci is similar to greenkeeper, it triggers a nightly rebuild on travis, so you know every day if something has caused your build to fail.\n. `hyper::server::Request` has a `remote_addr` field which contains the `SocketAddr` of the request, probably easiest to just use that instead of passing the port around separately.\n. by the way thanks for reaching out on #245, I let that one slip through the cracks\n. You're right, that's the client address. If we're going to do this, we might as well just add the host socket address to the Request type and use that, rather than passing it around separately.\n\nThanks,\n         Jonathan Reem\n\nOn Fri, Jan 23, 2015 at 5:46 PM, Michael Sproul notifications@github.com\nwrote:\n\n> ## The `remote_addr` is the IP and port of the client, is it not? From poking around in Hyper it seems the local equivalent is ignored in the `listen` methods.\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/pull/273#issuecomment-71223204\n. Ya, just store it on Iron and add it to our Request type, we can upstream\nlater.\nOn Fri, Jan 23, 2015 at 9:22 PM Michael Sproul notifications@github.com\nwrote:\n\n> Just to clarify, you mean Hyper's request type?\n> \n> Otherwise the only way we can store it on our Request type is by storing\n> it on Iron as I've done here. This is because the only arguments to\n> hyper::server:Handler::handle are self and a Hyper request + response.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/iron/iron/pull/273#issuecomment-71259117.\n. Looks good - I'll merge when everything builds again.\n. Excellent!\n. Awesome! Thanks for doing this.\n. Yay breaking all the things ever!\n. @michaelsproul @zzmp thoughts?\n\n@zzmp I know you liked the ability to handle, but in practice it made no sense to switch back to the no-error path.\n. Particular open question: is it correct for `Handler` to not have a `catch`, and therefore be bypassed in the error flow?\n. @s-panferov There are a few disadvantages to splitting everything up:\n1. You have to link stuff like loggers an additional time\n2. Anything that wants to run as both a normal middleware and an error handler has to be linked twice\n\nYou never need to think about indexes, just relative order - I anticipate that error handlers will just go at the end most of the time.\n. Other open question:\n\nShould `catch` expose a way to switch back to the normal track at all? My intuition this time said no, but I think that a \"just switch back to the next middleware\" might be valuable. This is how express works, since you can call `next()` with no args in an error handler to switch back to the normal track. Thoughts?\n. I would be far more comfortable with stuff like router raising errors on NotFound if there was a way to switch back.\n. You could actually still write a generic `Suppress` type which you'd just wrap the middleware whose errors you would like to ignore in.\n. Ok, I'm convinced this is desired... I'll push an update.\n. Done! Before I land this, I want to add some tests for the chain implementation, since it has enough indexing to make me edgy.\n. Ok. Tests added - 200 lines of infrastructure to allow reasonable tests...\n. Landing, breaking everything!\n. Awesome! Feel free to make a PR and I'll give you a review of the changes.\n. Fixed!\n. Included in #275 \n. Iron and rust are still pretty unstable, so I wouldn't recommend using them in production just yet. There are also a bunch of polish issues with Iron and associated middleware, though I am rapidly addressing them and making it a core focus for the next few weeks.\n\nPerformance is definitely a goal of Iron, but it has to be framed inside the blocking-IO world that it lives in, which means it won't be as fast as some other fast solutions built on asynchronous IO. That said, Iron wrecks node.js and other higher-level evented libraries in req/sec (by like an order of magnitude). \n\nI don't know enough about vibe.d (I had to google it) to really compare it to Iron, but from what I've read it appears to be based on non-blocking IO, which means it will have a different performance model than what Iron has.\n. Since this is just a question, I'm closing.\n. Thank you!\n. Travis has an old rustc, so boo.\n. That example was actually broken before this change, moving the `println!` was unrelated. `.listen` returns an RAII guard that, when dropped, will block until the server is closed. By saving the guard into a variable using a let statement, the dropping of the guards is delayed until after they are all started (at the end of the block), removing the blocking behavior.\n. Builds!\n. Thank you very much for your work!\n. Seems like this belongs in a proper iron/body-parser implementation.\n\nPlugin configuration is unfortunately very tricky and I haven't been able to come up with a really good way to do it.\n. Given that body-access is the poster-child for plugins, it seems like it should be one. I'd rather a patch to body-parser for now, and we can maybe move it to core in the future.\n. If you're doing a fixup, can you also remove this from the example and Show => Debug?\n. Amazing.\n. Thanks.\n. This is awesome and super exciting. I saw your work in hyper and I'm really glad to see it here too.\n\nI just left a few comments, let me know your thoughts.\n. How about we just provide `http(addr)` and `https(addr, certificate, key)` constructors?\n. It seems like a nuisance to have to get and type out the protocol.\n. Sorry, I've been very confusing. What I meant was to replace listen with http and https.\n. Yes.\n. Looks pretty good, I will read once more and merge in the morning.\n. Ah ya, my bad for letting this spin. Just did another read through, looks like good work.\n. @SkylerLipthay The simplest thing is to just add another dependency on `lazy_static` and load it there.\n\nThis whole methods feels a bit not so good. It should really parse directly from the extension string to an instantiated `Mime`, which is cloned. This avoids allocating an intermediate string and the cost of re-parsing. Setting the raw header is a bit bad practice and more importantly will just move the cost of re-parsing later if it is ever accessed again.\n\nThe way we used to do it was with [rust-http-content-type](https://github.com/reem/rust-http-content-type), which generated a phf table of extension => rust-http mime instance. In this case it would be extension => hyper mime instance. Unfortunately depending on a modified version of that would ruin all hope of us being usable in 1.0 stable.\n\nAll of that said, it seems the best way forward is to do the simplest thing and use `lazy_static` to store a `Types` instance.\n. @SkylerLipthay needs a rebase, since I merged some other changes.\n. Looks good otherwise.\n. So everything is broken on travis right now. There's a fix on the way, so I'll just wait for it to land and merge this tomorrow.\n. @SkylerLipthay will need another rebase and travis broken yet again :/\n. @SkylerLipthay finally things are actually moving, there's a small bug in the impl here, see the travis log (just a simple `expected Option<T> found T` error)\n. FINALLY\n. Did you compile with optimizations?\n. I just tested and got 92k locally.\n. Can I get the exact commands you used to compile iron, run the example, and run the benchmark?\n. You are building without optimizations. Use `cargo build --release`, `cargo run --release`.\n. Are you running on a VM? VMs are usually slower.\n. I'm not sure what to tell you, a lot of things can influence these numbers. For instance, when my computer's battery is low I get like 500 req/s.\n\nUnfortunately, I can't really fix this right now without being able to at least reproduce locally, sorry.\n\nThe best thing you could do would be to maybe profile the executable while it is being benchmarked a few times and include that, along with commands and computer specs.\n\nIf you get back to me with that I might be able to re-open the issue and fix it, if the profiling is informative.\n. I'm not comfortable with this as I think it will cause confusion with many users assuming this is for setting the status code. \n\nThe ContentLength header is available in the `iron::headers` module, which is a re-export of all the hyper headers.\n. Ya, go ahead :D. Make a different PR, I'm closing this one.\n. LGTM. Thank you!\n. I agree we want this long term, but I honestly don't think we really know enough about what Rust web development will look like for us to make these decisions right now.\n. For what it's worth I own the `http` name on crates.io - that seems to me to be a fine place to aggregate standards for web development in rust.\n. Thanks.\n. Done.\n. Enabling `sudo: false` means you are opting in to travis' container-based infrastructure, which serves up builds and has very good caches.\n. Taking a look right now.\n. Looks great to me. Excellent work @panicbit.\n. Awesome, this looks great. Thank you so much for all the PRs, but as discussed before I'm gonna wait for travis to be be back up, unless you need something urgently merged.\n. <3\n. This is a known issue, but @zzmp is on it!\n. Boom, updated! @zzmp nice job\n. While you might technically be right, I'm really don't _want_ to put something like this in the README, it's bad for business, you know ;)\n\nThese are temporary limitations anyway, we are already thinking of better ways to distribute work over the thread pool to allow handling many more concurrent connections.\n. Sure, if you craft it to be a little more positive ;)\n\nEDIT: I don't mean that anything your saying is bad, just that I don't really want it in the README\n. @s-panferov you still interested in landing this?\n. closing due to inactivity but feel free to open another\n. Hmm, good call. @zzmp can you check this out? If I recall correctly it should be really easy to add another crate to the docs.\n. Collapsing into #338 \n. I think the documentation here is not wrong, just highly technical and possibly in-need of rephrasing. \n\nA `valid URL in a relative scheme` is not the same as a `valid relative URL`; in this case \"scheme\" refers to the protocol, e.g. http, https, not the format of the url itself.\n. @lambdajp Awesome! I'm really happy to get other people working on this too.\n\nI'd caution against writing anything very long-form right now, since while things are relatively stable there will still be breaking changes, leading to (possibly) lots of outdated documentation. Believe me, I've had to delete hundreds of lines of documentation already.\n\nExamples are usually much easier to update and get checked for breakage automatically by the continuous integration system. Short documentation is also easy to update, because the changes that broke it are usually near it.\n. @lambdaburrito Cool. I'd ensure that you recommend that users read the rust book/intro first, especially since Iron uses a variety of more complex type system features.\n. I'm working on a fix for this right now. #314 is the start but I have to fix mocking tools too.\n. Awesome, thanks!\n. Done!\n. Hmm, that's inconvenient since it means we won't be able to automatically set the content type when a File is passed to set the body of a response. That said, it's not necessarily blocking. Could we grow an API based on `readlink` in the future, or is that unlikely to happen?\n\nEDIT: Also, is it possible that we could have `#[cfg(nightly)]`?\n. Yup.\n. @gsquire thanks for fixing :)\n. Just restarted travis to show the current build failures.\n. superseded by #325\n. The build is fixed on master. I'm closing because I don't want to do this until there is some ecosystem stability because it makes the developer workflow really hard (have to release and do menial updates even more often).\n. Fixed in master\n. Hey @rookwood101, I just wanted to let you know that there are a few contributing bugs to the build breaking right now, but I have these fixes already in a local branch that I am waiting on the last upstream fix to PR. It should be ready to go with tomorrows nightly since the needed rust PR merged a few hours ago.\n\nAs a result I'm probably gonna close these when that PR goes live, since I'd have to do a bunch of rebasing otherwise.\n. superseded by #325\n. superseded by #325\n. @natemara sorry, I I just merged #325 which already includes similar changes.\n. I think this current case is mostly for implementation concerns - due to the nature of `rust-url` we need a full url including host to create the request's url instance. I'll see what I can do about fixing this though, since there's no need to be unnecessarily mean to HTTP/1.0 :).\n. Thanks! Can you change the commit message to be a bit more descriptive and follow the style of the other commits in the history?\n. @ghmlee Great! Thank you.\n. Fixed.\n. @lambdaburrito I'm sorry, you are right, I misread the original post and thought this was only about iron proper not also router. I'll reopen and see what I can do about fixing this today.\n. Actually fixed!\n. Looks good, can you squash?\n. Also do me a favor and ping me when you do, I don't get a notification if you push new commits, so I don't know when the PR has been updated.\n. Fixed in the latest version of num_cpus.\n. Thank you for all this analysis and information! This is almost definitely caused by https://github.com/hyperium/hyper/issues/368.\n. @jlouis you might be interested in some preliminary work being done here: https://github.com/reem/transfer, I'm working on a low-latency server built on mio, an event loop over epoll.\n\nI'm also working on fixing the hyper issue with a queueing abstraction.\n. Sorry, but I really don't like how the crates.io badge from shields.io is orange. Maybe if you could find consistent styles with a crates.io badge that's green?\n. @DevoNoel Looks great, thanks for fixing this!\n. I looked through the implementation and didn't see anything obvious... @michaelsproul you are probably most familiar with the url implementation - any idea what might be happening here?\n. Yup. Closing due to inactivity. Anyone feel free to comment if they can reproduce.\n. @zzmp this is what I was talking about\n. @briancolfer I believe your rust version is out of date, Default was added to the prelude rather recently. I just compiled iron locally on the latest beta and nightly, so closing.\n. Sounds good to me :)\n. This is also what `AroundMiddleware` is basically for.\n. Though I do agree that sugar for constructing chains is definitely desirable.\n. I think you're right and we should just copy examples/time.rs, it's easier to keep things consistent that way.\n. Nice, thanks :)\n. Pinned to hyper 0.5 for now. Will update to 0.6 in the near future, but it will require some thought to try and avoid breaking iron's API.\n. Fixed!\n. This is great, thank you. It's a little unfortunate that making ssl optional doesn't really have an effect unless all extension crates manually opt-out. @alexcrichton do you have any ideas how we could use cargo to make this more ergonomic?\n. I'm mostly just concerned about people forgetting to set `default-features = false` even if they could. I think you're right and that might be a sign that it shouldn't be on by default.\n. We can tackle the issue of optional ssl later.\n. @gsquire can you remake this PR to the router repo?\n. We can't have it here since it would be a circular dependency, unfortunately.\n. @AndrewBrinker yes and yes.\n\nI am in favor of this change.\n. Each request is handled in a different thread, so the request extensions can act as a form of thread-local storage.\n. @singpolyma there is a pool, but a request gets exclusive access to the thread it's being handled in until it is finished, then another request can be handled on the same thread.\n. I agree we want something like this, but I have to think about the API a bit.\n\nRegardless, one major comment on the implementation ChainLink should just contain a Chain and call its methods rather than reimplementing the internals.\n. Makes sense to me. Thanks for this!\n. @muja I agree completely, this is functionality we are looking to develop in hyper which we could then expose in iron.\n. @muja currently the std library doesn't provide a way to close a `TcpListener`. As soon as it does, we will add support in hyper and then I can add support in iron.\n. LGTM, thanks!\n. @netmml ok, looks good to me now. Can you squash?\n. Squashed manually in #379\n. Closing due to inactivity but feel free to reopen with the requested changes.\n. Great! I like the comment too, helps clarify what's going on.\n. As discussed earlier I am definitely for this. I'm hesitating about exposing the hyper response directly, but I think it's probably the right thing to do here.\n. @bfrog can you actually open an issue for that feature request? It makes perfect sense you'd want to run actions post-actual-response-writing but the current API does not really allow that.\n\n@sfackler the reason it can't be an AfterMiddleware is because those still run before the response is actually written out.\n\nSorry for taking so long to merge this, I've just been thinking about it and I also want to ensure I merge it when I have time to go and update the other repos in `iron`.\n. This is now sort of possible by doing the work in the WriteBody impl used as the Response body, which typically runs after the Handler has returned.\n. Perhaps there's room for another example which integrates these concepts? More examples is better, IMO.\n. cc #311 \n. Yes, it should be `automatically`.\n. Thanks!\n. `HttpResult` is actually a reexport of `hyper::Result`, I've made it a longer name to make it clear it is not the Result type used ubiquitously in Iron, that is `IronResult`. `IronResult` is not called `Result` since it is in the iron `prelude` module, and putting a `Result` symbol in there would not work well.\n\nI use the renaming-Result idiom in many crates, but it doesn't fit well in this case.\n. It is used to populate the `local_addr` field of `Request` in `Request::from_http`, and can be \"accessed\" through that. It is meant to be an implementation detail of the `Iron` type.\n. Hmm, can you instead just mark them `#[doc(hidden)]`?\n. Hmm, it might actually be better to just make them private fields.\n. I left some specific comments, but at a higher level you actually do not need to use an AroundMiddleware here, an AfterMiddleware (using the catch method) would do perfectly fine, since all you need to do is introspect the response/error.\n. @ilkosta actually you can change the response content, or even replace the response wholesale - nothing is written to the actual stream until the top-level Handler has returned (which necessitates all middleware having run).\n. Closing due to inactivity but feel free to reopen with the requested changes.\n. Hmm, can you post some context, like your Cargo.toml or other code? I am having trouble reproducing this locally.\n. Sorry, I can't reproduce this locally with either the latest stable cargo and rustc or the latest nightly, could you try upgrading and seeing if that solves your problem?.\n\nEDIT: versions:\n\n```\n# stable:\n~/c/r/deps-on-iron git:master \u276f\u276f\u276f cargo --version                                                  \u25fc\ncargo 0.4.0-nightly (15b497b 2015-07-08) (built 2015-07-09)\n~/c/r/deps-on-iron git:master \u276f\u276f\u276f rustc --version                                                  \u25fc\nrustc 1.2.0 (082e47636 2015-08-03)\n\n# nightly:\n~/c/r/deps-on-iron git:master \u276f\u276f\u276f cargo --version                                                  \u25fc\ncargo 0.5.0-nightly (4bc0456 2015-09-02)\n~/c/r/deps-on-iron git:master \u276f\u276f\u276f rustc --version                                                  \u25fc\nrustc 1.4.0-nightly (cd138dc44 2015-09-02)\n```\n. Thanks!\n. cc @sfackler no more *s!\n. Thanks :)\n. It does make the example longer, but also more useful I agree.\n. Thanks!\n. This would definitely be useful. I've started work towards solving this in the above linked PR to hyper.\n. @flada-auxv thanks!\n. Awesome! This is exactly the kind of thing we need to make iron more approachable.\n\nI've given the two examples a read and I have two main thoughts:\n- the error recovery example would be even better if it also included AfterMiddleware, to make it clear what happens in that case (even if the behavior is basically exactly the same)\n- the router example should mention the real `router` crate/handler just so people know it exists\n. Thank you!\n. Yeah, it really depends on your machine. I get roughly between 80 and 90, sometimes more. These are just microbenchmarks.\n. Yeah, seems reasonable to me. The stats in the repo are from running the benchmark on my machine:\n\nMacBook Pro (Retina, 15-inch, Mid 2014)\nProcessor 2.8 GHz Intel Core i7\nMemory 16 GB 1600 MHz DDR3\n\nif you want to amend the PR to include that info, I would be happy to merge.\n. Closing due to inactivity, feel free to remake the PR with the requested changes.\n. Looks good to me, thanks!\n. @hellpain can you include the full series of commands you used to get that result (preferably from git clone onwards) so I can try to reproduce it locally?\n. I can reproduce as well, though my perf is more like 8k req/sec. I think this is likely due to hyper turning off keep-alive by default, which would substantially degrade performance in a benchmark like wrk.\n\nIron could turn keep-alive back on by default to solve this problem, improving perf in benchmarks but bringing back the demons of https://github.com/hyperium/hyper/issues/368.\n. I believe this is basically fixed by turning hyper keep alive back on by default.\n. @TyOverby this is probably because router also depends on iron and likely doesn't set default-features = false in its own Cargo.toml. \n\nUnrelated, but note that iron re-exports typemap as iron::typemap, so you shouldn't need to depend on it directly.\n. @TyOverby router should be updated to set default-features = false for its dependency on iron.\n. You probably meant to return `&mut Chain`, not `&Chain`. The calls cannot actually be chained on a `&Chain`, which is immutable.\n. This seems like a pure win to me, it isn't even too bad of a breaking change.\n. Can you squash and I will merge?\n. Awesome!\n. This has a conflict with the last PR you made, which I just merged. I am hesitant to land this immediately as it is a breaking change. Could you instead make a new function link_around, and we can remove the old around function later?\n. Given that we plan to deprecate around, the real implementation should live int he body of link_around and be called from around, rather than the other way around.\n. Not currently. We will likely get `#[deprecated]` back in the near future though.\n. Merged anyway, we can deal with removing `around` when the time comes.\n. Can you add a short note to the docs that these macros are experimental? Otherwise LGTM.\n. I'm not totally sure how to feel about the different modifiers, but I think if we are going to go that way we should include a note in the docs with the suggested use cases. I think it would be fine to merge the macros themselves as is now, we can always iterate on them if they aren't as convenient as imagined for real use cases.\n. I like `iexpect`.\n. Thanks, missed this.\n. Huh, well this is neat. I wonder who requested this for us?\n. Yes, I will attempt to do a release in the coming days bumping the version of hyper used to the 0.7 series, which should resolve this issue.\n. 0.2.5 with hyper 0.7 released!\n. Yes, I agree making ssl opt-in is the right move here.\n. Remove the default feature should be all that is needed (except, as @untitaker mentioned, removing unnecessary `default-features = false` in reverse dependencies).\n. Hmm, I think I know what's going on. Try replacing the final lines with:\n\n``` rust\nlet mut result = vec![0; b\"Hello World!\".len()];\nresponse_body.write(&mut *result).unwrap();\n\nassert_eq!(result, b\"Hello, world!\");\n```\n\nI think the impl of io::Write for Vec might not be doing what we want.\n. Oh man, sorry, total red herring. The real problem is just that `ResponseBody` is an `io::Write`, and calling `write` on it is for _adding_ data to it, not reading it out.\n\nThe appropriate thing to do is something like this:\n\n``` rust\nfn hello_world_handler(_: &mut Request) -> IronResult<Response> {\n    Ok(Response::with((iron::status::Ok, \"Hello, world!\")))\n}\n\nfn main() {\n    let data = Cursor::new(Vec::new());\n    let mut stream = MockStream::new(data);\n    let mut reader = BufReader::new(&mut stream as &mut NetworkStream);\n    let mut req = request::new(method::Get,\n                               Url::parse(\"http://localhost:3000/users\").unwrap(),\n                               &mut reader);\n\n    let response = hello_world_handler(&mut req).unwrap();\n\n    // Create an io::Write we can write into.\n    let mut result = Vec::new();\n    { // We need this block so we can access result later.\n        // Give ResponseBody the Vec as a target to write to.\n        let mut response_body = ResponseBody::new(&mut result);\n        // Write from the response body -> ResponseBody -> Vec\n        response.body.unwrap().write_body(&mut response_body).ok();\n    }\n\n    // Read the contents of the Vec\n    assert_eq!(result, b\"Hello, world!\");\n}\n```\n. No problem :)\n. Superseded by #431 which re-exports all of the iron module.\n. Thanks!\n. @untitaker from my position I think the most important reason to transition the license is to allow code from these libraries to be used in the std library or other parts of the rust distribution, which are all dual licensed MIT/Apache-2.0. That said, I do agree that relicensing or not is unlikely to have a strong effect on adoption in the ecosystem.\n\nI'm for it if we can amass all the necessary relicensing waivers.\n. Thanks!\n. @wubin1989 openssl v0.7.5 is referring to version 0.7.5 of rust-openssl, see https://github.com/sfackler/rust-openssl not the version of openssl itself.\n. Thanks!\n. Closing because stale, but please feel free to make a new PR with updated code!\n. BodyReader needs a public constructor, since its field is private. Otherwise LGTM.\n. Err, my bad, for some reason I thought the field was private.\n. Merged. I will make a new release later today when I have the time to also update extensions to point at the new release.\n. Anyone else with release powers feel free to do the same - just ensure that you release 0.3 and update extensions to it.\n. I agree with @untitaker, closing for now but feel free to make a new PR any time with the new plan.\n. Can we add back a note somewhere that you can write your own modifiers? This is a big reason for their use.\n. Yes, by default this is true, but you can configure the size of the thread pool using the `Iron::listen_with` method.\n. Yup, seems reasonable, this is also an easy task, so marking with easy so someone new has the opportunity to fix it.\n. So thinking about this more, the ideal situation is:\n- we have an in-memory buffer for reading data from the socket\n- we read into this buffer whenever a chunk is available until it is full\n- user code can drain from this buffer asynchronously\n- when the buffer is full we stop reading from the socket until the user code has drained some data, then we resume (the logic here is a bit tricky, but it should work)\n\nThis way we don't have to deal with an ever-expanding in-memory buffer or resorting to a disk buffer.\n\nIn terms of how we actually expose this to the user, something like a specialized `eventual` Stream would probably be the best way to go without going full coroutines, which could also work.\n. In terms of how I'm thinking to land something like this: I'd like to do one more release of iron that will be the final release based off of sync hyper and that exposes a sync interface, then start another release for the asynchronous version. We can then maintain the synchronous version for some time before deprecating it.\n. @bluss, could you change this to instead still deny missing docs on test? My intention is to force travis to fail if anything is undocumented.\n. I need to catch up on upstream `url` changes to know if we could just hold on to `url::Url` directly, but if it is possible then I would love to do it.\n. Lets move all further discussion to #453, which is a superset of this PR (and hopefully can land soon!)\n. Just gave this a more thorough read, and it looks fantastic! Thank you very much for making this change, it's something I've wanted to do for a long time.\n\nThere's only one major thing I think we should change: many of the methods return owned types (`String`, `Vec<String>`, etc.) by internally calling cloning methods when we could just return the borrowed variant. Wherever possible, I would like to avoid adding any allocations by just returning the borrowed type instead.\n\nI think the only remaining refactor would be substituting String for a proper error type, but that can be left for another PR.\n. thanks!\n. Yes! It should actually be something like:\n\n``` rust\nlet _server = Iron::new(hello_world).http(\"localhost:3000\").unwrap();\nprintln!(\"On 3000\");\n```\n\nwhich would actually wait until the server is listening to print that it is listening. The problem with the current example is that the server guard is dropped immediately, instead of saved.\n. Closing in favor of #446 \n. @adrianbrink this `Handler` is the _iron_ `Handler` trait, not the hyper one. It's defined here https://github.com/iron/iron/blob/16c858ec2901e2992fe5e529780f59fa8ed12903/src/middleware/mod.rs#L57-L61.\n. @untitaker so awkward situation but I appear to have lost the password for iron-bot, I'll keep looking into it and update you\n. Better yet just moved the repo over to https://github.com/iron/build-doc\n. Can you update `.travis.yml` to use this?\n. Ideally, we'd have a way to specify the build command also, but at that point we're basically creating a simple package manager - which is pretty out of scope. I think this should be as extensible as necessary to make getting started with Iron as simple as:\n\n``` bash\ngit clone iron/iron\n./configure\nmake\n```\n\nbut we shouldn't spend _too_ much time on it. V2.0 will definitely use Cargo, assuming it's ready by then.\n. Update: anymap is a great example of this. We want to manage that dependency using this script, but it's build command is just `make`.\n. Can you edit the travis command also, so we don't have to do that in a separate branch and we can remove the redundancy?\n\nUPDATE: The travis failure for this PR is because of changes in rust-nightly, specifically removing ~[T] from the language completely, so sort of don't worry about it.\n. Could you squash these commits or just remove the first one? Considering this pull is actually to delete the paragraph it doesn't make sense to include it.\n. We will doc this explicitly later.\n. Actually, on second thought, can you close this PR and make a new one to a doc/ingot branch on iron itself, so we can both work on this? I have lots to add to the Ingot explanation.\n. We should write a tool to automate this.\n. I agree. If someone wanted to become a `sed` guru that would be cool but otherwise I think we might need something a bit more powerful (I'm thinking lo-dash template and gulp).\n. This is more trouble than it's worth. Closing.\n. Awesome.\n. Fixed in #13 \n. Is it also possible to break out the change to `listen` and the `Iron` struct itself into a different PR?\n. @zzmp Merging this now because you aren't here to make the PR.\n. Can you make this change in all those places?\n. Well, the lifetime we are transmuting to is definitely `'static`, which is certainly longer than the lifetime that it has. However we lose access to the pointer at the same time that the destructor of the underlying memory is destroyed, so everything is fine.\n\n+1 to close, for now at least.\n. Tagged as wontfix.\n. Fixed :)\n. Make doc pull requests to doc/doc-all, which will then be pull requested into master.\n. Done.\n. Can you rebase this against doc/doc-all?\n. I'm calling this low priority for now. There is basically no competition in that space and we have already dedicated to move to Teepee later. This refactor should probably happen during that wave of breaking changes.\n. Closing this as we have moved to structs for Request and Response.\n. Rebase time!\n. I'm not convinced yet that this needs to be in core. I think this belongs in an \"iron-common\" style repo that offers Iron bundled with many common middleware and trait extensions.\n. It is possible to extend Response outside of core - this functionality could be implemented outside of Iron. I think that is where it belongs. The majority of users would then use Iron-Common, which would come bundled with this and other functionality.\n\nSee: https://github.com/koajs/koala\n. I'm willing to bend on this. Can you rename send to send_file?\n. Can you rebase this in a way that it can be merged without #49? I'd like to make this change, but I'm not convinced on the value of #49 yet.\n. Commit 3db02ac should probably be prefixed (fix) not (feat)\n. It's unlikely that mount can use this, but I will definitely make this change as part of my refactor of Router.\n. If you come up with more utility methods, I can refactor to a more common trait name and add more heavy-use-case methods.\n. I like. I'll implement that refactor.\n. @zzmp I disagree. I think that makes the common use case (sending a status code + body) more annoying for the uncommon case which might as well just be `res.write(data.as_bytes())`. We'd be creating a function that saves a single method call.\n. Done.\n. It should be after I refactor Router.\n. Merge?\n. This is now the canonical way to implement simple, throwaway middleware. I\u2019ll include a response-time example that uses a multi-directional middleware.\n. Closing for now in favor of a refactor to Chain.\n. I hadn't considered the need to `use iron::Chain`. That makes me less happy about this. Any thoughts from the rest of @iron/dev-team?\n. @theptrk That's a good point I didn't consider. I'm saying this is accepted in lieu of merging it, just to give all existing PRs in middleware a day to get sorted out.\n\nI'll merge this before I leave tonight and we can fix it as part of our daily \"fix what broke yesterday\" sprint.\n. This is now out of the scope of this repo, since the code generation moved to a different repo in #111 \n. This is a BREAKING CHANGE because all other ./configure installs of Iron will immediately stop working. I will be making PRs to all middleware to add Cargo to them soon after I get this working.\n. @zzmp Merge?\n. Can you swap ResponseTime for Hello World, or something else at least slightly non-trivial? It's pretty boring to see a really simple Hello World for this.\n. It's unnecessary to have both _..._ in the example AND have a 'abbreviated for clarity' note.\n. @zzmp Hello World -> ResponseTime and I'll merge.\n. Especially with the current fn Clone madness.\n. This is a serious problem. We have a _lot_ of existing code that relies on fn's being Cloneable.\n. This seems outside of our ability to fix.\n\nI'm going to create a FromFn struct, which would be usable like so: \n`server.chain.link(FromFn::new(hello_world_fn))`\n. Putting it in `iron::middleware::FromFn`\n. We aren't sure. We think it's a bug with trait detection related to some new logic in the compiler for type checking traits.\n\nFromFn is intentionally bare-bones so it can be easily deleted when this gets resolved.\n. @zzmp it's impossible right now because if you have a generic impl for a trait you can't have any other impls for that trait, which is a known issue.\n\nBasically, if you had `impl<T: Copy> Clone for T { fn clone(&self) -> T { *self } }` then you couldn't `impl Clone` for any type that _wasn't already Copy_ which is basically the entire point.\n\nThis is also why we have `impl Middleware for Box<Chain>` instead of `impl<C: Chain> Middleware for C`.\n. We are just going with wrk.\n. @cburgdorf As long as we are still doing codegen, I'd like to keep it behind a strong veil, however @zzmp wrote most of the file-serving logic, so I'll let him make the call.\n. There are actually no more of these, so closing.\n. @mavdi @zzmp I'm merging this because I need the change to debug other issues re: cargo and travis and it's a clear win.\n. Yes, unfortunately once you have written to the body you can no longer write any headers. Until we get around to creating our own abstraction layer over rust-http's Request objects or switch to a new backend this isn't something we can support. :/\n. We should really have some sort of error mechanism for detecting this case and warning you, so that it doesn't just silently fail.\n. @emk This is a really good point. I'll be adding this feature later today.\n. A quick examination leads me to believe that this might be a bit harder than I thought. How do I tell if no middleware has handled a request? In Express it's as easy as \"did a request make it all the way through the stack\" but in Iron, which allows bidirectional middleware, it's unclear what the condition is for modifying a request and setting it to be a 404 is.\n. That seems like a reasonable approach. \n\nI think there might be a bit of refactoring to be done regarding the control flow around Middleware. Right now it's impossible to distinguish between `Unwind` as in \"I'm done, so don't continue\" and `Unwind` as in \"there is an error, so don't continue.\"\n\nWe were discussing adding a third variant to the `Status` enum of `Error(Box<Show>)` or something similar that would call a separate handler than `Unwind`. I think I might take a crack at it later today and see if I can make the entire scheme more convenient.\n. This problem is in fact very easy to solve! Middleware just aren't shared. Instead, the chain is cloned for each request and on a new thread, meaning that there are in fact two different instances of ResponseTime for the two different requests, solving this problem nicely.\n\nThis is slightly inefficient, but we think it presents a very nice-looking API and hasn't been a source of performance problems for us.\n. Thanks for this list @killercup. Fixed via several PRs.\n. @cengizIO unfortunately `ab` is a bit weird, I got these numbers benchmarking using `wrk`. Weirdness surrounding benchmarking is on our todo list. Some kind of script would probably be the best way to do it.\n. @cengizIO This is awesome. Thanks!\n. @cengizIO You're killing it. Thanks.\n. @zzmp @theptrk @mcreinhard Is this something we definitely want?\n. We already have an explicit dependency through our use of serve_forever in listen. This is nothing new.Thanks,\n         Jonathan Reem\n\nOn Thu, Jul 24, 2014 at 1:48 PM, Zach Pomerantz notifications@github.com\nwrote:\n\n> This relies explicitly on the `rust-http` implementation, specifically, https://github.com/chris-morgan/rust-http/blob/master/src/http/server/mod.rs#L56\n> \n> ## @reem, I'm fine merging this, but could you make note of the explicit dependency in a comment so that we don't lose track of it?\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/pull/108#issuecomment-50075900\n. @zzmp Yes, we are still slightly dependent, but users of our library are no longer exposed to that. Merge?\n. @zzmp Actually, specifically regarding files, this new scheme is significantly more memory efficient as it doesn't read the entire file into memory except to send it to the client in write_back. serve_file only creates a reader for that file, it doesn't actually read it.\n\nIt very rarely makes sense to crudely concatenate multiple chunks of data in different controllers. There's almost no time that makes sense and if it did (which I bet is extremely rarely) you can just store a Reader/Writer in alloy and replace body with it later.\n. @zzmp Updates and fixes.\n. @zzmp Updated. 404 logic will be changed in the Response PR.\n. This is pretty much what I had in mind. It would probably be best to wait for rust-http to stop using liburl and then use the servo url object instead. I'd also love it if it was https compatible, but that may be asking a little much until we have a better base than rust-http.\n. @michaelsproul Now that rust-http uses the new rust-url (great job!) we can probably update this to use it too.\n. @michaelsproul It's been fixed.\n. @michaelsproul This is pretty awesome. Can you do me a favor and update the doc-comment for the url field to just specify a few common access fields and/or tell users where they can find more info on that struct.\n. This is fantastic! Where would you like to me to put feedback? (Here, Github issues, etc.)\n\nThere isn't a great place for us to have a repository of middleware right now, but in the near future (hopefully) Cargo will have a central repository and we can just tag things iron-middleware or something along those lines.\n\nYou can _usually_ find me on the #iron irc channel.\n. #119 Implements this change, and I'll merge it later.\n. Closed via. #119 \n. @michaelsproul Feel free! That'd be awesome. I'm going to merge in #119 and start fixing middleware later today (soon).\n. @michaelsproul Thanks.\n. This is awesome. Thanks.\n. This is tricky, because we'd like the method to be implemented on `Response` but access some form of app-global configuration - you'd set up the templating by adding a Middleware with some options on it like the templating engine and template directories, but I'm not sure how that information gets to res.render.\n\nThis are good thoughts to be having, but I'm not sure what the answer is.\n. I think it's cleaner to just provide a `Templating` trait that any template engine could implement, then you provide an instance of that trait to the templating middleware and it uses that for `res.render`. My main concern is that `res.render` would have no access to the `Alloy` and therefore no access to any configuration.\n\nThis is solvable by placing a second `Alloy` in Response, but I'm not sure if that's the way to go. I think there is a better, more general way to do app-wide configuration than this, but I'm not sure how yet.\n\nMaybe the best way would be to add a global-configuration Alloy on each _Iron_ instance - then provide a &-reference to the app in both request and response? This is fast but also quite convenient, and could in fact be made memory efficient by storing the global Alloy behind an Arc, so it is not cloned for each request.\n. I'm only concerned that adding a reference to the app in `Request` and `Response` makes testing trickier - right now I've managed to create a small mocking library for `Request` and `Response` that does not have to resort to unsafe anywhere (https://github.com/reem/iron-test) but an app reference may make that trickier.\n. There's way too much of `std::mem::unitialized` in our tests right now, so that would be great to fix.\n\nI'd _really_ rather not fall back to an environment variable. Maybe, instead of a global persistent reference to Iron, we could just have a global persistent reference to some sort of global preferences object that only coincidentally happens to be stored on `Iron`.\n\nI think that we'll find, however, that there may be a need for a general-purpose Alloy-like structure on Response.\n. I think there needs to be a dedicated way to immutably access shared global configuration. More thoughts to come.\n. I think the solution is to include a `config: Arc<AnyMap>` in both Request and Response. This allows easy global configuration and is pretty easy to mock in tests.\n. I think providing access to config in both places is perfectly fine.\n. The configuration problem is mostly solved through the `Read` variant in `Persistent` and the interface it exposes.\n. You can definitely do this with a syntax extension, or even without one if you are willing to lose a bit of expressiveness. However, I think that's probably the domain of a templating engine, not this middleware.\n. @aochagavia They have done much of the work that we'd like to do, but I'd much rather be templating engine agnostic and support a richer interface - notably nickels `.render` only allows `HashMap<&'static str, &'static str>` which means that you can't render a template with dynamic data, like from a database.\n. Agreed. There could be some really cool work to be done in making a crazy syntax extensions for creating templates.\n. @allan-simon I also just recently started learning about syntax extensions. If you want an example of a (hopefully) well written one: https://github.com/reem/stainless \n. @allan-simon I think it would probably be best to adopt an existing templating standard and possibly just make changes to it, rather than starting from scratch.\n\nThe most ideal situation is that I can create `static` or `const` templates which are aware of the types they must be passed to be rendered, then I can get nice type errors if I try to pass incompatible things as the pieces of the template.\n. Just a note, but its Yehuda Katz, aka wycats. :)\n. Possibly obsoleted by better ideas, but not sure yet.\n. @SuprDewd this is good work. We need to make lots of changes in this vein, to make Iron more robust, friendlier, and actually usable for a real application server.\n. A struct that looks like this would probably do it:\n\n``` rust\nstruct Url<'a> {\n   port: u32,\n   username: Option<&'a str>,\n   password: Option<&'a str>,\n   host: url::Host,\n   path: &'a [String],\n   query: Option<&'a str>,\n   fragment: Option<&'a str>\n}\n```\n\nOr maybe...\n\n``` rust\nstruct Url {\n   port: u32,\n   username: Option<String>,\n   password: Option<String>,\n   host: url::Host,\n   path: Vec<String>,\n   query: HashMap<String, String>,\n   fragment: Option<String>\n}\n```\n. Plugins of that kind are very in flux right now. I was talking to @wycats today about a whole new scheme for lazily-computed plugins.\n\nThe advantage of fields over methods is there is no `url.path_mut()` and `url.path()` annoyance.\n. The problem with representing things as enums is that they you often end up exposing to your users situations where they have to match to get at the contents of the enum even if you are 100% sure that only one variant is valid. Always-Some Options are just one tiny instance of this. \n\nI'd much rather have a NonRelativeSchemeUrl than an enum, one of whose variants is a NonRelativeSchemeUrl.\n. That seems like a reasonable approach. If you want to take a stab at implementing this I'd be glad to code review. I'm a tiny bit swamped right now with other refactors, so I can't take it on fully right now.\n. It would be nice if we could implement show - it makes lots of things nicer, but, don't worry about it for now, just get something up and running and we will see if we need it later.\n. I'd rather rename rust-url, as that is never exported/exposed in any way.\n. Otherwise this looks really solid. I much prefer this as an abstraction to what we had earlier. Thanks again for your continued work on Iron, as you can see it really makes a difference.\n. I was going to do it, but if you want to, go ahead! I have some time today, so I'm going to sit down and refactor router to be better.\n. @iron/dev-team @brycefisher @michaelsproul Can I get any of your thoughts on this? Does this seem like a good idea? What problems still need to be solved?\n. The primary advantage over just adding traits is that this guarantees a consistent API and prevents people from having to implement and re-implement the functionality of `get` and `get_ref`.\n\nBasically:\n\n``` rust\nstruct Request {\n  body: String\n  extensions: AnyMap\n}\n\nimpl Extensible for Request { etc. }\n\n// Stupid example.\nstruct BodyLength { len: uint }\n\n// Implementation is much simpler, you only deal with construction.\nimpl PluginFor<Request> for BodyLength {\n  fn construct(req: &Request) -> BodyLength {\n    BodyLength { len: req.len() }\n  }\n}\n\n// Usage site\n// Safe, namespaced, typesafe, guaranteed interface\nlet body_length = req.get::<BodyLength>();\n\n// Middleware alternative:\n\nstruct BodyLength { len: uint };\n\nimpl Middleware for BodyLength {\n  fn enter(req: &Request) -> Result<(), Box<Show>> {\n    req.extensions.insert(BodyLength { req.len() });\n    Ok(());\n  }\n}\n\ntrait BodyLength { fn body_length(&self) -> uint }\n\nimpl BodyLength for Request {\n  fn body_length(&self) -> uint {\n    self.extensions.find::<BodyLength>().unwrap().len\n  }\n}\n\n// Insert into server in the correct order! (error prone/not-safe)\nserver.whatever(BodyLength)\n\n// Usage site \n// Additional problem here is that there's no requirement to expose & and an &mut vs.\n// by value etc. Every middleware has its own naming convention and methods easily\n// will clash name-spaces.\nlet body_length = req.body_length()\n```\n\nThis does not obsolete the need for Mixins as an approach - templating still needs `Response::render` but it removes the need to duplicate this basic API - this is very nice for a large variety of things and can still be used internally by Mixins which expose other things. The major idea is it is automatically correctly lazy, correctly order-independent, and correctly matching with best style.\n\nThis additionally does not solve the configuration problem, which is still looking for a rock-solid solution.\n. There is no method overloading. You could just have a `get_unconditional` method, but then you also need `get_unconditional_ref` and `get_unconditonal_mut` method... I think it's best to just force people to deal with the failure.\n\nA real implementation would probably use `Result` instead of `Option`, once we decide on a standard Error type I can refactor rust-plugin to be generic in the error type and then we can just re-export as `RequestPlugin` and `ResponsePlugin`.\n. I'm currently implementing a trie-based router. I'm opening a separate issue for discussion of an Iron-universal error type, which is a blocker for this to be actually implemented.\n. I'm attempting this right now using https://github.com/reem/rust-error, which I believe meets all of our criteria.\n\nIt is:\n- Generic\n- Recoverable\n- Convertible\n- Extensible\n\nand most importantly it allows third-party errors to get the same treatment as first-part ones, which is critically important.\n. I've made further refactors to rust-error and will be rolling this change into a huge PR in the near future.\n. Here's an outline of my thought process on this: https://medium.com/@jreem/what-should-you-get-from-an-error-6704dbdc4895\n. Done.\n. Oops. I accidentally rolled this in to #136 \n\nAnyway, #136 needs this change so I'll just leave it in that PR.\n. Actually, this just implements the change suggested in #135, as that is a pre-requisite for this change.\n\nThis PR also deprecates Alloy as an alias, but should not break any existing code yet. (Just introduce deprecation warnings).\n. @iron/dev-team @michaelsproul @brycefisher If you guys want to look this over, go ahead. I'll merge tomorrow barring any resistance, but this seems like a straightforward change to me.\n. This has been partly addressed by `iron/params`.\n. With a test too. Fantastic.\n. @brycefisher I believe this is useful for you.\n. Oops. Thanks for catching this.\n. This should be \"Compile common\" so no, because several middleware still do not compile.\n. @ProtectedMode I agree completely. Recently it's been a challenge to keep just Iron itself compiling, but now that things are calming down a bit I think we get back to stability (and getting everything compiling).\n. This issue is pointless and outdated, obviously we want things to compile, but there is no need to track everything here.\n. Can you update the Cargo.toml to be the updated upstreams?\n. The field and method won't clash, especially as first-class-methods are not supported yet, so we should have both so users don't have to use Extensible to get access to extensions.\n\nFor similar reasons we should re-export typemap.\n. That's cool. We don't need to export Assoc - if you're making a Plugin you need it but then you should just be depending on rust-plugin directly.\n. Nice. Good job with this.\n. An AroundMiddleware either calls the internal handler to get a response and modifies it or creates its own response, if you ignore the return value of the internal handler... that's just your problem.\n. @iron/contributors @iron/dev-team Anyone else have comments?\n. @zzmp Bump. I added an overview of Middleware. Probably needs heavy editing.\n. @brycefisher fixed all your catches\n\n@michaelsproul renamed to AroundMiddleware::with_handler and clarified in the docs for it. Does this clear up your concern?\n\nBarring any further questions, I will be merging this, publishing my blog post, and beginning to fix and refactor middleware tomorrow.\n. Candidate: https://github.com/duelinmarkers/todo-backend-rust-iron\n. That sounds like a really good skeleton. Do you have any ideas for the content of something like that?\n. @duelinmarkers I saw your `After` struct for generating `AfterMiddleware` from bare functions and thought that `AfterMiddleware` should just be impled for bare functions in iron itself.\n. I considered this when creating the trait and I haven't settled on a better way. Primarily, the problem is that you'd like to be able to construct the AroundMiddleware however it is supposed to be constructed (it's constructor might take many arguments, for instance) but you do not have access to the handler at construction time.\n\nThe alternative is to have `AroundMiddleware::from_handler` and rely on `persistent::Read` for all configuration. I don't love this approach, because it means that we will have to use `Read` _a lot_, and it is already used for configuring Plugins.\n. Hmm, I do use one of those internally to implement `ChainBuilder::around` safely, but I think it's probably best to instead change the `AroundMiddleware` trait to look more like this:\n\n``` rust\npub trait AroundMiddleware {\n    fn from_handler<H>(self, H) -> Box<Handler + Send + Sync> where H: Handler;\n}\n```\n\nNotice that the `: Handler` bound on AroundMiddleware itself is gone, `from_handler` now takes `self` (so might want to be renamed) and produces a _new_ Handler, which could be made from self or could be a different type completely. \n\nI think this makes AroundMiddleware significantly more ergonomic to use, even if their implementation is a bit weird. It also makes them usable outside of a Chain. For instance, we could do something like:\n\n``` rust\nIron::new(Logger::new().from_handler(whatever))\n```\n\nDirectly, to avoid issues with \"you must link first and last\" etc.\n. ``` rust\npub trait AroundMiddleware {\n    fn around<H>(self, H) -> Box<Handler + Send + Sync> where H: Handler;\n}\n\npub struct Logger { format: String }\n\nimpl Logger {\n    // All initialization and configuration logic goes here.\n    // If the work done by this is particularly complex, you can put functionality here\n    // and call it through LoggerHandler::logger or equivalent.\n}\n\n// Private, as nobody interacts with this except through a trait object.\nstruct LoggerHandler<H> { logger: Logger, handler: H; }\n\nimpl AroundMiddleware for Logger {\n   // Takes self by-value, so it's also clearer that this is only called once.\n   fn around<H>(self, handler: H) -> Box<Handler + Send + Sync> where H: Handler {\n     // Unfortunately have to add another level of indirection here until we get unboxed abstract return types \n     box LoggerHandler { \n          logger: self,\n          handler: handler\n      } as Box<Handler + Send + Sync>\n   }\n}\n\nimpl Handler for LoggerHandler {\n   fn call(&self, req: &mut Request) -> IronResult<Response> {\n       let entry = time::precise_time_ns();\n       let res = self.handler.call(req);\n       // This logic would probably be in Logger, but is here for simplicity.\n       println!(\"{}, took: {}\", self.logger.format, time::precise_time_ns() - entry);\n       res\n   }\n}\n\n// Use it\nfn main() { Iron::new(Logger::new().around(my_handler)).listen(Ipv4Addr(127, 0, 0, 1), 3000); }\n```\n. You can use a NoOp, I even defined and use one in the implementation of `ChainBuilder::around` but I think that this actually represents a much better approach. \n\nEven though it adds a tiny bit of code to the implementation of an AroundMiddleware, it makes their use significantly more ergonomic - especially because you can easily use them without a Chain for things like Logger.\n\nI'm going to make a version of this in a branch and we'll see how it goes. I'll write up a few examples to see how this compares to the old system and which is better in both implementation and usage.\n\nIf we do go with the current approach, we should definitely expose a NoOp Handler that just returns 200 OK\n. Looks great. I'd love if we could lift the IoResult into IronResult so this could be easily used with try! within middleware etc. but that is out of scope for this PR.\n\nI think `serve` can also be removed, will file.\n. Hmmm.. Restarted travis, appears fixed. Thanks for looking into it. I probably would've given up long before reaching out to travis support.\n. `let x: Option<Status> = FromPrimitive::from_u16(200);`\n\nThe method is on the `FromPrimitive` trait, not on the Status struct. I was under the impression this enables `as` conversions, but I guess not.\n. As with the removal of `Response::serve` this change is in line with the new method of working with Responses, i.e. that Response is created in a Handler just once, and future AfterMiddleware have rights to modify, but usually should not replace, an existing Response.\n\nDefaultErrors should probably either re-implement the logic in `from_file`, which is ugly I know (but at least it's just 3 or 4 lines), or get the body out of a fake Response generated with `from_file`. I regret that it is unergonomic, but I think it is ok for it to be this way as most AfterMiddleware should not be replacing the Response wholesale, just doing postprocressing.\n\nDefaultErrors seems like an exception to the rule, so is unfortunately not as easy to create. There might be merit to a less opinionated method, but it seems that it is simple enough to implement in any crate which absolutely needs it and might not be something we want to encourage.\n. Repeatedly returning `Err(UnitializedHandler)` is basically the same as repeated `Option::unwrap` just with a tiny bit more reporting.\n\nWe should either fail fast by actually `fail!`ing or we should provide an infallible mechanism for creating handlers, which this provides. In this system, badly initialized handlers fail once and immediately before the server even starts running, which is _much_ better than repeated crashes on incoming requests.\n\nPersonally, I much prefer the infallible systems and avoiding `fail!` when possible, hence this PR.\n. This could actually be made much simpler to work with with the impl of Handler for `|&:` closures, since you can just return one instead of creating a new type specifically for your Handler, given that impl, the example from the other thread would just be:\n\n``` rust\npub struct Logger { format: String }\n\nimpl Logger {\n    // All initialization and configuration logic goes here.\n    // If the work done by this is particularly complex, you can put functionality here\n    // and call it through LoggerHandler::logger or equivalent.\n}\n\nimpl AroundMiddleware for Logger {\n   // Takes self by-value, so it's also clearer that this is only called once.\n   fn around<H>(self, handler: H) -> Box<Handler + Send + Sync> where H: Handler {\n       // Theoretically using an impl of F: Fn Handler for F. Right now requires double box :/\n       box() ( |&: _| {       \n           let entry = time::precise_time_ns();\n           let res = self.handler.call(req);\n           // This logic would probably be in Logger, but is here for simplicity.\n           println!(\"{}, took: {}\", self.logger.format, time::precise_time_ns() - entry);\n           res\n       }) as Box<Handler + Send + Sync>\n   }\n}\n\n// Use it\nfn main() { Iron::new(Logger::new().around(my_handler)).listen(Ipv4Addr(127, 0, 0, 1), 3000); }\n```\n\nThis PR also has the advantage of making us able to implement AroundMiddleware for `|:` closures.\n. Keep in mind that this is relying on several yet-to-be-implemented features in rust, mainly multidispatch and higher-ranked lifetimes, and assuming they iron out the many bugs in unboxed closures. Until then you will have to define a 2nd struct or deal with writing:\n\n``` rust\nbox() \n    (box() (|&: _| closure body) \n     as Box<Fn<(&mut Request,), IronResult<Response>> + Send + Sync>)\nas Box<Handler + Send + Sync>\n```\n\nbecause we can only implement Handler for Box<Fn<..>> instead of F: Fn<..>\n. I am feverishly awaiting those so I can make our Hello World just:\n\n```\nIron::new(|&: _| Ok(Response::with(status::Ok, \"Hello World!\"))).listen(Ipv4Addr(127, 0, 0, 1), 3000)\n```\n\nAlas, not yet :(\n. I think the consensus is that this is a good thing. I'm going to merge this when travis passes.\n. Should do this for Before, After, and Around Middleware, and add alternative impls for catch variants of all three and Handler. Should make working with Iron waaaay better.\n. There are ICE's everywhere when trying to actually use this in examples -.-. I'll keep working at this in a branch, but there are many things that need to change in rust before this is nice, working, and ergonomic.\n. Closing for now. Will revisit in a bit when unboxed closures stabilize and we get multidispatch.\n. Fails due to rust-http build failures, but compiles when using my fork, which compiles in the temp branch.\n. That sounds like a good workflow. This depends on whether you are creating a test for BeforeMiddleware, AroundMiddleware, Handlers, or AfterMiddleware.\n\nIn lieu of better docs (I'm working on it, promise :)) the general strategy I would take for each is:\n\nFor all: use https://github.com/reem/iron-test to mock Request and Response.\n\nBefore: Create a Request, pass in an &mut reference to it, check if it has the state you want afterwards.\n\nHandlers: Create a Request, pass in an &mut reference to it, check if the Response looks the way you want.\n\nAfter: Create a Request and Response, pass in &mut references to both of them, check if they have the state you want afterwards.\n\nAround: Create a mock Handler, create a Request, initialize the AroundMiddleware, then do the same thing as for testing handlers.\n\nI'll keep this issue open as there should really be better docs/examples surrounding this. (middleware in the iron org should also be tested much more than they are now).\n. 1. Gives us more control over concurrency strategy\n2. Faster\n3. Better representations of Request and Response, including a much better header representation\n4. Less painful to implement for, as it is designed much more deliberately.\n5. Exposes a safe streaming response abstraction\n   etc.\n. I do to. Chris Morgan is very smart, but he's also very busy. Hyper is a sort of splinter-project from Teepeee. seanmonstar started it because he wanted to move a bit faster and I've been contributing recently to make it even better.\n. Fixed through #173 \n\nThanks for reporting.\n. Haha I had already made the PR 40 minutes ago, was just waiting for travis :).\n. Oooh, linker errors, my favorite :P\n\nUnfortunately, I can't really help you anymore than saying it looks like you don't have a dependency of some kind, or your library path is not set right, or.. it could be a lot of things. I don't think it's a problem with Iron itself, because it builds fine on my machine. Are you sure you have the dependencies that it is looking for?\n. I believe they are the same. Try setting `LD_LIBRARY_PATH=LD_LIBRARY_PATH=/usr/local/lib:/usr/local/lib/rustlib/x86_64-unknown-linux-gnu/lib/`\n. Weird... Can you reach out on the IRC? I don't really know what else to tell you, sorry :/\n. That might be worth having on the rust-http README as well. If you want to make a PR to either/both, I would merge :)\n. Linking to rust-openssl would probably be best, both here and in rust-http.\n. This can be mostly accomplished through the use of https://github.com/reem/watch and a small custom bash script which does the steps above.\n\nI'll try to put something together tomorrow that does at least some of this.\n. A workaround for this is to just use `cargo run` and write mounting paths and such so that they are relative to the place where the executable is run from.\n. Thanks for this fix. Weird that this was not turned on before.\n. I'm getting insanely weird errors trying to make this compile - adding these re-exports explodes random things.\n. I used a different fix in #181 to do the same thing. Thanks for contributing!\n. Apparently building with `--release` on the same machine led to over _95k_ requests per second. I'm flabbergasted at those results and am very curious if we can repeat that anywhere else.\n. Makes sense, that is likely to be most of the overhead of making any request.\n. I'm going to close this, it's good to have but there's not really an action item.\n. You need to update your rust, the syntax for unboxed closures was recently changed. Pinning versions doesn't help right now since rust changes in ways that make versioning slightly useless.\n. This issue is showing up on travis too, but I don't know what's going on or how to fix it, unfortunately.\n\nI'll update this issue if I make any progress fixing this.\n. Fixed!\n. Fixes one issue. Still fails with a linker error in cargo test.\n. Ugh, I'm having a hard time fixing this since I can't reproduce on my machine. `cargo build && cargo test` runs without error for me...\n. Hmm.. The source of this error seems to be rust-http-content-type, specifically it's generator. Will investigate further.\n. That's alright. I am getting this error now but not sure how to figure it out.\n. Fixed!\n. This is an error in phf_mac, made a pr to fix as https://github.com/sfackler/rust-phf/pulls/18\n. There was a bug, but it is fixed now!\n. Unfortunately this is a bug in one of our dependencies... I'll try and track it down ASAP.\n. @jacek99 Can you try this again with the latest nightly and `cargo update`? This builds fine for me.\n. Oh sorry I misread your earlier comment. Iron core doesn't build right now because some of its dependentcies aren't updated for later iron. In the meantime I suggest pulling iron/iron and grabbing any other middleware you need one by one.\n\nIf they don't work you could open issues in their respective repos and I would try to fix them.\n. @jacek99 I'm closing this issue, but feel free to open others (in fact I encourage you too!).\n. This issue could be made in iron/core, and that recommendation should likely be changed until all the parts are building again.\n. This should probably be tied to the 302 status code.\n. @michaelsproul You're right. That said, I think we should still find a way to tie this to a subset of status codes, since it really only makes semantic sense with those three.\n. On second thought I think we need a general solution to this problem, but I'm not sure what it is. For now, let's just go with any status.\n\nHowever, the second parameter should definitely be changed to accept a `Url`, not an `&str`.\n. This should probably use `iron::Url`, importable through `use {Url}`.\n\n@michaelsproul what do you think?\n. Also, if you're going to make another edit anyway, can you rename the commit to something like:\n\n`(feat) Added a redirect constructor to Response.`\n. That should probably be a method on Iron's Url, but the above works as a stop-gap.\n. @gaudecker Awesome! Thanks for all this work.\n. Looks great.\n. Perfect. Thank you.\n. I'm a little worried about the possible combinatorial explosion of constructors here. Perhaps a series of builder-esque methods would be better, like:\n\n``` rust\nResponse::with(status::Ok, \"whatever\").type(JsonMediaType)\n```\n\nEDIT: ugh type is a keyword, how about `.media`?\n. @plcstpierre It's a bit tricky, because you can't have a builder method that works for both `self` and `&mut self`. In this case, we really want `(self) -> Response`, but for AfterMiddleware `&mut self` would be convenient.\n\nIn this case what you would do is add another method which takes `self`, modifies it, then eventually returns it.\n. @plcstpierre I think a nice API for this on Response would probably be best.\n. @jedahan Agreed. I think our marketing of Iron's features/design could use a little TLC.\n. I implemented part of this in rust-http and tested locally, this improves the performance by Iron by over 80%! I would really like to land this, but alas upstream rust is borked.\n. Actually this works fine on latest Iron and boosts our req/sec up to 84k!\n. I filed an issue in rust-Lang/rust about my frustration there.\n\nOn a separate note, @huonw pointed out that there was a glaring unsafety in set_mut, so I had to change the implementation, meaning this needs some fixes before it is merged.\n. Rebased and updated for latest rust-modifier.\n. Yup. Thanks!\n. This is not in nightly yet, so travis fails, but this is correct.\n. It seems like the best thing would be to implement stuff for Iron here https://github.com/swagger-api/swagger-codegen? Honestly I am not sure as I have never used Swagger.\n. From the discussion it looks like this can be done out of core, so I'm closing.\n\nFeel free to rekindle discussion elsewhere or try to convince me that this needs to go in iron proper and I should reopen.\n. This is very interesting. It looks like there are two panics here, where the second happened during unwinding, causing the whole server to abort whereas panics would usually be enclosed in a single task.\n. Is the source code for your server public? Looking into this, it's likely the initial panic came from use code as opposed to code within Iron. I think I've figured out what's causing this.\n. I am trying to tackle this with a new panic-resistant task pool that I just wrote here: https://github.com/reem/rust-resistant-taskpool but I have to do a lot more testing to find out if it's solid enough for use.\n. Fixed by the new task pool in master.\n. You can always call `MediaType::new` yourself and pass it to the `ContentType` tuple constructor. This is just a convenience method.\n. Ya, `MediaType` also has a `new` method to make this easier.\n. @torhve does this address your concern, or do you think calling `MediaType::new` is too inconvenient?\n. Merging because Cargo is broken but this does work.\n. Same cargo bug.\n. cc #171 #203\n. Major topics to hit:\n- Handlers\n- Middleware System\n- Plugins\n- Modifiers\n- Streaming/Write strategy\n- Headers\n- Testing\n. Unfortunately I never got around to completing this, but I did write one chapter in this repo: https://github.com/iron/byexample\r\n\r\nI agree it is extremely important and I would be extraordinarily grateful if anyone contributes further chapters addressing any of the other topics I listed above.. Unrelated failures because of enum namespacing so merging anyway. Thanks for taking care of this.\n. This needs one hell of a rebase.\n. Awesome! This is failing due to an OpenSSL problem. I'll look into it then merge.\n. Great success!\n. It's green! It's green!\n. Not exactly, but if you assign a Reader to body then it will be streamed in parts.\n. Closing since there's not a huge action item for us here. Feel free to comment if you think there's more to say here.\n. Just fixed in #227!\n. Just merged #231, so should be fixed now. Thanks for the PR anyway.\n. Thanks for the fix.\n. We are thinking about the best way to publish iron middleware on crates, and I'll probably get around to it in the next few days.\n. This is mostly done.\n. Fixed a while back.\n. Should be fixed now, thanks for filing! \n. Ya I've narrowed the issue and am working on a fix.\n. It's because of a misuse of the host header on my part. I am working on a fix.\n. Thanks!\n. There is a slight regression here due to port not being properly used, but that should be fixable separately.\n. This is filed in hyper already as https://github.com/hyperium/hyper/issues/148, it's just a bit of over-eager logging and doesn't mean there is really an error.\n. Try updating your rust version, it works for me.\n. You can pretty easily implement this behavior as a custom Handler, similar to the way Router and Mount work, that wrap many Handlers and add additional behavior. I think this would probably be the best way to go around this.\n\nI actually looked into implementing this sort of handler, but embarrassingly enough I actually deleted the folder by accident since I was sure I had it on github (I didn't).\n. What I mean is that you can write a middleware that is _like_ router or mount, which can take many handlers and do what you want with them (basically all this: https://github.com/rustless/rustless/blob/master/src/middleware.rs#L49-L98) can just go in the implementation of Handler for some type.\n. Closing, unless you have a further action item.\n. This is actually what we used to do internally, but I transitioned away from a regex-based router because it lead to poor performance, a very complex implementation, and several other such problems.\n\nWe could write a custom matcher to match string globs _and_ regexes, but there would be a _huge_ increase in implementation complexity.\n. The current approach is much faster and has a simpler implementation (from Iron's perspective), so I doubt this change will be made. If you have any killer reasons or examples of why regex based routing is needed over our current glob and param matching, I might be convinced, but otherwise closing as wontfix.\n. Usually it's actually fastest to work on the latest versions of dependencies so a version update isn't necessary every time a dependency breaks and pushes a fix (many updates are because of compiler changes, so pinning versions will just get you broken versions).\n\nThis breakage is my fault, since I pushed a new version of error and haven't had time to fix Iron yet - however, I do want to fix Iron ASAP, so will be pushing a fix for error 0.0.3 instead of merging this later tonight.\n. @graue it's possible we could do that. I would love to have less breakage, but there's a lot of additional maintenance burden for me if I have to maintain working `0.0.*` and `0.1.*` versions of all of Iron's dependencies. (There are a lot of packages involved here)\n. It hasn't happened that much, anyway, Iron has been fixed in the meantime.\n. This was fixed a while back, so closing.\n. This gets us compiling again, but doesn't fix the immediate-exit problem, which requires an update to hyper, which I am also working on.\n. Rolled this in another PR that fixes a wide variety of issues. Thanks anyway.\n. When you run `cargo run --release --example hello` cargo ignores the `--release` flag when you set `--example`, which is why you are seeing poor performance. Build iron with `cargo build --release` and then compile `hello.rs` manually using `rustc --opt-level=3 examples/hello.rs -L target/release -L target/release/deps -C lto --cfg ndebug` to get a fully optimized binary to test with.\n. It's probably because of the VM, I just ran the same thing and got 85k. Closing.\n. Thanks.\n. I merged that fix to modifier but haven't updated crates.io. This is all sort of moot until hyper gets updated anyway, which is what I'm working on now.\n. Iron will continue to track nightly (like the rest of the ecosystem) until\n1.0 stable, when it will split to have two branches, one for 1.0 stable and\none for 1.0 nightlies. This will continue into 1.X versions.\n\nEventually Iron itself will hit 1.0 and adopt a similar versioning scheme\nto Rust itself, but that's a while off.\nOn Tue, Jan 13, 2015 at 9:23 PM Daniel notifications@github.com wrote:\n\n> Also failing on 1.0.0-alpha. Any plans to support alpha (and later\n> beta/stable)?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/iron/iron/issues/255#issuecomment-69812906.\n. Fixed.\n. @pzol Thanks for this, but I ended up needing to make a bunch of other unrelated changes, so I just rolled everything into #257 instead.\n. Examples are ICEing, nothing that can be done right now so merging.\n. @iho unfortunately this is the current situation, Iron will continue to track nightlies until 1.0 stable, where a solution for cases like this will be devised (perhaps some kind of switch for stable/unstable channels).\n\nAs a result, I'm going to close this, since nothing can really be done right now.\n. Nope, this isn't your fault at all. A dependency of one of Iron's dependencies, mucell, hasn't been updated for the latest version of rustc so it's broken right now. This should be fixed in the very near future, hang in there :).\n. Ya, that's a difference ICE in rustc, but that should be fixed in the next nightly.\n. I submitted a pull request to mucell to fix the build failure.\n. @jihokoo Great, then we're just waiting for the mucell fix to be merged.\n. Fixed!\n. @heynemann, it looks like your rust install is borked, since it can't find `core` or `std` which are the internal and external std libs respectively. Try to uninstall and reinstall using the rustup.sh script.\n. Nope, I'm on OS X too. This happens every once in a while, just uninstall and reinstall and that usually fixes it.\n. @heynemann run `cargo update` to get the latest versions of all the dependencies, including mucell.\n\nDon't be sorry! It's no problem.\n. @heynemann Did you compile with optimizations or are you running on a VM? Make sure that when you benchmark you use the `--release` flag with cargo, i.e. `cargo run --release --example hello`.\n. Ugh ya, benchmarking with `ab` is super borked and I've never really been able to figure it out. Try using `wrk` instead, that tends to work much better.\n. I agree completely. I haven't really felt the need to do this yet since everything is still in flux and hyper is the only real option right now, but eventually I think there should be a protocol/trait layer between hyper and Iron so that you can swap out the hyper back end.\n. It's possible that `Request` could be changed to allow streaming of the input data. I've thought about it and the issues that come up with direct `Response` streaming aren't really an issue for `Request`, since there is only one state (i.e. no \"status line written\", \"headers written\", \"nothing written\" etc.). \n\nThe major issue I anticipate is that this makes testing a bit trickier, but from my memory of the internals of Hyper I think it's actually pretty easy to mock an `HttpWriter` with whatever data you want. This also has the side-effect of making `Request` no longer `'static` or `Send` (since `HttpWriter` is given to us by Hyper with a lifetime), which can be a pain.\n. I can take a crack at making this change tomorrow (newtype `&'a mut HttpWriter` and change `Request::body` to use that), but it's not too complex a change and probably interesting if either of you wants to give it a try first.\n. We now allow streaming the request body, so Iron should now be able to support this use case well.\n. cc @s-panferov @cybergeek94\n\nI had some free time so I just made the change. Thoughts on the approach? Do you think `Request` should implement `Reader` itself, or is the current isolation to the `body` field appropriate?\n. @cybergeek94 I think it would actually be the role of a Plugin to properly read the request body and transform it into whatever form a Handler can actually use and storing it in the request extensions, whether that's reading the whole thing and parsing it into JSON or parsing it using multipart or whatnot. It should be rare for the Handler to be responsible for dealing with a raw request body directly.\n\nBeforeMiddleware used to fill this role, but the lazily-evaluated and cached nature of Plugins actually makes them ideal for dealing with this sort of one-shot data.\n\nA badly written BeforeMiddleware can already cause all sorts of havoc by setting properties on Request to nonsensical values - providing the body as a reader doesn't change that.\n. Updated for #275, landing.\n. This appears to already be done: https://github.com/iron/iron/blob/master/src/middleware.rs#L279\n\nIs there something else that this doesn't cover?\n. This is now done via the new body abstraction, it is now possible to write to the body using a normal `io::Write` interface.\n. @ProtectedMode Awesome.\n. @untitaker rust-ci is similar to greenkeeper, it triggers a nightly rebuild on travis, so you know every day if something has caused your build to fail.\n. `hyper::server::Request` has a `remote_addr` field which contains the `SocketAddr` of the request, probably easiest to just use that instead of passing the port around separately.\n. by the way thanks for reaching out on #245, I let that one slip through the cracks\n. You're right, that's the client address. If we're going to do this, we might as well just add the host socket address to the Request type and use that, rather than passing it around separately.\n\nThanks,\n         Jonathan Reem\n\nOn Fri, Jan 23, 2015 at 5:46 PM, Michael Sproul notifications@github.com\nwrote:\n\n> ## The `remote_addr` is the IP and port of the client, is it not? From poking around in Hyper it seems the local equivalent is ignored in the `listen` methods.\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/pull/273#issuecomment-71223204\n. Ya, just store it on Iron and add it to our Request type, we can upstream\nlater.\nOn Fri, Jan 23, 2015 at 9:22 PM Michael Sproul notifications@github.com\nwrote:\n\n> Just to clarify, you mean Hyper's request type?\n> \n> Otherwise the only way we can store it on our Request type is by storing\n> it on Iron as I've done here. This is because the only arguments to\n> hyper::server:Handler::handle are self and a Hyper request + response.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/iron/iron/pull/273#issuecomment-71259117.\n. Looks good - I'll merge when everything builds again.\n. Excellent!\n. Awesome! Thanks for doing this.\n. Yay breaking all the things ever!\n. @michaelsproul @zzmp thoughts?\n\n@zzmp I know you liked the ability to handle, but in practice it made no sense to switch back to the no-error path.\n. Particular open question: is it correct for `Handler` to not have a `catch`, and therefore be bypassed in the error flow?\n. @s-panferov There are a few disadvantages to splitting everything up:\n1. You have to link stuff like loggers an additional time\n2. Anything that wants to run as both a normal middleware and an error handler has to be linked twice\n\nYou never need to think about indexes, just relative order - I anticipate that error handlers will just go at the end most of the time.\n. Other open question:\n\nShould `catch` expose a way to switch back to the normal track at all? My intuition this time said no, but I think that a \"just switch back to the next middleware\" might be valuable. This is how express works, since you can call `next()` with no args in an error handler to switch back to the normal track. Thoughts?\n. I would be far more comfortable with stuff like router raising errors on NotFound if there was a way to switch back.\n. You could actually still write a generic `Suppress` type which you'd just wrap the middleware whose errors you would like to ignore in.\n. Ok, I'm convinced this is desired... I'll push an update.\n. Done! Before I land this, I want to add some tests for the chain implementation, since it has enough indexing to make me edgy.\n. Ok. Tests added - 200 lines of infrastructure to allow reasonable tests...\n. Landing, breaking everything!\n. Awesome! Feel free to make a PR and I'll give you a review of the changes.\n. Fixed!\n. Included in #275 \n. Iron and rust are still pretty unstable, so I wouldn't recommend using them in production just yet. There are also a bunch of polish issues with Iron and associated middleware, though I am rapidly addressing them and making it a core focus for the next few weeks.\n\nPerformance is definitely a goal of Iron, but it has to be framed inside the blocking-IO world that it lives in, which means it won't be as fast as some other fast solutions built on asynchronous IO. That said, Iron wrecks node.js and other higher-level evented libraries in req/sec (by like an order of magnitude). \n\nI don't know enough about vibe.d (I had to google it) to really compare it to Iron, but from what I've read it appears to be based on non-blocking IO, which means it will have a different performance model than what Iron has.\n. Since this is just a question, I'm closing.\n. Thank you!\n. Travis has an old rustc, so boo.\n. That example was actually broken before this change, moving the `println!` was unrelated. `.listen` returns an RAII guard that, when dropped, will block until the server is closed. By saving the guard into a variable using a let statement, the dropping of the guards is delayed until after they are all started (at the end of the block), removing the blocking behavior.\n. Builds!\n. Thank you very much for your work!\n. Seems like this belongs in a proper iron/body-parser implementation.\n\nPlugin configuration is unfortunately very tricky and I haven't been able to come up with a really good way to do it.\n. Given that body-access is the poster-child for plugins, it seems like it should be one. I'd rather a patch to body-parser for now, and we can maybe move it to core in the future.\n. If you're doing a fixup, can you also remove this from the example and Show => Debug?\n. Amazing.\n. Thanks.\n. This is awesome and super exciting. I saw your work in hyper and I'm really glad to see it here too.\n\nI just left a few comments, let me know your thoughts.\n. How about we just provide `http(addr)` and `https(addr, certificate, key)` constructors?\n. It seems like a nuisance to have to get and type out the protocol.\n. Sorry, I've been very confusing. What I meant was to replace listen with http and https.\n. Yes.\n. Looks pretty good, I will read once more and merge in the morning.\n. Ah ya, my bad for letting this spin. Just did another read through, looks like good work.\n. @SkylerLipthay The simplest thing is to just add another dependency on `lazy_static` and load it there.\n\nThis whole methods feels a bit not so good. It should really parse directly from the extension string to an instantiated `Mime`, which is cloned. This avoids allocating an intermediate string and the cost of re-parsing. Setting the raw header is a bit bad practice and more importantly will just move the cost of re-parsing later if it is ever accessed again.\n\nThe way we used to do it was with [rust-http-content-type](https://github.com/reem/rust-http-content-type), which generated a phf table of extension => rust-http mime instance. In this case it would be extension => hyper mime instance. Unfortunately depending on a modified version of that would ruin all hope of us being usable in 1.0 stable.\n\nAll of that said, it seems the best way forward is to do the simplest thing and use `lazy_static` to store a `Types` instance.\n. @SkylerLipthay needs a rebase, since I merged some other changes.\n. Looks good otherwise.\n. So everything is broken on travis right now. There's a fix on the way, so I'll just wait for it to land and merge this tomorrow.\n. @SkylerLipthay will need another rebase and travis broken yet again :/\n. @SkylerLipthay finally things are actually moving, there's a small bug in the impl here, see the travis log (just a simple `expected Option<T> found T` error)\n. FINALLY\n. Did you compile with optimizations?\n. I just tested and got 92k locally.\n. Can I get the exact commands you used to compile iron, run the example, and run the benchmark?\n. You are building without optimizations. Use `cargo build --release`, `cargo run --release`.\n. Are you running on a VM? VMs are usually slower.\n. I'm not sure what to tell you, a lot of things can influence these numbers. For instance, when my computer's battery is low I get like 500 req/s.\n\nUnfortunately, I can't really fix this right now without being able to at least reproduce locally, sorry.\n\nThe best thing you could do would be to maybe profile the executable while it is being benchmarked a few times and include that, along with commands and computer specs.\n\nIf you get back to me with that I might be able to re-open the issue and fix it, if the profiling is informative.\n. I'm not comfortable with this as I think it will cause confusion with many users assuming this is for setting the status code. \n\nThe ContentLength header is available in the `iron::headers` module, which is a re-export of all the hyper headers.\n. Ya, go ahead :D. Make a different PR, I'm closing this one.\n. LGTM. Thank you!\n. I agree we want this long term, but I honestly don't think we really know enough about what Rust web development will look like for us to make these decisions right now.\n. For what it's worth I own the `http` name on crates.io - that seems to me to be a fine place to aggregate standards for web development in rust.\n. Thanks.\n. Done.\n. Enabling `sudo: false` means you are opting in to travis' container-based infrastructure, which serves up builds and has very good caches.\n. Taking a look right now.\n. Looks great to me. Excellent work @panicbit.\n. Awesome, this looks great. Thank you so much for all the PRs, but as discussed before I'm gonna wait for travis to be be back up, unless you need something urgently merged.\n. <3\n. This is a known issue, but @zzmp is on it!\n. Boom, updated! @zzmp nice job\n. While you might technically be right, I'm really don't _want_ to put something like this in the README, it's bad for business, you know ;)\n\nThese are temporary limitations anyway, we are already thinking of better ways to distribute work over the thread pool to allow handling many more concurrent connections.\n. Sure, if you craft it to be a little more positive ;)\n\nEDIT: I don't mean that anything your saying is bad, just that I don't really want it in the README\n. @s-panferov you still interested in landing this?\n. closing due to inactivity but feel free to open another\n. Hmm, good call. @zzmp can you check this out? If I recall correctly it should be really easy to add another crate to the docs.\n. Collapsing into #338 \n. I think the documentation here is not wrong, just highly technical and possibly in-need of rephrasing. \n\nA `valid URL in a relative scheme` is not the same as a `valid relative URL`; in this case \"scheme\" refers to the protocol, e.g. http, https, not the format of the url itself.\n. @lambdajp Awesome! I'm really happy to get other people working on this too.\n\nI'd caution against writing anything very long-form right now, since while things are relatively stable there will still be breaking changes, leading to (possibly) lots of outdated documentation. Believe me, I've had to delete hundreds of lines of documentation already.\n\nExamples are usually much easier to update and get checked for breakage automatically by the continuous integration system. Short documentation is also easy to update, because the changes that broke it are usually near it.\n. @lambdaburrito Cool. I'd ensure that you recommend that users read the rust book/intro first, especially since Iron uses a variety of more complex type system features.\n. I'm working on a fix for this right now. #314 is the start but I have to fix mocking tools too.\n. Awesome, thanks!\n. Done!\n. Hmm, that's inconvenient since it means we won't be able to automatically set the content type when a File is passed to set the body of a response. That said, it's not necessarily blocking. Could we grow an API based on `readlink` in the future, or is that unlikely to happen?\n\nEDIT: Also, is it possible that we could have `#[cfg(nightly)]`?\n. Yup.\n. @gsquire thanks for fixing :)\n. Just restarted travis to show the current build failures.\n. superseded by #325\n. The build is fixed on master. I'm closing because I don't want to do this until there is some ecosystem stability because it makes the developer workflow really hard (have to release and do menial updates even more often).\n. Fixed in master\n. Hey @rookwood101, I just wanted to let you know that there are a few contributing bugs to the build breaking right now, but I have these fixes already in a local branch that I am waiting on the last upstream fix to PR. It should be ready to go with tomorrows nightly since the needed rust PR merged a few hours ago.\n\nAs a result I'm probably gonna close these when that PR goes live, since I'd have to do a bunch of rebasing otherwise.\n. superseded by #325\n. superseded by #325\n. @natemara sorry, I I just merged #325 which already includes similar changes.\n. I think this current case is mostly for implementation concerns - due to the nature of `rust-url` we need a full url including host to create the request's url instance. I'll see what I can do about fixing this though, since there's no need to be unnecessarily mean to HTTP/1.0 :).\n. Thanks! Can you change the commit message to be a bit more descriptive and follow the style of the other commits in the history?\n. @ghmlee Great! Thank you.\n. Fixed.\n. @lambdaburrito I'm sorry, you are right, I misread the original post and thought this was only about iron proper not also router. I'll reopen and see what I can do about fixing this today.\n. Actually fixed!\n. Looks good, can you squash?\n. Also do me a favor and ping me when you do, I don't get a notification if you push new commits, so I don't know when the PR has been updated.\n. Fixed in the latest version of num_cpus.\n. Thank you for all this analysis and information! This is almost definitely caused by https://github.com/hyperium/hyper/issues/368.\n. @jlouis you might be interested in some preliminary work being done here: https://github.com/reem/transfer, I'm working on a low-latency server built on mio, an event loop over epoll.\n\nI'm also working on fixing the hyper issue with a queueing abstraction.\n. Sorry, but I really don't like how the crates.io badge from shields.io is orange. Maybe if you could find consistent styles with a crates.io badge that's green?\n. @DevoNoel Looks great, thanks for fixing this!\n. I looked through the implementation and didn't see anything obvious... @michaelsproul you are probably most familiar with the url implementation - any idea what might be happening here?\n. Yup. Closing due to inactivity. Anyone feel free to comment if they can reproduce.\n. @zzmp this is what I was talking about\n. @briancolfer I believe your rust version is out of date, Default was added to the prelude rather recently. I just compiled iron locally on the latest beta and nightly, so closing.\n. Sounds good to me :)\n. This is also what `AroundMiddleware` is basically for.\n. Though I do agree that sugar for constructing chains is definitely desirable.\n. I think you're right and we should just copy examples/time.rs, it's easier to keep things consistent that way.\n. Nice, thanks :)\n. Pinned to hyper 0.5 for now. Will update to 0.6 in the near future, but it will require some thought to try and avoid breaking iron's API.\n. Fixed!\n. This is great, thank you. It's a little unfortunate that making ssl optional doesn't really have an effect unless all extension crates manually opt-out. @alexcrichton do you have any ideas how we could use cargo to make this more ergonomic?\n. I'm mostly just concerned about people forgetting to set `default-features = false` even if they could. I think you're right and that might be a sign that it shouldn't be on by default.\n. We can tackle the issue of optional ssl later.\n. @gsquire can you remake this PR to the router repo?\n. We can't have it here since it would be a circular dependency, unfortunately.\n. @AndrewBrinker yes and yes.\n\nI am in favor of this change.\n. Each request is handled in a different thread, so the request extensions can act as a form of thread-local storage.\n. @singpolyma there is a pool, but a request gets exclusive access to the thread it's being handled in until it is finished, then another request can be handled on the same thread.\n. I agree we want something like this, but I have to think about the API a bit.\n\nRegardless, one major comment on the implementation ChainLink should just contain a Chain and call its methods rather than reimplementing the internals.\n. Makes sense to me. Thanks for this!\n. @muja I agree completely, this is functionality we are looking to develop in hyper which we could then expose in iron.\n. @muja currently the std library doesn't provide a way to close a `TcpListener`. As soon as it does, we will add support in hyper and then I can add support in iron.\n. LGTM, thanks!\n. @netmml ok, looks good to me now. Can you squash?\n. Squashed manually in #379\n. Closing due to inactivity but feel free to reopen with the requested changes.\n. Great! I like the comment too, helps clarify what's going on.\n. As discussed earlier I am definitely for this. I'm hesitating about exposing the hyper response directly, but I think it's probably the right thing to do here.\n. @bfrog can you actually open an issue for that feature request? It makes perfect sense you'd want to run actions post-actual-response-writing but the current API does not really allow that.\n\n@sfackler the reason it can't be an AfterMiddleware is because those still run before the response is actually written out.\n\nSorry for taking so long to merge this, I've just been thinking about it and I also want to ensure I merge it when I have time to go and update the other repos in `iron`.\n. This is now sort of possible by doing the work in the WriteBody impl used as the Response body, which typically runs after the Handler has returned.\n. Perhaps there's room for another example which integrates these concepts? More examples is better, IMO.\n. cc #311 \n. Yes, it should be `automatically`.\n. Thanks!\n. `HttpResult` is actually a reexport of `hyper::Result`, I've made it a longer name to make it clear it is not the Result type used ubiquitously in Iron, that is `IronResult`. `IronResult` is not called `Result` since it is in the iron `prelude` module, and putting a `Result` symbol in there would not work well.\n\nI use the renaming-Result idiom in many crates, but it doesn't fit well in this case.\n. It is used to populate the `local_addr` field of `Request` in `Request::from_http`, and can be \"accessed\" through that. It is meant to be an implementation detail of the `Iron` type.\n. Hmm, can you instead just mark them `#[doc(hidden)]`?\n. Hmm, it might actually be better to just make them private fields.\n. I left some specific comments, but at a higher level you actually do not need to use an AroundMiddleware here, an AfterMiddleware (using the catch method) would do perfectly fine, since all you need to do is introspect the response/error.\n. @ilkosta actually you can change the response content, or even replace the response wholesale - nothing is written to the actual stream until the top-level Handler has returned (which necessitates all middleware having run).\n. Closing due to inactivity but feel free to reopen with the requested changes.\n. Hmm, can you post some context, like your Cargo.toml or other code? I am having trouble reproducing this locally.\n. Sorry, I can't reproduce this locally with either the latest stable cargo and rustc or the latest nightly, could you try upgrading and seeing if that solves your problem?.\n\nEDIT: versions:\n\n```\n# stable:\n~/c/r/deps-on-iron git:master \u276f\u276f\u276f cargo --version                                                  \u25fc\ncargo 0.4.0-nightly (15b497b 2015-07-08) (built 2015-07-09)\n~/c/r/deps-on-iron git:master \u276f\u276f\u276f rustc --version                                                  \u25fc\nrustc 1.2.0 (082e47636 2015-08-03)\n\n# nightly:\n~/c/r/deps-on-iron git:master \u276f\u276f\u276f cargo --version                                                  \u25fc\ncargo 0.5.0-nightly (4bc0456 2015-09-02)\n~/c/r/deps-on-iron git:master \u276f\u276f\u276f rustc --version                                                  \u25fc\nrustc 1.4.0-nightly (cd138dc44 2015-09-02)\n```\n. Thanks!\n. cc @sfackler no more *s!\n. Thanks :)\n. It does make the example longer, but also more useful I agree.\n. Thanks!\n. This would definitely be useful. I've started work towards solving this in the above linked PR to hyper.\n. @flada-auxv thanks!\n. Awesome! This is exactly the kind of thing we need to make iron more approachable.\n\nI've given the two examples a read and I have two main thoughts:\n- the error recovery example would be even better if it also included AfterMiddleware, to make it clear what happens in that case (even if the behavior is basically exactly the same)\n- the router example should mention the real `router` crate/handler just so people know it exists\n. Thank you!\n. Yeah, it really depends on your machine. I get roughly between 80 and 90, sometimes more. These are just microbenchmarks.\n. Yeah, seems reasonable to me. The stats in the repo are from running the benchmark on my machine:\n\nMacBook Pro (Retina, 15-inch, Mid 2014)\nProcessor 2.8 GHz Intel Core i7\nMemory 16 GB 1600 MHz DDR3\n\nif you want to amend the PR to include that info, I would be happy to merge.\n. Closing due to inactivity, feel free to remake the PR with the requested changes.\n. Looks good to me, thanks!\n. @hellpain can you include the full series of commands you used to get that result (preferably from git clone onwards) so I can try to reproduce it locally?\n. I can reproduce as well, though my perf is more like 8k req/sec. I think this is likely due to hyper turning off keep-alive by default, which would substantially degrade performance in a benchmark like wrk.\n\nIron could turn keep-alive back on by default to solve this problem, improving perf in benchmarks but bringing back the demons of https://github.com/hyperium/hyper/issues/368.\n. I believe this is basically fixed by turning hyper keep alive back on by default.\n. @TyOverby this is probably because router also depends on iron and likely doesn't set default-features = false in its own Cargo.toml. \n\nUnrelated, but note that iron re-exports typemap as iron::typemap, so you shouldn't need to depend on it directly.\n. @TyOverby router should be updated to set default-features = false for its dependency on iron.\n. You probably meant to return `&mut Chain`, not `&Chain`. The calls cannot actually be chained on a `&Chain`, which is immutable.\n. This seems like a pure win to me, it isn't even too bad of a breaking change.\n. Can you squash and I will merge?\n. Awesome!\n. This has a conflict with the last PR you made, which I just merged. I am hesitant to land this immediately as it is a breaking change. Could you instead make a new function link_around, and we can remove the old around function later?\n. Given that we plan to deprecate around, the real implementation should live int he body of link_around and be called from around, rather than the other way around.\n. Not currently. We will likely get `#[deprecated]` back in the near future though.\n. Merged anyway, we can deal with removing `around` when the time comes.\n. Can you add a short note to the docs that these macros are experimental? Otherwise LGTM.\n. I'm not totally sure how to feel about the different modifiers, but I think if we are going to go that way we should include a note in the docs with the suggested use cases. I think it would be fine to merge the macros themselves as is now, we can always iterate on them if they aren't as convenient as imagined for real use cases.\n. I like `iexpect`.\n. Thanks, missed this.\n. Huh, well this is neat. I wonder who requested this for us?\n. Yes, I will attempt to do a release in the coming days bumping the version of hyper used to the 0.7 series, which should resolve this issue.\n. 0.2.5 with hyper 0.7 released!\n. Yes, I agree making ssl opt-in is the right move here.\n. Remove the default feature should be all that is needed (except, as @untitaker mentioned, removing unnecessary `default-features = false` in reverse dependencies).\n. Hmm, I think I know what's going on. Try replacing the final lines with:\n\n``` rust\nlet mut result = vec![0; b\"Hello World!\".len()];\nresponse_body.write(&mut *result).unwrap();\n\nassert_eq!(result, b\"Hello, world!\");\n```\n\nI think the impl of io::Write for Vec might not be doing what we want.\n. Oh man, sorry, total red herring. The real problem is just that `ResponseBody` is an `io::Write`, and calling `write` on it is for _adding_ data to it, not reading it out.\n\nThe appropriate thing to do is something like this:\n\n``` rust\nfn hello_world_handler(_: &mut Request) -> IronResult<Response> {\n    Ok(Response::with((iron::status::Ok, \"Hello, world!\")))\n}\n\nfn main() {\n    let data = Cursor::new(Vec::new());\n    let mut stream = MockStream::new(data);\n    let mut reader = BufReader::new(&mut stream as &mut NetworkStream);\n    let mut req = request::new(method::Get,\n                               Url::parse(\"http://localhost:3000/users\").unwrap(),\n                               &mut reader);\n\n    let response = hello_world_handler(&mut req).unwrap();\n\n    // Create an io::Write we can write into.\n    let mut result = Vec::new();\n    { // We need this block so we can access result later.\n        // Give ResponseBody the Vec as a target to write to.\n        let mut response_body = ResponseBody::new(&mut result);\n        // Write from the response body -> ResponseBody -> Vec\n        response.body.unwrap().write_body(&mut response_body).ok();\n    }\n\n    // Read the contents of the Vec\n    assert_eq!(result, b\"Hello, world!\");\n}\n```\n. No problem :)\n. Superseded by #431 which re-exports all of the iron module.\n. Thanks!\n. @untitaker from my position I think the most important reason to transition the license is to allow code from these libraries to be used in the std library or other parts of the rust distribution, which are all dual licensed MIT/Apache-2.0. That said, I do agree that relicensing or not is unlikely to have a strong effect on adoption in the ecosystem.\n\nI'm for it if we can amass all the necessary relicensing waivers.\n. Thanks!\n. @wubin1989 openssl v0.7.5 is referring to version 0.7.5 of rust-openssl, see https://github.com/sfackler/rust-openssl not the version of openssl itself.\n. Thanks!\n. Closing because stale, but please feel free to make a new PR with updated code!\n. BodyReader needs a public constructor, since its field is private. Otherwise LGTM.\n. Err, my bad, for some reason I thought the field was private.\n. Merged. I will make a new release later today when I have the time to also update extensions to point at the new release.\n. Anyone else with release powers feel free to do the same - just ensure that you release 0.3 and update extensions to it.\n. I agree with @untitaker, closing for now but feel free to make a new PR any time with the new plan.\n. Can we add back a note somewhere that you can write your own modifiers? This is a big reason for their use.\n. Yes, by default this is true, but you can configure the size of the thread pool using the `Iron::listen_with` method.\n. Yup, seems reasonable, this is also an easy task, so marking with easy so someone new has the opportunity to fix it.\n. So thinking about this more, the ideal situation is:\n- we have an in-memory buffer for reading data from the socket\n- we read into this buffer whenever a chunk is available until it is full\n- user code can drain from this buffer asynchronously\n- when the buffer is full we stop reading from the socket until the user code has drained some data, then we resume (the logic here is a bit tricky, but it should work)\n\nThis way we don't have to deal with an ever-expanding in-memory buffer or resorting to a disk buffer.\n\nIn terms of how we actually expose this to the user, something like a specialized `eventual` Stream would probably be the best way to go without going full coroutines, which could also work.\n. In terms of how I'm thinking to land something like this: I'd like to do one more release of iron that will be the final release based off of sync hyper and that exposes a sync interface, then start another release for the asynchronous version. We can then maintain the synchronous version for some time before deprecating it.\n. @bluss, could you change this to instead still deny missing docs on test? My intention is to force travis to fail if anything is undocumented.\n. I need to catch up on upstream `url` changes to know if we could just hold on to `url::Url` directly, but if it is possible then I would love to do it.\n. Lets move all further discussion to #453, which is a superset of this PR (and hopefully can land soon!)\n. Just gave this a more thorough read, and it looks fantastic! Thank you very much for making this change, it's something I've wanted to do for a long time.\n\nThere's only one major thing I think we should change: many of the methods return owned types (`String`, `Vec<String>`, etc.) by internally calling cloning methods when we could just return the borrowed variant. Wherever possible, I would like to avoid adding any allocations by just returning the borrowed type instead.\n\nI think the only remaining refactor would be substituting String for a proper error type, but that can be left for another PR.\n. thanks!\n. Yes! It should actually be something like:\n\n``` rust\nlet _server = Iron::new(hello_world).http(\"localhost:3000\").unwrap();\nprintln!(\"On 3000\");\n```\n\nwhich would actually wait until the server is listening to print that it is listening. The problem with the current example is that the server guard is dropped immediately, instead of saved.\n. Closing in favor of #446 \n. @adrianbrink this `Handler` is the _iron_ `Handler` trait, not the hyper one. It's defined here https://github.com/iron/iron/blob/16c858ec2901e2992fe5e529780f59fa8ed12903/src/middleware/mod.rs#L57-L61.\n. @untitaker so awkward situation but I appear to have lost the password for iron-bot, I'll keep looking into it and update you\n. Better yet just moved the repo over to https://github.com/iron/build-doc\n. ",
    "zzmp": "I generalized the script a few ways. The function now takes different arguments:\n- git uri\n- repo name\n- build location (optional)\n- build command (optional)\n\ndep/*/configure will no longer be executed unless the file exists and the user has correct permissions.\n\nI've also added extensive comments to the script, to make it more transparent.\n. Let's wait to merge this until **rust-http** is updated, at the very least.\nThe script also includes **rust-openssl**, but that line can be commented out if not updated before **rust-http**.\n. This section should be rendered as multiple paragraphs (list elements), and that still isn't working. Could you roll that into this pull request?\n. @reem Donezo.\n. Add markdown around Types/Traits: `Iron`, `Ingot`, etc.\n. bash? Maybe templating (ERB-style)? If we use templating, we can make it a grunt-like task, but we might want to do it in bash or another scripting language so we can stick it in our configure file - just have it be done as part of configure, so we never have to commit the changes.\n\nJust ideas..\n. Good wrapping, let's us be extensible in the future.\n. `IronRequest` should be a public struct.\n. This may be an issue external to this PR, but types are coerced in Iron with no extensibility. The only choice for coerced types is, at this point, `IronRequest` and `IronResponse`, unless we retool the boot process.\n\nUPDATE: This is now documents as an issue, #14.\n. This currently fails at commit 994a8ce - I'm working on resolving it - hold off on merging/commenting.\n. Branch `feat/handler-unsafe` implements this correctly, so I am closing this PR in favor of that.\n. Nicely done!\n. Good call.\n. This is awesome. Two grammar fixes, then it's _golden_.\n. Looks legit.\n. I love it. Impeccable!\n. Shoutout to @Ogeon - thanks for your help.\n. I'm working on this in my fork's bug/lifetime-response branch. It may be a good starting-off point, though it does not compile.\n. @ogeon thinks this may not be fixable due to a compiler bug/inconsistency.\n\nIn the the [forked branch](https://github.com/zzmp/iron/tree/bug/response-lifetime) the compiler cannot infer the bound lifetime because it is defined in a trait (it would work if it were defined in a struct). It should be expected to work in both cases.\n. I have also tried `impl`'ing the `fn`s within a wrapping `struct`, but I come up against the same errors. To be explicit:\n\n```\nsrc/iron/mod.rs:140:1: 149:2 note: consider using an explicit lifetime parameter as shown: fn handler<'a, 'b, Rq: Request, Rs: Response + HttpResponse<'a, 'b>,\n           F: Furnace<Rq,\n                      Rs>>(furnace: &mut F, req: &server::Request,\n                           res: &mut server::ResponseWriter<'b>)\nsrc/iron/mod.rs:140 fn handler<'a, 'b,\nsrc/iron/mod.rs:141            Rq: Request,\nsrc/iron/mod.rs:142            Rs: Response + HttpResponse<'a, 'b>,\nsrc/iron/mod.rs:143            F: Furnace<Rq, Rs>>\nsrc/iron/mod.rs:144         (furnace: &mut F, req: &server::Request, res: &mut server::ResponseWriter) {\nsrc/iron/mod.rs:145     let mut request: Rq = Request::from_http(req);\n                    ...\nsrc/iron/mod.rs:146:30: 146:58 error: cannot infer an appropriate lifetime for lifetime parameter 'b in function call due to conflicting requirements\nsrc/iron/mod.rs:146     let response_lifetimed = transmute_res_lifetimes(res);\n```\n. The two cases I've encountered:\n- Specify a lifetime parameter on the `from_http` trait.\n  \n  The function is given a `ResponseWriter` with anonymous lifetimes because `handle_request` does not take lifetimes. This makes it impossible to extend with bound lifetimes (with or without unsafe) as the type checker will always fail to coerce these lifetimes.\n\n```\nerror: mismatched types: expected `&mut http::server::response::ResponseWriter<'b>` but found `&mut http::server::response::ResponseWriter<'_>`\n```\n- Transmute the `ResponseWriter` unsafely to have the same lifetimes as `IronResponse` (through the trait implementation).\n  \n  Again, the function is given a `ResponseWriter` with anonymous lifetimes. Instead of the lifetime being incompatible with what the compiler expects, the compiler expects _nothing_.\n  \n  The `ResponseWriter` is given a lifetime that will last the duration of the response (as it should), until it goes out of scope at the end of the inner `serve_forever` loop (see **rust-http**'s source for details). The `IronResponse` (or other concrete type implemented on the `Response` trait) is given a lifetime that will last from the beginning of our transmute through the end of our middleware-traversing function (`handler` in the iron mod). This means that the type being transmuted _to_ has a shorter lifetime than that being transmuted _from_, so we should encounter no issues from our unsafe block.\n\nDespite its unseemliness, the compiler seems right - this should not compile - even though we know that it will be fine if it does. I think we can justify our use of `unsafe` here.\n\n@reem, @theptrk @mcreinhard: Motion to close this issue.\n. `Ingots` is our standard style. Good catch.\n. This does not yet compile because b\"byte literals\" were added to **rust-http**, but are not yet in the nightly compiler from which Travis compiles. We'll need to re-run them in the morning, or ask Travis to use a different source.\n. I think this is common enough functionality for a server that it should be in core, as many `Middleware` could conceivably rely on it. This is small enough and valuable enough (i.e. desirable in the vast majority of servers) that it should remain here IMO.\n\nAny `Middleware` should not be in core, but this just extends the `Response` without adding any extra `struct`.\n\nI hoped to get this in core, as well as automatic setting of the `Content-Type` based on the extension of what was passed into `send`, and _nothing else_.\n. I still disagree. My argument is solely that `send` will make it easier to build `Middleware` on top of `Iron` without having to include other libraries (like an Iron-Common).\n\nIf you're still not convinced, and won't be, go ahead and close this.\n. How do you feel about `serve_file`?\n. @reem Done.\n. Does this mean you'll be refactoring router/mount to use these?\n. Are there other getters that we could conceivably add?\n\nThere is no trait:`Get`, so we'd be safe changing the name if we have multiple getters. I'm checking the **rust-http** docs right now to explore other possibilities. (Only looking for heavy use cases.)\n. I'd just rather do it early so we have less refactoring on middleware downstream. Give me till 3.\n. FYI\n\n``` rust\nimpl RequestUri {\n    /// Interpret a RFC2616 Request-URI\n    fn from_string(request_uri: String) -> Option<RequestUri> {\n        if request_uri == String::from_str(\"*\") {\n            Some(Star)\n        } else if request_uri.as_slice()[0] as char == '/' {\n            Some(AbsolutePath(request_uri))\n        } else if request_uri.as_slice().contains(\"/\") {\n            // An authority can't have a slash in it\n            match from_str(request_uri.as_slice()) {\n                Some(url) => Some(AbsoluteUri(url)),\n                None => None,\n            }\n        } else {\n            // TODO: parse authority with extra::net::url\n            Some(Authority(request_uri))\n        }\n    }\n}\n```\n\nIn our common case, we'll only care about `AbsolutePath`. `AbsoluteUri` looks like its only used for proxies.\n. `Get` seems friendlier to me than `GetUrl`, but either one is fine. I don't think we'll be adding any other accessor functions - everything else is fairly exposed, or complex enough to be in middleware.\n. I'd like to see more standard naming. Send is already a trait, so I suggest:\n`Serve`, `serve_file`,  `serve_data`, `serve_status`.\n\nI see no reason to use multiple traits.\n. Also, serving a body does not always mean serving a status code. Can you refactor the status code to be an `Option`?\n. +1, do it the way you had it. Just refactor to a single trait.\n. Make sure to update lib.rs to use `Serve` instead of `ServeFile`. Travis failed.\n. So long as this is a working example, :100: \n\nhoo boy pictures :8ball: :1234: :+1: \n. Currently, `make clean` also clears the `deps` folder, but does not clear the rlibs and dylibs in `target/...`.\n\nI do not think `make clean` needs to clear the `deps` folder. Instead, `./configure` should be clearing its rlibs and dylibs out of `targets/...` before trying to put new ones in, or else forcing a rewrite in that folder.\n\nAdditionally, removing `deps/` from `make clean` will retain the dependency tree. Can it be included in this PR?\n. Don't you love strongly typed languages?\n. Failed travis.\n. Instead of replacing the example middleware with a function, can you make two separate example files, or have two examples within one file?\n\nThe old example _is_ still relevant.\n. So long as there are two examples.\n. This is in a feature branch of iron/iron now.\n. +1 (to the refactor)\n. Good, but no more convenience functions. Can't be cluttering up the core.\n. Resource on procedural macros: http://blog.burntsushi.net/rust-regex-syntax-extensions\n(or the [`regex!` source](http://doc.rust-lang.org/src/regex_macros/home/rustbuild/src/rust-buildbot/slave/nightly-linux/build/src/libregex_macros/lib.rs.html#11-645)).\n\nI don't know how feasible this is because it relies on an external source (the mimes list), but the source could be pulled in without conversion to rust, with that being left to a macro. Just spitballing..\n. Closing this to work from `iron:doc/README`. PR to come..\n. !\n. This failed due to nightly breaks. Travis will need to be reset once changes are made.\n\n@reem, your branch incorporates Cargo. I'll make a PR now to incorporate the nightly breaks (already merged to the source repo).\n. @reem bump\n. Can do, give it half hour.\n. @reem Bump. So much bump.\n. Unless you want to pair on `rust-lang/rust`, I'm not sure we have a recourse.\n. huon mentioned that the recent break was probably due to this: https://github.com/rust-lang/rust/pull/15191\n. I don't think we should do this. It still involves changing our code at every point where a bare function was used, so the overhead is the same as just `impl`'ing a function as `fn enter` in a middleware struct, but it introduces a lot of technical debt (and what might be considered code bloat). I commented on this strategy when I opened this issue.\n\nCan you come back to discuss this?\n. It should be fixed eventually. There's an active issue out on it - https://github.com/rust-lang/rust/issues/14820.\n\nThe plan is to fix it with `impl<T:Copy> Clone for T { ... }` (stated in the above issue).\n(I don't really understand why this isn't possible already, but according to the issue it's not.)\n. Technically, it's fine, and with middleware heavy on terminal controllers, this is definitely a boon.\n\nI'm still wary of adding in another helper struct, but we _need_ to compile today. So long as it comes out when bare `fn`s (with lifetimes) can `impl Clone` again.\n. @cburgdorf, as long as you can keep the test, I think it'd be a good idea to inline it. The codegen already exposes just the one function (`get_generated_content_type`), so I don't think it's necessary to wrap it anymore. Go ahead and nuke the file.\n. Thanks!\n\nI've heard talk of procedural macros that may make this even better, but I can't find any documentation on it (@reem).\n\nUPDATE: I've been told that this is the only resource: http://blog.burntsushi.net/rust-regex-syntax-extensions\n. @reem, this shouldn't be generated anymore. The file was replaced with `/src/response/mimes/mod.rs`. Can you respond to this?\n. This is awesome. I'll open an issue for the rest of the library.\n\nUPDATE: #91 was opened for this.\n. It looks like `rust-http` is currently failing. Travis will need to be restarted once that is fixed.\n\n@mavdi, it looks like you made this change because of changes to http, caused by nightly breaks. Is that right?\n. This is a limitation from `rust-http`, which requires that all headers be written before any of the body. If you look at the source, the headers are flushed when any of the body is first written, and are then never written again.\n\nI think there is some documentation of this in the `cookie` module, but you're right in that it should be more clear. Feel free to add to the documentation, or we will get to it soon.\n. Parts of this fixed in #99:\n- [X] Fix link to urlencoded\n- [X] Remove quotations in link to rust-http\n- [x] Give metric with which to compare \"17,000+ requests per second\" to add relative meaning\n- [x] Add description/\"Hello, world!\" as a doc comment to `lib.rs`\n. Merging this, as it just changes documentation. Travis is failing because `cargo` is not being loaded - not sure why, I'll open a separate issue.\n. This relies explicitly on the `rust-http` implementation, specifically, https://github.com/chris-morgan/rust-http/blob/master/src/http/server/mod.rs#L56\n\n@reem, I'm fine merging this, but could you make note of the explicit dependency in a comment so that we don't lose track of it?\n. This removes a dependency to `rust-http` through abstraction, but #108 adds a dependency to the implementation of it. I'm fine with both of them, but we are still dependent in terms of the way we are tweaking and fine-tuning for performance.\n. Delaying the writing allows headers to be written through successive mutations of the headers structure, even if there were calls to `serve` in between. :+1:\n\nHowever, it seems as if `serve` and `serve_file` can now only be called once, exclusively, and subsequent writes to the same `Response` are no longer possible :(. I don't want to take away that functionality, as it allows multiple controllers to contribute to serving. It also means that the write will be delayed until all of a file is written, which may _greatly_ delay things like file-writing (files will need to be read/written twice) and consume more memory internally. Can you think of ways to mitigate this?\n. @reem The old implementation did this as well (without reading the entire file into memory), so we're not gaining efficiency. We are gaining the ability to write headers at any time, and losing the ability to concatenate chunks to the body. Update for defaulting `404` and other small changes and this should be good to merge.\n. I looked at the Travis, and not a warning in sight! This is great.\n. Note: We'll need to rebuild the docs to see these changes live on http://docs.ironframework.io\n. @reem Looks great! The biggest thing is the `404` logic - I think that is better placed in our `Response` wrapper, rather than in the logic here. Otherwise, everything else is fairly small.\n. @brycefisher, when you observed this, did you have any middleware linked in? Could you show me a code sample?\n. Essentially, done!\n. I'm through `src/iron.rs`, and it looks good so far - starting `src/middleware.rs`.\n\nBackticks in comments are incredibly inconsistent, and it would be unproductive to mark them all if there are still legitimate code changes. Once the code is reviewed, we should rereview this for consistency of documentation, as well as thoroughness (separate PR).\n. @reem looks good. A few questions for my own comprehension before I call the review complete.\n. @reem bump\n. I'd leave this up for at least a day to see if anyone else wants to comment. Otherwise, I'm done here. I'll go through documentation more later and in a separate issue/PR.\n. Thanks! Was trying to pass tests for `static-file` and noticed that this was failing.\n. This was actually a break from `rust-http`. See this PR: https://github.com/chris-morgan/rust-http/pull/164\n. Downstream dependencies will continue to break until reem/iron-test is fixed as well.\n\n@reem, this is one possibility: https://github.com/reem/iron-test/pull/6\n. @iron/contributors anyone want to have a look before this gets merged in?\n. yay!\n. I've updated the build scripts to include all dependencies.\nCheck it out at github.com/iron-bot/build-doc\n\nUnfortunately, it didn't seem like Cargo could handle doccing multiple crates, so I rewrite the search index as it docs.\n. See github.com/iron-bot/build-doc\n. Can you change the commit message from worning to warning? Then it looks good.\n. I generalized the script a few ways. The function now takes different arguments:\n- git uri\n- repo name\n- build location (optional)\n- build command (optional)\n\ndep/*/configure will no longer be executed unless the file exists and the user has correct permissions.\n\nI've also added extensive comments to the script, to make it more transparent.\n. Let's wait to merge this until **rust-http** is updated, at the very least.\nThe script also includes **rust-openssl**, but that line can be commented out if not updated before **rust-http**.\n. This section should be rendered as multiple paragraphs (list elements), and that still isn't working. Could you roll that into this pull request?\n. @reem Donezo.\n. Add markdown around Types/Traits: `Iron`, `Ingot`, etc.\n. bash? Maybe templating (ERB-style)? If we use templating, we can make it a grunt-like task, but we might want to do it in bash or another scripting language so we can stick it in our configure file - just have it be done as part of configure, so we never have to commit the changes.\n\nJust ideas..\n. Good wrapping, let's us be extensible in the future.\n. `IronRequest` should be a public struct.\n. This may be an issue external to this PR, but types are coerced in Iron with no extensibility. The only choice for coerced types is, at this point, `IronRequest` and `IronResponse`, unless we retool the boot process.\n\nUPDATE: This is now documents as an issue, #14.\n. This currently fails at commit 994a8ce - I'm working on resolving it - hold off on merging/commenting.\n. Branch `feat/handler-unsafe` implements this correctly, so I am closing this PR in favor of that.\n. Nicely done!\n. Good call.\n. This is awesome. Two grammar fixes, then it's _golden_.\n. Looks legit.\n. I love it. Impeccable!\n. Shoutout to @Ogeon - thanks for your help.\n. I'm working on this in my fork's bug/lifetime-response branch. It may be a good starting-off point, though it does not compile.\n. @ogeon thinks this may not be fixable due to a compiler bug/inconsistency.\n\nIn the the [forked branch](https://github.com/zzmp/iron/tree/bug/response-lifetime) the compiler cannot infer the bound lifetime because it is defined in a trait (it would work if it were defined in a struct). It should be expected to work in both cases.\n. I have also tried `impl`'ing the `fn`s within a wrapping `struct`, but I come up against the same errors. To be explicit:\n\n```\nsrc/iron/mod.rs:140:1: 149:2 note: consider using an explicit lifetime parameter as shown: fn handler<'a, 'b, Rq: Request, Rs: Response + HttpResponse<'a, 'b>,\n           F: Furnace<Rq,\n                      Rs>>(furnace: &mut F, req: &server::Request,\n                           res: &mut server::ResponseWriter<'b>)\nsrc/iron/mod.rs:140 fn handler<'a, 'b,\nsrc/iron/mod.rs:141            Rq: Request,\nsrc/iron/mod.rs:142            Rs: Response + HttpResponse<'a, 'b>,\nsrc/iron/mod.rs:143            F: Furnace<Rq, Rs>>\nsrc/iron/mod.rs:144         (furnace: &mut F, req: &server::Request, res: &mut server::ResponseWriter) {\nsrc/iron/mod.rs:145     let mut request: Rq = Request::from_http(req);\n                    ...\nsrc/iron/mod.rs:146:30: 146:58 error: cannot infer an appropriate lifetime for lifetime parameter 'b in function call due to conflicting requirements\nsrc/iron/mod.rs:146     let response_lifetimed = transmute_res_lifetimes(res);\n```\n. The two cases I've encountered:\n- Specify a lifetime parameter on the `from_http` trait.\n  \n  The function is given a `ResponseWriter` with anonymous lifetimes because `handle_request` does not take lifetimes. This makes it impossible to extend with bound lifetimes (with or without unsafe) as the type checker will always fail to coerce these lifetimes.\n\n```\nerror: mismatched types: expected `&mut http::server::response::ResponseWriter<'b>` but found `&mut http::server::response::ResponseWriter<'_>`\n```\n- Transmute the `ResponseWriter` unsafely to have the same lifetimes as `IronResponse` (through the trait implementation).\n  \n  Again, the function is given a `ResponseWriter` with anonymous lifetimes. Instead of the lifetime being incompatible with what the compiler expects, the compiler expects _nothing_.\n  \n  The `ResponseWriter` is given a lifetime that will last the duration of the response (as it should), until it goes out of scope at the end of the inner `serve_forever` loop (see **rust-http**'s source for details). The `IronResponse` (or other concrete type implemented on the `Response` trait) is given a lifetime that will last from the beginning of our transmute through the end of our middleware-traversing function (`handler` in the iron mod). This means that the type being transmuted _to_ has a shorter lifetime than that being transmuted _from_, so we should encounter no issues from our unsafe block.\n\nDespite its unseemliness, the compiler seems right - this should not compile - even though we know that it will be fine if it does. I think we can justify our use of `unsafe` here.\n\n@reem, @theptrk @mcreinhard: Motion to close this issue.\n. `Ingots` is our standard style. Good catch.\n. This does not yet compile because b\"byte literals\" were added to **rust-http**, but are not yet in the nightly compiler from which Travis compiles. We'll need to re-run them in the morning, or ask Travis to use a different source.\n. I think this is common enough functionality for a server that it should be in core, as many `Middleware` could conceivably rely on it. This is small enough and valuable enough (i.e. desirable in the vast majority of servers) that it should remain here IMO.\n\nAny `Middleware` should not be in core, but this just extends the `Response` without adding any extra `struct`.\n\nI hoped to get this in core, as well as automatic setting of the `Content-Type` based on the extension of what was passed into `send`, and _nothing else_.\n. I still disagree. My argument is solely that `send` will make it easier to build `Middleware` on top of `Iron` without having to include other libraries (like an Iron-Common).\n\nIf you're still not convinced, and won't be, go ahead and close this.\n. How do you feel about `serve_file`?\n. @reem Done.\n. Does this mean you'll be refactoring router/mount to use these?\n. Are there other getters that we could conceivably add?\n\nThere is no trait:`Get`, so we'd be safe changing the name if we have multiple getters. I'm checking the **rust-http** docs right now to explore other possibilities. (Only looking for heavy use cases.)\n. I'd just rather do it early so we have less refactoring on middleware downstream. Give me till 3.\n. FYI\n\n``` rust\nimpl RequestUri {\n    /// Interpret a RFC2616 Request-URI\n    fn from_string(request_uri: String) -> Option<RequestUri> {\n        if request_uri == String::from_str(\"*\") {\n            Some(Star)\n        } else if request_uri.as_slice()[0] as char == '/' {\n            Some(AbsolutePath(request_uri))\n        } else if request_uri.as_slice().contains(\"/\") {\n            // An authority can't have a slash in it\n            match from_str(request_uri.as_slice()) {\n                Some(url) => Some(AbsoluteUri(url)),\n                None => None,\n            }\n        } else {\n            // TODO: parse authority with extra::net::url\n            Some(Authority(request_uri))\n        }\n    }\n}\n```\n\nIn our common case, we'll only care about `AbsolutePath`. `AbsoluteUri` looks like its only used for proxies.\n. `Get` seems friendlier to me than `GetUrl`, but either one is fine. I don't think we'll be adding any other accessor functions - everything else is fairly exposed, or complex enough to be in middleware.\n. I'd like to see more standard naming. Send is already a trait, so I suggest:\n`Serve`, `serve_file`,  `serve_data`, `serve_status`.\n\nI see no reason to use multiple traits.\n. Also, serving a body does not always mean serving a status code. Can you refactor the status code to be an `Option`?\n. +1, do it the way you had it. Just refactor to a single trait.\n. Make sure to update lib.rs to use `Serve` instead of `ServeFile`. Travis failed.\n. So long as this is a working example, :100: \n\nhoo boy pictures :8ball: :1234: :+1: \n. Currently, `make clean` also clears the `deps` folder, but does not clear the rlibs and dylibs in `target/...`.\n\nI do not think `make clean` needs to clear the `deps` folder. Instead, `./configure` should be clearing its rlibs and dylibs out of `targets/...` before trying to put new ones in, or else forcing a rewrite in that folder.\n\nAdditionally, removing `deps/` from `make clean` will retain the dependency tree. Can it be included in this PR?\n. Don't you love strongly typed languages?\n. Failed travis.\n. Instead of replacing the example middleware with a function, can you make two separate example files, or have two examples within one file?\n\nThe old example _is_ still relevant.\n. So long as there are two examples.\n. This is in a feature branch of iron/iron now.\n. +1 (to the refactor)\n. Good, but no more convenience functions. Can't be cluttering up the core.\n. Resource on procedural macros: http://blog.burntsushi.net/rust-regex-syntax-extensions\n(or the [`regex!` source](http://doc.rust-lang.org/src/regex_macros/home/rustbuild/src/rust-buildbot/slave/nightly-linux/build/src/libregex_macros/lib.rs.html#11-645)).\n\nI don't know how feasible this is because it relies on an external source (the mimes list), but the source could be pulled in without conversion to rust, with that being left to a macro. Just spitballing..\n. Closing this to work from `iron:doc/README`. PR to come..\n. !\n. This failed due to nightly breaks. Travis will need to be reset once changes are made.\n\n@reem, your branch incorporates Cargo. I'll make a PR now to incorporate the nightly breaks (already merged to the source repo).\n. @reem bump\n. Can do, give it half hour.\n. @reem Bump. So much bump.\n. Unless you want to pair on `rust-lang/rust`, I'm not sure we have a recourse.\n. huon mentioned that the recent break was probably due to this: https://github.com/rust-lang/rust/pull/15191\n. I don't think we should do this. It still involves changing our code at every point where a bare function was used, so the overhead is the same as just `impl`'ing a function as `fn enter` in a middleware struct, but it introduces a lot of technical debt (and what might be considered code bloat). I commented on this strategy when I opened this issue.\n\nCan you come back to discuss this?\n. It should be fixed eventually. There's an active issue out on it - https://github.com/rust-lang/rust/issues/14820.\n\nThe plan is to fix it with `impl<T:Copy> Clone for T { ... }` (stated in the above issue).\n(I don't really understand why this isn't possible already, but according to the issue it's not.)\n. Technically, it's fine, and with middleware heavy on terminal controllers, this is definitely a boon.\n\nI'm still wary of adding in another helper struct, but we _need_ to compile today. So long as it comes out when bare `fn`s (with lifetimes) can `impl Clone` again.\n. @cburgdorf, as long as you can keep the test, I think it'd be a good idea to inline it. The codegen already exposes just the one function (`get_generated_content_type`), so I don't think it's necessary to wrap it anymore. Go ahead and nuke the file.\n. Thanks!\n\nI've heard talk of procedural macros that may make this even better, but I can't find any documentation on it (@reem).\n\nUPDATE: I've been told that this is the only resource: http://blog.burntsushi.net/rust-regex-syntax-extensions\n. @reem, this shouldn't be generated anymore. The file was replaced with `/src/response/mimes/mod.rs`. Can you respond to this?\n. This is awesome. I'll open an issue for the rest of the library.\n\nUPDATE: #91 was opened for this.\n. It looks like `rust-http` is currently failing. Travis will need to be restarted once that is fixed.\n\n@mavdi, it looks like you made this change because of changes to http, caused by nightly breaks. Is that right?\n. This is a limitation from `rust-http`, which requires that all headers be written before any of the body. If you look at the source, the headers are flushed when any of the body is first written, and are then never written again.\n\nI think there is some documentation of this in the `cookie` module, but you're right in that it should be more clear. Feel free to add to the documentation, or we will get to it soon.\n. Parts of this fixed in #99:\n- [X] Fix link to urlencoded\n- [X] Remove quotations in link to rust-http\n- [x] Give metric with which to compare \"17,000+ requests per second\" to add relative meaning\n- [x] Add description/\"Hello, world!\" as a doc comment to `lib.rs`\n. Merging this, as it just changes documentation. Travis is failing because `cargo` is not being loaded - not sure why, I'll open a separate issue.\n. This relies explicitly on the `rust-http` implementation, specifically, https://github.com/chris-morgan/rust-http/blob/master/src/http/server/mod.rs#L56\n\n@reem, I'm fine merging this, but could you make note of the explicit dependency in a comment so that we don't lose track of it?\n. This removes a dependency to `rust-http` through abstraction, but #108 adds a dependency to the implementation of it. I'm fine with both of them, but we are still dependent in terms of the way we are tweaking and fine-tuning for performance.\n. Delaying the writing allows headers to be written through successive mutations of the headers structure, even if there were calls to `serve` in between. :+1:\n\nHowever, it seems as if `serve` and `serve_file` can now only be called once, exclusively, and subsequent writes to the same `Response` are no longer possible :(. I don't want to take away that functionality, as it allows multiple controllers to contribute to serving. It also means that the write will be delayed until all of a file is written, which may _greatly_ delay things like file-writing (files will need to be read/written twice) and consume more memory internally. Can you think of ways to mitigate this?\n. @reem The old implementation did this as well (without reading the entire file into memory), so we're not gaining efficiency. We are gaining the ability to write headers at any time, and losing the ability to concatenate chunks to the body. Update for defaulting `404` and other small changes and this should be good to merge.\n. I looked at the Travis, and not a warning in sight! This is great.\n. Note: We'll need to rebuild the docs to see these changes live on http://docs.ironframework.io\n. @reem Looks great! The biggest thing is the `404` logic - I think that is better placed in our `Response` wrapper, rather than in the logic here. Otherwise, everything else is fairly small.\n. @brycefisher, when you observed this, did you have any middleware linked in? Could you show me a code sample?\n. Essentially, done!\n. I'm through `src/iron.rs`, and it looks good so far - starting `src/middleware.rs`.\n\nBackticks in comments are incredibly inconsistent, and it would be unproductive to mark them all if there are still legitimate code changes. Once the code is reviewed, we should rereview this for consistency of documentation, as well as thoroughness (separate PR).\n. @reem looks good. A few questions for my own comprehension before I call the review complete.\n. @reem bump\n. I'd leave this up for at least a day to see if anyone else wants to comment. Otherwise, I'm done here. I'll go through documentation more later and in a separate issue/PR.\n. Thanks! Was trying to pass tests for `static-file` and noticed that this was failing.\n. This was actually a break from `rust-http`. See this PR: https://github.com/chris-morgan/rust-http/pull/164\n. Downstream dependencies will continue to break until reem/iron-test is fixed as well.\n\n@reem, this is one possibility: https://github.com/reem/iron-test/pull/6\n. @iron/contributors anyone want to have a look before this gets merged in?\n. yay!\n. I've updated the build scripts to include all dependencies.\nCheck it out at github.com/iron-bot/build-doc\n\nUnfortunately, it didn't seem like Cargo could handle doccing multiple crates, so I rewrite the search index as it docs.\n. See github.com/iron-bot/build-doc\n. Can you change the commit message from worning to warning? Then it looks good.\n. ",
    "theptrk": "Sometimes you use `Ingot`s and sometimes `Ingots`. Which is the right way to reference it?\n\nsrc/iron/mod.rs has `Ingot`s\n. Chain > Furnace\n. If you insist on using Chain, this makes sense. In terms of introduction, `server.link` is a little confusing because it seems like the function is creating a link to the server. `server.chain.link` is more descriptive and hints to a sequential process (possibly middleware). \n. Thanks! Ill look into this tonight.\n. :+1: \n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n\nPatrick \n\n> On Jan 12, 2016, at 11:00 AM, Mikko Perttunen notifications@github.com wrote:\n> \n> I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Sometimes you use `Ingot`s and sometimes `Ingots`. Which is the right way to reference it?\n\nsrc/iron/mod.rs has `Ingot`s\n. Chain > Furnace\n. If you insist on using Chain, this makes sense. In terms of introduction, `server.link` is a little confusing because it seems like the function is creating a link to the server. `server.chain.link` is more descriptive and hints to a sequential process (possibly middleware). \n. Thanks! Ill look into this tonight.\n. :+1: \n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n\nPatrick \n\n> On Jan 12, 2016, at 11:00 AM, Mikko Perttunen notifications@github.com wrote:\n> \n> I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "cburgdorf": "I noticed you handle this issue like this:\n\nhttps://github.com/iron/iron/commit/fe36c2df18b588fbcfc6b646e16397cb6c59adf0\n\nDo you have any insight in how this will be handled upstream? I mean, is it intended that `fn` is no longer clonable or is this a bug that should be resolved soon?\n. Ah, I see. Thanks for the pointers!\n. @reem don't make my head spin ;-)\n. Should I go ahead and nuke the whole file? Given it's usage across the code base (only once) it seems to be a good candidate to get inlined now that it's a one liner. Thoughts? @reem @zzmp @huonw \n. Ok @zzmp killed it with fire :)\n\nI made it a separate commit because I'm not sure if that's what you head in mind. I'm still not too familiar with how exactly the module system works so there might be a simpler way to achieve this.\n\nSo basically the old `response/mimes/mod.rs` was deleted and the old `response/mimes/mimegen.rs` became the new `response/mimes/mod.rs`.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I noticed you handle this issue like this:\n\nhttps://github.com/iron/iron/commit/fe36c2df18b588fbcfc6b646e16397cb6c59adf0\n\nDo you have any insight in how this will be handled upstream? I mean, is it intended that `fn` is no longer clonable or is this a bug that should be resolved soon?\n. Ah, I see. Thanks for the pointers!\n. @reem don't make my head spin ;-)\n. Should I go ahead and nuke the whole file? Given it's usage across the code base (only once) it seems to be a good candidate to get inlined now that it's a one liner. Thoughts? @reem @zzmp @huonw \n. Ok @zzmp killed it with fire :)\n\nI made it a separate commit because I'm not sure if that's what you head in mind. I'm still not too familiar with how exactly the module system works so there might be a simpler way to achieve this.\n\nSo basically the old `response/mimes/mod.rs` was deleted and the old `response/mimes/mimegen.rs` became the new `response/mimes/mod.rs`.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "davidcelis": "For what it's worth, `wrk` and `ab` give me varying benchmarks on almost every application I've used them on. Different tools benchmark differently, report different metrics, and will simply have different results. It's best to just pick a tool and stick with it.\n. For what it's worth, `wrk` and `ab` give me varying benchmarks on almost every application I've used them on. Different tools benchmark differently, report different metrics, and will simply have different results. It's best to just pick a tool and stick with it.\n. ",
    "mavdi": "Yep, which ultimately goes down to this\nhttps://github.com/rust-lang/rust/commit/12c334a77b897f7b1cb6cff3c56a71ecb89c82af\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. Yep, which ultimately goes down to this\nhttps://github.com/rust-lang/rust/commit/12c334a77b897f7b1cb6cff3c56a71ecb89c82af\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. ",
    "msierks": "+1 for abstraction. Would love to see this feature. :)\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. +1 for abstraction. Would love to see this feature. :)\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "emk": "Well, one possible approach would be to return 404 if all the handlers returned `Continue`, and if none returned `Unwind`. Maybe I'm misunderstanding the design, but `Unwind` seems to indicate \"I've actually returned a real response\", and `Continue` indicates \"I'm doing some pre- and post-processing, but I hope somebody else can provide the real response; I'm just passing it through.\"\n\nOr have I totally misunderstood the design?\n. Interesting.\n\nAnother possible approach might be to represent errors as an ordinary `Unwind` plus a response body generated by `serve(InternalError, \"Blah, blah, blah)`. I think that's how some of the simpler middleware frameworks do it: they map errors directly to HTTP error responses. But then again, that might break if the error occurs after the response has already been partially written\u2014I don't know all the cases that have to be handled in modern HTTP.\n\nGood luck, and thank you for a great library!\n. Well, one possible approach would be to return 404 if all the handlers returned `Continue`, and if none returned `Unwind`. Maybe I'm misunderstanding the design, but `Unwind` seems to indicate \"I've actually returned a real response\", and `Continue` indicates \"I'm doing some pre- and post-processing, but I hope somebody else can provide the real response; I'm just passing it through.\"\n\nOr have I totally misunderstood the design?\n. Interesting.\n\nAnother possible approach might be to represent errors as an ordinary `Unwind` plus a response body generated by `serve(InternalError, \"Blah, blah, blah)`. I think that's how some of the simpler middleware frameworks do it: they map errors directly to HTTP error responses. But then again, that might break if the error occurs after the response has already been partially written\u2014I don't know all the cases that have to be handled in modern HTTP.\n\nGood luck, and thank you for a great library!\n. ",
    "jnicklas": "Thanks, that makes sense. I saw now that this is described in the docs as well.\n. Thanks, that makes sense. I saw now that this is described in the docs as well.\n. ",
    "cengizIO": "@reem I added a wiki page with my wrk experience. \n\nhttps://github.com/iron/iron/wiki/How-to-Benchmark-hello.rs-Example\n. @reem I added a wiki page with my wrk experience. \n\nhttps://github.com/iron/iron/wiki/How-to-Benchmark-hello.rs-Example\n. ",
    "omasanori": "FYI: here is a PR for rust-http to migrate to rust-url. https://github.com/chris-morgan/rust-http/pull/113\n. FYI: here is a PR for rust-http to migrate to rust-url. https://github.com/chris-morgan/rust-http/pull/113\n. ",
    "michaelsproul": "Updated.\n\nI encountered some weirdness with Cargo, but I see you've already reported a bug at https://github.com/rust-lang/cargo/issues/337.\n. I had a bit more of a look at this, and I think this is about as good as we can do with the current state of `rust-http`. SSL isn't supported at all on the server side by `rust-http`, which I hadn't previously realised. Because of this, I reckon hard-coding \"http://\" is fine for now, as HTTPS support will only come with Teepee and a host of other changes to this code (plus there's an XXX to warn our future selves).\n\nSince my last commit, I've also removed the use of `Result::unwrap()` too, which was a bit sketchy.\n. Done.\n. I've got some time today if you'd like me to do this.\n. Lolwut, your build yesterday failed because of this, but mine today didn't? \n\nFailing: https://travis-ci.org/iron/iron/builds/31865907\nNot Failing: https://travis-ci.org/iron/iron/builds/31900038\n\nCargo changed its behaviour...\n. Whoops, just found #121.\n\nCloses #121 \n\n?\n. Consider this issue a place to discuss the limitations brought up in https://github.com/iron/mount/pull/32.\n. I was thinking of just using a struct with a `url::Url` inside it, but your method avoids re-computation of fields like `port` and avoids the method call syntax -- `url.port` is kind of cleaner than `url.port()`.\n\nThe only thing that might make me prefer methods is if we choose to provide mixins for our URL type. I notice you made `query` a `Hashmap` in your second representation. Storing the raw query string in the struct and then providing a lazily-computed `query_params` function via a mixin is another option.\n. Oh yes, fields it is then.\n. I am liking that a lot!\n\nThe port number as a `u16` makes a tonne of sense, I was surprised to see the spec advocating otherwise.\n\nIt seems like an enum with structure variants could also work well, but they're still feature gated and nobody seems to be working on them.\n. I meant for URL as a whole, but perhaps that would be too strange.\n\n``` rust\nenum Url {\n    RelativeSchemeUrl { },\n    NonRelativeSchemeUrl { },\n}\n```\n\nThat'd be heavy on matching...\n. Hmmm, I do like that a generic URL has fields common to both, although the complete enum design has its benefits.\n\nI suspect that most times when parsing a URL you expect one type or the other. Certainly for our purposes, code like this would be good:\n\n``` rust\nlet url: RelativeSchemeUrl = match Url::parse(url_string) {\n    Ok(generic_url) => {\n        match generic_url {\n            RelativeSchemeUrl(url) => url,\n            _ => return Error(\"Not a relative scheme url.\");\n        }\n    },\n    Err(e) => return Error(e)\n}\n```\n\nThe same pattern would apply when parsing `data:` URLs. You could maintain access to `scheme`, `query` and `fragment` using methods.\n\nThis change, being quite fundamental, may also depend on how you parse `data:` URLs, which I noticed is a TODO in the readme. I'm guessing you plan to parse the MIME type, character set and content encoding?\n\nThis may necessitate splitting `NonRelativeSchemeUrl` further, perhaps using an enum? Or maybe just a struct with optional fields?\n\n``` rust\nstruct NonRelativeSchemeUrl {\n    scheme: String,\n    mime_type: Option<MediaType>,\n    charset: Option<String>,\n    encoding: Option<Encoding>,\n    body: String\n}\n```\n\nOh god, I just looked up the list of schemes...\n\nhttps://en.wikipedia.org/wiki/URI_scheme#Official_IANA-registered_schemes\n. Thanks for the numeric port type :)\n. @SimonSapin: That sounds very reasonable.\n\n@reem: I think the embedded structs work quite well. On each `Request` we could simply store a `RelativeSchemeUrl`. The only compromise is the port, which we could make non-optional for HTTP(S) URLs. Given this, and Simon's previous comment about libraries extending `rust-url`, we could leave `rust-url` intact and just write our own wrapper (or do both?).\n\n``` rust\npub struct WebUrl {\n    pub scheme: String,\n    pub username: String,\n    pub password: Option<String>,\n    pub host: Host,\n    pub port: u16,\n    pub path: Vec<String>,\n    pub query: Option<String>,\n    pub fragment: Option<String>,\n}\n```\n. Ok, cool. I'll jump on it.\n. Err, do we want to implement `Show` for our URL type? Because it will involve either converting back to a `rust-url` type and formatting that, or re-writing a whole bunch of `rust-url`'s formatting logic... The latter option would be ok, but might make this section of code harder to maintain...\n. Yeah, I didn't think the `custom_url` module would sneak into as many places as it did. Renaming is neater.\n\nAlways a pleasure working on Iron, hopefully it's headed for greatness as Rust matures :)\n. Would you like me to update static-file and mount for the API change?\n. Yeah, I'd quite like to see how using this thing actually is :P\n. I've read over `rust-plugin` a couple of times and I feel like there's something I'm missing...\n\nHow does it differ from the approach I suggested, where we just add methods to the `Request` and `Response` using traits?\n\nWhat sort of usage do you envisage? Sample code would be instructive I feel.\n. Ok, that makes sense. I thought there may have been a funky static guarantee I was missing.\n\nA consistent API seems like a good idea, and name clashes resolvable as type parameters are easy to read, e.g. `req.get::<m1::Type>()`.\n\nWould it be too much to ask for versions with and without option types? There are certainly cases where we could guarantee the creation of the Plugin, and hence it's presence in the map. This complicates the get method though, I don't think you can overload for types fulfilling different traits?\n. Good to go.\n. Ok, updated. Github seems a little confused about the diffs though.\n. Yeah, that was my logic too.\n. Thanks.\n. I'd like to take a look, but won't get a chance to until tomorrow.\n. Could we rename `AroundMiddleware::around` to `init`, to make it clear that it only gets called once during chain creation, and is very different from `before` and `after`?\n\nApart from that I am loving the design.\n. @reem: Looks good to me :+1:\n. I started working on a data server, kinda like [Thingspeak](https://thingspeak.com/), but it fell by the wayside when I started hacking on Iron's internals. It uses Postgres, routing, etc.\n\nI like the todo-list example.\n. Yeah, I like the idea of linking a few examoles, with a list of features used in each one. My current project is 'festivus' - a Postgres backed time-series database for power and energy data.\n\nhttps://github.com/michaelsproul/festivus\n. The consuming method looks good.\n. Just to be clear, there is no _existing response_ when using `Response::from_file`, it's a static method.\n\nI've been having a read of your default errors middleware and I think it would be well suited to being `AroundMiddleware` in the new system. Because handlers return `Result` types, you could make the behaviour dependant on the errors returned rather than the status codes. This would then require a way to map error types onto status codes, which you could do with a modified `TypeMap`, or a trait. Here's some code (using a trait) to demonstrate what I mean:\n\n``` rust\n// defaulterror/lib.rs\nuse iron::status::{mod, Status};\n\n// Implement this trait on expected error types.\ntrait DefaultError {\n    fn default_error() -> Status {\n        status::NotFound\n    }\n}\n\nstruct DefaultErrorHandler {\n    wrapped_handler: Box<Handler + Send + Sync>,\n    status_map: HashMap<Status, SomeObject>\n}\n\nimpl Handler for DefaultErrorHandler {\n    fn call(&self, req: &mut Request) -> IronResult<Response> {\n        match self.wrapped_handler() {\n            Ok(res) => Ok(res),\n            Err(e) => {\n                let error_handler = self.status_map.find(e.default_error());\n                // Use the error handler to create the response (with a function, from a file, whatever)\n                Ok(error_handler.create_response())\n            }\n        }\n    }\n}\n\nimpl AroundMiddleware for DefaultErrorHandler {\n    fn with_handler(&mut self, handler: Box<Handler + Send + Sync>) {\n        // XXX: Impossible to create self.handler with an empty value,\n        // so this doesn't really work... Option<Box<Handler + Send + Sync>> may be necessary.\n        self.handler = handler\n    }\n}\n```\n\nThen, when using the default errors library, you specify custom mappings by implementing the trait.\n\n``` rust\nimpl DefaultError for NoFile {\n    fn default_error() -> Status { status::NoContent }\n}\nimpl DefaultError for NoMatch {}\n```\n\nHmmm, it could even be useful to map straight from error types to response producers, so you can have multiple pages with the same status code (a 404 for a missing file might look different to a 404 for a missing route).\n\nI think we've also run into a broader deficiency in the `AroundMiddleware` system, namely that capturing the `handler` will require an `Option` type. Have we actually implemented anything as `AroundMiddleware` yet? I'll open a separate issue.\n. No probs! Once I started thinking about it I felt I had to take it to its natural conclusion. I think an enum would work well and some sugar might be nice :)\n. Whoops, dupe of #155 \n. Initialisation of other fields is problematic, as discussed elsewhere.\n. Hmmm, I was having second thoughts about this, but I've decided the `Option` is worse because it removes static guarantees. I was thinking we could export an `UnitializedHandler` error for people to return when matching on `self.handler`, but that's a whole other way for programs to fail that is quite unnecessary. IMO the nicest way to do this would be to implement a method on `Option<H: Handler>` which returns an `IronResult<Response>`, with `None` mapping to `Err(UnitializedHandler)`.\n. The NoOp handler is conceptually the same as the option type, it still allows you to accidentally initialise your AroundMiddleware with useless handlers.\n\nI am liking this PR's approach more and more, despite its complexity. If we name things right, I think it could be quite intuitive (and I think the current names are petty good).\n. @reem: Not necessarily. It seems 301, 302 and 303 could all be relevant?\n. Yeah, an `iron::Url` is preferable, as it has HTTP specific behaviour.\n. Looks great. I like the API and the implementation looks good apart from the inlining of `io::util::copy`.\n\n:+1:\n. Sorry it took so long to get a fix for this!\n\nThanks for reporting!\n. The `remote_addr` is the IP and port of the client, is it not? From poking around in Hyper it seems the local equivalent is ignored in the `listen` methods.\n. Just to clarify, you mean Hyper's request type?\n\nOtherwise the only way we can store it on our Request type is by storing it on `Iron` as I've done here. This is because the only arguments to `hyper::server:Handler::handle` are `self` and a Hyper request + response.\n. Ok, sounds sensible. Keeps our API consistent at least.\n. Done, but Hyper and a few other things are broken because of the change to the `std::error::Error` trait (the detail now has to be provided via `Display`).\n. Bump. It builds!\n. The system looks good, I think not attempting to handle errors is much cleaner.\n\nI also think not having a `catch` method on AroundMiddleware is fine, as AroundMiddleware can already modify errors that occur in their wrapped handler(s) and it doesn't make much sense to go through the primary response construction pipeline if something goes badly wrong. I imagine that the catch method would be useful for communicating between related middleware, did you have any concrete examples in mind?\n. Sorry, this was me! This documentation is referring to the definition in the URL spec:\n\nhttps://url.spec.whatwg.org/#relative-scheme\n\nI think that adding a comment about how a relative scheme is distinct from a relative URL, and linking to the spec would be one solution.\n. I haven't been able to reproduce this, and according to this test program, Iron and `rust-url` produce the same results:\n\n``` rust\nextern crate iron;\nextern crate url;\n\nuse iron::request::Url;\n\nfn main() {\n    let url_str = \"http://host.com/?#fragment=thing&q1=v1\";\n\n    let u = url::Url::parse(url_str).unwrap();\n    let i = Url::parse(url_str).unwrap();\n\n    println!(\"Raw URL parser results:\");\n    println!(\"  Query: {:?}\", u.query);\n    println!(\"  Fragment: {:?}\", u.fragment);\n\n    println!(\"Iron URL parser results:\");\n    println!(\"  Query: {:?}\", i.query);\n    println!(\"  Fragment: {:?}\", i.fragment);\n}\n```\n\nOutput:\n\n```\nRaw URL parser results:\n  Query: Some(\"\")\n  Fragment: Some(\"fragment=thing&q1=v1\")\nIron URL parser results:\n  Query: Some(\"\")\n  Fragment: Some(\"fragment=thing&q1=v1\")\n```\n\nAs you can see, all the data after the `#` gets dumped into the fragment field. This is part of the WHATWG URL spec: https://url.spec.whatwg.org/#query-state\n\nOnce the URL parsing state machine enters the fragment state it treats all subsequent characters as part of the the fragment, and there's no way to get back to the query state to parse the `&q1=v1` part.\n\n@waqqas-abdulkareem, could you provide a link to the Facebook API you're dealing with? From my investigations so far it seems they may be returning invalid URLs, or there's some error elsewhere in the pipeline.\n. Triage... I think we can close this? @reem @waqqas-abdulkareem \n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Updated.\n\nI encountered some weirdness with Cargo, but I see you've already reported a bug at https://github.com/rust-lang/cargo/issues/337.\n. I had a bit more of a look at this, and I think this is about as good as we can do with the current state of `rust-http`. SSL isn't supported at all on the server side by `rust-http`, which I hadn't previously realised. Because of this, I reckon hard-coding \"http://\" is fine for now, as HTTPS support will only come with Teepee and a host of other changes to this code (plus there's an XXX to warn our future selves).\n\nSince my last commit, I've also removed the use of `Result::unwrap()` too, which was a bit sketchy.\n. Done.\n. I've got some time today if you'd like me to do this.\n. Lolwut, your build yesterday failed because of this, but mine today didn't? \n\nFailing: https://travis-ci.org/iron/iron/builds/31865907\nNot Failing: https://travis-ci.org/iron/iron/builds/31900038\n\nCargo changed its behaviour...\n. Whoops, just found #121.\n\nCloses #121 \n\n?\n. Consider this issue a place to discuss the limitations brought up in https://github.com/iron/mount/pull/32.\n. I was thinking of just using a struct with a `url::Url` inside it, but your method avoids re-computation of fields like `port` and avoids the method call syntax -- `url.port` is kind of cleaner than `url.port()`.\n\nThe only thing that might make me prefer methods is if we choose to provide mixins for our URL type. I notice you made `query` a `Hashmap` in your second representation. Storing the raw query string in the struct and then providing a lazily-computed `query_params` function via a mixin is another option.\n. Oh yes, fields it is then.\n. I am liking that a lot!\n\nThe port number as a `u16` makes a tonne of sense, I was surprised to see the spec advocating otherwise.\n\nIt seems like an enum with structure variants could also work well, but they're still feature gated and nobody seems to be working on them.\n. I meant for URL as a whole, but perhaps that would be too strange.\n\n``` rust\nenum Url {\n    RelativeSchemeUrl { },\n    NonRelativeSchemeUrl { },\n}\n```\n\nThat'd be heavy on matching...\n. Hmmm, I do like that a generic URL has fields common to both, although the complete enum design has its benefits.\n\nI suspect that most times when parsing a URL you expect one type or the other. Certainly for our purposes, code like this would be good:\n\n``` rust\nlet url: RelativeSchemeUrl = match Url::parse(url_string) {\n    Ok(generic_url) => {\n        match generic_url {\n            RelativeSchemeUrl(url) => url,\n            _ => return Error(\"Not a relative scheme url.\");\n        }\n    },\n    Err(e) => return Error(e)\n}\n```\n\nThe same pattern would apply when parsing `data:` URLs. You could maintain access to `scheme`, `query` and `fragment` using methods.\n\nThis change, being quite fundamental, may also depend on how you parse `data:` URLs, which I noticed is a TODO in the readme. I'm guessing you plan to parse the MIME type, character set and content encoding?\n\nThis may necessitate splitting `NonRelativeSchemeUrl` further, perhaps using an enum? Or maybe just a struct with optional fields?\n\n``` rust\nstruct NonRelativeSchemeUrl {\n    scheme: String,\n    mime_type: Option<MediaType>,\n    charset: Option<String>,\n    encoding: Option<Encoding>,\n    body: String\n}\n```\n\nOh god, I just looked up the list of schemes...\n\nhttps://en.wikipedia.org/wiki/URI_scheme#Official_IANA-registered_schemes\n. Thanks for the numeric port type :)\n. @SimonSapin: That sounds very reasonable.\n\n@reem: I think the embedded structs work quite well. On each `Request` we could simply store a `RelativeSchemeUrl`. The only compromise is the port, which we could make non-optional for HTTP(S) URLs. Given this, and Simon's previous comment about libraries extending `rust-url`, we could leave `rust-url` intact and just write our own wrapper (or do both?).\n\n``` rust\npub struct WebUrl {\n    pub scheme: String,\n    pub username: String,\n    pub password: Option<String>,\n    pub host: Host,\n    pub port: u16,\n    pub path: Vec<String>,\n    pub query: Option<String>,\n    pub fragment: Option<String>,\n}\n```\n. Ok, cool. I'll jump on it.\n. Err, do we want to implement `Show` for our URL type? Because it will involve either converting back to a `rust-url` type and formatting that, or re-writing a whole bunch of `rust-url`'s formatting logic... The latter option would be ok, but might make this section of code harder to maintain...\n. Yeah, I didn't think the `custom_url` module would sneak into as many places as it did. Renaming is neater.\n\nAlways a pleasure working on Iron, hopefully it's headed for greatness as Rust matures :)\n. Would you like me to update static-file and mount for the API change?\n. Yeah, I'd quite like to see how using this thing actually is :P\n. I've read over `rust-plugin` a couple of times and I feel like there's something I'm missing...\n\nHow does it differ from the approach I suggested, where we just add methods to the `Request` and `Response` using traits?\n\nWhat sort of usage do you envisage? Sample code would be instructive I feel.\n. Ok, that makes sense. I thought there may have been a funky static guarantee I was missing.\n\nA consistent API seems like a good idea, and name clashes resolvable as type parameters are easy to read, e.g. `req.get::<m1::Type>()`.\n\nWould it be too much to ask for versions with and without option types? There are certainly cases where we could guarantee the creation of the Plugin, and hence it's presence in the map. This complicates the get method though, I don't think you can overload for types fulfilling different traits?\n. Good to go.\n. Ok, updated. Github seems a little confused about the diffs though.\n. Yeah, that was my logic too.\n. Thanks.\n. I'd like to take a look, but won't get a chance to until tomorrow.\n. Could we rename `AroundMiddleware::around` to `init`, to make it clear that it only gets called once during chain creation, and is very different from `before` and `after`?\n\nApart from that I am loving the design.\n. @reem: Looks good to me :+1:\n. I started working on a data server, kinda like [Thingspeak](https://thingspeak.com/), but it fell by the wayside when I started hacking on Iron's internals. It uses Postgres, routing, etc.\n\nI like the todo-list example.\n. Yeah, I like the idea of linking a few examoles, with a list of features used in each one. My current project is 'festivus' - a Postgres backed time-series database for power and energy data.\n\nhttps://github.com/michaelsproul/festivus\n. The consuming method looks good.\n. Just to be clear, there is no _existing response_ when using `Response::from_file`, it's a static method.\n\nI've been having a read of your default errors middleware and I think it would be well suited to being `AroundMiddleware` in the new system. Because handlers return `Result` types, you could make the behaviour dependant on the errors returned rather than the status codes. This would then require a way to map error types onto status codes, which you could do with a modified `TypeMap`, or a trait. Here's some code (using a trait) to demonstrate what I mean:\n\n``` rust\n// defaulterror/lib.rs\nuse iron::status::{mod, Status};\n\n// Implement this trait on expected error types.\ntrait DefaultError {\n    fn default_error() -> Status {\n        status::NotFound\n    }\n}\n\nstruct DefaultErrorHandler {\n    wrapped_handler: Box<Handler + Send + Sync>,\n    status_map: HashMap<Status, SomeObject>\n}\n\nimpl Handler for DefaultErrorHandler {\n    fn call(&self, req: &mut Request) -> IronResult<Response> {\n        match self.wrapped_handler() {\n            Ok(res) => Ok(res),\n            Err(e) => {\n                let error_handler = self.status_map.find(e.default_error());\n                // Use the error handler to create the response (with a function, from a file, whatever)\n                Ok(error_handler.create_response())\n            }\n        }\n    }\n}\n\nimpl AroundMiddleware for DefaultErrorHandler {\n    fn with_handler(&mut self, handler: Box<Handler + Send + Sync>) {\n        // XXX: Impossible to create self.handler with an empty value,\n        // so this doesn't really work... Option<Box<Handler + Send + Sync>> may be necessary.\n        self.handler = handler\n    }\n}\n```\n\nThen, when using the default errors library, you specify custom mappings by implementing the trait.\n\n``` rust\nimpl DefaultError for NoFile {\n    fn default_error() -> Status { status::NoContent }\n}\nimpl DefaultError for NoMatch {}\n```\n\nHmmm, it could even be useful to map straight from error types to response producers, so you can have multiple pages with the same status code (a 404 for a missing file might look different to a 404 for a missing route).\n\nI think we've also run into a broader deficiency in the `AroundMiddleware` system, namely that capturing the `handler` will require an `Option` type. Have we actually implemented anything as `AroundMiddleware` yet? I'll open a separate issue.\n. No probs! Once I started thinking about it I felt I had to take it to its natural conclusion. I think an enum would work well and some sugar might be nice :)\n. Whoops, dupe of #155 \n. Initialisation of other fields is problematic, as discussed elsewhere.\n. Hmmm, I was having second thoughts about this, but I've decided the `Option` is worse because it removes static guarantees. I was thinking we could export an `UnitializedHandler` error for people to return when matching on `self.handler`, but that's a whole other way for programs to fail that is quite unnecessary. IMO the nicest way to do this would be to implement a method on `Option<H: Handler>` which returns an `IronResult<Response>`, with `None` mapping to `Err(UnitializedHandler)`.\n. The NoOp handler is conceptually the same as the option type, it still allows you to accidentally initialise your AroundMiddleware with useless handlers.\n\nI am liking this PR's approach more and more, despite its complexity. If we name things right, I think it could be quite intuitive (and I think the current names are petty good).\n. @reem: Not necessarily. It seems 301, 302 and 303 could all be relevant?\n. Yeah, an `iron::Url` is preferable, as it has HTTP specific behaviour.\n. Looks great. I like the API and the implementation looks good apart from the inlining of `io::util::copy`.\n\n:+1:\n. Sorry it took so long to get a fix for this!\n\nThanks for reporting!\n. The `remote_addr` is the IP and port of the client, is it not? From poking around in Hyper it seems the local equivalent is ignored in the `listen` methods.\n. Just to clarify, you mean Hyper's request type?\n\nOtherwise the only way we can store it on our Request type is by storing it on `Iron` as I've done here. This is because the only arguments to `hyper::server:Handler::handle` are `self` and a Hyper request + response.\n. Ok, sounds sensible. Keeps our API consistent at least.\n. Done, but Hyper and a few other things are broken because of the change to the `std::error::Error` trait (the detail now has to be provided via `Display`).\n. Bump. It builds!\n. The system looks good, I think not attempting to handle errors is much cleaner.\n\nI also think not having a `catch` method on AroundMiddleware is fine, as AroundMiddleware can already modify errors that occur in their wrapped handler(s) and it doesn't make much sense to go through the primary response construction pipeline if something goes badly wrong. I imagine that the catch method would be useful for communicating between related middleware, did you have any concrete examples in mind?\n. Sorry, this was me! This documentation is referring to the definition in the URL spec:\n\nhttps://url.spec.whatwg.org/#relative-scheme\n\nI think that adding a comment about how a relative scheme is distinct from a relative URL, and linking to the spec would be one solution.\n. I haven't been able to reproduce this, and according to this test program, Iron and `rust-url` produce the same results:\n\n``` rust\nextern crate iron;\nextern crate url;\n\nuse iron::request::Url;\n\nfn main() {\n    let url_str = \"http://host.com/?#fragment=thing&q1=v1\";\n\n    let u = url::Url::parse(url_str).unwrap();\n    let i = Url::parse(url_str).unwrap();\n\n    println!(\"Raw URL parser results:\");\n    println!(\"  Query: {:?}\", u.query);\n    println!(\"  Fragment: {:?}\", u.fragment);\n\n    println!(\"Iron URL parser results:\");\n    println!(\"  Query: {:?}\", i.query);\n    println!(\"  Fragment: {:?}\", i.fragment);\n}\n```\n\nOutput:\n\n```\nRaw URL parser results:\n  Query: Some(\"\")\n  Fragment: Some(\"fragment=thing&q1=v1\")\nIron URL parser results:\n  Query: Some(\"\")\n  Fragment: Some(\"fragment=thing&q1=v1\")\n```\n\nAs you can see, all the data after the `#` gets dumped into the fragment field. This is part of the WHATWG URL spec: https://url.spec.whatwg.org/#query-state\n\nOnce the URL parsing state machine enters the fragment state it treats all subsequent characters as part of the the fragment, and there's no way to get back to the query state to parse the `&q1=v1` part.\n\n@waqqas-abdulkareem, could you provide a link to the Facebook API you're dealing with? From my investigations so far it seems they may be returning invalid URLs, or there's some error elsewhere in the pipeline.\n. Triage... I think we can close this? @reem @waqqas-abdulkareem \n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "brycefisher": "@reem, thanks!! Github issues on https://github.com/brycefisher/defaulterrors would probably make the most sense.\n. I'm all behind shortening Middleware signatures.\n\nI think the project is early enough that there's (almost) nothing in the wild yet, so this shouldn't break too many users downstream implementations.\n. rust-mustache is pretty decent.\n\nI'm not sure about making this middleware. Do mean create a new piece of middleware that acts as the templating engine? \n\nI'm familiar with how Express does this for NodeJs. The developer configures Express to pass through res.render() invocations to the templating engine. The developer also supplies template director(y|ies). Do you plan to create something similar?\n. I just realized that Mixins would make Middleware an _ideal_ way to provide a replaceable templating engine. Sorry I'm a little slow on the uptake.\n\nPerhaps, we could establish a convention that a particular Alloy entry (maybe something like a Vec of Path objects) contains the directories for whatever template engine Middleware is used. There could be a Hashmap in Alloy for per-engine app-wide configuration settings. \n\nA third part of the convention could be that a piece of middleware acting as the render engine would provide a res.render() method via Mixins.\n\nHow does that strike your fancy?\n. Yes! That's essentially what express does with `app.set(key, value)` and `app.get(key)`. Is no other way to provide config, other than in fn arguments?\n\nIt seems like there may be other app-wide configuration needs that may come along anyway -- there should a simple app-wide in memory data-store ready to go.\n. Ugh -- that would suck. Hmmm, maybe we could check for an environmental variable (IRON_VIEWS) and fallback to a default directory for templates (./views). I'm not sure if I'm in love with this idea, but it should prevent any unsafe could or references back to Iron in res or req...\n\nI saw that repo. I'm **super** excited to play with that.\n. Yeah, relying _only_ on environment variables is wrong.\n. I think this is the most ergonomic solution. Would it make any difference if the config is accessed in Response or Request? It _feels_ wrong to provide the same information in two places, but I can't think of any particular problems with this idea.\n. @allan-simon sounds like this would really put us ahead of the node / ruby / python community by really leveraging all the best parts of rustc.\n. Oops -- looks like a router specific issue. I think this repo is fine :-)\n. @reem -- thanks for roping us in. like @michaelsproul, I don't totally understand this. Could you do some of this work in a branch so we could see what you have in mind?\n. Cool, there's also less boilerplate as you noted. Let's do it!\n. Woot! Time to properly refactor DefaultErrors :-)\n. Iron is compiling -- does that close this issue?\n. :+1:\n. @reem, this is rad. I'm a big fan of evolving past Express the way you've laid out in this PR.\n. @reem - can't wait for you to merge this! I'll try to help with refactoring tonight\n. Awesome sauce! Time to refactor all the other things :-)\n. What about creating a default NoOp handler. Then, when `from_handler()` is invoked, just replace it?\n. I'm feeling really slow on the uptake here. Can you gist a totally bare bones example implementation?\n. Awesome!! Thanks, @reem. This isn't necessary more ergonomic IMHO, since it requires an extra struct, but I like that it dispenses with the necessity of an Option<Handler> field.\n\nI would probably opt to use a NoOp in preference to this for simplicity's sake.\n. Sounds like a plan!\n. Hmm, can't reproduce this issue locally. `cargo build; cargo test; cargo doc` all work flawlessly on my mac. Looks to be either a travis issue or a cargo issue...\n. Had an interesting chat in the rust irc. Apparently the permissions error is 700 (448 is written in decimal notation, not octal).\n\nTravis-CI support offered to spin up a VM and provide SSH access to debug this issue. I'm out of time now, but they promised to help if I ping henrikhodne on IRC or email support@travis-ci.com.\n\nAs an aside, I've open a [new issue on rust](https://github.com/rust-lang/rust/issues/16943) to display permissions issues in octal notation.\n\n**EDIT**: doesn't look like anything is wrong inside reem/rust-unsafe-any. The problem appears to be in travis and/or cargo.\n. Yay!\n. Thanks!!\n. Thanks for the swift input @reem. I think you're right about DefaultErrors being an exception, and that this is easy enough to override. \n. @michaelsproul thanks!! You've nearly refactored the whole thing for me.That sounds like a much better approach. \n\n`SomeObject` would be some sort of enum with various kinds of response (file, string, reader, or fn) and `create_response` could match self and create the appropriate response.\n\nPossibly, I could add a macro or some other kind of sugar to reduce the boilerplate needed to implement the DefaultErrors errors trait.\n. @reem, I agree -- a server should not fail during requests if we could foresee that coming ahead of time.\n\nHowever, I'm worried about the amount of boilerplate required to create middleware. This is definitely way harder than building something in Expressjs -- two structs now need to be built (and understood) and three different traits need to be implemented. I feel like we're going backwards in terms of creating an intuitive server for our developers.\n\nPersonally, I much prefer to the existing Nop implementation. That way, developers building on top of Iron have less boilerplate, the library is more intuitive, and we avoid all the Option complexity as well. This would be even better if the Nop returned either a NotFound error or a InternalServerError. \n. I like this new 1 struct approach much better. You have to define a custom struct anyway, and there's no unnecessary `impl`s to worry about.\n. Good to know!\n. Looks like you're there :-)\n. I haven't read through all the changes here, but I do like new api with chaining. I like reducing repetitive boilerplate as much as possible.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. @reem, thanks!! Github issues on https://github.com/brycefisher/defaulterrors would probably make the most sense.\n. I'm all behind shortening Middleware signatures.\n\nI think the project is early enough that there's (almost) nothing in the wild yet, so this shouldn't break too many users downstream implementations.\n. rust-mustache is pretty decent.\n\nI'm not sure about making this middleware. Do mean create a new piece of middleware that acts as the templating engine? \n\nI'm familiar with how Express does this for NodeJs. The developer configures Express to pass through res.render() invocations to the templating engine. The developer also supplies template director(y|ies). Do you plan to create something similar?\n. I just realized that Mixins would make Middleware an _ideal_ way to provide a replaceable templating engine. Sorry I'm a little slow on the uptake.\n\nPerhaps, we could establish a convention that a particular Alloy entry (maybe something like a Vec of Path objects) contains the directories for whatever template engine Middleware is used. There could be a Hashmap in Alloy for per-engine app-wide configuration settings. \n\nA third part of the convention could be that a piece of middleware acting as the render engine would provide a res.render() method via Mixins.\n\nHow does that strike your fancy?\n. Yes! That's essentially what express does with `app.set(key, value)` and `app.get(key)`. Is no other way to provide config, other than in fn arguments?\n\nIt seems like there may be other app-wide configuration needs that may come along anyway -- there should a simple app-wide in memory data-store ready to go.\n. Ugh -- that would suck. Hmmm, maybe we could check for an environmental variable (IRON_VIEWS) and fallback to a default directory for templates (./views). I'm not sure if I'm in love with this idea, but it should prevent any unsafe could or references back to Iron in res or req...\n\nI saw that repo. I'm **super** excited to play with that.\n. Yeah, relying _only_ on environment variables is wrong.\n. I think this is the most ergonomic solution. Would it make any difference if the config is accessed in Response or Request? It _feels_ wrong to provide the same information in two places, but I can't think of any particular problems with this idea.\n. @allan-simon sounds like this would really put us ahead of the node / ruby / python community by really leveraging all the best parts of rustc.\n. Oops -- looks like a router specific issue. I think this repo is fine :-)\n. @reem -- thanks for roping us in. like @michaelsproul, I don't totally understand this. Could you do some of this work in a branch so we could see what you have in mind?\n. Cool, there's also less boilerplate as you noted. Let's do it!\n. Woot! Time to properly refactor DefaultErrors :-)\n. Iron is compiling -- does that close this issue?\n. :+1:\n. @reem, this is rad. I'm a big fan of evolving past Express the way you've laid out in this PR.\n. @reem - can't wait for you to merge this! I'll try to help with refactoring tonight\n. Awesome sauce! Time to refactor all the other things :-)\n. What about creating a default NoOp handler. Then, when `from_handler()` is invoked, just replace it?\n. I'm feeling really slow on the uptake here. Can you gist a totally bare bones example implementation?\n. Awesome!! Thanks, @reem. This isn't necessary more ergonomic IMHO, since it requires an extra struct, but I like that it dispenses with the necessity of an Option<Handler> field.\n\nI would probably opt to use a NoOp in preference to this for simplicity's sake.\n. Sounds like a plan!\n. Hmm, can't reproduce this issue locally. `cargo build; cargo test; cargo doc` all work flawlessly on my mac. Looks to be either a travis issue or a cargo issue...\n. Had an interesting chat in the rust irc. Apparently the permissions error is 700 (448 is written in decimal notation, not octal).\n\nTravis-CI support offered to spin up a VM and provide SSH access to debug this issue. I'm out of time now, but they promised to help if I ping henrikhodne on IRC or email support@travis-ci.com.\n\nAs an aside, I've open a [new issue on rust](https://github.com/rust-lang/rust/issues/16943) to display permissions issues in octal notation.\n\n**EDIT**: doesn't look like anything is wrong inside reem/rust-unsafe-any. The problem appears to be in travis and/or cargo.\n. Yay!\n. Thanks!!\n. Thanks for the swift input @reem. I think you're right about DefaultErrors being an exception, and that this is easy enough to override. \n. @michaelsproul thanks!! You've nearly refactored the whole thing for me.That sounds like a much better approach. \n\n`SomeObject` would be some sort of enum with various kinds of response (file, string, reader, or fn) and `create_response` could match self and create the appropriate response.\n\nPossibly, I could add a macro or some other kind of sugar to reduce the boilerplate needed to implement the DefaultErrors errors trait.\n. @reem, I agree -- a server should not fail during requests if we could foresee that coming ahead of time.\n\nHowever, I'm worried about the amount of boilerplate required to create middleware. This is definitely way harder than building something in Expressjs -- two structs now need to be built (and understood) and three different traits need to be implemented. I feel like we're going backwards in terms of creating an intuitive server for our developers.\n\nPersonally, I much prefer to the existing Nop implementation. That way, developers building on top of Iron have less boilerplate, the library is more intuitive, and we avoid all the Option complexity as well. This would be even better if the Nop returned either a NotFound error or a InternalServerError. \n. I like this new 1 struct approach much better. You have to define a custom struct anyway, and there's no unnecessary `impl`s to worry about.\n. Good to know!\n. Looks like you're there :-)\n. I haven't read through all the changes here, but I do like new api with chaining. I like reducing repetitive boilerplate as much as possible.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. ",
    "Valve": "I don't know if this question is relevant, just curious if it's possible to compile a view as part of the build process. For example there is play! framework for Scala, where views are normal scala files, statically checked and compiled by the scala compiler (https://playframework.com/documentation/2.3.x/ScalaTemplates). I wonder if it's possible to do the same in Rust.\n. hyper over rust-http? What are the advantages of Hyper?\n. I wonder if teepee is going anywhere.\n. I don't know if this question is relevant, just curious if it's possible to compile a view as part of the build process. For example there is play! framework for Scala, where views are normal scala files, statically checked and compiled by the scala compiler (https://playframework.com/documentation/2.3.x/ScalaTemplates). I wonder if it's possible to do the same in Rust.\n. hyper over rust-http? What are the advantages of Hyper?\n. I wonder if teepee is going anywhere.\n. ",
    "aochagavia": "it could be interesting to look at the way Nickel has implemented [mustache support](https://github.com/nickel-org/nickel.rs/commit/3754e89f2cb89323b972cbcd9f7601d9c731aade)\n. it could be interesting to look at the way Nickel has implemented [mustache support](https://github.com/nickel-org/nickel.rs/commit/3754e89f2cb89323b972cbcd9f7601d9c731aade)\n. ",
    "allan-simon": "as someone was noting for scala, in cppcms ,  a webframework in C++ (so in the same segment of \"compiled language\") the use template file , that get compiles into C++ \n\nbasically the idea is that your template file is converted into a C++ class   + a name , which is then added to a hashmap, then in your  \"controller\"  methods you just do \n\n```\n render(content_structure,  \"name_of_the_template\")\n```\n\ncontent_structure being a plain struct, with the data you want to render in your template.\n\nThe advantage I see to this approach is \n- possibility to add dynamic data\n- compile time check,  (the same as people of the posgresql rust library have created a compile time check of the SQL statement) \n-  performance (as it's only compiled once)  \n- still possible for corner case to inject \"raw\" rust code\n  If that seems interesting, I can provide more details on how it is implemented as I've been working with this templating system quite extensively (and would interested to re implement it in Iron) \n\nhttp://cppcms.com/wikipp/en/page/cppcms_1x_templates_gen\nhttp://cppcms.com/wikipp/en/page/cppcms_1x_templates_comm\n. I've finished a side project of mine these last days, and I've started today to take a look at syntax extensions, I will soon create a \"toy\" repository on my github to keep track on my progress on comprehension of \"how to create complex syntax extensions\"  , so that at the end I could use to have a tutorial on how the machinery work, so that we don\u2019t end up with an unmaintainable extension.\n\nI will keep you updated on my progress for this, though I think it's going to take me at least a week or two before getting a \"beginning of proof of concept\", but things will get faster after a good grasp on this.\n. @reem Perfect it will help a lot.\n. Hello, just to keeps you updated, using your stainless extension and brain_fuck macro, I've started a toy html template extension and now i'm able to generate function to output html and to mix rust code in it \n\nhttps://bpaste.net/show/62c46adedcb2\n\nright now I have 2 tags \n- <% template name() %>  which generate a   function \"name() -> String\" \n- <% rust xxxxxx %>  that permits to \"inject\" rust code inside a template, I've first implemented this one because it was IMHO the most complex one (the others will follow the same logic as <% template %>, and it will permit to have \"workarounds\" waiting for me to implement more specific tags (like <% if %> etc. \n\nother things are treated as html and added to the output buffer returned by string\n\nRight now I'm still making myself clear about what i want, and I will tell you when I got something that reflect my idea of the templating engine I want, so that we can start discussing about making change on it \n. actually as said, I'm basing the syntax/concept fully on the one of the \"cppcms\" framework, (which I think was also based on an existing one, as vim was able to put a nice syntaxic coloration)  as I think it's closer to what I'm doing (i.e template transformed into native code at compilation time) \n\nand yup as you said, the goal is to have the same garanty in the template as we have in rust, i.e if it compiles then you're sure it works (i.e syntax checking / type checking etc.) \n. as someone was noting for scala, in cppcms ,  a webframework in C++ (so in the same segment of \"compiled language\") the use template file , that get compiles into C++ \n\nbasically the idea is that your template file is converted into a C++ class   + a name , which is then added to a hashmap, then in your  \"controller\"  methods you just do \n\n```\n render(content_structure,  \"name_of_the_template\")\n```\n\ncontent_structure being a plain struct, with the data you want to render in your template.\n\nThe advantage I see to this approach is \n- possibility to add dynamic data\n- compile time check,  (the same as people of the posgresql rust library have created a compile time check of the SQL statement) \n-  performance (as it's only compiled once)  \n- still possible for corner case to inject \"raw\" rust code\n  If that seems interesting, I can provide more details on how it is implemented as I've been working with this templating system quite extensively (and would interested to re implement it in Iron) \n\nhttp://cppcms.com/wikipp/en/page/cppcms_1x_templates_gen\nhttp://cppcms.com/wikipp/en/page/cppcms_1x_templates_comm\n. I've finished a side project of mine these last days, and I've started today to take a look at syntax extensions, I will soon create a \"toy\" repository on my github to keep track on my progress on comprehension of \"how to create complex syntax extensions\"  , so that at the end I could use to have a tutorial on how the machinery work, so that we don\u2019t end up with an unmaintainable extension.\n\nI will keep you updated on my progress for this, though I think it's going to take me at least a week or two before getting a \"beginning of proof of concept\", but things will get faster after a good grasp on this.\n. @reem Perfect it will help a lot.\n. Hello, just to keeps you updated, using your stainless extension and brain_fuck macro, I've started a toy html template extension and now i'm able to generate function to output html and to mix rust code in it \n\nhttps://bpaste.net/show/62c46adedcb2\n\nright now I have 2 tags \n- <% template name() %>  which generate a   function \"name() -> String\" \n- <% rust xxxxxx %>  that permits to \"inject\" rust code inside a template, I've first implemented this one because it was IMHO the most complex one (the others will follow the same logic as <% template %>, and it will permit to have \"workarounds\" waiting for me to implement more specific tags (like <% if %> etc. \n\nother things are treated as html and added to the output buffer returned by string\n\nRight now I'm still making myself clear about what i want, and I will tell you when I got something that reflect my idea of the templating engine I want, so that we can start discussing about making change on it \n. actually as said, I'm basing the syntax/concept fully on the one of the \"cppcms\" framework, (which I think was also based on an existing one, as vim was able to put a nice syntaxic coloration)  as I think it's closer to what I'm doing (i.e template transformed into native code at compilation time) \n\nand yup as you said, the goal is to have the same garanty in the template as we have in rust, i.e if it compiles then you're sure it works (i.e syntax checking / type checking etc.) \n. ",
    "sunng87": "Hi, I have talked with @reem in IRC but also want to update here. I have been working on a [handlebars template engine for rust](https://github.com/sunng87/handlebars-rust) and I'm going to create an [iron middleware](https://github.com/sunng87/handlebars-iron) for integration.\n\nBy far, the handlebars-rust project is almost finished and should support most of handlebars features, helper customization and template inheritance. I'm now working on the middleware. Since it's still difficult to compile iron against rust nightly, I may still need several days for it.\n\nAs discussed with @reem, we will create a new `Template` struct contains template name and data you want to render. `Template` will implement `Modifier` for `Response`, so users can call `response.set(template)`. The information will be stored in extensions and processed by middleware. I'm also going to keep it easy to test. So users can test their handlers by retrieving data from extensions (in test function).\n. To answer some questions above, handlebars is a widely used template syntax created by Yokuda Hatz (yes, it's who made cargo also) originally in javascript. In handlebars-rust, there is a tricky point that you have to make the data implements `ToJson` so we can render it. Because in handlebars, there's if/else, each and some other custom flow controls, data are not only for rendering, but also to control rendering. So I can't just use a \"Show\" trait or String/&str type for it. Lucky enough, most common data structure implements `ToJson`, so we can use it without (too much) pain.\n. Oh, sorry for wycats.\n. The middleware [handlebars-iron](https://github.com/sunng87/handlebars-iron) is done and available from crates.io\n. I believe this is too high-level to be in the core. From its clojure/ring implementation and [application](https://github.com/metosin/compojure-api), I think it will be implemented as a standalone library/framework, maybe mount-able to ~~ring~~ iron (edited) and has its own default routers. \n. Referencing this ICE that blocks iron build: rust-lang/rust#20676\n. I confirm this ICE has been fixed in `rustc 1.0.0-nightly (f4f10dba2 2015-01-17 20:31:08 +0000)`\n\nWe should be blocked by the mucell error only.\n. In #261, I have a proposal that make iron decoupled with hyper or any other backend. I think it shares the same idea of this one. Iron can be a standard request/response and middleware framework. The will be lower level adapters for hyper, and higher level frameworks for url routing, session/cookies, etc.\n. @s-panferov Yes, there's no such \"standard\" thing. The idea is to make iron decoupled from underlying network layer. That is, do not use anything \"hyper\" specific in the request and response struct. \n\nCurrently there's no need to persuade other framework like nickle to adopt. Just to make iron API more beautiful.\n. https://github.com/conduit-rust/conduit \n\nConduit is aimed to be such a library, not sure if iron has plan to adopt.\n. Personally I think it's pretty difficult to fit websocket into Iron's request-middleware-response model. I haven't seen elegant abstraction in other languages for this.. I didn't look into the code but I'm +1 for this idea. Most Ring-like framework has similar issue. \n\nWhen I work on Handlebars, I hope Iron response could give me a `Write` instead of `Read`. So I won't have to generate pages into a string, then copy it into response.\n. IMO, Iron has a beautiful architecture. In Iron, the whole application is made up with a few middlewares. That's pretty much like [Clojure's Ring](https://github.com/ring-clojure/ring). In Iron, everything is middleware, you can choose your own composition of middlewares. \n\nFor example, \n- the route middleware dispatches requests to different handlers\n- the body reader middleware parses http request body and transform them into data structures easier to deal with\n- [my handlebars template](https://github.com/sunng87/handlebars-iron) middleware renders data models into web pages\n\nThe middleware architecture splits your code by its functionality, made it easier to test.\n\nNickel is more like nodejs's express framework, it's an all-in-one framework comparing to Iron. It has most essential components in web development built-in. I have never use nickel, but I used to investigate the possibility for making handlebars template engine work for it, and failed. \n\nI'm not saying which one is better. To me, Iron is simpler, while Nickel seems easier. And personally I like the Iron design.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Template rendering is done via middleware. Take a look at handlebars-iron and its example:\nhttps://github.com/sunng87/handlebars-iron\n. This is not \"official\". I don't think there will be an \"official\" templating middleware for Iron's architecture. :smile: \n\nThere is an example in the code tree:\nhttps://github.com/sunng87/handlebars-iron/blob/master/examples/server.rs\n\nPlease check if it works for you.\n. @shinriyo you data should implement `ToJson`, try\n\n```\ndata = String::new()\n```\n. Sorry for off-topic. I just feel the SSL thing may be out of the core scope of iron, as a web framework. In python world we saw a clear separation between servers and frameworks. I think it's time for iron developers think about #261 and #295 \n. You can find a working example in my [iron-json-response](https://github.com/sunng87/iron-json-response/blob/master/src/lib.rs#L69)\n. I believe this should be done in an iron ecosystem crate, instead of inside iron itself. As a micro server library, iron has a beautiful, extensiable design to do this externally. We should keep the core compact.. Hyper 0.11 has been released. What's the status of this?. +1 for @seanmonstar . Iron as a web framework should be better to focus on framework part, leaving server implementation plugable for others. This is what we have in Python's WSGI ecosystem. There are a few frameworks (flask, django, bottle) and a few serves (fapws, mainheld).\r\n\r\n. Hi, I have talked with @reem in IRC but also want to update here. I have been working on a [handlebars template engine for rust](https://github.com/sunng87/handlebars-rust) and I'm going to create an [iron middleware](https://github.com/sunng87/handlebars-iron) for integration.\n\nBy far, the handlebars-rust project is almost finished and should support most of handlebars features, helper customization and template inheritance. I'm now working on the middleware. Since it's still difficult to compile iron against rust nightly, I may still need several days for it.\n\nAs discussed with @reem, we will create a new `Template` struct contains template name and data you want to render. `Template` will implement `Modifier` for `Response`, so users can call `response.set(template)`. The information will be stored in extensions and processed by middleware. I'm also going to keep it easy to test. So users can test their handlers by retrieving data from extensions (in test function).\n. To answer some questions above, handlebars is a widely used template syntax created by Yokuda Hatz (yes, it's who made cargo also) originally in javascript. In handlebars-rust, there is a tricky point that you have to make the data implements `ToJson` so we can render it. Because in handlebars, there's if/else, each and some other custom flow controls, data are not only for rendering, but also to control rendering. So I can't just use a \"Show\" trait or String/&str type for it. Lucky enough, most common data structure implements `ToJson`, so we can use it without (too much) pain.\n. Oh, sorry for wycats.\n. The middleware [handlebars-iron](https://github.com/sunng87/handlebars-iron) is done and available from crates.io\n. I believe this is too high-level to be in the core. From its clojure/ring implementation and [application](https://github.com/metosin/compojure-api), I think it will be implemented as a standalone library/framework, maybe mount-able to ~~ring~~ iron (edited) and has its own default routers. \n. Referencing this ICE that blocks iron build: rust-lang/rust#20676\n. I confirm this ICE has been fixed in `rustc 1.0.0-nightly (f4f10dba2 2015-01-17 20:31:08 +0000)`\n\nWe should be blocked by the mucell error only.\n. In #261, I have a proposal that make iron decoupled with hyper or any other backend. I think it shares the same idea of this one. Iron can be a standard request/response and middleware framework. The will be lower level adapters for hyper, and higher level frameworks for url routing, session/cookies, etc.\n. @s-panferov Yes, there's no such \"standard\" thing. The idea is to make iron decoupled from underlying network layer. That is, do not use anything \"hyper\" specific in the request and response struct. \n\nCurrently there's no need to persuade other framework like nickle to adopt. Just to make iron API more beautiful.\n. https://github.com/conduit-rust/conduit \n\nConduit is aimed to be such a library, not sure if iron has plan to adopt.\n. Personally I think it's pretty difficult to fit websocket into Iron's request-middleware-response model. I haven't seen elegant abstraction in other languages for this.. I didn't look into the code but I'm +1 for this idea. Most Ring-like framework has similar issue. \n\nWhen I work on Handlebars, I hope Iron response could give me a `Write` instead of `Read`. So I won't have to generate pages into a string, then copy it into response.\n. IMO, Iron has a beautiful architecture. In Iron, the whole application is made up with a few middlewares. That's pretty much like [Clojure's Ring](https://github.com/ring-clojure/ring). In Iron, everything is middleware, you can choose your own composition of middlewares. \n\nFor example, \n- the route middleware dispatches requests to different handlers\n- the body reader middleware parses http request body and transform them into data structures easier to deal with\n- [my handlebars template](https://github.com/sunng87/handlebars-iron) middleware renders data models into web pages\n\nThe middleware architecture splits your code by its functionality, made it easier to test.\n\nNickel is more like nodejs's express framework, it's an all-in-one framework comparing to Iron. It has most essential components in web development built-in. I have never use nickel, but I used to investigate the possibility for making handlebars template engine work for it, and failed. \n\nI'm not saying which one is better. To me, Iron is simpler, while Nickel seems easier. And personally I like the Iron design.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Template rendering is done via middleware. Take a look at handlebars-iron and its example:\nhttps://github.com/sunng87/handlebars-iron\n. This is not \"official\". I don't think there will be an \"official\" templating middleware for Iron's architecture. :smile: \n\nThere is an example in the code tree:\nhttps://github.com/sunng87/handlebars-iron/blob/master/examples/server.rs\n\nPlease check if it works for you.\n. @shinriyo you data should implement `ToJson`, try\n\n```\ndata = String::new()\n```\n. Sorry for off-topic. I just feel the SSL thing may be out of the core scope of iron, as a web framework. In python world we saw a clear separation between servers and frameworks. I think it's time for iron developers think about #261 and #295 \n. You can find a working example in my [iron-json-response](https://github.com/sunng87/iron-json-response/blob/master/src/lib.rs#L69)\n. I believe this should be done in an iron ecosystem crate, instead of inside iron itself. As a micro server library, iron has a beautiful, extensiable design to do this externally. We should keep the core compact.. Hyper 0.11 has been released. What's the status of this?. +1 for @seanmonstar . Iron as a web framework should be better to focus on framework part, leaving server implementation plugable for others. This is what we have in Python's WSGI ecosystem. There are a few frameworks (flask, django, bottle) and a few serves (fapws, mainheld).\r\n\r\n. ",
    "untitaker": "I think this can be closed since handlebars-iron seems to work fairly well.\n. I've written [mysteryshack](https://github.com/untitaker/mysteryshack), a small server implementing [remoteStorage](http://remotestorage.io/). Rough scope:\n- Basic user and session management\n- JSON API + very small subset of OAuth\n- Administration interface for OAuth tokens\n\nAs an intermediate step we could clone http://flask.pocoo.org/community/poweredby/ using a wiki or doc page.\n. You can do `response.set(file_object)`. See http://ironframework.io/doc/modifier/trait.Modifier.html for other types you can pass to `response.set` (see \"Implementors\" section)\n. As far as I can tell you can just use [std::io::copy](https://doc.rust-lang.org/std/io/fn.copy.html) for this?\n. I think we rather need something like greenkeeper for Rust.\n. Sorry, closed wrong issue.\n. I made those fields private in https://github.com/iron/iron/commit/e88a4f3a915ed726ae3a45ecefbac3952afda421\n. is this still an issue?\n. Closing because this is neither reproducible nor an active thread.\n. what @zr40 said.\n. Excellent, thanks!\n. Shall we close this then?\n\nOn 1 December 2015 18:16:07 CET, Andrii Dmytrenko notifications@github.com wrote:\n\n> Updated crates, now performance is back to normal (Requests/sec: \n> 80339.57)\n> \n> Crates updated:\n> \n> ```\n>    Updating cookie v0.1.21 -> v0.2.2\n>    Updating gcc v0.3.19 -> v0.3.20\n>    Updating hyper v0.6.16 -> v0.7.0\n>    Updating iron v0.2.4 -> v0.2.5\n>    Updating language-tags v0.0.7 -> v0.2.0\n>    Removing libc v0.1.12\n>    Updating log v0.3.3 -> v0.3.4\n>    Updating num_cpus v0.2.9 -> v0.2.10\n>    Updating openssl v0.6.7 -> v0.7.1\n>    Updating openssl-sys v0.6.7 -> v0.7.1\n>      Adding openssl-sys-extras v0.7.1\n>    Updating url v0.2.38 -> v0.5.0\n> ```\n> \n> I suspect it was hyper update, which fixed the regression.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/396#issuecomment-161037258\n\n## \n\nSent from my phone. Please excuse my brevity.\n. I strongly suspect that this has something to do with keepalive-support being reenabled. Are there noticable differences in performance if you don't make any use of keepalive?\n. Might be closed in favor of https://github.com/hyperium/hyper/pull/676\n. Actually I don't see a reason why we should ever use catch_panic. The current behavior would work fine in any case.\n\nI think I muttered something about custom error handlers in IRC, but we really shouldn't encourage to control flow with panics.\n. Are there any appropriate markers that we can apply to the deprecated function?\n. Done, also I changed the default modifier of some_or.\n. Ok, **now** I'm done.\n\nThe idea here is to use `itry` for internal operations, and `some_or` for parsing the request.\n- `itry!(write_to_db())`\n- `some_or!(get_a_url_param())`\n\nSince this is not really a hard requirement in any way, I'm not sure whether to include this into the docs.\n. Added a note.\n. Also I think I'm going to rework the examples...\n. there, I also updated the examples. I didn't find a good usecase for `some_or`, to build a better example I'd have to pull in `urlencoded`.\n. We need a better name for `some_or`. Perhaps `iexpect`?\n. renamed to `iexpect`.\n. @reem any update?\n. \\o/\n. Perhaps this is the way to go, yes. @reem?\n. I don't think there's any other change required.\n\nReverting all those `default-features = false` PRs is not required to make this work, although I suppose it should be done at some point.\n. Not sure why we don't export everything from `iron::iron`. @reem?\n. Seems reasonable, thank you!\n. Nice @sfackler!. Already fixed by https://github.com/iron/iron/commit/ed0b849656189365e2b6241708c85c2b1a824f68\n. The only reference @cmr gave me in https://github.com/sunng87/handlebars-iron/issues/27 is [this Quora answer by a Google engineer](https://www.quora.com/Does-the-MIT-license-require-attribution-in-a-binary-only-distribution), which doesn't even confirm what he is trying to prove. Instead the author there says it's \"just the right thing to do\" to credit the dependencies' author in the UI.\n\nThe other \"case study\" he vaguely mentioned are Android apps that have MIT dependencies:\n\n> see many google android apps with long lists of MIT attributions\n\nbut the apps that I have seen give credits to all dependencies, MIT-licensed or not.\n\nFurthermore I have a serious problem with how this proposal is formulated, and the rhetoric used to convice crate authors to switch licenses. @cmr claims [MIT-licensed libraries will not be used in software at all](https://github.com/untitaker/rust-atomicwrites/issues/11#issuecomment-170365577):\n\n> the actual implication is that your crate won't get used in dual MIT/Apache-2.0 codebases, which is largely what the Rust ecosystem has settled on.\n\nand makes it seem like the choice of MIT/Apache is a dogma in the Rust community. In [another issue](https://github.com/SimonSapin/rust-forest/issues/3), he paddles back, saying it's a rather \"theoretical problem\".\n\nApart from that I have never seen anybody else make comparably strong claims. It's never been an issue in any software I've ever worked on, and enough software with MIT-dependencies (or 3-clause BSD, which has similar conditions)  is deployed without replicating the copyright claims in their GUIs.\n. I think the whole thing is ~~unproven to be relevant.~~ actually provably irrelevant in practice.\n\nThat said, I do not care how my (minor) contributions are (re-)licensed.\n. What information in particular do you want from Hyper's datastructures?\n. @frjonsen I think your bug is valid but not related to this issue. Please create a new issue though\n\nOn 10 March 2017 12:04:28 CET, \"Fredrik Jons\u00e9n\" <notifications@github.com> wrote:\n>Ah, yes, I see now I went through the issue a bit quickly, as it seemed\n>similar enough to the issue I was having. Sorry about that.\n>\n>-- \n>You are receiving this because you were mentioned.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/425#issuecomment-285641606\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. Thanks!\n. I think this can be closed then.\n. @reem? LGTM\n. I feel like an API like this would be less Java-esque:\n\n```\nlet iron = Iron::new(h);\niron.protocol(Http);\niron.addr(...);\niron.hyper_server(...)  // The actual new functionality\niron.listen();\n```\n\nSince the existing methods `http`, `https` and `listen_with` all consume `self`, they can modify the `Iron` instance at will.\n. On mobile, if the link works im :+1:\n. Thanks!\n. Thanks!\n. what @KalitaAlexey said. With that, I don't think there's anything actionable here.\n. Thanks!\n. [`iron::Request`](http://ironframework.io/doc/iron/request/struct.Request.html) has a `headers` field, whose type is from [hyper](http://hyper.rs/hyper/hyper/header/struct.Headers.html).\n\n```\nrequest.headers.get::<iron::headers::ContentType>()\n```\n\nThis will return an instance of this struct: http://ironframework.io/doc/iron/headers/struct.ContentType.html\n. ...what?\n. How is the performance test invalid because of this processor?\n. Ah, now I understand. From the page:\n\n> Total Number of Threads: 12\n\nThis refers to the amount of POSIX threads the Iron server spawns.\n\nYou are claiming this is outdated/wrong/invalid because the Intel page claims that this Intel CPU has only 8 threads.\n\nThis is not relevant though: You can spawn as many POSIX threads as you like, independent of the CPU.\n. We could add a default implementation for `T: Iterator<Item=String>` or something like that.\n. There were also a few releases inbetween, so `cargo update` probably should fix this issue automatically. However, I wonder if we should explicitly require at least the `0.9.x` release that brought this fix.\n. Bump, does upgrading hyper fix this?\n. Please post your Cargo.lock.. Ok, I assume this is fixed in the async branch of hyper and will be fixed when that is released.. I'm unsure about just reading in all the data. This seems like it would have severe perf impact in some situations (like rejecting massive file upload due to failed precondition or missing permissions). Thanks!\n. We might as well rename this issue. :)\n. https://github.com/iron/iron/issues/501 here you go\n. Mutability is a property of variables in Rust, not types (except maybe for pointer types).\n\nYou can use `response.set_mut` to add modifiers to the response (Like the ones you pass to `Response::with` or `Response::set`).\n. The docs in ironframework.io seem to be out of sync.\n. I don't know (not Iron's issue tbh), but perhaps it can't deal with `use-as`: https://github.com/iron/iron/blob/master/src/lib.rs#L95\n. Pluggable is reexported though. The other way around, Pluggable is exported as Plugin. Also the reexport is at the top-level, see src link earlier.. Ok, so this is a docs issue. Ftr Pluggable is exported at top-level and within the prelude, both times under the name Plugin.. Renaming API because of possible bugs in the compiler (and rustdoc) sounds unappealing. This name has been like that forever, so I have no idea what caused the docs to end up like that.. If we merge this, I wonder if we would have to nuke this API again when we refactor the entire thing for Hyper 0.10 (async API).\n. :+1:. Contrary I don't think that it should be possible to release a new Iron version where such lints fail (improved or not).\n\nI see that the Cargo issue got closed.\n. IIRC @reem mentioned that he wanted to refactor the API around Iron requests/urls as well, I hope this will eliminate all those costly conversions.\n. I was thinking more about how creating and returning responses (especially streaming responses) would work within handlers. `.listen`, `.https` etc may not differ that much, but I'd still wait for Hyper's async stuff to stabilize.\n\nI think you mean #450 in particular, I just don't know how Hyper's API will develop.\n. You could argue though that we shouldn't let development stall while Hyper's figuring out how to do async.\n. Great!. Yes it is.\n. You can just do `Response::with(body_buffer)`.\n. @flosse any update on this?\n. Closing due to inactivity, ping if anything is unclear.\n. Please ask this on the rust IRC channel or StackOverflow.\n. Do older Rust versions not have this problem?\n\nOn 2 August 2016 17:11:52 CEST, BenjaminGill-Metaswitch notifications@github.com wrote:\n\n> As of rustc 1.12.0-nightly (7333c4ac2 2016-07-31), iron 0.3 as\n> downloaded by nightly Cargo fails to compile with the following error:\n> \n> ```\n> $ cargo build\n>    Updating registry `https://github.com/rust-lang/crates.io-index`\n> Downloading iron v0.3.0\n> error: unable to get packages from source\n> \n> Caused by:\n> failed to parse manifest at\n> `/home/centos/.cargo/registry/src/github.com-1ecc6299db9ec823/iron-0.3.0/Cargo.toml`\n> ```\n> \n> As far as I can tell, this is due to `plugin = \"0.2*\"` in Cargo.toml -\n> removing the `*` causes it to compile again quite happily. This was\n> fixed in 16c858ec2901e2992fe5e529780f59fa8ed12903 - I don't know how\n> this is still present in the version that cargo automatically\n> downloads.\n> \n> Might it be possible to get a v0.3.1 released with this fixed?\n> \n> ---\n> \n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/471\n\n## \n\nSent from my Android device with K-9 Mail. Please excuse my brevity.\n. I'm unable to reproduce this. I can't find the broken version specifier at either [the git repo](https://github.com/rust-lang/crates.io-index/blob/master/ir/on/iron) or [the frontend](https://crates.io/crates/iron/0.3.0)\n. Sorry, nevermind.\n. This is a bug because the hyper status representation changed.\n. Thanks!\n. I can imagine using Into instead of `into_generic_url` though. AsRef would probably be useful.\n. Would you say that implementing `From<url::Url>`, `Into<url::Url>` and `AsRef<url::Url>` is preferrable? Should I remove the redundant methods or leave those that are already in a stable release?\n. > But using existing, idiomatic methods such as Into etc would definitely be preferable for new functions.\n\nI agree.\n\n> it'd be awesome if we could have both ways.\n\nI disagree, I don't think we should duplicate the API, and deprecate the existing methods.\n\nI pushed a commit to show what I mean.\n. We can't actually implement `From<url::Url>` because `from_generic_url` returns a `Result` and may fail. `TryFrom` is unfortunately not stable.\n. Do we agree though that `into_generic_url` should be deprecated? @reem Any comments?\n. @reem I think this is ready to merge.\n. I'll just go ahead...\n. It appears listening on `localhost` makes Iron listen to the IPv6 address on your machine, but not the IPv4 one. `curl` will first try IPv6 for resolving `localhost`, but obviously not for `127.0.0.1`.\n\nSo _I think_ the difference between Iron and your other services is that Iron will resolve to IPv6 by default while your other services use IPv4. I imagine if you try `curl http://[::1]:<port>`, it will succeed for Iron but fail for your other services.\n\nA quick fix for this behavior is to remove the entry for `::1` from your `/etc/hosts` (adding `::1 localhost` to mine makes me able to reproduce this), but I wonder why there are local differences between several applications wrt preference of IPv4 vs IPv6.\n. That should be a BeforeMiddleware and probably also its own crate. I have one here: https://github.com/untitaker/mysteryshack/blob/master/src/mysteryshack/web/utils.rs#L22\n. Also this thing is possibly incomplete, e.g. it only modifies the request URI and not the `Host` header too.\n. Yes it appears so, though in the meantime multiple packages for this may exist. If one could compile a list, we can close this.\n\nOn 10 May 2017 00:33:10 GMT+02:00, Guillem Llompart <notifications@github.com> wrote:\n>Hi\n>\n>Is this still open pending?\n>\n>-- \n>You are receiving this because you commented.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/481#issuecomment-300320962\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. Thanks!\n. If you build Iron with the `ssl` feature, you get the `https` method which takes a path to certificate and key.\n\n@reem I'd like to modify the iron-bot script to add the ssl feature for docs, could it be moved to the iron org?\n. I don't think `docs.rs` is any more flexible. I doubt that you can configure features at all.\n. We already had it on by default, with the effect that it was impossible to disable because every extension implicitly depended on it when depending on standard Iron.\n\nOn 6 October 2016 22:59:47 CEST, Andrew Hobden notifications@github.com wrote:\n\n> (I'd be willing to argue that a feature such as `https` should be\n> opt-out rather than opt-in)\n> \n> ## \n> \n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/483#issuecomment-252086996\n\n## \n\nSent from my Android device with K-9 Mail. Please excuse my brevity.\n. I fixed up the ssl feature stuff, but it appears deployment in general fails, see the current travis build: https://travis-ci.org/iron/iron/jobs/173813466#L1279\n. Do other clients work while the JVM client fails?\n\nOn Thu, Sep 29, 2016 at 11:54:30PM -0700, Jeremy Mawson wrote:\n\n> ```\n> git clone https://github.com/iron/iron.git\n> (cd iron && cargo run --example hello)\n> ```\n> \n> ```\n> $ curl \"http://localhost:3000/\"\n> Hello world!\n> ```\n> \n> but\n> \n> ```\n> $ scala\n> scala> scala.io.Source.fromURL(\"http://localhost:3000/\").mkString\n> java.net.ConnectException: Connection refused\n> ```\n> \n> I found this issue when my own Iron app suddenly stopped accepting requests. I raised a [stackoverflow question](http://stackoverflow.com/questions/39781623/localhost-iron-server-curl-connects-but-scala-cannot), but then it started working again. A few hours later, the app is no longer accepting requests from the JVM once more.\n> - OSX 10.11.6\n> - cargo 0.13.0-nightly (9399229 2016-09-14)\n>   also tested with\n> - cargo 0.13.0-nightly (19cfb67 2016-09-28)\n> \n> ## \n> \n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/484\n. Cool stuff, thanks.\n. This is a bug in Hyper's Host header parsing iff curl behavior is correct.\n. And curl's behavior is apparently correct.\n. Please test with https://github.com/hyperium/hyper/pull/946\n. `master` would be irrelevant, but it has been merged into a maintenance branch as well. Can anybody confirm this issue is fixed?. Since the two examples only differ in a single line I think it makes sense to include both lines in the same file (one commented out, or in a different handler...?), like you already did in one of the files for a third alternative. _Another_ alternative is to use the `mime!` macro...\n\nIn the end we might focus on two usecases: Passing mimetype from other sources (therefore parsing from a string) and having a hardcoded one.\n. I think using router for this example removes the \"minimal\" aspect from it. I'd rather make just different handlers that all do the same thing in different ways, and serve only one of them (with a comment that the other handlers are alternatives)\n. Thanks! I misread the code...\n. Ah, I misread the code.\n\nOn 25 October 2016 15:19:36 CEST, Andreas Sommer notifications@github.com wrote:\n\n> AndiDog commented on this pull request.\n> \n> > fn main() {\n> > -    Iron::new(|_: &mut Request| {\n> > -        let content_type =\n> >   \"application/json\".parse::<Mime>().unwrap();\n> > -        Ok(Response::with((content_type, status::Ok, \"{}\")))\n> > -    }).http(\"localhost:3000\").unwrap();\n> > -    let args: Vec<String> = env::args().collect();\n> > -    let variant_index = if args.len() > 1 { args[1].parse().unwrap() }\n> >   else { 1 };\n> \n> You mean for the integer parsing? I'd rather have it scream out loud if\n> the user passes an invalid value.\n> \n> ## \n> \n> You are receiving this because you commented.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/pull/489\n\n## \n\nSent from my Android device with K-9 Mail. Please excuse my brevity.\n. Lgtm\n. Thanks for this PR, however I don't understand, why is this more realistic?\n. Ah, the import of routing fails, I think this PR should be filed against the routing repo since the crate is available there.\n. You mean your PR?\n. There's an example in the routing repo.\n. Fair enough, thanks.\n. Redis is unfinished yet in my library. It doesn't actually do anything yet\n. I tend to agree with you for e.g. web frameworks in Python or other higher-level languages, but keep in mind that the usecases for Rust web applications are likely to be different. If one were to write an API server, that middleware may be completely unnecessary and slow down compiletime at best, bloat binaries at worst.\n. Also I'm trying to minimize the waste of time here by moving as much as possible into the iron org, where it can be more easily found and effort focused.\n. Though I probably wouldn't have anything against including params/urlencoded/body-parser into iron, as most of those are not that large.\n. That library is acting on a different level though. The session libraries only allow you to set key-value data on the user session, this implements an entire auth layer\n. Not entirely sure what you're looking for, just added a barebones login example: https://github.com/untitaker/iron-sessionstorage/blob/master/examples/login.rs\n. I moved iron-sessionstorage to the iron org but am hesitant to remove the old library. I also can't really rename it to \"session\" because otherwise we need a different name on crates.io.\n. I think it was intended to lkeep the middleware system independent of Chain, but I don't think there's much value to doing that anyway.\n\nHowever, if you want to arbitrarily modify the chain, I rather recommend passing the chain as mutable reference _to_ your library, instead of passing your middleware to the chain. Instead of exporting a middleware, you'd export a function or method that takes a `&mut Chain` and modifies it.\n. Ah, yeah. I think we should totally link to this on the website (but not in this repo)\n. That's the job of Hyper, please refer to https://github.com/hyperium/hyper/issues/304. If Hyper supports it, we can reopen this issue if Iron needs modification.\n. Middlewares would still be applied in order.\n. #523 updates to async Hyper, for now just using a threadpool. I recommend using `error-chain` for proper errorhandling. Creating simple stringly-typed errors is an antipattern (not specific to Rust), and error-chain helps with that.. Cool beans, thanks. We now use docs.rs. Unfortunately this link doesn't work, but the base URL `/doc/urlencoded/` does at least.. Now everything redirects to docs.rs! Two things need to be done:\r\n\r\n* Remove `build-docs.sh` from all CI configurations\r\n* Add missing redirects. Thanks!. Can we re-add the tests for this in Travis?. Thanks!. It would be, but that's backwards-incompatible.. I guess this is backwards-incompatible if you pattern-match the entire struct, but I don't think that's a common thing to do, so I would've passed it off as okay.\r\n\r\nFair point about #510.. @sfackler feel free to write the API change to accessors in a new PR.. Thanks!. Done. By the way, Hyper's testsuite has been failing for a while now, according to Travis. What's up with that?. Thanks!. oh, cc @reem I think. I don't see a reason either why ResponseBody should persist, but perhaps there's a need for some reason we're missing.. Thanks, I'll wait 1-2 days until I do a bugfix release (perhaps there are more things I've missed).. Yeah that's a breaking change. We can merge it into master, but not any of the maintenance branches.. Thanks!. > I think the original path has to be passed to /login as a parameter like /login/:target, and the handler for /login extracts it and redirects. Can url segment parameters like this contain  slashes or should it be a URL encoded GET parameter? \n\nThat is correct, though you would rather use a query parameter (the part after\nthe ?) for this. Look at how GitHub does it, for example.\n. You're most likely listening on `127.0.0.1` when you have to listen on `0.0.0.0`.. Then it is perhaps a firewall from Windows?. Do you have a comparable experience with any other development server? Such as\n`python3 -mhttp.server`.\n\nOn Thu, Jan 19, 2017 at 01:36:34PM -0800, Boscop wrote:\n> No, I had that problem before, but then I allowed the exe on both private and public networks.\n> Before that I got `ERR_CONNECTION_TIMED_OUT` on the phone (refused to connect), after that I got the content, but in some cases it fails and only loads the site to ~75% before this error happens. Then I refresh and it succeeds. I definitely think it's not a firewall issue.\n> \n> -- \n> You are receiving this because you commented.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/518#issuecomment-273906193\n. >This project can't be served with a simple file server because it's using maud to render the html and needs db access etc.\r\n\r\nSure, but I meant to test whether this is a network problem. So which project you choose wouldn't matter. Python's builtin server is very slow, that is known.\r\n\r\nI don't know what's wrong with it. Could you check whether this happens with other Hyper-based frameworks, or whether this problem occurs with clients other than the laptop it's running on and your smartphone?. Neat, thanks!. I'm unsure about this. I don't think the API docs are the right place for this.. To be honest I don't really understand wny Iron needs to document this. You can't pass `request.body` directly because that would destructure the request. You can't pass `&request.body` because you need to modify the body to be able to read it.\r\n\r\nThis is one of those things that naturally results out of how ownership works in Rust. I don't think Iron's API docs are the correct place to put this. I suppose we could have an example just for this though.. This is excellent! I think for now we can definetly use a threadpool and maybe introduce async handlers at a later point as per #446.. However, the tests fail because the https parts are no longer implemented.. I think we should postpone the `AsyncHandler` to a different PR. Before Hyper 0.10, the entire `https` function wasn't available without a SSL feature flag. I suppose it's time to bring this back and make `tokio_tls` an optional dependency.\r\n\r\nThe rest of your changes feels quite a bit over my head, perhaps somebody else can review them.. @reem @Hoverbear please review. Again I'd like somebody else to review this as well.... Yeah we should get this merged and released soon. However I think this is outside of my expertise.\n\nOn 17 June 2017 11:17:44 GMT+02:00, Ning Sun <notifications@github.com> wrote:\n>Hyper 0.11 has been released. What's the status of this?\n>\n>-- \n>You are receiving this because you were mentioned.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/pull/523#issuecomment-309203894\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. All of the above are fine, though having multiple processes on the same machine appears to be overkill for me (the server really restarts fast enough).. Fixed, thanks!. Feel free to open a PR and cc me\n\nOn Wed, Apr 12, 2017 at 06:56:53AM -0700, Yves Dorfsman wrote:\n> Is there a reason why iron/iron code does not comply with rustfmt format?\n> \n> It means that those of us who use rustfmt plug-ins have to disable the plug-ins from our editors before we can work on this project. It also open space for discussions about style...\n> \n> I'm happy to create a Pull Request for this, but first want to know if there's a reason for not using it.\n> \n> -- \n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/532\n. agreed with @dorfsmay, this could be done in either order. It doesn't matter tbh.. With which iron app did you test that?. I don't get those stats on my local machine using the same command as you did. Can you access the URL you used for wrk from your browser? This may be one of those issues where Iron listens to the  ipv6 localhost (`[::1]`), but wrk sends their request to ipv4 localhost (`127.0.0.1`). Replace `localhost` with an IP address (`127.0.0.1`), both in your app and the wrk command to work around this.. Steven: I thought that too, but since the helloworld example is not using a\nrouter, it accepts any URL path.\n\nOn Thu, Apr 13, 2017 at 10:49:21AM -0700, Steven Fackler wrote:\n> http://127.0.0.1:3000/name/foo is going to hit a 404, which is not a 2xx or 3xx response code.\n> \n> -- \n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/534#issuecomment-293973311\n. Ah, but you are right for the example @Eilie posted.. Great to hear, and no problem :)\n\nOn April 13, 2017 8:11:15 PM GMT+02:00, Eilie <notifications@github.com> wrote:\n>Closed #534.\n>\n>-- \n>You are receiving this because you were mentioned.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/534#event-1042363390\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. That website is hosted at https://github.com/iron/iron.github.io\r\n\r\nI think we could add some links to third-party tutorials until we have a dedicated website for this.. If you have the time to create a new website I would apprechiate it! The problem with the current one is that it is IMO barely extensible. We should switch to a popular static site generator.. I dont understand what you mean. We already use markdown, partially.\n\nOn April 14, 2017 4:14:22 PM GMT+02:00, Yves Dorfsman <notifications@github.com> wrote:\n>I'd go one step further, let's pic a popular markup in order not to be\n>coupled with a tool.\n>\n>Any suggestions?\n>\n>-- \n>You are receiving this because you commented.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/535#issuecomment-294160606\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. We will need to settle for some generator whether we like it or not. AFAIK\nMarkdown doesn't have any syntax for e.g. cross references.\n\nI had Hugo or Lektor in mind, but I don't know which one would be more popular.\n\nOn Fri, Apr 14, 2017 at 07:22:46AM -0700, Yves Dorfsman wrote:\n> What I meant was to be careful not getting into specialized markup that comes, and can only be rendered, with a specific tool. Any suggestion for a tool?\n> \n> -- \n> You are receiving this because you commented.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/535#issuecomment-294161941\n. It is GitHub pages, but we can use Travis to build anything.. There is no official, but if you ask on the /r/rust subreddit I'm sure somebody\nwill be happy to give you a very detailed answer on what's wrong with Iron's\ndocs :)\n\nOn Sat, Apr 15, 2017 at 11:03:15AM -0700, Bryan Tan wrote:\n> Is there an issue tracking a list of things to be documented? I'd like to contribute, but I'm not quite sure where to begin.\n> \n> -- \n> You are receiving this because you commented.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/535#issuecomment-294308828\n. The most current session management crate is `iron-sessionstorage`. The other ones are unmaintained.. I just updated the README for this. Please point out other bad links.. Iron has structs for Cookie and Set-Cookie if that is the kind of low-level access you need. Otherwise I don't see why you can't use iron-sessionstorage for the usecases you described. It exposes a key-value storage interface that supports the operations you want, and it can be set up to use signed cookies underneath.\n\nWhere did you find the URL for iron-sessionstorage that doesn't work?\n\nOn April 15, 2017 4:51:23 PM GMT+02:00, Yves Dorfsman <notifications@github.com> wrote:\n>I cloned the iron-session repo, \"cargo doc\" and went through it's\n>documentation.\n>\n>There is no easy was to get the value of a cookie outside of a session.\n>Cookies are used for a lot of things outside session, turning feature\n>flags on, routing in blue/green environment, etc...\n>\n>Also, cookies are just a form of sepcialised header. As far as I am\n>concerned, iron/headers is missing the concept of cookies. It deals\n>with the http header/concept of \"Set-Cookie\" with\n>https://docs.rs/iron/0.5.1/iron/headers/struct.SetCookie.html but does\n>not deal at all with http header/concept of \"Cookie\", even though it is\n>one of the most used header on the internet!\n>\n>Can we add that concept directly into iron/headers? Are there any\n>strong objections to it (don't want to waste time on a PR that'll be\n>rejected on philosophical ground)?\n>\n>-- \n>You are receiving this because you modified the open/close state.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/536#issuecomment-294297974\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. BTW the correct doc url for iron-sessionstorage is https://docs.rs/iron-sessionstorage\n\nOn Sat, Apr 15, 2017 at 07:51:23AM -0700, Yves Dorfsman wrote:\n> I cloned the iron-session repo, \"cargo doc\" and went through it's documentation.\n> \n> There is no easy was to get the value of a cookie outside of a session. Cookies are used for a lot of things outside session, turning feature flags on, routing in blue/green environment, etc...\n> \n> Also, cookies are just a form of sepcialised header. As far as I am concerned, iron/headers is missing the concept of cookies. It deals with the http header/concept of \"Set-Cookie\" with https://docs.rs/iron/0.5.1/iron/headers/struct.SetCookie.html but does not deal at all with http header/concept of \"Cookie\", even though it is one of the most used header on the internet!\n> \n> Can we add that concept directly into iron/headers? Are there any strong objections to it (don't want to waste time on a PR that'll be rejected on philosophical ground)?\n> \n> -- \n> You are receiving this because you modified the open/close state.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/536#issuecomment-294297974\n. On Sat, Apr 15, 2017 at 08:46:51AM -0700, Yves Dorfsman wrote:\n> I must be missing something. I hate to ask for things I should be able to find myself, but can you point me to Iron's struct for \"cookie\"?\n\nhttps://docs.rs/iron/0.5.1/iron/headers/struct.Cookie.html\n\nI recommend using the search on the site itself, it has worked well for me.\n\n> \n> I cannot find it in the doc. I did a fetch/pull on iron and \"ag -i cookie\" is not return anything.\n> \n> -- \n> You are receiving this because you modified the open/close state.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/536#issuecomment-294301197\n. Fantastic, thanks for that!. Thanks!. Yes it should be here. Headers are case-insensitive.. Right, we should probably reexport unicase from hyper. We cannot prevent unicase types being \"leaked\", they're public API even if just for `Eq`. I would prefer adding a new section for 3rdparty packages to the README. BTW, `iron-sessionstorage` already exists, we should join forces on this one. I released Iron 0.6.0, please file PRs with me in cc for extension updates.\n\nOn Mon, Oct 30, 2017 at 02:46:15AM +0000, cetra3 wrote:\n> What's the status of this request? Looks like the urlencoded stuff has been resolved?\n> \n> -- \n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/551#issuecomment-340329879\n. Thanks!. I think this can be closed since handlebars-iron seems to work fairly well.\n. I've written [mysteryshack](https://github.com/untitaker/mysteryshack), a small server implementing [remoteStorage](http://remotestorage.io/). Rough scope:\n- Basic user and session management\n- JSON API + very small subset of OAuth\n- Administration interface for OAuth tokens\n\nAs an intermediate step we could clone http://flask.pocoo.org/community/poweredby/ using a wiki or doc page.\n. You can do `response.set(file_object)`. See http://ironframework.io/doc/modifier/trait.Modifier.html for other types you can pass to `response.set` (see \"Implementors\" section)\n. As far as I can tell you can just use [std::io::copy](https://doc.rust-lang.org/std/io/fn.copy.html) for this?\n. I think we rather need something like greenkeeper for Rust.\n. Sorry, closed wrong issue.\n. I made those fields private in https://github.com/iron/iron/commit/e88a4f3a915ed726ae3a45ecefbac3952afda421\n. is this still an issue?\n. Closing because this is neither reproducible nor an active thread.\n. what @zr40 said.\n. Excellent, thanks!\n. Shall we close this then?\n\nOn 1 December 2015 18:16:07 CET, Andrii Dmytrenko notifications@github.com wrote:\n\n> Updated crates, now performance is back to normal (Requests/sec: \n> 80339.57)\n> \n> Crates updated:\n> \n> ```\n>    Updating cookie v0.1.21 -> v0.2.2\n>    Updating gcc v0.3.19 -> v0.3.20\n>    Updating hyper v0.6.16 -> v0.7.0\n>    Updating iron v0.2.4 -> v0.2.5\n>    Updating language-tags v0.0.7 -> v0.2.0\n>    Removing libc v0.1.12\n>    Updating log v0.3.3 -> v0.3.4\n>    Updating num_cpus v0.2.9 -> v0.2.10\n>    Updating openssl v0.6.7 -> v0.7.1\n>    Updating openssl-sys v0.6.7 -> v0.7.1\n>      Adding openssl-sys-extras v0.7.1\n>    Updating url v0.2.38 -> v0.5.0\n> ```\n> \n> I suspect it was hyper update, which fixed the regression.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/396#issuecomment-161037258\n\n## \n\nSent from my phone. Please excuse my brevity.\n. I strongly suspect that this has something to do with keepalive-support being reenabled. Are there noticable differences in performance if you don't make any use of keepalive?\n. Might be closed in favor of https://github.com/hyperium/hyper/pull/676\n. Actually I don't see a reason why we should ever use catch_panic. The current behavior would work fine in any case.\n\nI think I muttered something about custom error handlers in IRC, but we really shouldn't encourage to control flow with panics.\n. Are there any appropriate markers that we can apply to the deprecated function?\n. Done, also I changed the default modifier of some_or.\n. Ok, **now** I'm done.\n\nThe idea here is to use `itry` for internal operations, and `some_or` for parsing the request.\n- `itry!(write_to_db())`\n- `some_or!(get_a_url_param())`\n\nSince this is not really a hard requirement in any way, I'm not sure whether to include this into the docs.\n. Added a note.\n. Also I think I'm going to rework the examples...\n. there, I also updated the examples. I didn't find a good usecase for `some_or`, to build a better example I'd have to pull in `urlencoded`.\n. We need a better name for `some_or`. Perhaps `iexpect`?\n. renamed to `iexpect`.\n. @reem any update?\n. \\o/\n. Perhaps this is the way to go, yes. @reem?\n. I don't think there's any other change required.\n\nReverting all those `default-features = false` PRs is not required to make this work, although I suppose it should be done at some point.\n. Not sure why we don't export everything from `iron::iron`. @reem?\n. Seems reasonable, thank you!\n. Nice @sfackler!. Already fixed by https://github.com/iron/iron/commit/ed0b849656189365e2b6241708c85c2b1a824f68\n. The only reference @cmr gave me in https://github.com/sunng87/handlebars-iron/issues/27 is [this Quora answer by a Google engineer](https://www.quora.com/Does-the-MIT-license-require-attribution-in-a-binary-only-distribution), which doesn't even confirm what he is trying to prove. Instead the author there says it's \"just the right thing to do\" to credit the dependencies' author in the UI.\n\nThe other \"case study\" he vaguely mentioned are Android apps that have MIT dependencies:\n\n> see many google android apps with long lists of MIT attributions\n\nbut the apps that I have seen give credits to all dependencies, MIT-licensed or not.\n\nFurthermore I have a serious problem with how this proposal is formulated, and the rhetoric used to convice crate authors to switch licenses. @cmr claims [MIT-licensed libraries will not be used in software at all](https://github.com/untitaker/rust-atomicwrites/issues/11#issuecomment-170365577):\n\n> the actual implication is that your crate won't get used in dual MIT/Apache-2.0 codebases, which is largely what the Rust ecosystem has settled on.\n\nand makes it seem like the choice of MIT/Apache is a dogma in the Rust community. In [another issue](https://github.com/SimonSapin/rust-forest/issues/3), he paddles back, saying it's a rather \"theoretical problem\".\n\nApart from that I have never seen anybody else make comparably strong claims. It's never been an issue in any software I've ever worked on, and enough software with MIT-dependencies (or 3-clause BSD, which has similar conditions)  is deployed without replicating the copyright claims in their GUIs.\n. I think the whole thing is ~~unproven to be relevant.~~ actually provably irrelevant in practice.\n\nThat said, I do not care how my (minor) contributions are (re-)licensed.\n. What information in particular do you want from Hyper's datastructures?\n. @frjonsen I think your bug is valid but not related to this issue. Please create a new issue though\n\nOn 10 March 2017 12:04:28 CET, \"Fredrik Jons\u00e9n\" <notifications@github.com> wrote:\n>Ah, yes, I see now I went through the issue a bit quickly, as it seemed\n>similar enough to the issue I was having. Sorry about that.\n>\n>-- \n>You are receiving this because you were mentioned.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/425#issuecomment-285641606\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. Thanks!\n. I think this can be closed then.\n. @reem? LGTM\n. I feel like an API like this would be less Java-esque:\n\n```\nlet iron = Iron::new(h);\niron.protocol(Http);\niron.addr(...);\niron.hyper_server(...)  // The actual new functionality\niron.listen();\n```\n\nSince the existing methods `http`, `https` and `listen_with` all consume `self`, they can modify the `Iron` instance at will.\n. On mobile, if the link works im :+1:\n. Thanks!\n. Thanks!\n. what @KalitaAlexey said. With that, I don't think there's anything actionable here.\n. Thanks!\n. [`iron::Request`](http://ironframework.io/doc/iron/request/struct.Request.html) has a `headers` field, whose type is from [hyper](http://hyper.rs/hyper/hyper/header/struct.Headers.html).\n\n```\nrequest.headers.get::<iron::headers::ContentType>()\n```\n\nThis will return an instance of this struct: http://ironframework.io/doc/iron/headers/struct.ContentType.html\n. ...what?\n. How is the performance test invalid because of this processor?\n. Ah, now I understand. From the page:\n\n> Total Number of Threads: 12\n\nThis refers to the amount of POSIX threads the Iron server spawns.\n\nYou are claiming this is outdated/wrong/invalid because the Intel page claims that this Intel CPU has only 8 threads.\n\nThis is not relevant though: You can spawn as many POSIX threads as you like, independent of the CPU.\n. We could add a default implementation for `T: Iterator<Item=String>` or something like that.\n. There were also a few releases inbetween, so `cargo update` probably should fix this issue automatically. However, I wonder if we should explicitly require at least the `0.9.x` release that brought this fix.\n. Bump, does upgrading hyper fix this?\n. Please post your Cargo.lock.. Ok, I assume this is fixed in the async branch of hyper and will be fixed when that is released.. I'm unsure about just reading in all the data. This seems like it would have severe perf impact in some situations (like rejecting massive file upload due to failed precondition or missing permissions). Thanks!\n. We might as well rename this issue. :)\n. https://github.com/iron/iron/issues/501 here you go\n. Mutability is a property of variables in Rust, not types (except maybe for pointer types).\n\nYou can use `response.set_mut` to add modifiers to the response (Like the ones you pass to `Response::with` or `Response::set`).\n. The docs in ironframework.io seem to be out of sync.\n. I don't know (not Iron's issue tbh), but perhaps it can't deal with `use-as`: https://github.com/iron/iron/blob/master/src/lib.rs#L95\n. Pluggable is reexported though. The other way around, Pluggable is exported as Plugin. Also the reexport is at the top-level, see src link earlier.. Ok, so this is a docs issue. Ftr Pluggable is exported at top-level and within the prelude, both times under the name Plugin.. Renaming API because of possible bugs in the compiler (and rustdoc) sounds unappealing. This name has been like that forever, so I have no idea what caused the docs to end up like that.. If we merge this, I wonder if we would have to nuke this API again when we refactor the entire thing for Hyper 0.10 (async API).\n. :+1:. Contrary I don't think that it should be possible to release a new Iron version where such lints fail (improved or not).\n\nI see that the Cargo issue got closed.\n. IIRC @reem mentioned that he wanted to refactor the API around Iron requests/urls as well, I hope this will eliminate all those costly conversions.\n. I was thinking more about how creating and returning responses (especially streaming responses) would work within handlers. `.listen`, `.https` etc may not differ that much, but I'd still wait for Hyper's async stuff to stabilize.\n\nI think you mean #450 in particular, I just don't know how Hyper's API will develop.\n. You could argue though that we shouldn't let development stall while Hyper's figuring out how to do async.\n. Great!. Yes it is.\n. You can just do `Response::with(body_buffer)`.\n. @flosse any update on this?\n. Closing due to inactivity, ping if anything is unclear.\n. Please ask this on the rust IRC channel or StackOverflow.\n. Do older Rust versions not have this problem?\n\nOn 2 August 2016 17:11:52 CEST, BenjaminGill-Metaswitch notifications@github.com wrote:\n\n> As of rustc 1.12.0-nightly (7333c4ac2 2016-07-31), iron 0.3 as\n> downloaded by nightly Cargo fails to compile with the following error:\n> \n> ```\n> $ cargo build\n>    Updating registry `https://github.com/rust-lang/crates.io-index`\n> Downloading iron v0.3.0\n> error: unable to get packages from source\n> \n> Caused by:\n> failed to parse manifest at\n> `/home/centos/.cargo/registry/src/github.com-1ecc6299db9ec823/iron-0.3.0/Cargo.toml`\n> ```\n> \n> As far as I can tell, this is due to `plugin = \"0.2*\"` in Cargo.toml -\n> removing the `*` causes it to compile again quite happily. This was\n> fixed in 16c858ec2901e2992fe5e529780f59fa8ed12903 - I don't know how\n> this is still present in the version that cargo automatically\n> downloads.\n> \n> Might it be possible to get a v0.3.1 released with this fixed?\n> \n> ---\n> \n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/471\n\n## \n\nSent from my Android device with K-9 Mail. Please excuse my brevity.\n. I'm unable to reproduce this. I can't find the broken version specifier at either [the git repo](https://github.com/rust-lang/crates.io-index/blob/master/ir/on/iron) or [the frontend](https://crates.io/crates/iron/0.3.0)\n. Sorry, nevermind.\n. This is a bug because the hyper status representation changed.\n. Thanks!\n. I can imagine using Into instead of `into_generic_url` though. AsRef would probably be useful.\n. Would you say that implementing `From<url::Url>`, `Into<url::Url>` and `AsRef<url::Url>` is preferrable? Should I remove the redundant methods or leave those that are already in a stable release?\n. > But using existing, idiomatic methods such as Into etc would definitely be preferable for new functions.\n\nI agree.\n\n> it'd be awesome if we could have both ways.\n\nI disagree, I don't think we should duplicate the API, and deprecate the existing methods.\n\nI pushed a commit to show what I mean.\n. We can't actually implement `From<url::Url>` because `from_generic_url` returns a `Result` and may fail. `TryFrom` is unfortunately not stable.\n. Do we agree though that `into_generic_url` should be deprecated? @reem Any comments?\n. @reem I think this is ready to merge.\n. I'll just go ahead...\n. It appears listening on `localhost` makes Iron listen to the IPv6 address on your machine, but not the IPv4 one. `curl` will first try IPv6 for resolving `localhost`, but obviously not for `127.0.0.1`.\n\nSo _I think_ the difference between Iron and your other services is that Iron will resolve to IPv6 by default while your other services use IPv4. I imagine if you try `curl http://[::1]:<port>`, it will succeed for Iron but fail for your other services.\n\nA quick fix for this behavior is to remove the entry for `::1` from your `/etc/hosts` (adding `::1 localhost` to mine makes me able to reproduce this), but I wonder why there are local differences between several applications wrt preference of IPv4 vs IPv6.\n. That should be a BeforeMiddleware and probably also its own crate. I have one here: https://github.com/untitaker/mysteryshack/blob/master/src/mysteryshack/web/utils.rs#L22\n. Also this thing is possibly incomplete, e.g. it only modifies the request URI and not the `Host` header too.\n. Yes it appears so, though in the meantime multiple packages for this may exist. If one could compile a list, we can close this.\n\nOn 10 May 2017 00:33:10 GMT+02:00, Guillem Llompart <notifications@github.com> wrote:\n>Hi\n>\n>Is this still open pending?\n>\n>-- \n>You are receiving this because you commented.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/481#issuecomment-300320962\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. Thanks!\n. If you build Iron with the `ssl` feature, you get the `https` method which takes a path to certificate and key.\n\n@reem I'd like to modify the iron-bot script to add the ssl feature for docs, could it be moved to the iron org?\n. I don't think `docs.rs` is any more flexible. I doubt that you can configure features at all.\n. We already had it on by default, with the effect that it was impossible to disable because every extension implicitly depended on it when depending on standard Iron.\n\nOn 6 October 2016 22:59:47 CEST, Andrew Hobden notifications@github.com wrote:\n\n> (I'd be willing to argue that a feature such as `https` should be\n> opt-out rather than opt-in)\n> \n> ## \n> \n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/483#issuecomment-252086996\n\n## \n\nSent from my Android device with K-9 Mail. Please excuse my brevity.\n. I fixed up the ssl feature stuff, but it appears deployment in general fails, see the current travis build: https://travis-ci.org/iron/iron/jobs/173813466#L1279\n. Do other clients work while the JVM client fails?\n\nOn Thu, Sep 29, 2016 at 11:54:30PM -0700, Jeremy Mawson wrote:\n\n> ```\n> git clone https://github.com/iron/iron.git\n> (cd iron && cargo run --example hello)\n> ```\n> \n> ```\n> $ curl \"http://localhost:3000/\"\n> Hello world!\n> ```\n> \n> but\n> \n> ```\n> $ scala\n> scala> scala.io.Source.fromURL(\"http://localhost:3000/\").mkString\n> java.net.ConnectException: Connection refused\n> ```\n> \n> I found this issue when my own Iron app suddenly stopped accepting requests. I raised a [stackoverflow question](http://stackoverflow.com/questions/39781623/localhost-iron-server-curl-connects-but-scala-cannot), but then it started working again. A few hours later, the app is no longer accepting requests from the JVM once more.\n> - OSX 10.11.6\n> - cargo 0.13.0-nightly (9399229 2016-09-14)\n>   also tested with\n> - cargo 0.13.0-nightly (19cfb67 2016-09-28)\n> \n> ## \n> \n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/484\n. Cool stuff, thanks.\n. This is a bug in Hyper's Host header parsing iff curl behavior is correct.\n. And curl's behavior is apparently correct.\n. Please test with https://github.com/hyperium/hyper/pull/946\n. `master` would be irrelevant, but it has been merged into a maintenance branch as well. Can anybody confirm this issue is fixed?. Since the two examples only differ in a single line I think it makes sense to include both lines in the same file (one commented out, or in a different handler...?), like you already did in one of the files for a third alternative. _Another_ alternative is to use the `mime!` macro...\n\nIn the end we might focus on two usecases: Passing mimetype from other sources (therefore parsing from a string) and having a hardcoded one.\n. I think using router for this example removes the \"minimal\" aspect from it. I'd rather make just different handlers that all do the same thing in different ways, and serve only one of them (with a comment that the other handlers are alternatives)\n. Thanks! I misread the code...\n. Ah, I misread the code.\n\nOn 25 October 2016 15:19:36 CEST, Andreas Sommer notifications@github.com wrote:\n\n> AndiDog commented on this pull request.\n> \n> > fn main() {\n> > -    Iron::new(|_: &mut Request| {\n> > -        let content_type =\n> >   \"application/json\".parse::<Mime>().unwrap();\n> > -        Ok(Response::with((content_type, status::Ok, \"{}\")))\n> > -    }).http(\"localhost:3000\").unwrap();\n> > -    let args: Vec<String> = env::args().collect();\n> > -    let variant_index = if args.len() > 1 { args[1].parse().unwrap() }\n> >   else { 1 };\n> \n> You mean for the integer parsing? I'd rather have it scream out loud if\n> the user passes an invalid value.\n> \n> ## \n> \n> You are receiving this because you commented.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/pull/489\n\n## \n\nSent from my Android device with K-9 Mail. Please excuse my brevity.\n. Lgtm\n. Thanks for this PR, however I don't understand, why is this more realistic?\n. Ah, the import of routing fails, I think this PR should be filed against the routing repo since the crate is available there.\n. You mean your PR?\n. There's an example in the routing repo.\n. Fair enough, thanks.\n. Redis is unfinished yet in my library. It doesn't actually do anything yet\n. I tend to agree with you for e.g. web frameworks in Python or other higher-level languages, but keep in mind that the usecases for Rust web applications are likely to be different. If one were to write an API server, that middleware may be completely unnecessary and slow down compiletime at best, bloat binaries at worst.\n. Also I'm trying to minimize the waste of time here by moving as much as possible into the iron org, where it can be more easily found and effort focused.\n. Though I probably wouldn't have anything against including params/urlencoded/body-parser into iron, as most of those are not that large.\n. That library is acting on a different level though. The session libraries only allow you to set key-value data on the user session, this implements an entire auth layer\n. Not entirely sure what you're looking for, just added a barebones login example: https://github.com/untitaker/iron-sessionstorage/blob/master/examples/login.rs\n. I moved iron-sessionstorage to the iron org but am hesitant to remove the old library. I also can't really rename it to \"session\" because otherwise we need a different name on crates.io.\n. I think it was intended to lkeep the middleware system independent of Chain, but I don't think there's much value to doing that anyway.\n\nHowever, if you want to arbitrarily modify the chain, I rather recommend passing the chain as mutable reference _to_ your library, instead of passing your middleware to the chain. Instead of exporting a middleware, you'd export a function or method that takes a `&mut Chain` and modifies it.\n. Ah, yeah. I think we should totally link to this on the website (but not in this repo)\n. That's the job of Hyper, please refer to https://github.com/hyperium/hyper/issues/304. If Hyper supports it, we can reopen this issue if Iron needs modification.\n. Middlewares would still be applied in order.\n. #523 updates to async Hyper, for now just using a threadpool. I recommend using `error-chain` for proper errorhandling. Creating simple stringly-typed errors is an antipattern (not specific to Rust), and error-chain helps with that.. Cool beans, thanks. We now use docs.rs. Unfortunately this link doesn't work, but the base URL `/doc/urlencoded/` does at least.. Now everything redirects to docs.rs! Two things need to be done:\r\n\r\n* Remove `build-docs.sh` from all CI configurations\r\n* Add missing redirects. Thanks!. Can we re-add the tests for this in Travis?. Thanks!. It would be, but that's backwards-incompatible.. I guess this is backwards-incompatible if you pattern-match the entire struct, but I don't think that's a common thing to do, so I would've passed it off as okay.\r\n\r\nFair point about #510.. @sfackler feel free to write the API change to accessors in a new PR.. Thanks!. Done. By the way, Hyper's testsuite has been failing for a while now, according to Travis. What's up with that?. Thanks!. oh, cc @reem I think. I don't see a reason either why ResponseBody should persist, but perhaps there's a need for some reason we're missing.. Thanks, I'll wait 1-2 days until I do a bugfix release (perhaps there are more things I've missed).. Yeah that's a breaking change. We can merge it into master, but not any of the maintenance branches.. Thanks!. > I think the original path has to be passed to /login as a parameter like /login/:target, and the handler for /login extracts it and redirects. Can url segment parameters like this contain  slashes or should it be a URL encoded GET parameter? \n\nThat is correct, though you would rather use a query parameter (the part after\nthe ?) for this. Look at how GitHub does it, for example.\n. You're most likely listening on `127.0.0.1` when you have to listen on `0.0.0.0`.. Then it is perhaps a firewall from Windows?. Do you have a comparable experience with any other development server? Such as\n`python3 -mhttp.server`.\n\nOn Thu, Jan 19, 2017 at 01:36:34PM -0800, Boscop wrote:\n> No, I had that problem before, but then I allowed the exe on both private and public networks.\n> Before that I got `ERR_CONNECTION_TIMED_OUT` on the phone (refused to connect), after that I got the content, but in some cases it fails and only loads the site to ~75% before this error happens. Then I refresh and it succeeds. I definitely think it's not a firewall issue.\n> \n> -- \n> You are receiving this because you commented.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/518#issuecomment-273906193\n. >This project can't be served with a simple file server because it's using maud to render the html and needs db access etc.\r\n\r\nSure, but I meant to test whether this is a network problem. So which project you choose wouldn't matter. Python's builtin server is very slow, that is known.\r\n\r\nI don't know what's wrong with it. Could you check whether this happens with other Hyper-based frameworks, or whether this problem occurs with clients other than the laptop it's running on and your smartphone?. Neat, thanks!. I'm unsure about this. I don't think the API docs are the right place for this.. To be honest I don't really understand wny Iron needs to document this. You can't pass `request.body` directly because that would destructure the request. You can't pass `&request.body` because you need to modify the body to be able to read it.\r\n\r\nThis is one of those things that naturally results out of how ownership works in Rust. I don't think Iron's API docs are the correct place to put this. I suppose we could have an example just for this though.. This is excellent! I think for now we can definetly use a threadpool and maybe introduce async handlers at a later point as per #446.. However, the tests fail because the https parts are no longer implemented.. I think we should postpone the `AsyncHandler` to a different PR. Before Hyper 0.10, the entire `https` function wasn't available without a SSL feature flag. I suppose it's time to bring this back and make `tokio_tls` an optional dependency.\r\n\r\nThe rest of your changes feels quite a bit over my head, perhaps somebody else can review them.. @reem @Hoverbear please review. Again I'd like somebody else to review this as well.... Yeah we should get this merged and released soon. However I think this is outside of my expertise.\n\nOn 17 June 2017 11:17:44 GMT+02:00, Ning Sun <notifications@github.com> wrote:\n>Hyper 0.11 has been released. What's the status of this?\n>\n>-- \n>You are receiving this because you were mentioned.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/pull/523#issuecomment-309203894\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. All of the above are fine, though having multiple processes on the same machine appears to be overkill for me (the server really restarts fast enough).. Fixed, thanks!. Feel free to open a PR and cc me\n\nOn Wed, Apr 12, 2017 at 06:56:53AM -0700, Yves Dorfsman wrote:\n> Is there a reason why iron/iron code does not comply with rustfmt format?\n> \n> It means that those of us who use rustfmt plug-ins have to disable the plug-ins from our editors before we can work on this project. It also open space for discussions about style...\n> \n> I'm happy to create a Pull Request for this, but first want to know if there's a reason for not using it.\n> \n> -- \n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/532\n. agreed with @dorfsmay, this could be done in either order. It doesn't matter tbh.. With which iron app did you test that?. I don't get those stats on my local machine using the same command as you did. Can you access the URL you used for wrk from your browser? This may be one of those issues where Iron listens to the  ipv6 localhost (`[::1]`), but wrk sends their request to ipv4 localhost (`127.0.0.1`). Replace `localhost` with an IP address (`127.0.0.1`), both in your app and the wrk command to work around this.. Steven: I thought that too, but since the helloworld example is not using a\nrouter, it accepts any URL path.\n\nOn Thu, Apr 13, 2017 at 10:49:21AM -0700, Steven Fackler wrote:\n> http://127.0.0.1:3000/name/foo is going to hit a 404, which is not a 2xx or 3xx response code.\n> \n> -- \n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/534#issuecomment-293973311\n. Ah, but you are right for the example @Eilie posted.. Great to hear, and no problem :)\n\nOn April 13, 2017 8:11:15 PM GMT+02:00, Eilie <notifications@github.com> wrote:\n>Closed #534.\n>\n>-- \n>You are receiving this because you were mentioned.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/534#event-1042363390\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. That website is hosted at https://github.com/iron/iron.github.io\r\n\r\nI think we could add some links to third-party tutorials until we have a dedicated website for this.. If you have the time to create a new website I would apprechiate it! The problem with the current one is that it is IMO barely extensible. We should switch to a popular static site generator.. I dont understand what you mean. We already use markdown, partially.\n\nOn April 14, 2017 4:14:22 PM GMT+02:00, Yves Dorfsman <notifications@github.com> wrote:\n>I'd go one step further, let's pic a popular markup in order not to be\n>coupled with a tool.\n>\n>Any suggestions?\n>\n>-- \n>You are receiving this because you commented.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/535#issuecomment-294160606\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. We will need to settle for some generator whether we like it or not. AFAIK\nMarkdown doesn't have any syntax for e.g. cross references.\n\nI had Hugo or Lektor in mind, but I don't know which one would be more popular.\n\nOn Fri, Apr 14, 2017 at 07:22:46AM -0700, Yves Dorfsman wrote:\n> What I meant was to be careful not getting into specialized markup that comes, and can only be rendered, with a specific tool. Any suggestion for a tool?\n> \n> -- \n> You are receiving this because you commented.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/535#issuecomment-294161941\n. It is GitHub pages, but we can use Travis to build anything.. There is no official, but if you ask on the /r/rust subreddit I'm sure somebody\nwill be happy to give you a very detailed answer on what's wrong with Iron's\ndocs :)\n\nOn Sat, Apr 15, 2017 at 11:03:15AM -0700, Bryan Tan wrote:\n> Is there an issue tracking a list of things to be documented? I'd like to contribute, but I'm not quite sure where to begin.\n> \n> -- \n> You are receiving this because you commented.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/535#issuecomment-294308828\n. The most current session management crate is `iron-sessionstorage`. The other ones are unmaintained.. I just updated the README for this. Please point out other bad links.. Iron has structs for Cookie and Set-Cookie if that is the kind of low-level access you need. Otherwise I don't see why you can't use iron-sessionstorage for the usecases you described. It exposes a key-value storage interface that supports the operations you want, and it can be set up to use signed cookies underneath.\n\nWhere did you find the URL for iron-sessionstorage that doesn't work?\n\nOn April 15, 2017 4:51:23 PM GMT+02:00, Yves Dorfsman <notifications@github.com> wrote:\n>I cloned the iron-session repo, \"cargo doc\" and went through it's\n>documentation.\n>\n>There is no easy was to get the value of a cookie outside of a session.\n>Cookies are used for a lot of things outside session, turning feature\n>flags on, routing in blue/green environment, etc...\n>\n>Also, cookies are just a form of sepcialised header. As far as I am\n>concerned, iron/headers is missing the concept of cookies. It deals\n>with the http header/concept of \"Set-Cookie\" with\n>https://docs.rs/iron/0.5.1/iron/headers/struct.SetCookie.html but does\n>not deal at all with http header/concept of \"Cookie\", even though it is\n>one of the most used header on the internet!\n>\n>Can we add that concept directly into iron/headers? Are there any\n>strong objections to it (don't want to waste time on a PR that'll be\n>rejected on philosophical ground)?\n>\n>-- \n>You are receiving this because you modified the open/close state.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/iron/iron/issues/536#issuecomment-294297974\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. BTW the correct doc url for iron-sessionstorage is https://docs.rs/iron-sessionstorage\n\nOn Sat, Apr 15, 2017 at 07:51:23AM -0700, Yves Dorfsman wrote:\n> I cloned the iron-session repo, \"cargo doc\" and went through it's documentation.\n> \n> There is no easy was to get the value of a cookie outside of a session. Cookies are used for a lot of things outside session, turning feature flags on, routing in blue/green environment, etc...\n> \n> Also, cookies are just a form of sepcialised header. As far as I am concerned, iron/headers is missing the concept of cookies. It deals with the http header/concept of \"Set-Cookie\" with https://docs.rs/iron/0.5.1/iron/headers/struct.SetCookie.html but does not deal at all with http header/concept of \"Cookie\", even though it is one of the most used header on the internet!\n> \n> Can we add that concept directly into iron/headers? Are there any strong objections to it (don't want to waste time on a PR that'll be rejected on philosophical ground)?\n> \n> -- \n> You are receiving this because you modified the open/close state.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/536#issuecomment-294297974\n. On Sat, Apr 15, 2017 at 08:46:51AM -0700, Yves Dorfsman wrote:\n> I must be missing something. I hate to ask for things I should be able to find myself, but can you point me to Iron's struct for \"cookie\"?\n\nhttps://docs.rs/iron/0.5.1/iron/headers/struct.Cookie.html\n\nI recommend using the search on the site itself, it has worked well for me.\n\n> \n> I cannot find it in the doc. I did a fetch/pull on iron and \"ag -i cookie\" is not return anything.\n> \n> -- \n> You are receiving this because you modified the open/close state.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/536#issuecomment-294301197\n. Fantastic, thanks for that!. Thanks!. Yes it should be here. Headers are case-insensitive.. Right, we should probably reexport unicase from hyper. We cannot prevent unicase types being \"leaked\", they're public API even if just for `Eq`. I would prefer adding a new section for 3rdparty packages to the README. BTW, `iron-sessionstorage` already exists, we should join forces on this one. I released Iron 0.6.0, please file PRs with me in cc for extension updates.\n\nOn Mon, Oct 30, 2017 at 02:46:15AM +0000, cetra3 wrote:\n> What's the status of this request? Looks like the urlencoded stuff has been resolved?\n> \n> -- \n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/iron/iron/issues/551#issuecomment-340329879\n. Thanks!. ",
    "SimonSapin": "> @SimonSapin's rust-url strictly adheres to the WhatWG URL spec, so I don't think we can expect upstream changes for our own convenience.\n\nThat\u2019s not necessarily true, convenience APIs can be added without sacrificing spec conformance. Feel free to file issues on rust-url, what you find annoying is likely to be annoying to other users too. Now, about this specific issue, would something like this help?\n\n``` rust\nimpl Url {\n    /// This takes ownership of / moves the URL.\n    pub fn to_relative_scheme_url(self) -> Result<RelativeSchemeUrl, Url> {\n        match self.scheme_data {\n            RelativeSchemeData(RelativeSchemeData { username, password, host, port, path }) => {\n                Ok(RelativeSchemeUrl {\n                    scheme: self.scheme,\n                    username: username,\n                    password: password,\n                    host: host,\n                    port: port,\n                    path: path,\n                    query: self.query,\n                    fragment: self.fragment,\n                })\n            },\n            _ => Err(self)\n        }\n    }\n}\n\n\npub struct RelativeSchemeUrl {\n    pub scheme: String,\n    pub username: String,\n    pub password: Option<String>,\n    pub host: Host,\n    pub port: String,\n    pub path: Vec<String>,\n    pub query: Option<String>,\n    pub fragment: Option<String>,\n}\n```\n\nThis is basically the fields of `Url` (except `scheme_data`) and `RelativeSchemeData` together in a flat struct.\n\nAs to the port number, [it should be a `u16` integer](https://www.w3.org/Bugs/Public/show_bug.cgi?id=26446) rather than a string. I\u2019m planning to change that in rust-url.\n. > It seems like an enum with structure variants could also work well\n\nFor `Url::scheme_data`? Isn\u2019t the problem having to `match` to access the fields?\n. Without struct-like variants, it could be:\n\n``` rust\nenum Url {\n    RelativeSchemeUrl(RelativeSchemeUrl),\n    NonRelativeSchemeUrl(NonRelativeSchemeUrl),\n}\n\nstruct RelativeSchemeUrl { ... }\nstruct NonRelativeSchemeUrl { ... }\n```\n\nDo you think this would preferable? Since matching is annoying, I made the current design so that at least fields that exist on all URLs (scheme, query, and fragment) are directly fields of `Url`.\n. By the way, I\u2019ve changed the port number to `Option<u16>` https://github.com/servo/rust-url/commit/852d8a90ce6a883c01cb0fd0d99b504de7b18105\n. Parsing of `data` URLs will be a layer on top of the \"main\" URL parser, which will remain unchanged.\n. The goal is not to support all possible schemes in rust-url, but to let you build to let you build your own parsers on top of it. Common or tricky cases like `data` may be included on a case-by-case basis.\n. @reem let me know if/how changing rust-url would help. (Though preferably non-breaking changes at this point.)\n. > @SimonSapin's rust-url strictly adheres to the WhatWG URL spec, so I don't think we can expect upstream changes for our own convenience.\n\nThat\u2019s not necessarily true, convenience APIs can be added without sacrificing spec conformance. Feel free to file issues on rust-url, what you find annoying is likely to be annoying to other users too. Now, about this specific issue, would something like this help?\n\n``` rust\nimpl Url {\n    /// This takes ownership of / moves the URL.\n    pub fn to_relative_scheme_url(self) -> Result<RelativeSchemeUrl, Url> {\n        match self.scheme_data {\n            RelativeSchemeData(RelativeSchemeData { username, password, host, port, path }) => {\n                Ok(RelativeSchemeUrl {\n                    scheme: self.scheme,\n                    username: username,\n                    password: password,\n                    host: host,\n                    port: port,\n                    path: path,\n                    query: self.query,\n                    fragment: self.fragment,\n                })\n            },\n            _ => Err(self)\n        }\n    }\n}\n\n\npub struct RelativeSchemeUrl {\n    pub scheme: String,\n    pub username: String,\n    pub password: Option<String>,\n    pub host: Host,\n    pub port: String,\n    pub path: Vec<String>,\n    pub query: Option<String>,\n    pub fragment: Option<String>,\n}\n```\n\nThis is basically the fields of `Url` (except `scheme_data`) and `RelativeSchemeData` together in a flat struct.\n\nAs to the port number, [it should be a `u16` integer](https://www.w3.org/Bugs/Public/show_bug.cgi?id=26446) rather than a string. I\u2019m planning to change that in rust-url.\n. > It seems like an enum with structure variants could also work well\n\nFor `Url::scheme_data`? Isn\u2019t the problem having to `match` to access the fields?\n. Without struct-like variants, it could be:\n\n``` rust\nenum Url {\n    RelativeSchemeUrl(RelativeSchemeUrl),\n    NonRelativeSchemeUrl(NonRelativeSchemeUrl),\n}\n\nstruct RelativeSchemeUrl { ... }\nstruct NonRelativeSchemeUrl { ... }\n```\n\nDo you think this would preferable? Since matching is annoying, I made the current design so that at least fields that exist on all URLs (scheme, query, and fragment) are directly fields of `Url`.\n. By the way, I\u2019ve changed the port number to `Option<u16>` https://github.com/servo/rust-url/commit/852d8a90ce6a883c01cb0fd0d99b504de7b18105\n. Parsing of `data` URLs will be a layer on top of the \"main\" URL parser, which will remain unchanged.\n. The goal is not to support all possible schemes in rust-url, but to let you build to let you build your own parsers on top of it. Common or tricky cases like `data` may be included on a case-by-case basis.\n. @reem let me know if/how changing rust-url would help. (Though preferably non-breaking changes at this point.)\n. ",
    "ProtectedMode": "You should uncheck \"Logger\" and \"Static File\" since these don't compile. Maybe you should also create a note in the readme about the current state of middleware, since the current state is a bit deceiving in my opinion.\n\nI also want to emphasize the need for these middleware crates to compile, since a framework is basically useless without them for a bit more advanced projects...\n. By the way, maybe it would be a good idea to prefix the middleware with \"iron-\"?\n. @s-panferov, you were right about to_string, I didn't know it was implemented for these types; I changed it now.\n. You should uncheck \"Logger\" and \"Static File\" since these don't compile. Maybe you should also create a note in the readme about the current state of middleware, since the current state is a bit deceiving in my opinion.\n\nI also want to emphasize the need for these middleware crates to compile, since a framework is basically useless without them for a bit more advanced projects...\n. By the way, maybe it would be a good idea to prefix the middleware with \"iron-\"?\n. @s-panferov, you were right about to_string, I didn't know it was implemented for these types; I changed it now.\n. ",
    "tarekziade": "One simple but complete use case I have in mind for Iron is to implement lightweight JSON web services, where the pattern is roughly always the same:  \n\n1/ you get a JSON mapping in a POST or PUT -- or a plain GET / DELETE\n2/ you return a JSON mapping, filled by a controller that interacts w/ a database backend\n\nThat generally includes many small custom middlewares to control the input data etc\n. ok, thx\n. One simple but complete use case I have in mind for Iron is to implement lightweight JSON web services, where the pattern is roughly always the same:  \n\n1/ you get a JSON mapping in a POST or PUT -- or a plain GET / DELETE\n2/ you return a JSON mapping, filled by a controller that interacts w/ a database backend\n\nThat generally includes many small custom middlewares to control the input data etc\n. ok, thx\n. ",
    "jakejscott": "Holy shit that was quick! :+1: \n. I'm now having a problem when I run `cargo test`\n\n![error](https://cloud.githubusercontent.com/assets/287641/4210642/c684548c-3879-11e4-96e4-a4a747c4cf2c.png)\n. Not sure, I'm totally new to Rust. I just installed Cargo via `curl https://static.rust-lang.org/rustup.sh | sudo bash`\n\nI might try using `https://static.rust-lang.org/dist/rust-nightly-x86_64-unknown-linux-gnu.tar.gz` \n. Still get the same error\n. All good thanks for your help.\n. Hey @reem I got it working :) I went and made sure I could build & test both [rust-openssl](https://github.com/sfackler/rust-openssl) and [rust-http](https://github.com/chris-morgan/rust-http). \n\nTo get rust-http going I needed to install open ssl using:\n`sudo apt-get install libssl-dev`\n\nIt might be worth while adding a note about having to have open-ssl installed somewhere in the README?\n\nCheers\nJake\n. Okay will do.. It is documented here https://github.com/sfackler/rust-openssl/blob/master/README.md#linux\n\nDo you want me to include the instructions for both Linux and Windows, or a link to the instructions on rust-openssl?\n. Holy shit that was quick! :+1: \n. I'm now having a problem when I run `cargo test`\n\n![error](https://cloud.githubusercontent.com/assets/287641/4210642/c684548c-3879-11e4-96e4-a4a747c4cf2c.png)\n. Not sure, I'm totally new to Rust. I just installed Cargo via `curl https://static.rust-lang.org/rustup.sh | sudo bash`\n\nI might try using `https://static.rust-lang.org/dist/rust-nightly-x86_64-unknown-linux-gnu.tar.gz` \n. Still get the same error\n. All good thanks for your help.\n. Hey @reem I got it working :) I went and made sure I could build & test both [rust-openssl](https://github.com/sfackler/rust-openssl) and [rust-http](https://github.com/chris-morgan/rust-http). \n\nTo get rust-http going I needed to install open ssl using:\n`sudo apt-get install libssl-dev`\n\nIt might be worth while adding a note about having to have open-ssl installed somewhere in the README?\n\nCheers\nJake\n. Okay will do.. It is documented here https://github.com/sfackler/rust-openssl/blob/master/README.md#linux\n\nDo you want me to include the instructions for both Linux and Windows, or a link to the instructions on rust-openssl?\n. ",
    "cyplo": "Hi ! Just found this issue, do you know if there is a good way to do this nowadays ? Thanks !\n. Hi ! Just found this issue, do you know if there is a good way to do this nowadays ? Thanks !\n. ",
    "mathroc": "there is ongoing work that could solve this here : passcod/cargo-watch#25\n. there is ongoing work that could solve this here : passcod/cargo-watch#25\n. ",
    "passcod": "Cargo Watch should work for this on Windows, still waiting on further Cargo improvements for Unix support, see the issue @mathroc linked above. \n. Cargo Watch should work for this on Windows, still waiting on further Cargo improvements for Unix support, see the issue @mathroc linked above. \n. ",
    "Hoverbear": "Closing since this seems to be resolved by other libraries/repos. Thanks everyone! :)\n. This is caused by https://github.com/reem/rust-error/commit/3451a09c07a29eca1baaa847c5c8d53c83500094. \n\nIf you edit L62 of `src/lib.rs` and remove `ErrorRefExt`\n\n``` rust\n// Errors\npub use error::{Error};\n```\n\nThen modify the prelude:\n\n``` rust\npub mod prelude {\n    pub use {Set, Plugin, Error, Chain, Request,\n             Response, IronResult, IronError, Iron};\n}\n```\n\nYou'll get the output:\n\n```\n\u279c  iron git:(master) cargo build\n   Compiling iron v0.0.8 (file:///Users/hoverbear/git/iron)\nsrc/errors.rs:24:5: 27:6 error: method `name` is not a member of trait `Error`\nsrc/errors.rs:24     fn name(&self) -> &'static str {\nsrc/errors.rs:25         let FileError(ref err) = *self;\nsrc/errors.rs:26         err.desc\nsrc/errors.rs:27     }\nsrc/errors.rs:29:5: 32:6 error: method `description` is not a member of trait `Error`\nsrc/errors.rs:29     fn description(&self) -> Option<&str> {\nsrc/errors.rs:30         let FileError(ref err) = *self;\nsrc/errors.rs:31         err.detail.as_ref().map(|s| s.as_slice())\nsrc/errors.rs:32     }\nsrc/errors.rs:40:5: 42:6 error: method `name` is not a member of trait `Error`\nsrc/errors.rs:40     fn name(&self) -> &'static str {\nsrc/errors.rs:41         \"Hyper Error\"\nsrc/errors.rs:42     }\nsrc/errors.rs:55:5: 58:6 error: method `name` is not a member of trait `Error`\nsrc/errors.rs:55     fn name(&self) -> &'static str {\nsrc/errors.rs:56         let InvalidAddressError(ref err) = *self;\nsrc/errors.rs:57         err.desc\nsrc/errors.rs:58     }\nerror: aborting due to 4 previous errors\nCould not compile `iron`.\n\nTo learn more, run the command again with --verbose.\n```\n\nI'm not sure what to do about these with this recent change, @reem, any advice?\n. A workaround is to set the `error` crate version. You can do this like so: https://github.com/Hoverbear/iron/commit/f7aefca26018ae6c0741e5cc9238d99dde96001a.\n. Rust-ci doesn't exist anymore, closing this.\n. You can reproduce this by running `cargo run --examples hello` and in another terminal issuins this curl command:\n\n``` bash\ncurl --dump-header - -0 -H 'Host:' localhost:3000\n```\n\nOutput:\n\n``` bash\n$ curl localhost:3000\nHello world!%\n$ curl --dump-header - -0 -H 'Host:' localhost:3000\nHTTP/1.0 400 Bad Request\nDate: Sat, 01 Oct 2016 07:30:45 GMT\nConnection: close\nTransfer-Encoding: chunked\n```\n. Big props to @fsommar to taking this on and exploring! If you're interested in helping with their implementation please go do so on that repository.\n\nClosing this for now.\n. I'm going to close this PR since it's over a year old now and hasn't been merged.\n\nThank you @IanConnolly for submitting this PR. :)\n. Please feel free to submit a PR adding examples. I'm closing this in favor of #311.\n. Hey folks! I'm closing this issue since it's been inactive for almost a year. Please feel free to contribute some documentation in some way comparing the two, or even writing an article/post about it on your fancy websites. :)\n. This issue has been resolved, closing!\n. Is there still interest in this PR? Is it still relevant?\n. This is a question and has been answered, thus it is closed.\n. With Hyper moving to `futures-rs` and `tokio` this issue is irrelevant. Hyper no longer has a `mio` branch, but it does have a `tokio` branch.\n\nClosing this, if you're interested in improving the `async` situation please help out with Hyper's `tokio` branch. After it's ready we can get Iron working on it. :)\n. @KalitaAlexey Please re-open this issue if things are still a problem, otherwise this issue has been stale for several months and seems to be related to unlinked upstream bugs.\n. Closing, this has been answered and there have been no followups. :)\n. @untitaker I remember you saying something about a PR like this (I can't actually find the comment) might need it's interface nuked in the upcoming async branch? Do you have thoughts on merging something like this or 415?\n. Assigning myself to review.\n. Hi, 4.0 has been released!\n. https://github.com/iron/iron/tree/0.4.0\n. And please link the issue here when you do so we can follow it =D\n. I was unable to repo this with the latest versions.\n\n`Cargo.toml`:\n\n``` toml\n[package]\nname = \"my-server\"\nversion = \"0.1.0\"\nauthors = [\"me\"]\n\n[dependencies]\nrouter = \"0.4.0\"\n\n[dependencies.iron]\nversion = \"0.4.0\"\nfeatures = [\"ssl\"]\n```\n\n`src/main.rs`:\n\n``` rust\nextern crate iron;\nextern crate router;\n\nuse iron::status;\nuse iron::{Iron, IronResult, Request, Response};\nuse router::{Router};\nuse std::path::{Path};\nuse std::result::{Result};\n\nfn handler(_: &mut Request) -> IronResult<Response> {\n    println!(\"Got a request\");\n    Ok(Response::with((status::Ok, \"Hello World!\")))\n}\n\nfn main() {\n    let mut router = Router::new();\n    router.get(\"/foo\", handler, \"foo\");\n    // openssl genrsa -out localhost.key 4096\n    let key = Path::new(\"localhost.key\").to_path_buf();\n    // openssl req -key localhost.key -x509 -new -days 3650 -out cacert.crt\n    let cert = Path::new(\"localhost.crt\").to_path_buf();\n\n    match Iron::new(router).https(\"127.0.0.1:3000\", cert, key) {\n        Result::Ok(listening) => println!(\"{:?}\", listening),\n        Result::Err(err) => println!(\"{:?}\", err),\n    }\n    // curl -vvvv https://127.0.0.1:3000/foo -k\n}\n```\n\nRunning:\n\n``` bash\ncurl -vvvv https://127.0.0.1:3000/foo -k\n```\n\nA bunch as well as loading the URL in my browser many times resulted in no errors:\n\n![screen shot 2016-09-30 at 13 24 49](https://cloud.githubusercontent.com/assets/130903/18990346/761cca4a-8711-11e6-93d2-4ed45ffc006f.png)\n\nClosing since this seems to no longer be an issue.\n. #483 covers this and is in progress. Closing this in favor of that.\n\n@Cobrand:\n\n> Another quick question - but maybe here is not the right place - why not make ssl a default feature that you can disable if needed ?\n\nYou're welcome to create a new issue for this.\n. https://github.com/iron/session exists and may be a good starting point for this. You can also explore http://www.arewewebyet.org/topics/auth/.\n\nIf you find a way to make these integrate well with Iron please feel encouraged to write about it and report back.\n. @flosse Did this solve your question, or perhaps we could expand on the answer in some way?\n. @flosse Can you share a gist or example?\n. That'd be great! We could use something like https://github.com/semantic-rs/semantic-rs to do this I think.\n. I guess it wouldn't make sense to use `Into` for this since you just want a pointer.\n. Definitely. :)\n. If it already exists we should keep it -- People may depend on it.\n\nBut using existing, idiomatic methods such as `Into` etc would definitely be preferable for new functions.\n\nI, for one, prefer simple, familiar concepts over library-specific concepts. If you prefer this method it'd be awesome if we could have both ways.\n. @untitaker It looks very nice regardless. :)\n. Hmm... Could you give me an idea of what your network adapters look like? Maybe they're binding on different interfaces? I'm not sure that would even make sense though, would would they do that?\n. I admit I'm not really sure on this, perhaps someone else has some input.\n. In #484 we confirmed that this is likely the issue.\n\nI suspect it is likely that some (older) applications prefer IPv4 while some (newer) applications prefer IPv6.\n. Thanks! :)\n. Hi! Thanks for raising this. Any chance you could provide the headers which Firefox sends (but succeeds) as well? Maybe there is a difference.\n. I see a difference in the `Content-Type` field. \n\n``` diff\n+ Content-Type: multipart/form-data; boundary=---------------------------24775772147415635372086994\n- Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryRR14SThvtMDr9z5d\n```\n\nHmm...\n. Hey that's great! I'm glad. I was actually talking with a colleague about this today! Haha\n. This is an often used feature! \n\nIf you're interested in working on this @brunoqc we can definitely support you. :) I'm sure people would use it.\n. @vignesh-sankaran You'll need your own security certificates. I suggest using https://letsencrypt.org/ for this purpose since it's free and you don't need to deal with a crusty CA.\n. Just wanted to check, @reem. Any progress?\n\nIt may be worth looking at alternatives for documentation anyways. For example, http://docs.rs/\n. (I'd be willing to argue that a feature such as `https` should be opt-out rather than opt-in)\n. Doh!\n. Can you confirm that it is still an intermittent problem if you connect from 127.0.0.1?\n. Could it be related to #476?\n. Okay can you give me the output of your hosts file? Please see this comment from @untitaker https://github.com/iron/iron/issues/476#issuecomment-241730172\n. Okay, perfect. So this issue is resolved then? Can we close this?\n. `ci/circleci` fails with a 404 and is not actually a test failure.\n. Travis failures are due to temporary rustup breakage. (Ref: https://github.com/rust-lang/rustup.sh/pull/73)\n. This is ready and since it's a trivial commit I'm just going to merge it.\n. Complete test code:\n\n``` rust\nextern crate iron;\n#[macro_use] extern crate router;\n\nuse router::*;\nuse iron::prelude::*;\n\nfn main() {\n    let router = router!(index: get \"/\" => |req: &mut Request| Ok(Response::new()));\n    // ...\n    Iron::new(router).http(\"::1:8000\").unwrap();\n}\n```\n\nCorrect unexpected case:\n\n``` bash\ncurl -f -v \"http://[::1]:8000/\"\n```\n\nCorrect expected case:\n\n``` bash\ncurl -f -v \"http://localhost:8000/\"\n```\n. I wasn't able to figure out the issue in my cursory exploration. :( \n. This is probably because `somecooldomain.dev:80` is mapped to `127.0.0.1:80`. `127.0.0.1` means \"only on the local host\". :)\n\nCan you try doing `.http(\"0.0.0.0:80\")` instead?\n. Awesome!\n. :+1:\n\nIf we could be clever enough about it I'd be in favor of merging all repos into one greater `iron` repo through the use of workspaces.\n. Great, thanks!\n. Thanks for reporting this! Keep us up to date with your exploration please!\n. Can you explain why? This isn't the clippy repo.\n. This will be a big job and introduce significant breaking changes.\n. Right. By async we mean the middlewares themselves should support being async, so they should not block, for example. They would still be done in order.\n. Hrm, we could maybe implement [`From`](https://doc.rust-lang.org/book/error-handling.html#the-from-trait) for `String`...\n. Hrm, it looks like the rustdoc.css is never being pulled in.... In the meantime you can reference https://docs.rs/iron/0.4.0/iron/?search=writebody. Seems reasonable for me... Definitely might be breaking though.. Hm... Not to my knowledge at this moment. One possibility is just listening on 443 with a second Iron instance and proxying it to the 80.. Looks good, I agree this is an improvement! Do you think we should add a test as well? :). Yeah that's kind of what I thought too. :S I guess it's fine as is.. Thanks for this contribution! :) We really appreciate it!. Excellent, thank you. This is exactly what I hoped for. :). I'm concerned this will make merging #523 etc very hard.. What hosts the site? If it's Github pages they have built in jekyll support for repos.. Thanks for this!. Thanks for this! We need more examples. :). Could just put a link to the examples directory in the frontpage of the docs maybe!. @skylerlipthay I don't think we really schedule them. I'd be OK with having a new version published though.. Thanks!. Ping @reem . Currently Iron doesn't support async (See #523 #527, and the [`Cargo.toml`](https://github.com/iron/iron/blob/master/Cargo.toml#L25-L34)). Closing since this seems to be resolved by other libraries/repos. Thanks everyone! :)\n. This is caused by https://github.com/reem/rust-error/commit/3451a09c07a29eca1baaa847c5c8d53c83500094. \n\nIf you edit L62 of `src/lib.rs` and remove `ErrorRefExt`\n\n``` rust\n// Errors\npub use error::{Error};\n```\n\nThen modify the prelude:\n\n``` rust\npub mod prelude {\n    pub use {Set, Plugin, Error, Chain, Request,\n             Response, IronResult, IronError, Iron};\n}\n```\n\nYou'll get the output:\n\n```\n\u279c  iron git:(master) cargo build\n   Compiling iron v0.0.8 (file:///Users/hoverbear/git/iron)\nsrc/errors.rs:24:5: 27:6 error: method `name` is not a member of trait `Error`\nsrc/errors.rs:24     fn name(&self) -> &'static str {\nsrc/errors.rs:25         let FileError(ref err) = *self;\nsrc/errors.rs:26         err.desc\nsrc/errors.rs:27     }\nsrc/errors.rs:29:5: 32:6 error: method `description` is not a member of trait `Error`\nsrc/errors.rs:29     fn description(&self) -> Option<&str> {\nsrc/errors.rs:30         let FileError(ref err) = *self;\nsrc/errors.rs:31         err.detail.as_ref().map(|s| s.as_slice())\nsrc/errors.rs:32     }\nsrc/errors.rs:40:5: 42:6 error: method `name` is not a member of trait `Error`\nsrc/errors.rs:40     fn name(&self) -> &'static str {\nsrc/errors.rs:41         \"Hyper Error\"\nsrc/errors.rs:42     }\nsrc/errors.rs:55:5: 58:6 error: method `name` is not a member of trait `Error`\nsrc/errors.rs:55     fn name(&self) -> &'static str {\nsrc/errors.rs:56         let InvalidAddressError(ref err) = *self;\nsrc/errors.rs:57         err.desc\nsrc/errors.rs:58     }\nerror: aborting due to 4 previous errors\nCould not compile `iron`.\n\nTo learn more, run the command again with --verbose.\n```\n\nI'm not sure what to do about these with this recent change, @reem, any advice?\n. A workaround is to set the `error` crate version. You can do this like so: https://github.com/Hoverbear/iron/commit/f7aefca26018ae6c0741e5cc9238d99dde96001a.\n. Rust-ci doesn't exist anymore, closing this.\n. You can reproduce this by running `cargo run --examples hello` and in another terminal issuins this curl command:\n\n``` bash\ncurl --dump-header - -0 -H 'Host:' localhost:3000\n```\n\nOutput:\n\n``` bash\n$ curl localhost:3000\nHello world!%\n$ curl --dump-header - -0 -H 'Host:' localhost:3000\nHTTP/1.0 400 Bad Request\nDate: Sat, 01 Oct 2016 07:30:45 GMT\nConnection: close\nTransfer-Encoding: chunked\n```\n. Big props to @fsommar to taking this on and exploring! If you're interested in helping with their implementation please go do so on that repository.\n\nClosing this for now.\n. I'm going to close this PR since it's over a year old now and hasn't been merged.\n\nThank you @IanConnolly for submitting this PR. :)\n. Please feel free to submit a PR adding examples. I'm closing this in favor of #311.\n. Hey folks! I'm closing this issue since it's been inactive for almost a year. Please feel free to contribute some documentation in some way comparing the two, or even writing an article/post about it on your fancy websites. :)\n. This issue has been resolved, closing!\n. Is there still interest in this PR? Is it still relevant?\n. This is a question and has been answered, thus it is closed.\n. With Hyper moving to `futures-rs` and `tokio` this issue is irrelevant. Hyper no longer has a `mio` branch, but it does have a `tokio` branch.\n\nClosing this, if you're interested in improving the `async` situation please help out with Hyper's `tokio` branch. After it's ready we can get Iron working on it. :)\n. @KalitaAlexey Please re-open this issue if things are still a problem, otherwise this issue has been stale for several months and seems to be related to unlinked upstream bugs.\n. Closing, this has been answered and there have been no followups. :)\n. @untitaker I remember you saying something about a PR like this (I can't actually find the comment) might need it's interface nuked in the upcoming async branch? Do you have thoughts on merging something like this or 415?\n. Assigning myself to review.\n. Hi, 4.0 has been released!\n. https://github.com/iron/iron/tree/0.4.0\n. And please link the issue here when you do so we can follow it =D\n. I was unable to repo this with the latest versions.\n\n`Cargo.toml`:\n\n``` toml\n[package]\nname = \"my-server\"\nversion = \"0.1.0\"\nauthors = [\"me\"]\n\n[dependencies]\nrouter = \"0.4.0\"\n\n[dependencies.iron]\nversion = \"0.4.0\"\nfeatures = [\"ssl\"]\n```\n\n`src/main.rs`:\n\n``` rust\nextern crate iron;\nextern crate router;\n\nuse iron::status;\nuse iron::{Iron, IronResult, Request, Response};\nuse router::{Router};\nuse std::path::{Path};\nuse std::result::{Result};\n\nfn handler(_: &mut Request) -> IronResult<Response> {\n    println!(\"Got a request\");\n    Ok(Response::with((status::Ok, \"Hello World!\")))\n}\n\nfn main() {\n    let mut router = Router::new();\n    router.get(\"/foo\", handler, \"foo\");\n    // openssl genrsa -out localhost.key 4096\n    let key = Path::new(\"localhost.key\").to_path_buf();\n    // openssl req -key localhost.key -x509 -new -days 3650 -out cacert.crt\n    let cert = Path::new(\"localhost.crt\").to_path_buf();\n\n    match Iron::new(router).https(\"127.0.0.1:3000\", cert, key) {\n        Result::Ok(listening) => println!(\"{:?}\", listening),\n        Result::Err(err) => println!(\"{:?}\", err),\n    }\n    // curl -vvvv https://127.0.0.1:3000/foo -k\n}\n```\n\nRunning:\n\n``` bash\ncurl -vvvv https://127.0.0.1:3000/foo -k\n```\n\nA bunch as well as loading the URL in my browser many times resulted in no errors:\n\n![screen shot 2016-09-30 at 13 24 49](https://cloud.githubusercontent.com/assets/130903/18990346/761cca4a-8711-11e6-93d2-4ed45ffc006f.png)\n\nClosing since this seems to no longer be an issue.\n. #483 covers this and is in progress. Closing this in favor of that.\n\n@Cobrand:\n\n> Another quick question - but maybe here is not the right place - why not make ssl a default feature that you can disable if needed ?\n\nYou're welcome to create a new issue for this.\n. https://github.com/iron/session exists and may be a good starting point for this. You can also explore http://www.arewewebyet.org/topics/auth/.\n\nIf you find a way to make these integrate well with Iron please feel encouraged to write about it and report back.\n. @flosse Did this solve your question, or perhaps we could expand on the answer in some way?\n. @flosse Can you share a gist or example?\n. That'd be great! We could use something like https://github.com/semantic-rs/semantic-rs to do this I think.\n. I guess it wouldn't make sense to use `Into` for this since you just want a pointer.\n. Definitely. :)\n. If it already exists we should keep it -- People may depend on it.\n\nBut using existing, idiomatic methods such as `Into` etc would definitely be preferable for new functions.\n\nI, for one, prefer simple, familiar concepts over library-specific concepts. If you prefer this method it'd be awesome if we could have both ways.\n. @untitaker It looks very nice regardless. :)\n. Hmm... Could you give me an idea of what your network adapters look like? Maybe they're binding on different interfaces? I'm not sure that would even make sense though, would would they do that?\n. I admit I'm not really sure on this, perhaps someone else has some input.\n. In #484 we confirmed that this is likely the issue.\n\nI suspect it is likely that some (older) applications prefer IPv4 while some (newer) applications prefer IPv6.\n. Thanks! :)\n. Hi! Thanks for raising this. Any chance you could provide the headers which Firefox sends (but succeeds) as well? Maybe there is a difference.\n. I see a difference in the `Content-Type` field. \n\n``` diff\n+ Content-Type: multipart/form-data; boundary=---------------------------24775772147415635372086994\n- Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryRR14SThvtMDr9z5d\n```\n\nHmm...\n. Hey that's great! I'm glad. I was actually talking with a colleague about this today! Haha\n. This is an often used feature! \n\nIf you're interested in working on this @brunoqc we can definitely support you. :) I'm sure people would use it.\n. @vignesh-sankaran You'll need your own security certificates. I suggest using https://letsencrypt.org/ for this purpose since it's free and you don't need to deal with a crusty CA.\n. Just wanted to check, @reem. Any progress?\n\nIt may be worth looking at alternatives for documentation anyways. For example, http://docs.rs/\n. (I'd be willing to argue that a feature such as `https` should be opt-out rather than opt-in)\n. Doh!\n. Can you confirm that it is still an intermittent problem if you connect from 127.0.0.1?\n. Could it be related to #476?\n. Okay can you give me the output of your hosts file? Please see this comment from @untitaker https://github.com/iron/iron/issues/476#issuecomment-241730172\n. Okay, perfect. So this issue is resolved then? Can we close this?\n. `ci/circleci` fails with a 404 and is not actually a test failure.\n. Travis failures are due to temporary rustup breakage. (Ref: https://github.com/rust-lang/rustup.sh/pull/73)\n. This is ready and since it's a trivial commit I'm just going to merge it.\n. Complete test code:\n\n``` rust\nextern crate iron;\n#[macro_use] extern crate router;\n\nuse router::*;\nuse iron::prelude::*;\n\nfn main() {\n    let router = router!(index: get \"/\" => |req: &mut Request| Ok(Response::new()));\n    // ...\n    Iron::new(router).http(\"::1:8000\").unwrap();\n}\n```\n\nCorrect unexpected case:\n\n``` bash\ncurl -f -v \"http://[::1]:8000/\"\n```\n\nCorrect expected case:\n\n``` bash\ncurl -f -v \"http://localhost:8000/\"\n```\n. I wasn't able to figure out the issue in my cursory exploration. :( \n. This is probably because `somecooldomain.dev:80` is mapped to `127.0.0.1:80`. `127.0.0.1` means \"only on the local host\". :)\n\nCan you try doing `.http(\"0.0.0.0:80\")` instead?\n. Awesome!\n. :+1:\n\nIf we could be clever enough about it I'd be in favor of merging all repos into one greater `iron` repo through the use of workspaces.\n. Great, thanks!\n. Thanks for reporting this! Keep us up to date with your exploration please!\n. Can you explain why? This isn't the clippy repo.\n. This will be a big job and introduce significant breaking changes.\n. Right. By async we mean the middlewares themselves should support being async, so they should not block, for example. They would still be done in order.\n. Hrm, we could maybe implement [`From`](https://doc.rust-lang.org/book/error-handling.html#the-from-trait) for `String`...\n. Hrm, it looks like the rustdoc.css is never being pulled in.... In the meantime you can reference https://docs.rs/iron/0.4.0/iron/?search=writebody. Seems reasonable for me... Definitely might be breaking though.. Hm... Not to my knowledge at this moment. One possibility is just listening on 443 with a second Iron instance and proxying it to the 80.. Looks good, I agree this is an improvement! Do you think we should add a test as well? :). Yeah that's kind of what I thought too. :S I guess it's fine as is.. Thanks for this contribution! :) We really appreciate it!. Excellent, thank you. This is exactly what I hoped for. :). I'm concerned this will make merging #523 etc very hard.. What hosts the site? If it's Github pages they have built in jekyll support for repos.. Thanks for this!. Thanks for this! We need more examples. :). Could just put a link to the examples directory in the frontpage of the docs maybe!. @skylerlipthay I don't think we really schedule them. I'd be OK with having a new version published though.. Thanks!. Ping @reem . Currently Iron doesn't support async (See #523 #527, and the [`Cargo.toml`](https://github.com/iron/iron/blob/master/Cargo.toml#L25-L34)). ",
    "johnjelinek": "I saw similar behavior with httperf / ab vs wrk:\n\nab = 1600 req/sec\nhttperf = 1569 req/sec\nwrk = 38689.08 req/sec\n. Seems to be that `wrk` reuses open TCP sockets.\n. I saw similar behavior with httperf / ab vs wrk:\n\nab = 1600 req/sec\nhttperf = 1569 req/sec\nwrk = 38689.08 req/sec\n. Seems to be that `wrk` reuses open TCP sockets.\n. ",
    "tak1n": "okay thx :)\n. okay thx :)\n. ",
    "weejulius": "got the same issue\n. got the same issue\n. ",
    "Mutisk": "I'm going out on a limb a bit here but it sounds like: https://github.com/rust-lang/rust/issues/14344\n. I'm going out on a limb a bit here but it sounds like: https://github.com/rust-lang/rust/issues/14344\n. ",
    "BenoitZugmeyer": "The issue has been reported for Linux as well here: #187 . I've got the same error, and I really look forward a fix so I can continue my little project!\n. The issue has been reported for Linux as well here: #187 . I've got the same error, and I really look forward a fix so I can continue my little project!\n. ",
    "chad-russell": "Okay, sorry to duplicate an issue, I didn't realize it had already been reported.  I'm trying my best to look into it as well, although I'm a rust newbie so I don't know how much help I will really be\n. Okay, sorry to duplicate an issue, I didn't realize it had already been reported.  I'm trying my best to look into it as well, although I'm a rust newbie so I don't know how much help I will really be\n. ",
    "davidrhyswhite": "Ha, my fault for not reading the output correctly. Thanks for the quick response, I can see it's been fixed instead within this PR: https://github.com/sfackler/rust-phf/pull/19\n\nI can confirm this is working now.\n\nThanks again @reem \n. Thought I'd give this a go since I'm fairly new to both Rust and Iron and it's marked as easy. Ignore the first commit, I didn't read the contributing doc first. ;)\n. Updated with your suggestion. Out of curiosity why does the server block after `tiny` when moving the `println!` above the server calls?\n. Ha, my fault for not reading the output correctly. Thanks for the quick response, I can see it's been fixed instead within this PR: https://github.com/sfackler/rust-phf/pull/19\n\nI can confirm this is working now.\n\nThanks again @reem \n. Thought I'd give this a go since I'm fairly new to both Rust and Iron and it's marked as easy. Ignore the first commit, I didn't read the contributing doc first. ;)\n. Updated with your suggestion. Out of curiosity why does the server block after `tiny` when moving the `println!` above the server calls?\n. ",
    "whodidthis": "Woops, just updated rust and iron and it works, i guess i just had a bad version of either, sorry about that\n. Woops, just updated rust and iron and it works, i guess i just had a bad version of either, sorry about that\n. ",
    "jacek99": "Ubuntu 14.04, 64-bit\n. thank you\n. I did cargo update and then cargo build and I got\n\n   Compiling static_file v0.1.0 (https://github.com/iron/static-file.git#b9324a6f)\nsrc/response.rs:4:29: 4:35 error: unresolved import `serialize::json::Number`. There is no `Number` in `serialize::json`\nsrc/response.rs:4 use serialize::json::{Json, Number, String, Boolean, List, Object, Null};\n                                              ^~~~~~\nsrc/parser.rs:7:31: 7:41 error: unresolved import `iron::Middleware`. There is no `Middleware` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                              ^~~~~~~~~~\nsrc/parser.rs:7:43: 7:49 error: unresolved import `iron::Status`. There is no `Status` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                                          ^~~~~~\nsrc/parser.rs:7:51: 7:59 error: unresolved import `iron::Continue`. There is no `Continue` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                                                  ^~~~~~~~\n\nso I deleted Cargo.lock and tries cargo update and cargo build again and now I got a different error\n\n   Compiling static_file v0.1.0 (https://github.com/iron/static-file.git#b9324a6f)\nsrc/lib.rs:17:30: 17:31 error: obsolete syntax: `extern crate foo = bar` syntax\nsrc/lib.rs:17 extern crate test=\"iron-test\";\n                                           ^\nnote: write `extern crate bar as foo` instead\nerror: aborting due to previous error\nBuild failed, waiting for other jobs to finish...\nsrc/response.rs:4:29: 4:35 error: unresolved import `serialize::json::Number`. There is no `Number` in `serialize::json`\nsrc/response.rs:4 use serialize::json::{Json, Number, String, Boolean, List, Object, Null};\n                                              ^~~~~~\nsrc/parser.rs:7:31: 7:41 error: unresolved import `iron::Middleware`. There is no `Middleware` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                              ^~~~~~~~~~\nsrc/parser.rs:7:43: 7:49 error: unresolved import `iron::Status`. There is no `Status` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                                          ^~~~~~\nsrc/parser.rs:7:51: 7:59 error: unresolved import `iron::Continue`. There is no `Continue` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                                                  ^~~~~~~~\nerror: aborting due to 4 previous errors\nsrc/lib.rs:83:47: 83:57 error: type `FileError` does not implement any method in scope named `abstract`\nsrc/lib.rs:83                     return Err(FileError(err).abstract());\n                                                            ^~~~~~~~~~\nsrc/lib.rs:106:55: 106:65 error: type `FileError` does not implement any method in scope named `abstract`\nsrc/lib.rs:106                             return Err(FileError(err).abstract());\n                                                                     ^~~~~~~~~~\nsrc/lib.rs:128:20: 128:30 error: type `NoFile` does not implement any method in scope named `abstract`\nsrc/lib.rs:128         Err(NoFile.abstract())\n                                  ^~~~~~~~~~\nerror: aborting due to 3 previous errors\nCould not compile `session`.\n. ah, that explains it, thanks\n. should this issue not be changed then to \"Iron-Core does not compile with nightly\", since that is the recommended way to get started with Iron on your site?\n. ok\n. Ubuntu 14.04, 64-bit\n. thank you\n. I did cargo update and then cargo build and I got\n\n   Compiling static_file v0.1.0 (https://github.com/iron/static-file.git#b9324a6f)\nsrc/response.rs:4:29: 4:35 error: unresolved import `serialize::json::Number`. There is no `Number` in `serialize::json`\nsrc/response.rs:4 use serialize::json::{Json, Number, String, Boolean, List, Object, Null};\n                                              ^~~~~~\nsrc/parser.rs:7:31: 7:41 error: unresolved import `iron::Middleware`. There is no `Middleware` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                              ^~~~~~~~~~\nsrc/parser.rs:7:43: 7:49 error: unresolved import `iron::Status`. There is no `Status` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                                          ^~~~~~\nsrc/parser.rs:7:51: 7:59 error: unresolved import `iron::Continue`. There is no `Continue` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                                                  ^~~~~~~~\n\nso I deleted Cargo.lock and tries cargo update and cargo build again and now I got a different error\n\n   Compiling static_file v0.1.0 (https://github.com/iron/static-file.git#b9324a6f)\nsrc/lib.rs:17:30: 17:31 error: obsolete syntax: `extern crate foo = bar` syntax\nsrc/lib.rs:17 extern crate test=\"iron-test\";\n                                           ^\nnote: write `extern crate bar as foo` instead\nerror: aborting due to previous error\nBuild failed, waiting for other jobs to finish...\nsrc/response.rs:4:29: 4:35 error: unresolved import `serialize::json::Number`. There is no `Number` in `serialize::json`\nsrc/response.rs:4 use serialize::json::{Json, Number, String, Boolean, List, Object, Null};\n                                              ^~~~~~\nsrc/parser.rs:7:31: 7:41 error: unresolved import `iron::Middleware`. There is no `Middleware` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                              ^~~~~~~~~~\nsrc/parser.rs:7:43: 7:49 error: unresolved import `iron::Status`. There is no `Status` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                                          ^~~~~~\nsrc/parser.rs:7:51: 7:59 error: unresolved import `iron::Continue`. There is no `Continue` in `iron`\nsrc/parser.rs:7 use iron::{Request, Response, Middleware, Status, Continue};\n                                                                  ^~~~~~~~\nerror: aborting due to 4 previous errors\nsrc/lib.rs:83:47: 83:57 error: type `FileError` does not implement any method in scope named `abstract`\nsrc/lib.rs:83                     return Err(FileError(err).abstract());\n                                                            ^~~~~~~~~~\nsrc/lib.rs:106:55: 106:65 error: type `FileError` does not implement any method in scope named `abstract`\nsrc/lib.rs:106                             return Err(FileError(err).abstract());\n                                                                     ^~~~~~~~~~\nsrc/lib.rs:128:20: 128:30 error: type `NoFile` does not implement any method in scope named `abstract`\nsrc/lib.rs:128         Err(NoFile.abstract())\n                                  ^~~~~~~~~~\nerror: aborting due to 3 previous errors\nCould not compile `session`.\n. ah, that explains it, thanks\n. should this issue not be changed then to \"Iron-Core does not compile with nightly\", since that is the recommended way to get started with Iron on your site?\n. ok\n. ",
    "gaudecker": "How about an enum:\n\n``` rust\npub enum Redirect {\n    Permanent, // 301\n    Temporary, // 302\n    Other // 303\n}\n\n...\nfn redirect(redirect: Redirect, url: &str) -> Response;\n```\n. I updated the url to take an `Url`.\n. No problem. `HeaderCollection.location` wants an `Option<url::Url>`. How shoud I convert from `iron::Url` to `url::Url`?\n\n``` rust\nrust_url::Url::parse(url.to_string().as_slice()).unwrap() // this does the job\n```\n. Done.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. How about an enum:\n\n``` rust\npub enum Redirect {\n    Permanent, // 301\n    Temporary, // 302\n    Other // 303\n}\n\n...\nfn redirect(redirect: Redirect, url: &str) -> Response;\n```\n. I updated the url to take an `Url`.\n. No problem. `HeaderCollection.location` wants an `Option<url::Url>`. How shoud I convert from `iron::Url` to `url::Url`?\n\n``` rust\nrust_url::Url::parse(url.to_string().as_slice()).unwrap() // this does the job\n```\n. Done.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "plcstpierre": "I agree with your concern. I can modify it. \n\nOn the other hand, I am a beginner in rust. Do you have an example of builder pattern in the rust world?\n. @reem Do you think it would be better to have a builder of Response or a builder of HeaderCollection?\n. I agree with your concern. I can modify it. \n\nOn the other hand, I am a beginner in rust. Do you have an example of builder pattern in the rust world?\n. @reem Do you think it would be better to have a builder of Response or a builder of HeaderCollection?\n. ",
    "jedahan": "it definitely fits the koa model of middleware to be able to wrap something, like maybe wrap one of the routing middleware to autogenerate a /docs route or /swagger route...\n. it definitely fits the koa model of middleware to be able to wrap something, like maybe wrap one of the routing middleware to autogenerate a /docs route or /swagger route...\n. ",
    "schickling": "@reem I don't like the way that code is generated for me. I'd like to have full control and follow a way described by @jedahan \n. I think the third option (DSL) would be the best fit. Could this be implemented as a middleware or does it have to be in the core?\n. :+1: \n. @reem I don't like the way that code is generated for me. I'd like to have full control and follow a way described by @jedahan \n. I think the third option (DSL) would be the best fit. Could this be implemented as a middleware or does it have to be in the core?\n. :+1: \n. ",
    "s-panferov": "I have been implementing Swagger 2.0 support in [Rustless](https://github.com/rustless/rustless). It's quite easy in Rustless, because it has a knowledge about request params schema. \n\nAfter that, using my experience, I'll try to implement it for Iron. I think it's not a big deal in a simple case, but it requires some knowledge about request parameters and responses:\n1. We can leave them blank (it's not very informative).\n2. We can allow to specify JSON-schema files.\n3. We can provide some DSL to describe input parameters and responses.\n. > After that, using my experience, I'll try to implement it for Iron. I think it's not a big deal in a simple case,  > but it requires some knowledge about request parameters and responses:\n> 1. We can leave them blank (it's not very informative).\n> 2. We can allow to specify JSON-schema files.\n> 3. We can provide some DSL to describe input parameters and responses.\n\nI just want to add to my items:\n1. This is pretty useless.\n2. Now I have been working on JSON Schema library for Rust. After I'll finish the library, this scenario can be implemented for [iron/router](https://github.com/iron/router).\n3. This is already covered by [rustless](https://github.com/rustless/rustless) and I see unrealistic to make the same in some _simple_ Iron middleware.\n. I think that Router and Mount are good enough to cover almost all use-cases when you can separate your handlers to several fully independent routes. But when you can't...\n. Thanks for the explanation! At the moment, I'm going to convert `NotMatchError` into 404 `Response` at the last stage of Rustless invocation. After I finish migration I'll try to write the middleware for Iron.\n. I think everything is good. If a middleware wants to read the entire body, it can provide the body or it parts as request extensions (with help of TypeMap).\n\nr+\n. @reem The changes look good for me. I think that this PR is a huge improvement. :+1: \n\nWhat do you think about simplify it even more? Current flow is still complicated, because:\n1. We need to think about indexes of middlewares with `catch` methods.\n2. Catch signature is the same in all the middleware types, and I don't know which type I need to select to handle some common error which can happen everywhere.\n\nI propose to remove `catch` method from the middlewares and introduce new middleware type: `CatchMiddleware` (maybe `middleware` is the bad name for that thing, maybe just `Catcher` is better) with one `catch` method. When error fires we just pass it through _all the catchers_. It's much simpler for me to understand this flow with `Catchers`: Need to handle some specific error? Just place the Catcher to the catcher list.\n\nWhat do you think? Do you see some disadvantages of that flow?\n. @reem Ok, I understand your arguments. I have thought about (2) but can't imagine such situation. Do you have some relevant example?\n\nAnyway, current solution is comfortable enough to work with :+1: \n. Answer to myself. Things like logging, CORS middleware or some custom header setters that must affect all responses are examples of (2). \n. @reem It makes sense in situations when you use some external middleware and want to suppress some of it's errors.\n. > I would be far more comfortable with stuff like router raising errors on NotFound if there was a way to switch back.\n\nIt will enable #239\n. I have read the last changes, everything seems ok for my eyes.\n. :+1: \n. It can be a middleware, it's not a problem. And I think that it is common enough to be right in the core. If you agreed with me I'll implement this (or I can rewrite the body-parser).\n. See https://github.com/iron/body-parser/pull/43\n. @reem yes, I have just seen it\n. Updated\n. I think that we can pass it through an RFC process. Maybe I could write the RFC if you forgive my poor English. But at first I want to hear that all are interested.\n. @sunng87 \n\n> Iron can be a standard request/response and middleware framework\n\nI don't think that we must and _need_ to peek a standard framework, because all people has their own opinion. Time will put everything in its place. But we are able to pick some small standard parts now. Let's begin with that.\n. @reem could you please explain in a few words what does it do?\n. @reem thanks\n. @reem could you merge this please to unblock iron clients?\n. @reem nobody uses a sync web-server on mid/hi-load production without nginx, HAProxy etc. It's just a reminder for newcomers. Maybe we can just remove the sentence about limitations and leave only the recommendation?\n. Any progress on this? I'm very interested in this PR to update [rustless](https://github.com/rustless/rustless) to newer `hyper`. Can I help you in something?\n. Please see https://github.com/iron/iron/issues/446\n. I have been implementing Swagger 2.0 support in [Rustless](https://github.com/rustless/rustless). It's quite easy in Rustless, because it has a knowledge about request params schema. \n\nAfter that, using my experience, I'll try to implement it for Iron. I think it's not a big deal in a simple case, but it requires some knowledge about request parameters and responses:\n1. We can leave them blank (it's not very informative).\n2. We can allow to specify JSON-schema files.\n3. We can provide some DSL to describe input parameters and responses.\n. > After that, using my experience, I'll try to implement it for Iron. I think it's not a big deal in a simple case,  > but it requires some knowledge about request parameters and responses:\n> 1. We can leave them blank (it's not very informative).\n> 2. We can allow to specify JSON-schema files.\n> 3. We can provide some DSL to describe input parameters and responses.\n\nI just want to add to my items:\n1. This is pretty useless.\n2. Now I have been working on JSON Schema library for Rust. After I'll finish the library, this scenario can be implemented for [iron/router](https://github.com/iron/router).\n3. This is already covered by [rustless](https://github.com/rustless/rustless) and I see unrealistic to make the same in some _simple_ Iron middleware.\n. I think that Router and Mount are good enough to cover almost all use-cases when you can separate your handlers to several fully independent routes. But when you can't...\n. Thanks for the explanation! At the moment, I'm going to convert `NotMatchError` into 404 `Response` at the last stage of Rustless invocation. After I finish migration I'll try to write the middleware for Iron.\n. I think everything is good. If a middleware wants to read the entire body, it can provide the body or it parts as request extensions (with help of TypeMap).\n\nr+\n. @reem The changes look good for me. I think that this PR is a huge improvement. :+1: \n\nWhat do you think about simplify it even more? Current flow is still complicated, because:\n1. We need to think about indexes of middlewares with `catch` methods.\n2. Catch signature is the same in all the middleware types, and I don't know which type I need to select to handle some common error which can happen everywhere.\n\nI propose to remove `catch` method from the middlewares and introduce new middleware type: `CatchMiddleware` (maybe `middleware` is the bad name for that thing, maybe just `Catcher` is better) with one `catch` method. When error fires we just pass it through _all the catchers_. It's much simpler for me to understand this flow with `Catchers`: Need to handle some specific error? Just place the Catcher to the catcher list.\n\nWhat do you think? Do you see some disadvantages of that flow?\n. @reem Ok, I understand your arguments. I have thought about (2) but can't imagine such situation. Do you have some relevant example?\n\nAnyway, current solution is comfortable enough to work with :+1: \n. Answer to myself. Things like logging, CORS middleware or some custom header setters that must affect all responses are examples of (2). \n. @reem It makes sense in situations when you use some external middleware and want to suppress some of it's errors.\n. > I would be far more comfortable with stuff like router raising errors on NotFound if there was a way to switch back.\n\nIt will enable #239\n. I have read the last changes, everything seems ok for my eyes.\n. :+1: \n. It can be a middleware, it's not a problem. And I think that it is common enough to be right in the core. If you agreed with me I'll implement this (or I can rewrite the body-parser).\n. See https://github.com/iron/body-parser/pull/43\n. @reem yes, I have just seen it\n. Updated\n. I think that we can pass it through an RFC process. Maybe I could write the RFC if you forgive my poor English. But at first I want to hear that all are interested.\n. @sunng87 \n\n> Iron can be a standard request/response and middleware framework\n\nI don't think that we must and _need_ to peek a standard framework, because all people has their own opinion. Time will put everything in its place. But we are able to pick some small standard parts now. Let's begin with that.\n. @reem could you please explain in a few words what does it do?\n. @reem thanks\n. @reem could you merge this please to unblock iron clients?\n. @reem nobody uses a sync web-server on mid/hi-load production without nginx, HAProxy etc. It's just a reminder for newcomers. Maybe we can just remove the sentence about limitations and leave only the recommendation?\n. Any progress on this? I'm very interested in this PR to update [rustless](https://github.com/rustless/rustless) to newer `hyper`. Can I help you in something?\n. Please see https://github.com/iron/iron/issues/446\n. ",
    "barosl": "Good work, @reem! Thanks for the fast feedback.\n\nI've also opened an issue to track the behavior of `std::sync::TaskPool` in rust-lang/rust#18836, if you're interested!\n. Oh, man. I didn't know about the `ContentType::new()` method, so I've always created the `ContentType` struct manually, like this:\n\n``` rust\n.set(ContentType(MediaType {\n    type_: \"text\".into_string(),\n    subtype: \"html\".into_string(),\n    parameters: vec![],\n}))\n```\n\nThanks for letting me know `ContentType::new()`! Now my life's getting a lot easier.\n. I'm not sure I've done the error handling correctly in `iron.rs`. It compiles, but it is uncertain that the code is following the convention. Please review it.\n. `InvalidAddressError` was added.\n. :+1: :clap: :star: Nice work!\n. Good work, @reem! Thanks for the fast feedback.\n\nI've also opened an issue to track the behavior of `std::sync::TaskPool` in rust-lang/rust#18836, if you're interested!\n. Oh, man. I didn't know about the `ContentType::new()` method, so I've always created the `ContentType` struct manually, like this:\n\n``` rust\n.set(ContentType(MediaType {\n    type_: \"text\".into_string(),\n    subtype: \"html\".into_string(),\n    parameters: vec![],\n}))\n```\n\nThanks for letting me know `ContentType::new()`! Now my life's getting a lot easier.\n. I'm not sure I've done the error handling correctly in `iron.rs`. It compiles, but it is uncertain that the code is following the convention. Please review it.\n. `InvalidAddressError` was added.\n. :+1: :clap: :star: Nice work!\n. ",
    "calebmer": "I could definitely use this. Especially for streaming and testing as the current docs/types currently aren't too helpful in deducing how to do these things.\n. I could definitely use this. Especially for streaming and testing as the current docs/types currently aren't too helpful in deducing how to do these things.\n. ",
    "jnferner": "Is anyone working on this? Seems like something very important to do.. Is anyone working on this? Seems like something very important to do.. ",
    "azasypkin": "Hey @reem, is there any example of how \"assign a Reader to body\"?\n\nI have something very similar to https://github.com/iron/iron/issues/423, but I want to continuously stream response returned by Hyper client.\n\nThanks!\n. Thanks for your reply @untitaker! So as the result I've just created custom `struct` that implements `WriteBody + Send`. In case someone finds it useful and if simplify a lot and omit error handling `write_body` will look like:\n\n``` rust\nfn write_body(&mut self, response_body: &mut ResponseBody) -> io::Result<()> {\n    let client = hyper::Client::new();\n\n    let mut streamed_response = client.get(&self.mjpeg_stream_url)\n        .header(Connection::keep_alive())\n        .send()\n        .unwrap();\n\n    let mut buffer: [u8;300] = [0;300];\n\n    loop {\n        streamed_response.read_exact(&mut buffer).unwrap();\n        response_body.write(&buffer).unwrap();\n        response_body.flush().unwrap();\n    }\n\n    Ok(())\n}\n```\n. Hey @reem, is there any example of how \"assign a Reader to body\"?\n\nI have something very similar to https://github.com/iron/iron/issues/423, but I want to continuously stream response returned by Hyper client.\n\nThanks!\n. Thanks for your reply @untitaker! So as the result I've just created custom `struct` that implements `WriteBody + Send`. In case someone finds it useful and if simplify a lot and omit error handling `write_body` will look like:\n\n``` rust\nfn write_body(&mut self, response_body: &mut ResponseBody) -> io::Result<()> {\n    let client = hyper::Client::new();\n\n    let mut streamed_response = client.get(&self.mjpeg_stream_url)\n        .header(Connection::keep_alive())\n        .send()\n        .unwrap();\n\n    let mut buffer: [u8;300] = [0;300];\n\n    loop {\n        streamed_response.read_exact(&mut buffer).unwrap();\n        response_body.write(&buffer).unwrap();\n        response_body.flush().unwrap();\n    }\n\n    Ok(())\n}\n```\n. ",
    "kjs3": "Welp. :)\n. Welp. :)\n. ",
    "cmr": "I don't know why travis isn't running...\n. Pinging @txgo because of the @-mention limit\n. @untitaker Do you disagree with the terms of the Apache license, or do you disagree that the dual licensing is desirable, or do you disagree with the downsides of the MIT license that I've listed/my interpretation of its terms, or do you think the whole thing is irrelevant, or something else?\n. I don't know why travis isn't running...\n. Pinging @txgo because of the @-mention limit\n. @untitaker Do you disagree with the terms of the Apache license, or do you disagree that the dual licensing is desirable, or do you disagree with the downsides of the MIT license that I've listed/my interpretation of its terms, or do you think the whole thing is irrelevant, or something else?\n. ",
    "Novacha": "It seems that conduit follows the prefix structure that @ProtectedMode is suggesting ([here](https://crates.io/search?q=conduit) is a list of all conduit's middleware). That will prevent iron from polluting crates.io's names and make iron middleware easier to find. \n. It seems that conduit follows the prefix structure that @ProtectedMode is suggesting ([here](https://crates.io/search?q=conduit) is a list of all conduit's middleware). That will prevent iron from polluting crates.io's names and make iron middleware easier to find. \n. ",
    "letharion": "FWIW, I'm seeing the same thing.\n\n`curl -v http://127.0.0.1:3000`\n. <strike>I was just gonna say that it looks to me like https://github.com/servo/rust-url doesn't like domains that are ipv4 only, but I could definitely be wrong.</strike>\n\nThe above was based on this comment:\n/// Parse a host: either an IPv6 address in [] square brackets, or a domain.\nBut from looking at the code, I see no reason that IPv4 would not work.\n. :+1: \n. FWIW, I'm seeing the same thing.\n\n`curl -v http://127.0.0.1:3000`\n. <strike>I was just gonna say that it looks to me like https://github.com/servo/rust-url doesn't like domains that are ipv4 only, but I could definitely be wrong.</strike>\n\nThe above was based on this comment:\n/// Parse a host: either an IPv6 address in [] square brackets, or a domain.\nBut from looking at the code, I see no reason that IPv4 would not work.\n. :+1: \n. ",
    "renato-zannon": "Thank you :)\n. Thank you :)\n. ",
    "qubyte": "Huh. Compiles with updated rust. I might just set up a cron job to install rust nightly! Thanks.\n. Huh. Compiles with updated rust. I might just set up a cron job to install rust nightly! Thanks.\n. ",
    "graue": "Would SemVer be a possible workaround? You could ask for `somedep 0.1.*` and bump the minor version for a change to the API (as with `error 0.0.3`) but only bump patch version for a rustup.\n. Oh, I'm not saying maintain two branches, that's way too much work.\n\nEven without that, you'd fix the situation where a dependency has changed in an incompatible way but Rust itself hasn't.\n\nMaybe that doesn't happen a lot, and is still too much trouble; if so, feel free to close.\n. Would SemVer be a possible workaround? You could ask for `somedep 0.1.*` and bump the minor version for a change to the API (as with `error 0.0.3`) but only bump patch version for a rustup.\n. Oh, I'm not saying maintain two branches, that's way too much work.\n\nEven without that, you'd fix the situation where a dependency has changed in an incompatible way but Rust itself hasn't.\n\nMaybe that doesn't happen a lot, and is still too much trouble; if so, feel free to close.\n. ",
    "blaenk": ":+1: hopefully @reem can get to this soon.\n. :+1: hopefully @reem can get to this soon.\n. ",
    "m-r-r": "Hello,\n\nI have `iron = \"0.0.9\"` in my `Cargo.toml` and I have the same issue.\n\n---\n\n**EDIT**: It seems Hyper had the same issue: hyperium/hyper#205  \nThe fix is to add the `log` crate as a dependency in `Cargo.toml` (see hyperium/hyper@161a1a8).\n. Hello,\n\nI have `iron = \"0.0.9\"` in my `Cargo.toml` and I have the same issue.\n\n---\n\n**EDIT**: It seems Hyper had the same issue: hyperium/hyper#205  \nThe fix is to add the `log` crate as a dependency in `Cargo.toml` (see hyperium/hyper@161a1a8).\n. ",
    "pzol": "This works in 0.0.11\n. This works in 0.0.11\n. ",
    "rndr": "i've finally been able to compile iron (deps, 1.0-alpha, ...) and with rust-lang/cargo#831 being fixed if i run `cargo run --release --example hello` i'm getting:\n\n```\nRunning 10s test @ http://127.0.0.1:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     2.11ms    2.77ms   5.91ms   65.31%\n    Req/Sec    42.11k     7.80k   54.33k    65.23%\n  390795 requests in 10.02s, 42.49MB read\n  Socket errors: connect 0, read 0, write 0, timeout 3944\nRequests/sec:  39011.24\nTransfer/sec:      4.24MB\n```\n\nI've tried building by hand with your commands and it's same.\nI guess it's me running ubuntu under VMWare VM. Closing?\n. i've finally been able to compile iron (deps, 1.0-alpha, ...) and with rust-lang/cargo#831 being fixed if i run `cargo run --release --example hello` i'm getting:\n\n```\nRunning 10s test @ http://127.0.0.1:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     2.11ms    2.77ms   5.91ms   65.31%\n    Req/Sec    42.11k     7.80k   54.33k    65.23%\n  390795 requests in 10.02s, 42.49MB read\n  Socket errors: connect 0, read 0, write 0, timeout 3944\nRequests/sec:  39011.24\nTransfer/sec:      4.24MB\n```\n\nI've tried building by hand with your commands and it's same.\nI guess it's me running ubuntu under VMWare VM. Closing?\n. ",
    "blacksoil": "Looking at Rust-Modifier github page, this simple modification is required:\naharijanto@aharijanto-ThinkPad-X201:~/.cargo/registry/src/github.com-1ecc6299db9ec823/modifier-0.0.5/src$ diff lib.rs /home/aharijanto/Programming/rust-code/rust-modifier/src\n\n  \"< pub trait Set {\"\n  \"> pub trait Set: Sized {\"\n. There's another issue when compiling \"error\" crate:\n\ncargo build\n   Compiling error v0.0.3 (file:///home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3)\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:10:16: 10:19 warning: deprecated syntax; use the `self` keyword now\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:10 use std::fmt::{mod, Show, Formatter};\n                                                                                                          ^~~\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:4:12: 4:28 warning: feature is deprecated and will only be available for a limited time, please rewrite code that relies on it\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:4 #![feature(old_orphan_check)]\n                                                                                                     ^~~~~~~~~~~~~~~~\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:4:12: 4:28 warning: feature is deprecated and will only be available for a limited time, please rewrite code that relies on it\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:4 #![feature(old_orphan_check)]\n                                                                                                     ^~~~~~~~~~~~~~~~\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:84:1: 86:2 error: internal compiler error: coherence failed to report ambiguity: cannot locate the impl of the trait `core::fmt::Show` for the type `Error + 'static`\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:84 impl Show for Error {\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:85     fn fmt(&self, f: &mut Formatter) -> fmt::Result { (*self).fmt(f) }\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:86 }\nnote: the compiler unexpectedly panicked. this is a bug.\nnote: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugreport.html\nnote: run with `RUST_BACKTRACE=1` for a backtrace\nthread 'rustc' panicked at 'Box<Any>', /home/rustbuild/src/rust-buildbot/slave/nightly-dist-rustc-linux/build/src/libsyntax/diagnostic.rs:123\n\nCould not compile `error`.\n. Looking at Rust-Modifier github page, this simple modification is required:\naharijanto@aharijanto-ThinkPad-X201:~/.cargo/registry/src/github.com-1ecc6299db9ec823/modifier-0.0.5/src$ diff lib.rs /home/aharijanto/Programming/rust-code/rust-modifier/src\n\n  \"< pub trait Set {\"\n  \"> pub trait Set: Sized {\"\n. There's another issue when compiling \"error\" crate:\n\ncargo build\n   Compiling error v0.0.3 (file:///home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3)\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:10:16: 10:19 warning: deprecated syntax; use the `self` keyword now\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:10 use std::fmt::{mod, Show, Formatter};\n                                                                                                          ^~~\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:4:12: 4:28 warning: feature is deprecated and will only be available for a limited time, please rewrite code that relies on it\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:4 #![feature(old_orphan_check)]\n                                                                                                     ^~~~~~~~~~~~~~~~\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:4:12: 4:28 warning: feature is deprecated and will only be available for a limited time, please rewrite code that relies on it\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:4 #![feature(old_orphan_check)]\n                                                                                                     ^~~~~~~~~~~~~~~~\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:84:1: 86:2 error: internal compiler error: coherence failed to report ambiguity: cannot locate the impl of the trait `core::fmt::Show` for the type `Error + 'static`\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:84 impl Show for Error {\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:85     fn fmt(&self, f: &mut Formatter) -> fmt::Result { (*self).fmt(f) }\n/home/aharijanto/.cargo/registry/src/github.com-1ecc6299db9ec823/error-0.0.3/src/lib.rs:86 }\nnote: the compiler unexpectedly panicked. this is a bug.\nnote: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugreport.html\nnote: run with `RUST_BACKTRACE=1` for a backtrace\nthread 'rustc' panicked at 'Box<Any>', /home/rustbuild/src/rust-buildbot/slave/nightly-dist-rustc-linux/build/src/libsyntax/diagnostic.rs:123\n\nCould not compile `error`.\n. ",
    "danieljanes": "Also failing on 1.0.0-alpha. Any plans to support alpha (and later beta/stable)?\n. Also failing on 1.0.0-alpha. Any plans to support alpha (and later beta/stable)?\n. ",
    "eafzali": "I'm getting different error on Mac OS X, using latest version of iron and rust:\n\n```\n$ RUST_BACKTRACE=1 cargo run --verbose\n       Fresh typeable v0.0.7\n       Fresh rustc-serialize v0.2.8\n       Fresh pkg-config v0.1.4\n       Fresh unicase v0.0.2\n       Fresh matches v0.1.2\n       Fresh gcc v0.1.4\n       Fresh modifier v0.0.7\n       Fresh regex v0.1.10\n       Fresh unsafe-any v0.2.1\n       Fresh mucell v0.1.10\n       Fresh phantom v0.0.3\n       Fresh error v0.1.1\n       Fresh url v0.2.16\n       Fresh log v0.1.9\n       Fresh typemap v0.0.7\n       Fresh mime v0.0.6\n       Fresh plugin v0.2.0\n       Fresh openssl-sys v0.2.16\n       Fresh time v0.1.12\n       Fresh openssl v0.2.16\n       Fresh cookie v0.1.8\n       Fresh hyper v0.1.1\n       Fresh iron v0.0.13 (https://github.com/iron/iron.git#1e632f0b)\n   Compiling ironTest v0.0.1 (file:///Users/ehsan/Workspace/ironTest)\n     Running `rustc src/main.rs --crate-name ironTest --crate-type bin -g --out-dir /Users/ehsan/Workspace/ironTest/target --emit=dep-info,link -L dependency=/Users/ehsan/Workspace/ironTest/target -L dependency=/Users/ehsan/Workspace/ironTest/target/deps --extern iron=/Users/ehsan/Workspace/ironTest/target/deps/libiron-87d5ad47941cccb1.rlib --extern ironTest=/Users/ehsan/Workspace/ironTest/target/libironTest-323b2cd83dbaeffd.rlib -L native=/usr/lib -L native=/Users/ehsan/Workspace/ironTest/target/build/time-7c7fc3eb0c12ad75/out`\nerror: internal compiler error: static call to invalid vtable: VtableObject(VtableObject(object_ty=error::Error + 'static))\nnote: the compiler unexpectedly panicked. this is a bug.\nnote: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugreport.html\nnote: run with `RUST_BACKTRACE=1` for a backtrace\nthread 'rustc' panicked at 'Box<Any>', /Users/rustbuild/src/rust-buildbot/slave/nightly-dist-rustc-mac/build/src/libsyntax/diagnostic.rs:182\n\nstack backtrace:\n   1:        0x10b6b943c - sys::backtrace::write::h915f36e5cd3021f68Tt\n   2:        0x10b6db0cf - failure::on_fail::h9cc1228f7bd1c672WXz\n   3:        0x10b647b0e - rt::unwind::begin_unwind_inner::hd5314f8d41391a63NFz\n   4:        0x10922230f - rt::unwind::begin_unwind::h10161061209420488439\n   5:        0x109222c7b - diagnostic::Handler::bug::hf3693a5c74bbd0f3I4F\n   6:        0x1087e7070 - metadata::tydecode::parse_existential_bounds_::h4924998583922597012\n   7:        0x107f46a26 - trans::meth::trans_static_method_callee::h121f6bd3641ab9e8Jdz\n   8:        0x107f43844 - trans::callee::trans::hbd524d6a7bcad3bbOag\n   9:        0x107f4c84e - trans::callee::trans_call_inner::h17534404761379207397\n  10:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  11:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  12:        0x107f0b628 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  13:        0x107fd39ec - trans::base::trans_closure::h958dc77439137861U0t\n  14:        0x107ef6cc7 - trans::base::trans_fn::hf577d2d2415bb1e0zbu\n  15:        0x107ef8843 - trans::monomorphize::monomorphic_fn::ha3753571ab1e1697Tpd\n  16:        0x107f48549 - trans::callee::trans_fn_ref_with_substs::ha4203512deda00c0Zxg\n  17:        0x107f46d0e - trans::meth::trans_static_method_callee::h121f6bd3641ab9e8Jdz\n  18:        0x107f7122b - trans::expr::trans_def_fn_unadjusted::h0f303d2f55e6016bLfj\n  19:        0x107f68c90 - trans::expr::trans_def::h82fd2274b73389a6RIi\n  20:        0x107f50c07 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  21:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  22:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  23:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  24:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  25:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  26:        0x10800bfb9 - trans::tvec::write_content::hd9be974aac2e8bablIy\n  27:        0x107f5309e - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  28:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  29:        0x107fef354 - trans::_match::trans_match_inner::h50ded02cb23e3e19Pkx\n  30:        0x107f527b7 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  31:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  32:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  33:        0x107f6be48 - trans::expr::trans_addr_of::h2c4f0fccc9d6ce022Kj\n  34:        0x107f51308 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  35:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  36:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  37:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  38:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  39:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  40:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  41:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  42:        0x107f4ec6e - trans::callee::trans_call_inner::h7140968817533042343\n  43:        0x107f51f62 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  44:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  45:        0x107f0b628 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  46:        0x107fd39ec - trans::base::trans_closure::h958dc77439137861U0t\n  47:        0x107ef6cc7 - trans::base::trans_fn::hf577d2d2415bb1e0zbu\n  48:        0x107ef8843 - trans::monomorphize::monomorphic_fn::ha3753571ab1e1697Tpd\n  49:        0x107f48549 - trans::callee::trans_fn_ref_with_substs::ha4203512deda00c0Zxg\n  50:        0x107f46d0e - trans::meth::trans_static_method_callee::h121f6bd3641ab9e8Jdz\n  51:        0x107f7122b - trans::expr::trans_def_fn_unadjusted::h0f303d2f55e6016bLfj\n  52:        0x107f68c90 - trans::expr::trans_def::h82fd2274b73389a6RIi\n  53:        0x107f50c07 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  54:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  55:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  56:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  57:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  58:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  59:        0x10800bfb9 - trans::tvec::write_content::hd9be974aac2e8bablIy\n  60:        0x107f5309e - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  61:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  62:        0x107fef354 - trans::_match::trans_match_inner::h50ded02cb23e3e19Pkx\n  63:        0x107f527b7 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  64:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  65:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  66:        0x107f6be48 - trans::expr::trans_addr_of::h2c4f0fccc9d6ce022Kj\n  67:        0x107f51308 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  68:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  69:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  70:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  71:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  72:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  73:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  74:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  75:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  76:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  77:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  78:        0x107f0b628 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  79:        0x107f52ad1 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  80:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  81:        0x107fef354 - trans::_match::trans_match_inner::h50ded02cb23e3e19Pkx\n  82:        0x107f527b7 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  83:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  84:        0x107f0b628 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  85:        0x107fd39ec - trans::base::trans_closure::h958dc77439137861U0t\n  86:        0x107ef6cc7 - trans::base::trans_fn::hf577d2d2415bb1e0zbu\n  87:        0x107ef8843 - trans::monomorphize::monomorphic_fn::ha3753571ab1e1697Tpd\n  88:        0x107f48549 - trans::callee::trans_fn_ref_with_substs::ha4203512deda00c0Zxg\n  89:        0x107f46043 - trans::callee::trans_fn_ref::hab9fe6b5c2b65760amg\n  90:        0x107f2379d - trans::meth::trans_method_callee::h87ce70d4d0df6b62q8y\n  91:        0x107f4ddb4 - trans::callee::trans_call_inner::h7140968817533042343\n  92:        0x107f51f62 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  93:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  94:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  95:        0x107f09d75 - trans::controlflow::trans_stmt_semi::h81af79cb9de0f0edZ2d\n  96:        0x107f0b317 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  97:        0x107fd39ec - trans::base::trans_closure::h958dc77439137861U0t\n  98:        0x107ef6cc7 - trans::base::trans_fn::hf577d2d2415bb1e0zbu\n  99:        0x107ef236b - trans::base::trans_item::h30636ef682eb6834Uyu\n  100:        0x107fd9b6c - trans::base::trans_crate::h929a913e4df3cf43Buv\n ... <frames omitted>\n\nCould not compile `ironTest`.\n\nCaused by:\n  Process didn't exit successfully: `rustc src/main.rs --crate-name ironTest --crate-type bin -g --out-dir /Users/ehsan/Workspace/ironTest/target --emit=dep-info,link -L dependency=/Users/ehsan/Workspace/ironTest/target -L dependency=/Users/ehsan/Workspace/ironTest/target/deps --extern iron=/Users/ehsan/Workspace/ironTest/target/deps/libiron-87d5ad47941cccb1.rlib --extern ironTest=/Users/ehsan/Workspace/ironTest/target/libironTest-323b2cd83dbaeffd.rlib -L native=/usr/lib -L native=/Users/ehsan/Workspace/ironTest/target/build/time-7c7fc3eb0c12ad75/out` (status=101)\n```\n\nrust version\n\n```\n$ rustc --version\nrustc 1.0.0-nightly (8903c21d6 2015-01-15 22:42:58 +0000)\n```\n\nmain.rs\n\n``` rust\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nfn main() {     \n    Iron::new(|&: _: &mut Request| {\n        Ok(Response::with((status::Ok, \"Hello world!\")))\n    }).listen(\"localhost:3000\").unwrap();\n}\n```\n. Thanks @reem, I can also compile and run Hello world example now:\n\n``` rust\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nfn main() { \n    Iron::new(|&: _: &mut Request| {\n      Ok(Response::with((status::Ok, \"Hello world!\")))\n    }).listen(\"localhost:3000\").unwrap();\n}\n```\n\nIt's responding in browsers and using curl:\n\n``` bash\n$ curl http://localhost:3000/\nHello world!\n```\n\nbut something weird happens, I can not bench it using Apache Bench:\n\n``` bash\n$ ab -n 10000 -c 10 http://localhost:3000/\nThis is ApacheBench, Version 2.3 <$Revision: 1554214 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking localhost (be patient)\napr_pollset_poll: The timeout specified has expired (70007)\n```\n\nI've tried to listen on 0.0.0.0:3000 and accessing it from another host but the same thing happened.\n\nI have also put a `println!(\"new req\")` inside the handler but it just prints \"new req\" for example 10 times when I use `-c 10`.\n. I'm getting different error on Mac OS X, using latest version of iron and rust:\n\n```\n$ RUST_BACKTRACE=1 cargo run --verbose\n       Fresh typeable v0.0.7\n       Fresh rustc-serialize v0.2.8\n       Fresh pkg-config v0.1.4\n       Fresh unicase v0.0.2\n       Fresh matches v0.1.2\n       Fresh gcc v0.1.4\n       Fresh modifier v0.0.7\n       Fresh regex v0.1.10\n       Fresh unsafe-any v0.2.1\n       Fresh mucell v0.1.10\n       Fresh phantom v0.0.3\n       Fresh error v0.1.1\n       Fresh url v0.2.16\n       Fresh log v0.1.9\n       Fresh typemap v0.0.7\n       Fresh mime v0.0.6\n       Fresh plugin v0.2.0\n       Fresh openssl-sys v0.2.16\n       Fresh time v0.1.12\n       Fresh openssl v0.2.16\n       Fresh cookie v0.1.8\n       Fresh hyper v0.1.1\n       Fresh iron v0.0.13 (https://github.com/iron/iron.git#1e632f0b)\n   Compiling ironTest v0.0.1 (file:///Users/ehsan/Workspace/ironTest)\n     Running `rustc src/main.rs --crate-name ironTest --crate-type bin -g --out-dir /Users/ehsan/Workspace/ironTest/target --emit=dep-info,link -L dependency=/Users/ehsan/Workspace/ironTest/target -L dependency=/Users/ehsan/Workspace/ironTest/target/deps --extern iron=/Users/ehsan/Workspace/ironTest/target/deps/libiron-87d5ad47941cccb1.rlib --extern ironTest=/Users/ehsan/Workspace/ironTest/target/libironTest-323b2cd83dbaeffd.rlib -L native=/usr/lib -L native=/Users/ehsan/Workspace/ironTest/target/build/time-7c7fc3eb0c12ad75/out`\nerror: internal compiler error: static call to invalid vtable: VtableObject(VtableObject(object_ty=error::Error + 'static))\nnote: the compiler unexpectedly panicked. this is a bug.\nnote: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugreport.html\nnote: run with `RUST_BACKTRACE=1` for a backtrace\nthread 'rustc' panicked at 'Box<Any>', /Users/rustbuild/src/rust-buildbot/slave/nightly-dist-rustc-mac/build/src/libsyntax/diagnostic.rs:182\n\nstack backtrace:\n   1:        0x10b6b943c - sys::backtrace::write::h915f36e5cd3021f68Tt\n   2:        0x10b6db0cf - failure::on_fail::h9cc1228f7bd1c672WXz\n   3:        0x10b647b0e - rt::unwind::begin_unwind_inner::hd5314f8d41391a63NFz\n   4:        0x10922230f - rt::unwind::begin_unwind::h10161061209420488439\n   5:        0x109222c7b - diagnostic::Handler::bug::hf3693a5c74bbd0f3I4F\n   6:        0x1087e7070 - metadata::tydecode::parse_existential_bounds_::h4924998583922597012\n   7:        0x107f46a26 - trans::meth::trans_static_method_callee::h121f6bd3641ab9e8Jdz\n   8:        0x107f43844 - trans::callee::trans::hbd524d6a7bcad3bbOag\n   9:        0x107f4c84e - trans::callee::trans_call_inner::h17534404761379207397\n  10:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  11:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  12:        0x107f0b628 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  13:        0x107fd39ec - trans::base::trans_closure::h958dc77439137861U0t\n  14:        0x107ef6cc7 - trans::base::trans_fn::hf577d2d2415bb1e0zbu\n  15:        0x107ef8843 - trans::monomorphize::monomorphic_fn::ha3753571ab1e1697Tpd\n  16:        0x107f48549 - trans::callee::trans_fn_ref_with_substs::ha4203512deda00c0Zxg\n  17:        0x107f46d0e - trans::meth::trans_static_method_callee::h121f6bd3641ab9e8Jdz\n  18:        0x107f7122b - trans::expr::trans_def_fn_unadjusted::h0f303d2f55e6016bLfj\n  19:        0x107f68c90 - trans::expr::trans_def::h82fd2274b73389a6RIi\n  20:        0x107f50c07 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  21:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  22:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  23:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  24:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  25:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  26:        0x10800bfb9 - trans::tvec::write_content::hd9be974aac2e8bablIy\n  27:        0x107f5309e - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  28:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  29:        0x107fef354 - trans::_match::trans_match_inner::h50ded02cb23e3e19Pkx\n  30:        0x107f527b7 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  31:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  32:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  33:        0x107f6be48 - trans::expr::trans_addr_of::h2c4f0fccc9d6ce022Kj\n  34:        0x107f51308 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  35:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  36:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  37:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  38:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  39:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  40:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  41:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  42:        0x107f4ec6e - trans::callee::trans_call_inner::h7140968817533042343\n  43:        0x107f51f62 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  44:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  45:        0x107f0b628 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  46:        0x107fd39ec - trans::base::trans_closure::h958dc77439137861U0t\n  47:        0x107ef6cc7 - trans::base::trans_fn::hf577d2d2415bb1e0zbu\n  48:        0x107ef8843 - trans::monomorphize::monomorphic_fn::ha3753571ab1e1697Tpd\n  49:        0x107f48549 - trans::callee::trans_fn_ref_with_substs::ha4203512deda00c0Zxg\n  50:        0x107f46d0e - trans::meth::trans_static_method_callee::h121f6bd3641ab9e8Jdz\n  51:        0x107f7122b - trans::expr::trans_def_fn_unadjusted::h0f303d2f55e6016bLfj\n  52:        0x107f68c90 - trans::expr::trans_def::h82fd2274b73389a6RIi\n  53:        0x107f50c07 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  54:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  55:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  56:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  57:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  58:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  59:        0x10800bfb9 - trans::tvec::write_content::hd9be974aac2e8bablIy\n  60:        0x107f5309e - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  61:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  62:        0x107fef354 - trans::_match::trans_match_inner::h50ded02cb23e3e19Pkx\n  63:        0x107f527b7 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  64:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  65:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  66:        0x107f6be48 - trans::expr::trans_addr_of::h2c4f0fccc9d6ce022Kj\n  67:        0x107f51308 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  68:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  69:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  70:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  71:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  72:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  73:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  74:        0x107f1c9a6 - trans::callee::trans_args::h4dbd5da02f6e146bQch\n  75:        0x107f4d718 - trans::callee::trans_call_inner::h17534404761379207397\n  76:        0x107f53573 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  77:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  78:        0x107f0b628 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  79:        0x107f52ad1 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  80:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  81:        0x107fef354 - trans::_match::trans_match_inner::h50ded02cb23e3e19Pkx\n  82:        0x107f527b7 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  83:        0x107f0aa9b - trans::expr::trans_into::h1bd27e4edc2d4d2d3yh\n  84:        0x107f0b628 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  85:        0x107fd39ec - trans::base::trans_closure::h958dc77439137861U0t\n  86:        0x107ef6cc7 - trans::base::trans_fn::hf577d2d2415bb1e0zbu\n  87:        0x107ef8843 - trans::monomorphize::monomorphic_fn::ha3753571ab1e1697Tpd\n  88:        0x107f48549 - trans::callee::trans_fn_ref_with_substs::ha4203512deda00c0Zxg\n  89:        0x107f46043 - trans::callee::trans_fn_ref::hab9fe6b5c2b65760amg\n  90:        0x107f2379d - trans::meth::trans_method_callee::h87ce70d4d0df6b62q8y\n  91:        0x107f4ddb4 - trans::callee::trans_call_inner::h7140968817533042343\n  92:        0x107f51f62 - trans::expr::trans_rvalue_dps_unadjusted::hae30080072956996mTi\n  93:        0x107f50da4 - trans::expr::trans_unadjusted::h6a089a42d1a4a7dd7ji\n  94:        0x107f0baa6 - trans::expr::trans::h1c6cee53be616487xCh\n  95:        0x107f09d75 - trans::controlflow::trans_stmt_semi::h81af79cb9de0f0edZ2d\n  96:        0x107f0b317 - trans::controlflow::trans_block::h9268c2b4b087aafeQ3d\n  97:        0x107fd39ec - trans::base::trans_closure::h958dc77439137861U0t\n  98:        0x107ef6cc7 - trans::base::trans_fn::hf577d2d2415bb1e0zbu\n  99:        0x107ef236b - trans::base::trans_item::h30636ef682eb6834Uyu\n  100:        0x107fd9b6c - trans::base::trans_crate::h929a913e4df3cf43Buv\n ... <frames omitted>\n\nCould not compile `ironTest`.\n\nCaused by:\n  Process didn't exit successfully: `rustc src/main.rs --crate-name ironTest --crate-type bin -g --out-dir /Users/ehsan/Workspace/ironTest/target --emit=dep-info,link -L dependency=/Users/ehsan/Workspace/ironTest/target -L dependency=/Users/ehsan/Workspace/ironTest/target/deps --extern iron=/Users/ehsan/Workspace/ironTest/target/deps/libiron-87d5ad47941cccb1.rlib --extern ironTest=/Users/ehsan/Workspace/ironTest/target/libironTest-323b2cd83dbaeffd.rlib -L native=/usr/lib -L native=/Users/ehsan/Workspace/ironTest/target/build/time-7c7fc3eb0c12ad75/out` (status=101)\n```\n\nrust version\n\n```\n$ rustc --version\nrustc 1.0.0-nightly (8903c21d6 2015-01-15 22:42:58 +0000)\n```\n\nmain.rs\n\n``` rust\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nfn main() {     \n    Iron::new(|&: _: &mut Request| {\n        Ok(Response::with((status::Ok, \"Hello world!\")))\n    }).listen(\"localhost:3000\").unwrap();\n}\n```\n. Thanks @reem, I can also compile and run Hello world example now:\n\n``` rust\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nfn main() { \n    Iron::new(|&: _: &mut Request| {\n      Ok(Response::with((status::Ok, \"Hello world!\")))\n    }).listen(\"localhost:3000\").unwrap();\n}\n```\n\nIt's responding in browsers and using curl:\n\n``` bash\n$ curl http://localhost:3000/\nHello world!\n```\n\nbut something weird happens, I can not bench it using Apache Bench:\n\n``` bash\n$ ab -n 10000 -c 10 http://localhost:3000/\nThis is ApacheBench, Version 2.3 <$Revision: 1554214 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking localhost (be patient)\napr_pollset_poll: The timeout specified has expired (70007)\n```\n\nI've tried to listen on 0.0.0.0:3000 and accessing it from another host but the same thing happened.\n\nI have also put a `println!(\"new req\")` inside the handler but it just prints \"new req\" for example 10 times when I use `-c 10`.\n. ",
    "heynemann": "Thank you very much Jonathan!\n\nBernardo Heynemann\nDeveloper @ globo.com\n\nOn Sun, Jan 18, 2015 at 1:52 PM, Jonathan Reem notifications@github.com\nwrote:\n\n> I submitted a pull request to mucell to fix the build failure.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/iron/iron/issues/260#issuecomment-70413135.\n. Tried building today on mac os.\n\nThis was the output:\n\n```\nUpdating registry `https://github.com/rust-lang/crates.io-index`\n Downloading mucell v0.1.11\n Downloading cookie v0.1.8\n Downloading phantom v0.0.3\n Downloading typemap v0.0.7\n Downloading hyper v0.1.1\n Downloading mime v0.0.6\n Downloading time v0.1.12\n Downloading url v0.2.16\n Downloading gcc v0.1.5\n Downloading pkg-config v0.1.5\n Downloading openssl-sys v0.2.16\n Downloading rustc-serialize v0.2.8\n Downloading error v0.1.1\n Downloading unsafe-any v0.2.1\n Downloading modifier v0.0.7\n Downloading typeable v0.0.7\n Downloading plugin v0.2.0\n Downloading log v0.1.9\n Downloading regex v0.1.10\n Downloading openssl v0.2.16\n Downloading matches v0.1.2\n Downloading iron v0.0.13\n Downloading unicase v0.0.2\n   Compiling matches v0.1.2\n   Compiling regex v0.1.10\n   Compiling pkg-config v0.1.5\n   Compiling modifier v0.0.7\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/pkg-config-0.1.5/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/pkg-config-0.1.5/src/lib.rs:1 #![allow(unstable)]\n                                                                                       ^\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/matches-0.1.2/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/matches-0.1.2/lib.rs:1 #[macro_export]\n                                                                                ^\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/modifier-0.0.7/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/modifier-0.0.7/src/lib.rs:1 #![deny(missing_docs, warnings)]\n                                                                                     ^\nerror: aborting due to previous error\n   Compiling gcc v0.1.5\n   Compiling unicase v0.0.2\n   Compiling unsafe-any v0.2.1\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/regex-0.1.10/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/regex-0.1.10/src/lib.rs:1 // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n                                                                                   ^\nerror: aborting due to previous error\n   Compiling typeable v0.0.7\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/gcc-0.1.5/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/gcc-0.1.5/src/lib.rs:1 #![allow(unstable)]\n                                                                                ^\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/unicase-0.0.2/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/unicase-0.0.2/src/lib.rs:1 #![deny(missing_docs)]\n                                                                                    ^\nerror: aborting due to previous error\n   Compiling rustc-serialize v0.2.8\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/unsafe-any-0.2.1/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/unsafe-any-0.2.1/src/lib.rs:1 #![deny(missing_docs, warnings)]\n                                                                                       ^\nerror: aborting due to previous error\n   Compiling phantom v0.0.3\n   Compiling mucell v0.1.11\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/typeable-0.0.7/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/typeable-0.0.7/src/lib.rs:1 #![allow(unstable)]\n                                                                                     ^\nerror: aborting due to previous error\nBuild failed, waiting for other jobs to finish...\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/phantom-0.0.3/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/phantom-0.0.3/src/lib.rs:1 #![deny(missing_docs)]\n                                                                                    ^\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/mucell-0.1.11/src/lib.rs:75:14: 75:32 error: can't find crate for `core`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/mucell-0.1.11/src/lib.rs:75 #[macro_use] extern crate core;\n                                                                                                  ^~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/rustc-serialize-0.2.8/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/rustc-serialize-0.2.8/src/lib.rs:1 // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n                                                                                            ^\nerror: aborting due to previous error\nCould not compile `matches`.\n\nTo learn more, run the command again with --verbose.\n```\n\nI'm using the nightly built from today's source (rustc 1.0.0-nightly (ed530d7a3 2015-01-16 22:41:16 +0000)).\n\nAnything I'm missing now?\n. I did install today with rustup... ;( Maybe problem of using mac os?\n. Still failing with mucell... ;( Do I have to install mucell trunk or something? Sorry for all the questions. Trying out rust for the first time.\n. That did it ;) I got hello.rs running. The only issue I'm seeing is that in my ubuntu 14.10 I'm seeing somewhere near 8.5k reqs/sec. Nowhere near 84k reqs/sec. That's good enough anyway! Thanks for your help!\n. Thank you very much Jonathan!\n\nBernardo Heynemann\nDeveloper @ globo.com\n\nOn Sun, Jan 18, 2015 at 1:52 PM, Jonathan Reem notifications@github.com\nwrote:\n\n> I submitted a pull request to mucell to fix the build failure.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/iron/iron/issues/260#issuecomment-70413135.\n. Tried building today on mac os.\n\nThis was the output:\n\n```\nUpdating registry `https://github.com/rust-lang/crates.io-index`\n Downloading mucell v0.1.11\n Downloading cookie v0.1.8\n Downloading phantom v0.0.3\n Downloading typemap v0.0.7\n Downloading hyper v0.1.1\n Downloading mime v0.0.6\n Downloading time v0.1.12\n Downloading url v0.2.16\n Downloading gcc v0.1.5\n Downloading pkg-config v0.1.5\n Downloading openssl-sys v0.2.16\n Downloading rustc-serialize v0.2.8\n Downloading error v0.1.1\n Downloading unsafe-any v0.2.1\n Downloading modifier v0.0.7\n Downloading typeable v0.0.7\n Downloading plugin v0.2.0\n Downloading log v0.1.9\n Downloading regex v0.1.10\n Downloading openssl v0.2.16\n Downloading matches v0.1.2\n Downloading iron v0.0.13\n Downloading unicase v0.0.2\n   Compiling matches v0.1.2\n   Compiling regex v0.1.10\n   Compiling pkg-config v0.1.5\n   Compiling modifier v0.0.7\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/pkg-config-0.1.5/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/pkg-config-0.1.5/src/lib.rs:1 #![allow(unstable)]\n                                                                                       ^\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/matches-0.1.2/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/matches-0.1.2/lib.rs:1 #[macro_export]\n                                                                                ^\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/modifier-0.0.7/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/modifier-0.0.7/src/lib.rs:1 #![deny(missing_docs, warnings)]\n                                                                                     ^\nerror: aborting due to previous error\n   Compiling gcc v0.1.5\n   Compiling unicase v0.0.2\n   Compiling unsafe-any v0.2.1\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/regex-0.1.10/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/regex-0.1.10/src/lib.rs:1 // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n                                                                                   ^\nerror: aborting due to previous error\n   Compiling typeable v0.0.7\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/gcc-0.1.5/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/gcc-0.1.5/src/lib.rs:1 #![allow(unstable)]\n                                                                                ^\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/unicase-0.0.2/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/unicase-0.0.2/src/lib.rs:1 #![deny(missing_docs)]\n                                                                                    ^\nerror: aborting due to previous error\n   Compiling rustc-serialize v0.2.8\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/unsafe-any-0.2.1/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/unsafe-any-0.2.1/src/lib.rs:1 #![deny(missing_docs, warnings)]\n                                                                                       ^\nerror: aborting due to previous error\n   Compiling phantom v0.0.3\n   Compiling mucell v0.1.11\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/typeable-0.0.7/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/typeable-0.0.7/src/lib.rs:1 #![allow(unstable)]\n                                                                                     ^\nerror: aborting due to previous error\nBuild failed, waiting for other jobs to finish...\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/phantom-0.0.3/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/phantom-0.0.3/src/lib.rs:1 #![deny(missing_docs)]\n                                                                                    ^\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/mucell-0.1.11/src/lib.rs:75:14: 75:32 error: can't find crate for `core`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/mucell-0.1.11/src/lib.rs:75 #[macro_use] extern crate core;\n                                                                                                  ^~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/rustc-serialize-0.2.8/src/lib.rs:1:1: 1:1 error: can't find crate for `std`\n../../../.cargo/registry/src/github.com-1ecc6299db9ec823/rustc-serialize-0.2.8/src/lib.rs:1 // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n                                                                                            ^\nerror: aborting due to previous error\nCould not compile `matches`.\n\nTo learn more, run the command again with --verbose.\n```\n\nI'm using the nightly built from today's source (rustc 1.0.0-nightly (ed530d7a3 2015-01-16 22:41:16 +0000)).\n\nAnything I'm missing now?\n. I did install today with rustup... ;( Maybe problem of using mac os?\n. Still failing with mucell... ;( Do I have to install mucell trunk or something? Sorry for all the questions. Trying out rust for the first time.\n. That did it ;) I got hello.rs running. The only issue I'm seeing is that in my ubuntu 14.10 I'm seeing somewhere near 8.5k reqs/sec. Nowhere near 84k reqs/sec. That's good enough anyway! Thanks for your help!\n. ",
    "jihokoo": "@reem i forked iron, hyper, and mucell with your fix and its working :+1: \n. @reem i forked iron, hyper, and mucell with your fix and its working :+1: \n. ",
    "abonander": "I haven't been maintaining multipart lately due to lack of interest but I definitely wouldn't mind it becoming a component of Iron.\n\nThe main issue is that Iron provides the request body to its middleware as `Vec<u8>` which is kind of a bad idea if you want to support large request bodies, such as with file uploads. I shared some ideas in a Reddit discussion a while back but I don't know if anything came of that.\n. I'm concerned that a naively written `BeforeMiddleware` would be able to opaquely invalidate a request by reading its body to EOF, since it is passed `&mut Request`, thus making the body unavailable to subsequent middleware and handlers. It's mostly the user's problem, but it also seems like something we could easily prevent in the API. \n\nIs there any use-case where `BeforeMiddleware` has to inspect the request body directly? That would break anyways with this change, since the ordering of the middleware affects how much of the body might have been read.\n\nPerhaps `BeforeMiddleware` can get a `RequestInfo` struct that provides everything but the body, or separate the body from `Request` and pass it to `Handler` directly.\n. Ah. [The docs just need rebuilt then.](http://ironframework.io/doc/iron/middleware/trait.Handler.html) :smile: \n. I haven't been maintaining multipart lately due to lack of interest but I definitely wouldn't mind it becoming a component of Iron.\n\nThe main issue is that Iron provides the request body to its middleware as `Vec<u8>` which is kind of a bad idea if you want to support large request bodies, such as with file uploads. I shared some ideas in a Reddit discussion a while back but I don't know if anything came of that.\n. I'm concerned that a naively written `BeforeMiddleware` would be able to opaquely invalidate a request by reading its body to EOF, since it is passed `&mut Request`, thus making the body unavailable to subsequent middleware and handlers. It's mostly the user's problem, but it also seems like something we could easily prevent in the API. \n\nIs there any use-case where `BeforeMiddleware` has to inspect the request body directly? That would break anyways with this change, since the ordering of the middleware affects how much of the body might have been read.\n\nPerhaps `BeforeMiddleware` can get a `RequestInfo` struct that provides everything but the body, or separate the body from `Request` and pass it to `Handler` directly.\n. Ah. [The docs just need rebuilt then.](http://ironframework.io/doc/iron/middleware/trait.Handler.html) :smile: \n. ",
    "cyndis": "Thanks :) Your suggestions are good, I'll post a v2 in a moment :)\n. Here's v2. I'll squash once the patch is ready. One thing I was wondering about was if we should add Protocol to the prelude.\n. For what? :) Iron's constructor also requires handler and Protocol doesn't contain addr.\n. I don't feel it would be too bad if Protocol was included in the prelude, but I could replace Iron::new with Iron::http and Iron::https taking (handler) and (handler, certificate, key) respectively. That would also closely mirror Hyper's API.\n. Ah, ok :) That makes sense. So listen_with would still take a Protocol, just the convenience method would be replaced.\n. v3 here.\n. Hi, can you merge this? :)\n. Thanks!\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Thanks :) Your suggestions are good, I'll post a v2 in a moment :)\n. Here's v2. I'll squash once the patch is ready. One thing I was wondering about was if we should add Protocol to the prelude.\n. For what? :) Iron's constructor also requires handler and Protocol doesn't contain addr.\n. I don't feel it would be too bad if Protocol was included in the prelude, but I could replace Iron::new with Iron::http and Iron::https taking (handler) and (handler, certificate, key) respectively. That would also closely mirror Hyper's API.\n. Ah, ok :) That makes sense. So listen_with would still take a Protocol, just the convenience method would be replaced.\n. v3 here.\n. Hi, can you merge this? :)\n. Thanks!\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "SkylerLipthay": "Rebased!\n. @reem Well, I rebased!\n. @reem Fixed, rebased, squashed, reworded, and macarena'd.\n. Thanks for the report! If I am not mistaken, Hyper raises this if the request body is not entirely read by the end of handling. Is there a way to just close the stream, ignoring the rest of a body?\n. Hi! We actually have a new plugin that encapsulates `formdata` called [`iron/params`](https://github.com/iron/params); you might be interested in using that. Regardless, you can check out how the `hyper::header::Headers` and `formdata::Request` types were integrated [here](https://github.com/iron/params/blob/master/src/lib.rs#L525) and [here](https://github.com/iron/params/blob/master/src/lib.rs#L562).\n. @RenaudParis I know this is quite a late response, but I've just now released params 0.0.2, which fixes compatibility with the formdata crate and the error you described.\n. Hi!\n\n[`req.extensions.get`](http://ironframework.io/doc/iron/typemap/struct.TypeMap.html#method.get) captures `&self`, so `req` itself is immutably borrowed for the rest of the scope (in this case, the rest of the function). [`req.get_ref`](http://ironframework.io/doc/iron/prelude/trait.Pluggable.html#method.get_ref) tries to capture `&mut self`, but `req` cannot be mutably borrowed while any other borrows (mutable _or_ mutable) are active.\n\n`Pluggable`, through which `params::Map` is accessed, requires `&mut self`. For Iron's sake, this is nice because it allows plugins to \"mutate\" the request (in this case, reading from the request body stream to extract parameters).\n\nAnyway, a simple fix would be to reverse the order of the `let connection` and `let payload` lines; `payload` itself doesn't hold on to a reference of `req`, but `connection` does.\n\nOr, you may be interested in dropping usage of the `extensions` `TypeMap` altogether and using a `Plugin` to access the database. [Here's one example](https://github.com/superlogical/rustwebapp/blob/master/src/main.rs#L132) that uses Iron's `persistent` crate, which uses `Arc` internally to help you avoid these borrow/lifetime ergonomics issues.\n\nI'm not 100% sure if it's the intentional semantics of Iron, but `req.extensions` seems to be used for storing _pre-calculated data_ specifically for communication between middleware (such as with Iron's `router` middleware). Plugins are suited for _lazy evaluation_, and can also provide caching for the resultant data. `params` is a plugin because not all requests need to access request parameters, so they should only be deserialized when requested. In many ways, I think it's semantically correct for database access to be through plugins.\n\nSorry, I think I'm babbling. :smile: Hopefully this shed some light on your situation.\n. Looks great, thank you for the detailed pull request. I think we'll leave the default MIME type as `text/plain` just because this would otherwise be a breaking change and given my current capacity on this project I'm not comfortable making that call. Also I'm not sure how other frameworks handle it... Anyway, this can of course be changed in the future if deemed necessary. Thanks again!. Hmm. Well, that branch is quite behind `master` and it seems that all new commits over the past 4 months have gone straight into `master`. So I think you're good.\r\n\r\nThe question of \"when is the next version scheduled for release?\" is one I'm curious about myself... I don't know what this process looks like these days.... Rebased!\n. @reem Well, I rebased!\n. @reem Fixed, rebased, squashed, reworded, and macarena'd.\n. Thanks for the report! If I am not mistaken, Hyper raises this if the request body is not entirely read by the end of handling. Is there a way to just close the stream, ignoring the rest of a body?\n. Hi! We actually have a new plugin that encapsulates `formdata` called [`iron/params`](https://github.com/iron/params); you might be interested in using that. Regardless, you can check out how the `hyper::header::Headers` and `formdata::Request` types were integrated [here](https://github.com/iron/params/blob/master/src/lib.rs#L525) and [here](https://github.com/iron/params/blob/master/src/lib.rs#L562).\n. @RenaudParis I know this is quite a late response, but I've just now released params 0.0.2, which fixes compatibility with the formdata crate and the error you described.\n. Hi!\n\n[`req.extensions.get`](http://ironframework.io/doc/iron/typemap/struct.TypeMap.html#method.get) captures `&self`, so `req` itself is immutably borrowed for the rest of the scope (in this case, the rest of the function). [`req.get_ref`](http://ironframework.io/doc/iron/prelude/trait.Pluggable.html#method.get_ref) tries to capture `&mut self`, but `req` cannot be mutably borrowed while any other borrows (mutable _or_ mutable) are active.\n\n`Pluggable`, through which `params::Map` is accessed, requires `&mut self`. For Iron's sake, this is nice because it allows plugins to \"mutate\" the request (in this case, reading from the request body stream to extract parameters).\n\nAnyway, a simple fix would be to reverse the order of the `let connection` and `let payload` lines; `payload` itself doesn't hold on to a reference of `req`, but `connection` does.\n\nOr, you may be interested in dropping usage of the `extensions` `TypeMap` altogether and using a `Plugin` to access the database. [Here's one example](https://github.com/superlogical/rustwebapp/blob/master/src/main.rs#L132) that uses Iron's `persistent` crate, which uses `Arc` internally to help you avoid these borrow/lifetime ergonomics issues.\n\nI'm not 100% sure if it's the intentional semantics of Iron, but `req.extensions` seems to be used for storing _pre-calculated data_ specifically for communication between middleware (such as with Iron's `router` middleware). Plugins are suited for _lazy evaluation_, and can also provide caching for the resultant data. `params` is a plugin because not all requests need to access request parameters, so they should only be deserialized when requested. In many ways, I think it's semantically correct for database access to be through plugins.\n\nSorry, I think I'm babbling. :smile: Hopefully this shed some light on your situation.\n. Looks great, thank you for the detailed pull request. I think we'll leave the default MIME type as `text/plain` just because this would otherwise be a breaking change and given my current capacity on this project I'm not comfortable making that call. Also I'm not sure how other frameworks handle it... Anyway, this can of course be changed in the future if deemed necessary. Thanks again!. Hmm. Well, that branch is quite behind `master` and it seems that all new commits over the past 4 months have gone straight into `master`. So I think you're good.\r\n\r\nThe question of \"when is the next version scheduled for release?\" is one I'm curious about myself... I don't know what this process looks like these days.... ",
    "nyrf": "I have tried on my md101 8g ram and on ubuntu 14.10, got same result. \n. This is my cargo.toml\n\n``` toml\n[package]\n\nname = \"demo\"\nversion = \"0.0.1\"\nauthors = [\"nyrf <nyrf1125@gmail.com>\"]\n\n[dependencies]\niron=\"*\"\n```\n\n`src/main.rs`\n\n``` rust\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nfn main() {\n    Iron::new(|&: _: &mut Request| {\n        Ok(Response::with((status::Ok, \"Hello world!\")))\n    }).listen(\"localhost:3000\").unwrap();\n}\n```\n\nThen `cargo build`, `cargo run`, `wrk -t12 -c900 -d10s http://127.0.0.1:3000/`\n\n```\nRunning 10s test @ http://127.0.0.1:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    12.11ms   46.52ms 205.97ms   94.39%\n    Req/Sec     7.20k     1.65k    9.33k    77.93%\n  67271 requests in 10.07s, 7.31MB read\n  Socket errors: connect 0, read 255, write 0, timeout 3569\nRequests/sec:   6679.85\nTransfer/sec:    743.66KB\n```\n. Oh, i see, thank you. the new result.\n\n```\nRunning 10s test @ http://localhost:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     2.17ms    6.15ms  22.09ms   91.29%\n    Req/Sec    22.41k     8.06k   42.78k    68.87%\n  206459 requests in 10.07s, 22.45MB read\n  Socket errors: connect 0, read 855, write 5, timeout 2942\nRequests/sec:  20494.03\nTransfer/sec:      2.23MB\n```\n. No, i use my md101 , 8g ram  and samsung SSD 840PRO 256G.\n. I have tried on my md101 8g ram and on ubuntu 14.10, got same result. \n. This is my cargo.toml\n\n``` toml\n[package]\n\nname = \"demo\"\nversion = \"0.0.1\"\nauthors = [\"nyrf <nyrf1125@gmail.com>\"]\n\n[dependencies]\niron=\"*\"\n```\n\n`src/main.rs`\n\n``` rust\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nfn main() {\n    Iron::new(|&: _: &mut Request| {\n        Ok(Response::with((status::Ok, \"Hello world!\")))\n    }).listen(\"localhost:3000\").unwrap();\n}\n```\n\nThen `cargo build`, `cargo run`, `wrk -t12 -c900 -d10s http://127.0.0.1:3000/`\n\n```\nRunning 10s test @ http://127.0.0.1:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    12.11ms   46.52ms 205.97ms   94.39%\n    Req/Sec     7.20k     1.65k    9.33k    77.93%\n  67271 requests in 10.07s, 7.31MB read\n  Socket errors: connect 0, read 255, write 0, timeout 3569\nRequests/sec:   6679.85\nTransfer/sec:    743.66KB\n```\n. Oh, i see, thank you. the new result.\n\n```\nRunning 10s test @ http://localhost:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     2.17ms    6.15ms  22.09ms   91.29%\n    Req/Sec    22.41k     8.06k   42.78k    68.87%\n  206459 requests in 10.07s, 22.45MB read\n  Socket errors: connect 0, read 855, write 5, timeout 2942\nRequests/sec:  20494.03\nTransfer/sec:      2.23MB\n```\n. No, i use my md101 , 8g ram  and samsung SSD 840PRO 256G.\n. ",
    "aleksandrpak": "I have removed Modifier implementation for u64. Is it ok to add ContentLength header in Modifier implementation of File?\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I have removed Modifier implementation for u64. Is it ok to add ContentLength header in Modifier implementation of File?\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "Ogeon": "I'm interested. It's obvious that we have slightly different approaches to the problem, but our libraries exposes mostly similar request handling. Having a common API would make it easier to use the same additions on top of different base libraries. It fits well with the Rustful philosophy :)\n\nThe big question is \"How?\"\n. The problem I can see right now is that we will have to unify the way we handle data. It may even require an adapter layer. Rustful, for example, uses Hyper as a base and extends the request with more context and the response with a filtering plugin stack. I would rather not drop them from the library and I'm sure each library has its own complicating factor. Nickel, for example, is still using its own branch of rust-http (right?) and Iron seems to be built to create the response inside the handler and return it.\n. I almost forgot about Conduit for a moment. It can surely function as a minimal common set of features. I mean, it's all just HTTP in the end. The trick is to identify this set and make sure the interface is flexible enough to avoid turning everything into Hyper+overhead.\n. No, not as far as I know. You could possibly reuse pieces of some general HTTP library, in your case, but it would probably come with a lot more than what you need.\n. I'm interested. It's obvious that we have slightly different approaches to the problem, but our libraries exposes mostly similar request handling. Having a common API would make it easier to use the same additions on top of different base libraries. It fits well with the Rustful philosophy :)\n\nThe big question is \"How?\"\n. The problem I can see right now is that we will have to unify the way we handle data. It may even require an adapter layer. Rustful, for example, uses Hyper as a base and extends the request with more context and the response with a filtering plugin stack. I would rather not drop them from the library and I'm sure each library has its own complicating factor. Nickel, for example, is still using its own branch of rust-http (right?) and Iron seems to be built to create the response inside the handler and return it.\n. I almost forgot about Conduit for a moment. It can surely function as a minimal common set of features. I mean, it's all just HTTP in the end. The trick is to identify this set and make sure the interface is flexible enough to avoid turning everything into Hyper+overhead.\n. No, not as far as I know. You could possibly reuse pieces of some general HTTP library, in your case, but it would probably come with a lot more than what you need.\n. ",
    "Ryman": "Very interested in this, it's crossed my mind a few times, and I agree that 'how' is the question. \n\nRusts ownership model makes this tricky as @Ogeon has pointed out, where `iron` creates Responses in the handler while others pass them down into the handlers. At least we could start with a common base of traits based on hypers request and its `Streaming` and `Fresh` responses?\n\n@Ogeon re: rust-http: Yeah, still on a fork, but will hopefully be using hyper in the next week or so. \n\n@sunng87 things have probably changed a lot since then, but @reem did leave feedback on conduit's issue tracker [back in November](https://github.com/conduit-rust/conduit/issues/4) where he considers a potential common base.\n\ncc @SimonPersson\n. Very interested in this, it's crossed my mind a few times, and I agree that 'how' is the question. \n\nRusts ownership model makes this tricky as @Ogeon has pointed out, where `iron` creates Responses in the handler while others pass them down into the handlers. At least we could start with a common base of traits based on hypers request and its `Streaming` and `Fresh` responses?\n\n@Ogeon re: rust-http: Yeah, still on a fork, but will hopefully be using hyper in the next week or so. \n\n@sunng87 things have probably changed a lot since then, but @reem did leave feedback on conduit's issue tracker [back in November](https://github.com/conduit-rust/conduit/issues/4) where he considers a potential common base.\n\ncc @SimonPersson\n. ",
    "lucab": "Any progress on this? I'm approaching the same issue from the other end (fastcgi / uwsgi / etc connectors) and I'm not sure which traits should be provided to applications (for headers/env/body) and what should expect back.\n\nThis is an open question for [uwsgi-rust](https://github.com/unbit/uwsgi-rust), which is currently abusing strings everywhere.\n. Any progress on this? I'm approaching the same issue from the other end (fastcgi / uwsgi / etc connectors) and I'm not sure which traits should be provided to applications (for headers/env/body) and what should expect back.\n\nThis is an open question for [uwsgi-rust](https://github.com/unbit/uwsgi-rust), which is currently abusing strings everywhere.\n. ",
    "panicbit": "There still needs some work to be done.\nIron currently crashes when unwrapping the protocol (https://github.com/panicbit/iron/blob/a18db56fd6ffff94664a07784c1258fa827fa2b6/src/iron.rs#L147)\n. The crash was caused by writing to a struct that moved away (See rust-lang/rust#21232)\n. hyperium/hyper#354 is merged now, so this PR should build now\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Not sure what you're seeing, but `BodyReader` and its field look pretty public to me:\n\n``` rust\npub struct BodyReader<R: Send>(pub R);\n```\n\n;)\n. There still needs some work to be done.\nIron currently crashes when unwrapping the protocol (https://github.com/panicbit/iron/blob/a18db56fd6ffff94664a07784c1258fa827fa2b6/src/iron.rs#L147)\n. The crash was caused by writing to a struct that moved away (See rust-lang/rust#21232)\n. hyperium/hyper#354 is merged now, so this PR should build now\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Not sure what you're seeing, but `BodyReader` and its field look pretty public to me:\n\n``` rust\npub struct BodyReader<R: Send>(pub R);\n```\n\n;)\n. ",
    "dbalchev": "That was fast feedback.\nThanks!\n. That was fast feedback.\nThanks!\n. ",
    "golddranks": "Ah, I see. So does `a relative scheme` mean a URL without specifying the scheme, then? Like \"//google.com\"? In that case the docstring could indeed use some rephrasing to be more clear.\n. Ah, I see. So does `a relative scheme` mean a URL without specifying the scheme, then? Like \"//google.com\"? In that case the docstring could indeed use some rephrasing to be more clear.\n. ",
    "diogovk": "The url https://url.spec.whatwg.org/#relative-scheme seems to be no longer working.\nI've checked and `relative-scheme` was renamed to `special-scheme`, in the specification.\nThat's probably the source of this confusion.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. The url https://url.spec.whatwg.org/#relative-scheme seems to be no longer working.\nI've checked and `relative-scheme` was renamed to `special-scheme`, in the specification.\nThat's probably the source of this confusion.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "jamperry": "I would like to help out by creating a getting started guide as I feel this is a great way to get developers up and ready quickly. The guide will provide examples and how to use the modules like urlencoded, router, etc.\n. Don't worry, I believe you :) I've started to write the beginning of the guide here: https://github.com/lambdaburrito/iron/wiki/Getting-started\n. This shouldn't be closed as it's not fixed for the beta. I am very concerned that you cannot even see the build issues. \n. I would like to help out by creating a getting started guide as I feel this is a great way to get developers up and ready quickly. The guide will provide examples and how to use the modules like urlencoded, router, etc.\n. Don't worry, I believe you :) I've started to write the beginning of the guide here: https://github.com/lambdaburrito/iron/wiki/Getting-started\n. This shouldn't be closed as it's not fixed for the beta. I am very concerned that you cannot even see the build issues. \n. ",
    "ccostes": "Awesome, thanks for fixing this so quickly! This project looks pretty cool and I'm excited to check it out.\n. Awesome, thanks for fixing this so quickly! This project looks pretty cool and I'm excited to check it out.\n. ",
    "aturon": "Note that `File::path` is not likely to be stabilized soon -- it will probably be deprecated instead. Its primary use was for providing more informative error messages internally, but as part of the reform we've been stripping out these extra layers of functionality (and making the core IO types be thin wrappers around descriptors).\n. Note that `File::path` is not likely to be stabilized soon -- it will probably be deprecated instead. Its primary use was for providing more informative error messages internally, but as part of the reform we've been stripping out these extra layers of functionality (and making the core IO types be thin wrappers around descriptors).\n. ",
    "Parakleta": "This patch (a533de8) seems a little clumsy, since it leaves the comment on [#L93](https://github.com/iron/iron/blob/a255647264d198016e753019be2dbe1d120a6d7e/src/modifiers.rs#L93) which is no longer correct and didn't duplicate the mime setting behaviour into the `PathBuf` variant on [#L128](https://github.com/iron/iron/blob/a255647264d198016e753019be2dbe1d120a6d7e/src/modifiers.rs#L128).\n\nIs it possible to chain either `&Path` or `PathBuf` through the other to save duplicated code?  Alternatively since `PathBuf` implements `Deref` into `Path` can one or the other variant just be discarded (I'm still a bit fuzzy on how `Deref` works)?\n. This patch (a533de8) seems a little clumsy, since it leaves the comment on [#L93](https://github.com/iron/iron/blob/a255647264d198016e753019be2dbe1d120a6d7e/src/modifiers.rs#L93) which is no longer correct and didn't duplicate the mime setting behaviour into the `PathBuf` variant on [#L128](https://github.com/iron/iron/blob/a255647264d198016e753019be2dbe1d120a6d7e/src/modifiers.rs#L128).\n\nIs it possible to chain either `&Path` or `PathBuf` through the other to save duplicated code?  Alternatively since `PathBuf` implements `Deref` into `Path` can one or the other variant just be discarded (I'm still a bit fuzzy on how `Deref` works)?\n. ",
    "gsquire": "Are you referring to the join guard returned in a `thread::scoped` function? It says that it [\"blocks until it terminates\"](https://doc.rust-lang.org/std/thread/#scoped-threads) and looking at the Hyper source I see the listener [creates](https://github.com/hyperium/hyper/blob/4c5a42bcdab18f59d0d3ee3512d1e33c4dada2f2/src/server/mod.rs#L107) a scoped thread when making the connection pool.\n\nIf this is what you are referring to, then I will gladly take a shot at updating the documentation.\n. @reem I squashed the two commits and pushed it.\n. It builds now for me on beta. Sometimes it breaks but it will get updated rather quickly.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. @untitaker If this looks good, I can rebase my commits.\n. Is it not [already](https://github.com/iron/iron/blob/2fd6e079592ec340d8c75200bd54fde91ce34d51/src/lib.rs#L135)?\n. In Iron, you can use the [Modifier](http://ironframework.io/doc/modifier/trait.Modifier.html) trait to provide a response body. The best way to do this is through [`Response::with`](http://ironframework.io/doc/iron/response/struct.Response.html#method.with). It will accept anything that implements the Modifier trait for a Response.\n\nYou can pass in a String, bytes, a File, status codes, etc. And the list of implementors on the Modifier page will show you all that is available in the Iron crate. Of course you can implement your own type which modifies Responses too if you need more functionality.\n. This may be a better issue for [hyper](https://github.com/hyperium/hyper).\n. Yes, it is.\n\nYou can use [iron's modifiers](http://ironframework.io/doc/modifier/trait.Modifier.html) in a Response like such:\n\n``` rust\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nuse std::fs::File;\n\nfn use_file(_: &mut Request) -> IronResult<Response> {\n    let f = File::open(\"some.txt\").unwrap(); // For example's sake.\n    Ok(Response::with((status::Ok, f)))\n}\n\nfn main() {\n    Iron::new(use_file).http(\"localhost:3000\").unwrap();\n}\n```\n. No problem! Thanks for adding it in.. Are you referring to the join guard returned in a `thread::scoped` function? It says that it [\"blocks until it terminates\"](https://doc.rust-lang.org/std/thread/#scoped-threads) and looking at the Hyper source I see the listener [creates](https://github.com/hyperium/hyper/blob/4c5a42bcdab18f59d0d3ee3512d1e33c4dada2f2/src/server/mod.rs#L107) a scoped thread when making the connection pool.\n\nIf this is what you are referring to, then I will gladly take a shot at updating the documentation.\n. @reem I squashed the two commits and pushed it.\n. It builds now for me on beta. Sometimes it breaks but it will get updated rather quickly.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. @untitaker If this looks good, I can rebase my commits.\n. Is it not [already](https://github.com/iron/iron/blob/2fd6e079592ec340d8c75200bd54fde91ce34d51/src/lib.rs#L135)?\n. In Iron, you can use the [Modifier](http://ironframework.io/doc/modifier/trait.Modifier.html) trait to provide a response body. The best way to do this is through [`Response::with`](http://ironframework.io/doc/iron/response/struct.Response.html#method.with). It will accept anything that implements the Modifier trait for a Response.\n\nYou can pass in a String, bytes, a File, status codes, etc. And the list of implementors on the Modifier page will show you all that is available in the Iron crate. Of course you can implement your own type which modifies Responses too if you need more functionality.\n. This may be a better issue for [hyper](https://github.com/hyperium/hyper).\n. Yes, it is.\n\nYou can use [iron's modifiers](http://ironframework.io/doc/modifier/trait.Modifier.html) in a Response like such:\n\n``` rust\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nuse std::fs::File;\n\nfn use_file(_: &mut Request) -> IronResult<Response> {\n    let f = File::open(\"some.txt\").unwrap(); // For example's sake.\n    Ok(Response::with((status::Ok, f)))\n}\n\nfn main() {\n    Iron::new(use_file).http(\"localhost:3000\").unwrap();\n}\n```\n. No problem! Thanks for adding it in.. ",
    "byteslayer7": "I also haven't been able to build Iron. I've gotten a number of different errors the past few days but they all relate to the \"typemap\" package. The error I'm currently getting is this:\n\n```\nlib.rs:67:14: 67:23 error: expected ident, found `\"typemap\"`\n```\n. I also haven't been able to build Iron. I've gotten a number of different errors the past few days but they all relate to the \"typemap\" package. The error I'm currently getting is this:\n\n```\nlib.rs:67:14: 67:23 error: expected ident, found `\"typemap\"`\n```\n. ",
    "rookwood101": "Ok, thanks for letting me know.\n. Ok, thanks for letting me know.\n. ",
    "ghmlee": "@reem Is it okay? :)\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. @cmr Please mark my username and can you please remove my username on the list?. @reem Is it okay? :)\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. @cmr Please mark my username and can you please remove my username on the list?. ",
    "fuchsnj": "@lambdaburrito As a temporary fix, you can download the repository and use a .cargo config file to override the dependency to use the one you downloaded. See the `paths` config here: http://doc.crates.io/config.html\n. I have the same issue. This causes the HTTP method on the next request to parse incorrectly, and looks like this:\n\n```\nrequest method: Options\nrequest method: Post\nrequest method: Options\nrequest method: Extension(\"{\\\"password\\\":\\\"\\\"}POST\")\n```\n\nSee the issue causing this in hyper I opened a while ago: https://github.com/hyperium/hyper/issues/652\nAnd it looks like a fixed was merged recently: https://github.com/hyperium/hyper/issues/309\n. @lambdaburrito As a temporary fix, you can download the repository and use a .cargo config file to override the dependency to use the one you downloaded. See the `paths` config here: http://doc.crates.io/config.html\n. I have the same issue. This causes the HTTP method on the next request to parse incorrectly, and looks like this:\n\n```\nrequest method: Options\nrequest method: Post\nrequest method: Options\nrequest method: Extension(\"{\\\"password\\\":\\\"\\\"}POST\")\n```\n\nSee the issue causing this in hyper I opened a while ago: https://github.com/hyperium/hyper/issues/652\nAnd it looks like a fixed was merged recently: https://github.com/hyperium/hyper/issues/309\n. ",
    "jlouis": "And thank you for the pointer toward the problem. I agree this might be it. My current plan is probably to suspend my work with Rust/Iron for the while and focus on other frameworks, as I'm looking at latency distributions of different webservers/framework.\n\nIn any case, the current situation is not fair to Iron in any way, so I'd rather postpone the current and realign the spotlight later. I'll be watching the hyper issue as well as this one.\n. And thank you for the pointer toward the problem. I agree this might be it. My current plan is probably to suspend my work with Rust/Iron for the while and focus on other frameworks, as I'm looking at latency distributions of different webservers/framework.\n\nIn any case, the current situation is not fair to Iron in any way, so I'd rather postpone the current and realign the spotlight later. I'll be watching the hyper issue as well as this one.\n. ",
    "devonoel": "@reem Alright, well how about just using Travis' .svg badge instead?\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. @reem Alright, well how about just using Travis' .svg badge instead?\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "heibor": "I think use mio may be a good idear, it can bing us more performance.\n. I think use mio may be a good idear, it can bing us more performance.\n. ",
    "fsommar": "I started an implementation [here](https://github.com/fsommar/todo-backend-iron) with an in-memory list to maintain all todos. Currently it only supports adding a todo, getting all todos and deleting all todos.\n. It's working fully now, but I wouldn't say the code is idiomatic of Iron and Rust mainly because of the lack of error handling.\n\nSuggestions and PRs are welcomed.\n. I started an implementation [here](https://github.com/fsommar/todo-backend-iron) with an in-memory list to maintain all todos. Currently it only supports adding a todo, getting all todos and deleting all todos.\n. It's working fully now, but I wouldn't say the code is idiomatic of Iron and Rust mainly because of the lack of error handling.\n\nSuggestions and PRs are welcomed.\n. ",
    "zmbush": "Fixed.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Fixed.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "fenhl": "This is harder to implement than it looks, because `BeforeMiddleware` and `AfterMiddleware` are traits.\n. This is harder to implement than it looks, because `BeforeMiddleware` and `AfterMiddleware` are traits.\n. ",
    "sfackler": "I believe this is a Hyper rather than Iron issue - the `headers` module is reexported from Hyper.. I'd be totally on board with defining an opaque wrapper around the hyper response but think it still makes sense to have it be a concrete type instead of generic over `Write`.\n. Updated with the wrapper type.\n. @mneumann Here's one example of generating the response while sending it:\n\n``` rust\nstruct WriteNumbers;\n\nimpl WriteBody for WriteNumbers {\n    fn write_body(&mut self, body: &mut ResponseBody) -> IronResult<()> {\n        for i in 0..10000 {\n            try!(write!(body, \"{}\", i));\n        }\n    }\n}\n\nfn handle_write_numbers(_: &mut Request) -> IronResult<Response> {\n    let body: Box<WriteBody + Send> = Box::new(WriteNumbers);\n    Ok(Response::with(body))\n}\n```\n\n@bfrog That's not really how this API is structured. That seems like a job for [AfterMiddleware](http://ironframework.io/doc/iron/middleware/trait.AfterMiddleware.html)?\n. :confetti_ball: \n. This is implemented in #510. @untitaker I believe this is superseded by #510. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Yes!\n. @untitaker I believe the request is for a method that forwards to `Request::downcast_ref`: https://docs.rs/hyper/0.9.14/hyper/server/request/struct.Request.html#method.downcast_ref. I've added an after middleware that reads the remaining request body to a project I'm working on for this kind of thing. Hyper should probably have some logic to dispose of connections that haven't had their bodies consumed though - cc @seanmonstar. When a connection with an unconsumed body is recycled for keepalive, Hyper's internals will try to read a new request from it, get the remaining request body, fail to parse it as an HTTP header, and drop the connection. Normally this is fine, but if the client *immediately* tries to reuse the connection for another request, that can happen before it's notified that the connection dropped.. This is the behavior of current hyper (0.10)\nOn Sat, Mar 18, 2017 at 9:51 PM Matt Hauck <notifications@github.com> wrote:\n\n> @sfackler <https://github.com/sfackler>: Are you referring to new or old\n> behavior in hyper?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/iron/iron/issues/444#issuecomment-287594363>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/ABY2UburIq22V8ODJ44KnRh0yhCZxQmhks5rnLQ0gaJpZM4H5oeL>\n> .\n>\n. @untitaker I believe this is superseded by #510. @untitaker I believe this is superseded by #510. You can now provide an arbitrary Hyper `Listener` to Iron - does that cover this feature request?. Oops, wrong @seanmonstar... Ok, I've switched the https example over to native-tls, which should make things nicer for OSX and especially Windows users.. Done. It might actually be nicer to make Request opaque and provide accessors, since a bunch of this stuff is stored directly in the hyper request.. This is already a backwards-incompatible change since it's adding a field to a struct with no private fields.\r\n\r\n#510 is a breaking change anyway, so I'm not sure why that matters?. :+1: will do. Thanks! Any idea when you could cut an 0.5 release with this?. Not sure - @seanmonstar?. Thanks!. A Hyper release? :P. http://127.0.0.1:3000/name/foo is going to hit a 404, which is not a 2xx or 3xx response code.. Even if you want an nginx at the front door, you may still want to encrypt the in-network communications of the server and whatever else it's talking to.. It's totally possible - you can wrap the `Write`r in one that compresses the data:\r\n\r\n```\r\nuse flate2::{FlateWriteExt, Compression};\r\n\r\nstruct GzipBody(Box<WriteBody>);\r\n\r\nimpl WriteBody for GzipBody {\r\n    fn write_body(&mut self, w: &mut Write) -> io::Result<()> {\r\n        let mut w = w.gz_encode(Compression::Default);\r\n        self.0.write_body(&mut w)?;\r\n        w.finish().map(|_| ())\r\n    }\r\n}\r\n```. See here for an example of how to do this: https://github.com/iron/iron/issues/548#issuecomment-305829393. I believe this is a Hyper rather than Iron issue - the `headers` module is reexported from Hyper.. I'd be totally on board with defining an opaque wrapper around the hyper response but think it still makes sense to have it be a concrete type instead of generic over `Write`.\n. Updated with the wrapper type.\n. @mneumann Here's one example of generating the response while sending it:\n\n``` rust\nstruct WriteNumbers;\n\nimpl WriteBody for WriteNumbers {\n    fn write_body(&mut self, body: &mut ResponseBody) -> IronResult<()> {\n        for i in 0..10000 {\n            try!(write!(body, \"{}\", i));\n        }\n    }\n}\n\nfn handle_write_numbers(_: &mut Request) -> IronResult<Response> {\n    let body: Box<WriteBody + Send> = Box::new(WriteNumbers);\n    Ok(Response::with(body))\n}\n```\n\n@bfrog That's not really how this API is structured. That seems like a job for [AfterMiddleware](http://ironframework.io/doc/iron/middleware/trait.AfterMiddleware.html)?\n. :confetti_ball: \n. This is implemented in #510. @untitaker I believe this is superseded by #510. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Yes!\n. @untitaker I believe the request is for a method that forwards to `Request::downcast_ref`: https://docs.rs/hyper/0.9.14/hyper/server/request/struct.Request.html#method.downcast_ref. I've added an after middleware that reads the remaining request body to a project I'm working on for this kind of thing. Hyper should probably have some logic to dispose of connections that haven't had their bodies consumed though - cc @seanmonstar. When a connection with an unconsumed body is recycled for keepalive, Hyper's internals will try to read a new request from it, get the remaining request body, fail to parse it as an HTTP header, and drop the connection. Normally this is fine, but if the client *immediately* tries to reuse the connection for another request, that can happen before it's notified that the connection dropped.. This is the behavior of current hyper (0.10)\nOn Sat, Mar 18, 2017 at 9:51 PM Matt Hauck <notifications@github.com> wrote:\n\n> @sfackler <https://github.com/sfackler>: Are you referring to new or old\n> behavior in hyper?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/iron/iron/issues/444#issuecomment-287594363>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/ABY2UburIq22V8ODJ44KnRh0yhCZxQmhks5rnLQ0gaJpZM4H5oeL>\n> .\n>\n. @untitaker I believe this is superseded by #510. @untitaker I believe this is superseded by #510. You can now provide an arbitrary Hyper `Listener` to Iron - does that cover this feature request?. Oops, wrong @seanmonstar... Ok, I've switched the https example over to native-tls, which should make things nicer for OSX and especially Windows users.. Done. It might actually be nicer to make Request opaque and provide accessors, since a bunch of this stuff is stored directly in the hyper request.. This is already a backwards-incompatible change since it's adding a field to a struct with no private fields.\r\n\r\n#510 is a breaking change anyway, so I'm not sure why that matters?. :+1: will do. Thanks! Any idea when you could cut an 0.5 release with this?. Not sure - @seanmonstar?. Thanks!. A Hyper release? :P. http://127.0.0.1:3000/name/foo is going to hit a 404, which is not a 2xx or 3xx response code.. Even if you want an nginx at the front door, you may still want to encrypt the in-network communications of the server and whatever else it's talking to.. It's totally possible - you can wrap the `Write`r in one that compresses the data:\r\n\r\n```\r\nuse flate2::{FlateWriteExt, Compression};\r\n\r\nstruct GzipBody(Box<WriteBody>);\r\n\r\nimpl WriteBody for GzipBody {\r\n    fn write_body(&mut self, w: &mut Write) -> io::Result<()> {\r\n        let mut w = w.gz_encode(Compression::Default);\r\n        self.0.write_body(&mut w)?;\r\n        w.finish().map(|_| ())\r\n    }\r\n}\r\n```. See here for an example of how to do this: https://github.com/iron/iron/issues/548#issuecomment-305829393. ",
    "AlexTalker": "Now copy-pasted :smile: \n. Now copy-pasted :smile: \n. ",
    "alexcrichton": "If the majority of dependencies don't actually need SSL support then it may want to be a legit optional feature (e.g. support not built in), but otherwise inline syntax isn't so bad:\n\n``` toml\n[dependencies]\niron = { version = \"...\", default-features = false }\n```\n. If the majority of dependencies don't actually need SSL support then it may want to be a legit optional feature (e.g. support not built in), but otherwise inline syntax isn't so bad:\n\n``` toml\n[dependencies]\niron = { version = \"...\", default-features = false }\n```\n. ",
    "AerialX": "I'm in favour of making it optional by default, the reason I didn't was simply to keep existing projects from breaking on the next update if they used HTTPS. In fact, I'm not really sure why Hyper didn't do so, since that update was a breaking change anyway.\n\nThe issue is that it comes down to iron having two different types of dependencies. Middleware and plugins only depend on iron to extend its functionality and need access to core types and traits. End users of the framework also want the server spawning functionality. It may make sense to split them up into two separate crates, where middleware depends on `iron_core` and then `iron` just re-exports it all for users of the framework. For now though, making HTTPS truly optional isn't bad.\n\nAlso nice inline syntax, I wasn't aware of that! FWIW, in general, a `features = [\"!ssl\"]` would be pretty useful, though it feels like a cheating short-circuit solution.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I'm in favour of making it optional by default, the reason I didn't was simply to keep existing projects from breaking on the next update if they used HTTPS. In fact, I'm not really sure why Hyper didn't do so, since that update was a breaking change anyway.\n\nThe issue is that it comes down to iron having two different types of dependencies. Middleware and plugins only depend on iron to extend its functionality and need access to core types and traits. End users of the framework also want the server spawning functionality. It may make sense to split them up into two separate crates, where middleware depends on `iron_core` and then `iron` just re-exports it all for users of the framework. For now though, making HTTPS truly optional isn't bad.\n\nAlso nice inline syntax, I wasn't aware of that! FWIW, in general, a `features = [\"!ssl\"]` would be pretty useful, though it feels like a cheating short-circuit solution.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "alilleybrinker": "Presumably, if `Chain.link()` is being updated, we should also update `link_before()`, `link_after()`, and `around()`, yes?\n\n(As an aside, should `around()` be renamed to `link_around()` for consistency's sake?)\n. Cool. I am working on it now.\n. Oh geez, you're right. Fixing.\n. Squashed. :smile:\n. Yup. Can do. I knew they would conflict, but figured making two commits was\ngood for history-tracking purposes.\n\nOn Tue, Oct 27, 2015 at 8:42 PM, Jonathan Reem notifications@github.com\nwrote:\n\n> This has a conflict with the last PR you made, which I just merged. I am\n> hesitant to land this immediately as it is a breaking change. Could you\n> instead make a new function link_around, and we can remove the old around\n> function later?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/iron/iron/pull/402#issuecomment-151685016.\n. Okay, I've rebased on top of master, and added back the `around()` function with an additional comment about deprecation.\n. Yup. Fixed.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Presumably, if `Chain.link()` is being updated, we should also update `link_before()`, `link_after()`, and `around()`, yes?\n\n(As an aside, should `around()` be renamed to `link_around()` for consistency's sake?)\n. Cool. I am working on it now.\n. Oh geez, you're right. Fixing.\n. Squashed. :smile:\n. Yup. Can do. I knew they would conflict, but figured making two commits was\ngood for history-tracking purposes.\n\nOn Tue, Oct 27, 2015 at 8:42 PM, Jonathan Reem notifications@github.com\nwrote:\n\n> This has a conflict with the last PR you made, which I just merged. I am\n> hesitant to land this immediately as it is a breaking change. Could you\n> instead make a new function link_around, and we can remove the old around\n> function later?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/iron/iron/pull/402#issuecomment-151685016.\n. Okay, I've rebased on top of master, and added back the `around()` function with an additional comment about deprecation.\n. Yup. Fixed.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "sbstp": "I think this should be closed.\n. I think this should be closed.\n. ",
    "PlasmaPower": "This has been fixed, I'd like to reiterate the request for this issue to be closed.\n. This error is coming from iron's HTTP library `hyper`, which in turn uses `rust-openssl` for HTTPS. Try to reproduce the issue with a raw `hyper` server, then report it there (it doesn't seem reasonable to reproduce it without hyper, most likely it's due in part to hyper's use of rust-openssl).\n. This has been fixed, I'd like to reiterate the request for this issue to be closed.\n. This error is coming from iron's HTTP library `hyper`, which in turn uses `rust-openssl` for HTTPS. Try to reproduce the issue with a raw `hyper` server, then report it there (it doesn't seem reasonable to reproduce it without hyper, most likely it's due in part to hyper's use of rust-openssl).\n. ",
    "singpolyma": "Hmm, if it's one-thread-per-request then I guess this request doesn't make much sense :)  Should have looked closer before assuming there was a pool or something.\n. @reem oh, hmm, so the idea is if I put a mutable reference in a plugin, I could maybe share that way?\n. Hmm, if it's one-thread-per-request then I guess this request doesn't make much sense :)  Should have looked closer before assuming there was a pool or something.\n. @reem oh, hmm, so the idea is if I put a mutable reference in a plugin, I could maybe share that way?\n. ",
    "IanConnolly": "Realised I hadn't included an example anywhere!\n\nThe example in the README: \n\n``` rust\nfn main() {\n    let mut chain = Chain::new(hello_world);\n    chain.link_before(ResponseTime);\n    chain.link_after(ResponseTime);\n    Iron::new(chain).http(\"localhost:3000\").unwrap();\n}\n```\n\nbecomes:\n\n``` rust\nfn main() {\n    let chain = ChainLink::new(hello_world)\n        .link_before(ResponseTime)\n        .link_after(ResponseTime)\n        .lock_chain();\n    Iron::new(chain).http(\"localhost:3000\").unwrap();\n}\n```\n\nI left the methods defined on the `Chain` as I didn't want to break the API, and I presume someone can think up a use-case for mutating `Chain` after creation. \n. Good spot, will push that fix this evening.\n\nI'm using this patch on a project myself, so it'd be great to get something like this into Iron. I'm happy to put the work in to get it to happen.\n\nIf I end up getting to go to the meetup at Mozilla tomorrow I'll try and grab you to chat about it.\n. Realised I hadn't included an example anywhere!\n\nThe example in the README: \n\n``` rust\nfn main() {\n    let mut chain = Chain::new(hello_world);\n    chain.link_before(ResponseTime);\n    chain.link_after(ResponseTime);\n    Iron::new(chain).http(\"localhost:3000\").unwrap();\n}\n```\n\nbecomes:\n\n``` rust\nfn main() {\n    let chain = ChainLink::new(hello_world)\n        .link_before(ResponseTime)\n        .link_after(ResponseTime)\n        .lock_chain();\n    Iron::new(chain).http(\"localhost:3000\").unwrap();\n}\n```\n\nI left the methods defined on the `Chain` as I didn't want to break the API, and I presume someone can think up a use-case for mutating `Chain` after creation. \n. Good spot, will push that fix this evening.\n\nI'm using this patch on a project myself, so it'd be great to get something like this into Iron. I'm happy to put the work in to get it to happen.\n\nIf I end up getting to go to the meetup at Mozilla tomorrow I'll try and grab you to chat about it.\n. ",
    "nixpulvis": "Seems like most of the implementations could be abstracted with a macro.\n. Seems like most of the implementations could be abstracted with a macro.\n. ",
    "posix4e": "Should we close this?\n. Do we still want this?\n. Should we close this?\n. Do we still want this?\n. ",
    "muja": "Thanks for the response! So hyper doesn't support this either, good to know.\n\nIs this feature already envisioned / when should we expect it?\n. What about `drop(listener)`?\n\nFrom the [docs](https://doc.rust-lang.org/std/net/struct.TcpListener.html):\n\n```\nlet listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n\n[...]\n\n// close the socket server\ndrop(listener);\n```\n. Thanks for the response! So hyper doesn't support this either, good to know.\n\nIs this feature already envisioned / when should we expect it?\n. What about `drop(listener)`?\n\nFrom the [docs](https://doc.rust-lang.org/std/net/struct.TcpListener.html):\n\n```\nlet listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n\n[...]\n\n// close the socket server\ndrop(listener);\n```\n. ",
    "gyscos": "I think he meant once `TcpListener::accept()` is called, it blocks until a connection is made and cannot be cancelled. Current workaround to make it return it is to trigger a dummy tcp connection.\n. So reading directly from hyper's `Request.body` (which is what `iron::request::Request.body` does) doesn't work, because hyper uses a wrapper around the network stream that prevents reading from it (and blocking) when no body is present.\n\nThe [current workaround](https://github.com/hyperium/hyper/issues/707#issuecomment-168421089) is to use hyper's `Request::downcast_ref` to access the `HttpStream`. However I don't see a way to do that from a `iron::request::Body`.\n. I think he meant once `TcpListener::accept()` is called, it blocks until a connection is made and cannot be cancelled. Current workaround to make it return it is to trigger a dummy tcp connection.\n. So reading directly from hyper's `Request.body` (which is what `iron::request::Request.body` does) doesn't work, because hyper uses a wrapper around the network stream that prevents reading from it (and blocking) when no body is present.\n\nThe [current workaround](https://github.com/hyperium/hyper/issues/707#issuecomment-168421089) is to use hyper's `Request::downcast_ref` to access the `HttpStream`. However I don't see a way to do that from a `iron::request::Body`.\n. ",
    "jmatraszek": "Hi @gyscos,\r\ncould you please share a snippet with working workaround for this? I'll trying to implement this using dummy connection, but I fail to close Iron even after that. I would really appreciate that.. Hi @gyscos,\r\ncould you please share a snippet with working workaround for this? I'll trying to implement this using dummy connection, but I fail to close Iron even after that. I would really appreciate that.. ",
    "Stebalien": "There's already a ~~hyper-based~~ websocket implementation (https://github.com/cyderize/rust-websocket) so one approach would be to merge this code into iron. Unfortunately, as is, it needs to run on a separate port using a separate hyper instance.\n\nEdit: Scratch that. Hyper doesn't expose the underlying network stream so doing this would require a modification to hyper.\n. Related: https://github.com/hyperium/hyper/issues/521\n. Ah. I didn't realize they were pulled directly from hyper (documentation? what documentation?) :)\n. https://github.com/hyperium/hyper/issues/870\n. There's already a ~~hyper-based~~ websocket implementation (https://github.com/cyderize/rust-websocket) so one approach would be to merge this code into iron. Unfortunately, as is, it needs to run on a separate port using a separate hyper instance.\n\nEdit: Scratch that. Hyper doesn't expose the underlying network stream so doing this would require a modification to hyper.\n. Related: https://github.com/hyperium/hyper/issues/521\n. Ah. I didn't realize they were pulled directly from hyper (documentation? what documentation?) :)\n. https://github.com/hyperium/hyper/issues/870\n. ",
    "SamuelMarks": "FYI: That related issue has now been closed.\n\nAlso related: https://github.com/cyderize/rust-websocket/blob/master/examples/hyper.rs\n. There's always https://github.com/housleyjk/ws-rs\n\nBut there are recent commits to rust-websocket also: https://github.com/cyderize/rust-websocket/commits/master\n. Thanks, that did the trick.\n\nI thought that closures exposed their context?\n. FYI: That related issue has now been closed.\n\nAlso related: https://github.com/cyderize/rust-websocket/blob/master/examples/hyper.rs\n. There's always https://github.com/housleyjk/ws-rs\n\nBut there are recent commits to rust-websocket also: https://github.com/cyderize/rust-websocket/commits/master\n. Thanks, that did the trick.\n\nI thought that closures exposed their context?\n. ",
    "fabricedesre": "Is anyone actively working on that?\n. Is anyone actively working on that?\n. ",
    "dns2utf8": "The rust-websocket seems to have stopped development. Is there anyone looking into it again?\n. I was hoping for a direct Integration or a way to integrate one directly so it would use only one port\n. The rust-websocket seems to have stopped development. Is there anyone looking into it again?\n. I was hoping for a direct Integration or a way to integrate one directly so it would use only one port\n. ",
    "korczis": "Any plans with this?\n. Any plans with this?\n. ",
    "Trolldemorted": "another year has passed, is this still on the roadmap?. another year has passed, is this still on the roadmap?. ",
    "leodasvacas": "I think you have a closure problem. You don't want a `move` closure as your handler. Why not declare `content_type` inside the closure?\n. It's an ownership issue, directly related to the difference between the three types of closures: `FnOnce` (only callable once), `FnMut` (mutates the context) and `Fn` (only reads the context). A handler needs to be `Fn`, which gives stronger concurrency guarantees. `move` closures will take ownership of the context, so it's easy for it to become `FnOnce` or `FnMut`. [Huon has a great in-depth post on this](https://huonw.github.io/blog/2015/05/finding-closure-in-rust/).\n. Maybe it would be best to do that work in separate thread?\n. I think it's \"automatically\".\n. I don't have experience with this, but you might want to try out the [parser](https://github.com/iron/params) middleware, which also parses json.\n. `[80+K` you have a typo there. `84,000+` was more precise so maybe you can keep that.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I think you have a closure problem. You don't want a `move` closure as your handler. Why not declare `content_type` inside the closure?\n. It's an ownership issue, directly related to the difference between the three types of closures: `FnOnce` (only callable once), `FnMut` (mutates the context) and `Fn` (only reads the context). A handler needs to be `Fn`, which gives stronger concurrency guarantees. `move` closures will take ownership of the context, so it's easy for it to become `FnOnce` or `FnMut`. [Huon has a great in-depth post on this](https://huonw.github.io/blog/2015/05/finding-closure-in-rust/).\n. Maybe it would be best to do that work in separate thread?\n. I think it's \"automatically\".\n. I don't have experience with this, but you might want to try out the [parser](https://github.com/iron/params) middleware, which also parses json.\n. `[80+K` you have a typo there. `84,000+` was more precise so maybe you can keep that.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "ghost": "@reem sorry, using github's web interface\n. Oh, I see, this is a `mime` issue. Closing and tracking there.\n. Can replicate according to @hellpain's instructions with `rustc 1.3.0 (9a92aaf19 2015-09-15)`:\n\n```\nRunning 10s test @ http://[::1]:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    11.56ms   38.23ms 203.58ms   96.15%\n    Req/Sec    61.75     96.61   368.00     82.81%\n  909 requests in 10.10s, 101.20KB read\n  Socket errors: connect 0, read 9, write 0, timeout 0\nRequests/sec:     89.98\nTransfer/sec:     10.02KB\n```\n\nThe same goes for `rustc 1.5.0-nightly (32a8567ea 2015-10-05)`:\n\n```\nRunning 10s test @ http://[::1]:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    60.29ms   87.60ms 400.79ms   72.71%\n    Req/Sec   127.51    158.74   714.00     89.74%\n  905 requests in 10.08s, 100.75KB read\n  Socket errors: connect 0, read 5, write 0, timeout 0\nRequests/sec:     89.74\nTransfer/sec:      9.99KB\n```\n\nRunning Linux kernel 4.2.2-1-ARCH.\n. Unsurprisingly, it doesn't seem to matter whether the Iron server is bound to IPv4 or IPv6.\n. Actually, I can't replicate this in pure Hyper with `rustc 1.3.0 (9a92aaf19 2015-09-15)` and hyper 0.6.15 - the version latest Iron depends on - using the [hello world server in the README](https://github.com/hyperium/hyper#hello-world-server). I get 37k requests per second with that. Weird. \n. Never mind, it appears using the mount crate will resolve this issue. \n. @reem sorry, using github's web interface\n. Oh, I see, this is a `mime` issue. Closing and tracking there.\n. Can replicate according to @hellpain's instructions with `rustc 1.3.0 (9a92aaf19 2015-09-15)`:\n\n```\nRunning 10s test @ http://[::1]:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    11.56ms   38.23ms 203.58ms   96.15%\n    Req/Sec    61.75     96.61   368.00     82.81%\n  909 requests in 10.10s, 101.20KB read\n  Socket errors: connect 0, read 9, write 0, timeout 0\nRequests/sec:     89.98\nTransfer/sec:     10.02KB\n```\n\nThe same goes for `rustc 1.5.0-nightly (32a8567ea 2015-10-05)`:\n\n```\nRunning 10s test @ http://[::1]:3000/\n  12 threads and 900 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    60.29ms   87.60ms 400.79ms   72.71%\n    Req/Sec   127.51    158.74   714.00     89.74%\n  905 requests in 10.08s, 100.75KB read\n  Socket errors: connect 0, read 5, write 0, timeout 0\nRequests/sec:     89.74\nTransfer/sec:      9.99KB\n```\n\nRunning Linux kernel 4.2.2-1-ARCH.\n. Unsurprisingly, it doesn't seem to matter whether the Iron server is bound to IPv4 or IPv6.\n. Actually, I can't replicate this in pure Hyper with `rustc 1.3.0 (9a92aaf19 2015-09-15)` and hyper 0.6.15 - the version latest Iron depends on - using the [hello world server in the README](https://github.com/hyperium/hyper#hello-world-server). I get 37k requests per second with that. Weird. \n. Never mind, it appears using the mount crate will resolve this issue. \n. ",
    "evadnoob": "Thanks for the suggestion, turns out on a post I wasn't getting the body and that error is logged.  The error stopped when I added:\n\n```\n\n        let json_body = req.get::<bodyparser::Json>();\n        match json_body {\n            Ok(Some(json_body)) => println!(\"Parsed body:\\n{}\", json_body),\n            Ok(None) => println!(\"No body\"),\n            Err(err) => println!(\"Error: {:?}\", err)\n        }\n\n\n```\n\nThanks!\n. Thanks for the suggestion, turns out on a post I wasn't getting the body and that error is logged.  The error stopped when I added:\n\n```\n\n        let json_body = req.get::<bodyparser::Json>();\n        match json_body {\n            Ok(Some(json_body)) => println!(\"Parsed body:\\n{}\", json_body),\n            Ok(None) => println!(\"No body\"),\n            Err(err) => println!(\"Error: {:?}\", err)\n        }\n\n\n```\n\nThanks!\n. ",
    "ilkosta": "really thanks! great work\n. Really thanks! \nThis is better than I ever hoped.\nAs you have guessed I'm trying to learn rust using an Iron project as gym, and my pull is for a review :)\n\nI missed completely `map_err` as well as the method invocation of a struct. I thought that the structs went always instantiated and binded for the `ref.method() syntax`.\n\nNow I see that an AroundMiddleware was not necessary. Apart from this example I am interested in the use case of a rest webservice that uses json and wants to \"describe\" errors for not met requirements. In that case, with an AfterMiddleweare I cannot change the response content, only the response headers. True?\n. really thanks! great work\n. Really thanks! \nThis is better than I ever hoped.\nAs you have guessed I'm trying to learn rust using an Iron project as gym, and my pull is for a review :)\n\nI missed completely `map_err` as well as the method invocation of a struct. I thought that the structs went always instantiated and binded for the `ref.method() syntax`.\n\nNow I see that an AroundMiddleware was not necessary. Apart from this example I am interested in the use case of a rest webservice that uses json and wants to \"describe\" errors for not met requirements. In that case, with an AfterMiddleweare I cannot change the response content, only the response headers. True?\n. ",
    "mneumann": "Would be nice to see a small example how this can be used to write out a response from a regular iron handler.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Would be nice to see a small example how this can be used to write out a response from a regular iron handler.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "bfrog": "If this means I can write my handler like...\n\n``` rust\nfn handle_req(req: Request, res: Response) ->\n    res.WriteHeader();\n    for x in y {\n         res.Write(...);\n    }\n    // do more stuff after writting out response, like write some stats to a db somewhere\n    // log request and metrics somewhere, etc\n    // without delaying response time to client\n}\n```\n\nThat would be fantastic, its the main reason I'm not using iron at the moment, there's no clear way to do things after writing out a response.\n. Thinking about this more, I almost wonder if maybe a closure is the nicest way of dealing with this, that way you can pull state in from the current fn.\n. I guess it all depends on your machine, I get 200K req/sec on mine with iron, a core i7 4770k. Why would a mbp be a baseline\n\n``` sh\n~ \u276f\u276f\u276f wrk -c 100 -t 10 --latency --duration 30s http://127.0.0.1:3000/\nRunning 30s test @ http://127.0.0.1:3000/\n  10 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    70.11us   77.56us  14.54ms   95.97%\n    Req/Sec   111.42k    27.81k  200.11k    57.78%\n  Latency Distribution\n     50%   55.00us\n     75%   81.00us\n     90%  102.00us\n     99%  282.00us\n  6192107 requests in 30.01s, 620.05MB read\n  Socket errors: connect 0, read 0, write 0, timeout 1222\nRequests/sec: 206332.27\nTransfer/sec:     20.66MB\n```\n. @kulbida a desktop running arch linux with a core i7 4770k, 16gb ram, and a z87 chipset. Nothing too special. I think my ~2013 core i5 laptop gets ~100K rps, also linux. Might just be a mac thing? Seems like the mbp specs are pretty good. Remember that hyper currently uses threads for concurrency, so if Mac OS X is poor at scheduling those...\n. One thing that I've found useful is the ability to have per listener thread state. In my case the Sender side of std::sync::mpsc::channel's, but I could see other per thread data being useful. So perhaps something akin to iron/persistent but with a way to set it up per worker thread. Maybe even simply allowing the user to create an iron server per thread as hyper on the mio branch does now would allow per thread state to be created for handlers.\n. I spent some time investigating this and it really comes down to the Body being problematic. To avoid pushing all the async stuff into Iron the request body needs to either be entirely in memory or entirely on disk. As an alternative perhaps a continuation can be returned as a IronResult specifying it needs the Body to begin with. In all scenarios Body is no longer the same as it is in Iron 0.3\n\nThe in memory/on disk scenario I could see playing out basically where if the request body is extraordinarily large, its written to disk before being given. This is troublesome though because, what size is the maximum allowed? What's the cutoff for in memory or on disk?\n\nThe continuation method seems saner. Providing a closure as an IronResult, lets call it a ReadBody IronResult for the sake of examples takes read chunks of the body as a parameter...\n\nSo basically something like...\n\n``` rust\nfn some_handler(req: IronRequest) -> IronResult { \n     let request_handler = SomeHandler::new(req);\n    IronResult::ReadBody(move |chunk| { request_handler.handle_chunk(chunk) }) \n}\n```\n\nNot quite as nice as the std::io::Read for sure, but without something akin to co-routines...\n. Seems like a sensible way of doing things to me\n. I'm going to spend sometime this weekend working on trying to update iron to work with hyper master, I'm basing my changes on this PR now because I believe this is just waiting to merged @reem\n. Will this let me build my own listener per thread now? Its been a long time pain for me that everything using iron must be Sync+Send if shared among handlers when what I'd really like is per thread state rather than global state.. Thats perfect. No I don't extend the Request's themselves, I'd like to have per thread handlers that look something like.... struct MyHandler { db_conn: Conn } where conn doesn't need to be shared among a bunch of threads. Your changes make it sound like this will work perfectly with that.. If this means I can write my handler like...\n\n``` rust\nfn handle_req(req: Request, res: Response) ->\n    res.WriteHeader();\n    for x in y {\n         res.Write(...);\n    }\n    // do more stuff after writting out response, like write some stats to a db somewhere\n    // log request and metrics somewhere, etc\n    // without delaying response time to client\n}\n```\n\nThat would be fantastic, its the main reason I'm not using iron at the moment, there's no clear way to do things after writing out a response.\n. Thinking about this more, I almost wonder if maybe a closure is the nicest way of dealing with this, that way you can pull state in from the current fn.\n. I guess it all depends on your machine, I get 200K req/sec on mine with iron, a core i7 4770k. Why would a mbp be a baseline\n\n``` sh\n~ \u276f\u276f\u276f wrk -c 100 -t 10 --latency --duration 30s http://127.0.0.1:3000/\nRunning 30s test @ http://127.0.0.1:3000/\n  10 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    70.11us   77.56us  14.54ms   95.97%\n    Req/Sec   111.42k    27.81k  200.11k    57.78%\n  Latency Distribution\n     50%   55.00us\n     75%   81.00us\n     90%  102.00us\n     99%  282.00us\n  6192107 requests in 30.01s, 620.05MB read\n  Socket errors: connect 0, read 0, write 0, timeout 1222\nRequests/sec: 206332.27\nTransfer/sec:     20.66MB\n```\n. @kulbida a desktop running arch linux with a core i7 4770k, 16gb ram, and a z87 chipset. Nothing too special. I think my ~2013 core i5 laptop gets ~100K rps, also linux. Might just be a mac thing? Seems like the mbp specs are pretty good. Remember that hyper currently uses threads for concurrency, so if Mac OS X is poor at scheduling those...\n. One thing that I've found useful is the ability to have per listener thread state. In my case the Sender side of std::sync::mpsc::channel's, but I could see other per thread data being useful. So perhaps something akin to iron/persistent but with a way to set it up per worker thread. Maybe even simply allowing the user to create an iron server per thread as hyper on the mio branch does now would allow per thread state to be created for handlers.\n. I spent some time investigating this and it really comes down to the Body being problematic. To avoid pushing all the async stuff into Iron the request body needs to either be entirely in memory or entirely on disk. As an alternative perhaps a continuation can be returned as a IronResult specifying it needs the Body to begin with. In all scenarios Body is no longer the same as it is in Iron 0.3\n\nThe in memory/on disk scenario I could see playing out basically where if the request body is extraordinarily large, its written to disk before being given. This is troublesome though because, what size is the maximum allowed? What's the cutoff for in memory or on disk?\n\nThe continuation method seems saner. Providing a closure as an IronResult, lets call it a ReadBody IronResult for the sake of examples takes read chunks of the body as a parameter...\n\nSo basically something like...\n\n``` rust\nfn some_handler(req: IronRequest) -> IronResult { \n     let request_handler = SomeHandler::new(req);\n    IronResult::ReadBody(move |chunk| { request_handler.handle_chunk(chunk) }) \n}\n```\n\nNot quite as nice as the std::io::Read for sure, but without something akin to co-routines...\n. Seems like a sensible way of doing things to me\n. I'm going to spend sometime this weekend working on trying to update iron to work with hyper master, I'm basing my changes on this PR now because I believe this is just waiting to merged @reem\n. Will this let me build my own listener per thread now? Its been a long time pain for me that everything using iron must be Sync+Send if shared among handlers when what I'd really like is per thread state rather than global state.. Thats perfect. No I don't extend the Request's themselves, I'd like to have per thread handlers that look something like.... struct MyHandler { db_conn: Conn } where conn doesn't need to be shared among a bunch of threads. Your changes make it sound like this will work perfectly with that.. ",
    "BenBergman": "Closing in favour of #370\n. Closing in favour of #370\n. ",
    "Yamakaky": "Ok\n. Ok\n. ",
    "moenad": "If I create a new project with `cargo new` and I simply edit the cargo.toml file adding to it\n\n```\n[dependencies.iron]\nversion = \"*\"\n```\n\nor\n\n```\n[dependencies]\niron = \"*\"\n```\n\n and I try to  `generate-lockfile`, `build`.... I get the following:\n\n> Updating registry `https://github.com/rust-lang/crates.io-index`\n> \n> thread <main> has overflowed its stack\n> [1]    71643 illegal hardware instruction  cargo build\n\nOn the other hand, if I try the same thing with another dependency like Servo, everything works perfectly fine.\n\nRust is installed using brew.\n. If I create a new project with `cargo new` and I simply edit the cargo.toml file adding to it\n\n```\n[dependencies.iron]\nversion = \"*\"\n```\n\nor\n\n```\n[dependencies]\niron = \"*\"\n```\n\n and I try to  `generate-lockfile`, `build`.... I get the following:\n\n> Updating registry `https://github.com/rust-lang/crates.io-index`\n> \n> thread <main> has overflowed its stack\n> [1]    71643 illegal hardware instruction  cargo build\n\nOn the other hand, if I try the same thing with another dependency like Servo, everything works perfectly fine.\n\nRust is installed using brew.\n. ",
    "Mange": "You need to reinstall with the latest `HEAD`.\n\n```\nbrew uninstall rust\nbrew update\nvim  /usr/local/Library/Formula/rust.rb # Comment out the part about patching \"Makefile.in\", or the build will fail\nbrew install --HEAD rust\n```\n\nThis worked for me today, 2015-09-03. `cargo` was patched 4 days ago, but Homebrew does not have the new version of `cargo` in the formula. I trust this will be solved in time.\n. Actually, that might also be a bad idea. I can't compile the examples because of strange compiler errors. Maybe `master` is broken, maybe it's not compatible with latest `iron` version, maybe both.\n\nSo I either install a broken version of Rust (or rather Cargo), or I install a version of Rust that cannot compile Iron `master` or Iron samples with latest cargo release.\n\n```\nsrc/main.rs:40:5: 40:7 error: unable to infer enough type information about `_`; type annotations or generic parameter binding required [E0282]\nsrc/main.rs:40     Ok(Response::with(\n```\n\n**[EDIT: Nevermind. The error was that I put a semicolon at the end of my handler, so I guess that line became a statement and didn't return the correct value for the function definition. Or something. This is my first foray into Rust, and that error message was very confusing. I have no `_` in my code.]**\n. You need to reinstall with the latest `HEAD`.\n\n```\nbrew uninstall rust\nbrew update\nvim  /usr/local/Library/Formula/rust.rb # Comment out the part about patching \"Makefile.in\", or the build will fail\nbrew install --HEAD rust\n```\n\nThis worked for me today, 2015-09-03. `cargo` was patched 4 days ago, but Homebrew does not have the new version of `cargo` in the formula. I trust this will be solved in time.\n. Actually, that might also be a bad idea. I can't compile the examples because of strange compiler errors. Maybe `master` is broken, maybe it's not compatible with latest `iron` version, maybe both.\n\nSo I either install a broken version of Rust (or rather Cargo), or I install a version of Rust that cannot compile Iron `master` or Iron samples with latest cargo release.\n\n```\nsrc/main.rs:40:5: 40:7 error: unable to infer enough type information about `_`; type annotations or generic parameter binding required [E0282]\nsrc/main.rs:40     Ok(Response::with(\n```\n\n**[EDIT: Nevermind. The error was that I put a semicolon at the end of my handler, so I guess that line became a statement and didn't return the correct value for the function definition. Or something. This is my first foray into Rust, and that error message was very confusing. I have no `_` in my code.]**\n. ",
    "ScottHuangZL": "Thanks. Welcome more comments coming.\n. Thanks. Welcome more comments coming.\n. ",
    "dariusc93": "what @sunng87 stated pretty much sums it up. I've used both nickel and iron but honestly I do find iron being more \"pluggable\" in a sense to where you can bring or create your own middleware with ease. I been debating on which to use but havent came to a direct conclusion. \n. Is this even still a problem? \n. @veegee does it show that many when you use ab? \n. Is there a specific commit that couldve fixed this? \n. Why not put your application behind something like nginx or haproxy? (you can do this in a container as well if you dont want it directly on your system)\n. I know this is a late reply but it probably would be best to do this with nginx, haproxy or the like.\n. what @sunng87 stated pretty much sums it up. I've used both nickel and iron but honestly I do find iron being more \"pluggable\" in a sense to where you can bring or create your own middleware with ease. I been debating on which to use but havent came to a direct conclusion. \n. Is this even still a problem? \n. @veegee does it show that many when you use ab? \n. Is there a specific commit that couldve fixed this? \n. Why not put your application behind something like nginx or haproxy? (you can do this in a container as well if you dont want it directly on your system)\n. I know this is a late reply but it probably would be best to do this with nginx, haproxy or the like.\n. ",
    "flada-auxv": "@zzmp I've fixed it :see_no_evil: \n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. @zzmp I've fixed it :see_no_evil: \n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. ",
    "zr40": "Usernames and passwords are sent as a header, which means they don't appear in the request URL.\n. If you're going to depend on `modifier` in your own code, why doesn't it make sense adding it as a dependency?\n. Usernames and passwords are sent as a header, which means they don't appear in the request URL.\n. If you're going to depend on `modifier` in your own code, why doesn't it make sense adding it as a dependency?\n. ",
    "pdib": "Thanks for the feedback, I updated the PR.\nAlso, tell me if you have other topics in mind that could be turned into helpful examples.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Thanks for the feedback, I updated the PR.\nAlso, tell me if you have other topics in mind that could be turned into helpful examples.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "rkyoku": "Yes thank you @leodasvacas that's also what @seanmonstar advised me to try too, I'll definitely have a look! :)\n\nEDIT : well, bad luck again, it doesn't compile:\n\n```\nparams-0.0.1\\src\\lib.rs:564:26: 564:43 error: use of undeclared trait name `formdata::Request` [E0405]\nparams-0.0.1\\src\\lib.rs:564 impl<'c, 'a: 'c, 'b: 'a> formdata::Request for IronRequest<'c, 'a, 'b> {\n```\n. Yes thank you @leodasvacas that's also what @seanmonstar advised me to try too, I'll definitely have a look! :)\n\nEDIT : well, bad luck again, it doesn't compile:\n\n```\nparams-0.0.1\\src\\lib.rs:564:26: 564:43 error: use of undeclared trait name `formdata::Request` [E0405]\nparams-0.0.1\\src\\lib.rs:564 impl<'c, 'a: 'c, 'b: 'a> formdata::Request for IronRequest<'c, 'a, 'b> {\n```\n. ",
    "kulbida": "sure it depends on the machine but I changed related page as well, the page where you can see a spec for the machine used in this benchmark. see https://github.com/iron/iron/wiki/How-to-Benchmark-hello.rs-Example\nProbably it makes sense to display machine specific spec information in right next to the benchmark so all information will be in one place and it will not get out of sync? What do you think?\n. I just don't understand, I'm getting 28+K at most and still have pretty powerful machine. @bfrog what machine you have? \n. @reem ready for review.\n. @leodasvacas done!\n. ready for review\n. sure it depends on the machine but I changed related page as well, the page where you can see a spec for the machine used in this benchmark. see https://github.com/iron/iron/wiki/How-to-Benchmark-hello.rs-Example\nProbably it makes sense to display machine specific spec information in right next to the benchmark so all information will be in one place and it will not get out of sync? What do you think?\n. I just don't understand, I'm getting 28+K at most and still have pretty powerful machine. @bfrog what machine you have? \n. @reem ready for review.\n. @leodasvacas done!\n. ready for review\n. ",
    "syurchenko": "@reem \ncargo new hello_world --bin\nedit main.rs as here https://github.com/iron/iron/blob/master/examples/hello.rs\nadd to Cargo.toml\n\n> [dependencies.iron]\n> version = \"*\"\n\ncargo clean\ncargo build --release\n./target/release/hello_world\n\nThen in second terminal I start wrk:\nwrk -t12 -c900 -d10s http://127.0.0.1:3000/\n\nI think you will be able to reproduce this, if you delete Cargo.lock and let cargo download latest versions of packets. I suppose this bug in some external library, not in Iron. Unfortunately, I can`t recover old Cargo.lock, where I had good performance.\nI also repeated it on my notebook on clean system - 93 RPS. \n. @meowy On your hello-world I have 19k RPS instead of 19 on mine=)\n. @meowy Is there any way to fix keep-alive connections?\n. > wrk -t12 -c900 -d10s http://localhost:3000/\n> Running 10s test @ http://localhost:3000/\n>   12 threads and 900 connections\n>   Thread Stats   Avg      Stdev     Max   +/- Stdev\n>     Latency   180.63us  139.77us  13.53ms   93.58%\n>     Req/Sec    20.15k     1.67k   22.99k    77.23%\n>   202211 requests in 10.09s, 21.98MB read\n> Requests/sec:  20047.55\n> Transfer/sec:      2.18MB\n\nSpeed is even better on 2k RPS then in my first post on the same computer. Thanks all.\nIssue can be closed.\n. @reem \ncargo new hello_world --bin\nedit main.rs as here https://github.com/iron/iron/blob/master/examples/hello.rs\nadd to Cargo.toml\n\n> [dependencies.iron]\n> version = \"*\"\n\ncargo clean\ncargo build --release\n./target/release/hello_world\n\nThen in second terminal I start wrk:\nwrk -t12 -c900 -d10s http://127.0.0.1:3000/\n\nI think you will be able to reproduce this, if you delete Cargo.lock and let cargo download latest versions of packets. I suppose this bug in some external library, not in Iron. Unfortunately, I can`t recover old Cargo.lock, where I had good performance.\nI also repeated it on my notebook on clean system - 93 RPS. \n. @meowy On your hello-world I have 19k RPS instead of 19 on mine=)\n. @meowy Is there any way to fix keep-alive connections?\n. > wrk -t12 -c900 -d10s http://localhost:3000/\n> Running 10s test @ http://localhost:3000/\n>   12 threads and 900 connections\n>   Thread Stats   Avg      Stdev     Max   +/- Stdev\n>     Latency   180.63us  139.77us  13.53ms   93.58%\n>     Req/Sec    20.15k     1.67k   22.99k    77.23%\n>   202211 requests in 10.09s, 21.98MB read\n> Requests/sec:  20047.55\n> Transfer/sec:      2.18MB\n\nSpeed is even better on 2k RPS then in my first post on the same computer. Thanks all.\nIssue can be closed.\n. ",
    "badboy": "I have the same degradation with 1.3 and nightly: only ~90 requests/sec using the iron hello example.\n\nProblematic:\n\n```\nrustc 1.5.0-nightly (7beebbe56 2015-10-22)\nrustc 1.3.0 (9a92aaf19 2015-09-15)\n```\n. Docs are built using [this script](https://github.com/iron-bot/build-doc/blob/master/build-doc.sh).\nIt should build the docs using `cargo docs --features ssl` here: https://github.com/iron-bot/build-doc/blob/master/build-doc.sh#L8\n\n(and maybe documenting that for this the feature flag is needed in applications)\n. I have the same degradation with 1.3 and nightly: only ~90 requests/sec using the iron hello example.\n\nProblematic:\n\n```\nrustc 1.5.0-nightly (7beebbe56 2015-10-22)\nrustc 1.3.0 (9a92aaf19 2015-09-15)\n```\n. Docs are built using [this script](https://github.com/iron-bot/build-doc/blob/master/build-doc.sh).\nIt should build the docs using `cargo docs --features ssl` here: https://github.com/iron-bot/build-doc/blob/master/build-doc.sh#L8\n\n(and maybe documenting that for this the feature flag is needed in applications)\n. ",
    "veegee": "Same issue. What's going on here?\n. @dariusc93 very much so. When I set up the latest versions of all packages, with rust 1.4, I only get ~10 req/s with wrk.\n. @dariusc93 interesting, `ab` gives me the following:\n\n```\n\u279c ab -n 100000 -c 100 127.0.0.1:8001/\nThis is ApacheBench, Version 2.3 <$Revision: 1638069 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking 127.0.0.1 (be patient)\nCompleted 10000 requests\nCompleted 20000 requests\nCompleted 30000 requests\nCompleted 40000 requests\nCompleted 50000 requests\nCompleted 60000 requests\nCompleted 70000 requests\nCompleted 80000 requests\nCompleted 90000 requests\nCompleted 100000 requests\nFinished 100000 requests\n\n\nServer Software:\nServer Hostname:        127.0.0.1\nServer Port:            8001\n\nDocument Path:          /\nDocument Length:        12 bytes\n\nConcurrency Level:      100\nTime taken for tests:   4.926 seconds\nComplete requests:      100000\nFailed requests:        0\nTotal transferred:      11400000 bytes\nHTML transferred:       1200000 bytes\nRequests per second:    20300.88 [#/sec] (mean)\nTime per request:       4.926 [ms] (mean)\nTime per request:       0.049 [ms] (mean, across all concurrent requests)\nTransfer rate:          2260.06 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        1    2   0.2      2       4\nProcessing:     1    3   0.7      3      25\nWaiting:        1    2   0.7      2      24\nTotal:          3    5   0.6      5      27\n\nPercentage of the requests served within a certain time (ms)\n  50%      5\n  66%      5\n  75%      5\n  80%      5\n  90%      6\n  95%      6\n  98%      6\n  99%      6\n 100%     27 (longest request)\n```\n\n`wrk` gives me this:\n\n```\n\u279c wrk -c 100 http://localhost:8001\nRunning 10s test @ http://localhost:8001\n  2 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.50ms  767.35us   3.08ms   60.00%\n    Req/Sec   505.00      0.00   505.00    100.00%\n  100 requests in 10.02s, 11.13KB read\nRequests/sec:      9.98\nTransfer/sec:      1.11KB\n```\n\n**Code**:\n\n```\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nfn index(_: &mut Request) -> IronResult<Response> {\n    Ok(Response::with((status::Ok, \"Hello World!\")))\n}\n\nfn main() {\n    let addr = \"127.0.0.1:8001\";\n    println!(\"Listening on {}\", addr);\n    Iron::new(index).listen_with(addr, 64, iron::Protocol::Http).unwrap();\n}\n```\n. Same issue. What's going on here?\n. @dariusc93 very much so. When I set up the latest versions of all packages, with rust 1.4, I only get ~10 req/s with wrk.\n. @dariusc93 interesting, `ab` gives me the following:\n\n```\n\u279c ab -n 100000 -c 100 127.0.0.1:8001/\nThis is ApacheBench, Version 2.3 <$Revision: 1638069 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking 127.0.0.1 (be patient)\nCompleted 10000 requests\nCompleted 20000 requests\nCompleted 30000 requests\nCompleted 40000 requests\nCompleted 50000 requests\nCompleted 60000 requests\nCompleted 70000 requests\nCompleted 80000 requests\nCompleted 90000 requests\nCompleted 100000 requests\nFinished 100000 requests\n\n\nServer Software:\nServer Hostname:        127.0.0.1\nServer Port:            8001\n\nDocument Path:          /\nDocument Length:        12 bytes\n\nConcurrency Level:      100\nTime taken for tests:   4.926 seconds\nComplete requests:      100000\nFailed requests:        0\nTotal transferred:      11400000 bytes\nHTML transferred:       1200000 bytes\nRequests per second:    20300.88 [#/sec] (mean)\nTime per request:       4.926 [ms] (mean)\nTime per request:       0.049 [ms] (mean, across all concurrent requests)\nTransfer rate:          2260.06 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        1    2   0.2      2       4\nProcessing:     1    3   0.7      3      25\nWaiting:        1    2   0.7      2      24\nTotal:          3    5   0.6      5      27\n\nPercentage of the requests served within a certain time (ms)\n  50%      5\n  66%      5\n  75%      5\n  80%      5\n  90%      6\n  95%      6\n  98%      6\n  99%      6\n 100%     27 (longest request)\n```\n\n`wrk` gives me this:\n\n```\n\u279c wrk -c 100 http://localhost:8001\nRunning 10s test @ http://localhost:8001\n  2 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.50ms  767.35us   3.08ms   60.00%\n    Req/Sec   505.00      0.00   505.00    100.00%\n  100 requests in 10.02s, 11.13KB read\nRequests/sec:      9.98\nTransfer/sec:      1.11KB\n```\n\n**Code**:\n\n```\nextern crate iron;\n\nuse iron::prelude::*;\nuse iron::status;\n\nfn index(_: &mut Request) -> IronResult<Response> {\n    Ok(Response::with((status::Ok, \"Hello World!\")))\n}\n\nfn main() {\n    let addr = \"127.0.0.1:8001\";\n    println!(\"Listening on {}\", addr);\n    Iron::new(index).listen_with(addr, 64, iron::Protocol::Http).unwrap();\n}\n```\n. ",
    "Antti": "Updated crates, now performance is back to normal (Requests/sec:  80339.57)\n\nCrates updated:\n\n```\n    Updating cookie v0.1.21 -> v0.2.2\n    Updating gcc v0.3.19 -> v0.3.20\n    Updating hyper v0.6.16 -> v0.7.0\n    Updating iron v0.2.4 -> v0.2.5\n    Updating language-tags v0.0.7 -> v0.2.0\n    Removing libc v0.1.12\n    Updating log v0.3.3 -> v0.3.4\n    Updating num_cpus v0.2.9 -> v0.2.10\n    Updating openssl v0.6.7 -> v0.7.1\n    Updating openssl-sys v0.6.7 -> v0.7.1\n      Adding openssl-sys-extras v0.7.1\n    Updating url v0.2.38 -> v0.5.0\n```\n\nI suspect it was hyper update, which fixed the regression.\n. @sovereignsoftware didn't we have this problem all the time?\n. Updated crates, now performance is back to normal (Requests/sec:  80339.57)\n\nCrates updated:\n\n```\n    Updating cookie v0.1.21 -> v0.2.2\n    Updating gcc v0.3.19 -> v0.3.20\n    Updating hyper v0.6.16 -> v0.7.0\n    Updating iron v0.2.4 -> v0.2.5\n    Updating language-tags v0.0.7 -> v0.2.0\n    Removing libc v0.1.12\n    Updating log v0.3.3 -> v0.3.4\n    Updating num_cpus v0.2.9 -> v0.2.10\n    Updating openssl v0.6.7 -> v0.7.1\n    Updating openssl-sys v0.6.7 -> v0.7.1\n      Adding openssl-sys-extras v0.7.1\n    Updating url v0.2.38 -> v0.5.0\n```\n\nI suspect it was hyper update, which fixed the regression.\n. @sovereignsoftware didn't we have this problem all the time?\n. ",
    "sovereignsoftware": "I wouldn't consider it completely fixed. I'm having two issues with performance still. With `wrk` it performs well now, but with `wrk2` it falters and times out 2/3 of requests. The difference between the two is that `wrk2` tries to force-feed a given throughput level to the server:\n\n```\n> wrk2 -t4 -c10000 -d60s -R 1000000 http://localhost:3000/\nRunning 1m test @ http://localhost:3000/\n  4 threads and 10000 connections\n  Thread calibration: mean lat.: 6.798ms, rate sampling interval: 10ms\n  Thread calibration: mean lat.: 9223372036854776.000ms, rate sampling interval: 10ms\n  Thread calibration: mean lat.: 1.049ms, rate sampling interval: 10ms\n  Thread calibration: mean lat.: 9223372036854776.000ms, rate sampling interval: 10ms\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     0.95ms  495.12us  23.30ms   68.01%\n    Req/Sec   679.49    692.42     2.22k    77.23%\n  155888 requests in 1.01m, 21.26MB read\n  Socket errors: connect 8983, read 0, write 0, timeout 234398\nRequests/sec:   2575.48\nTransfer/sec:    359.66KB\n```\n\nThe same benchmark with Scala's http4s, for example, will handle 66k req/s on the same machine with the same test but the latency numbers will be expectedly through the roof. \n\nI also find that after running either `wrk` or `wrk2`, the Iron server is \"stuck\" for a while and won't handle any new requests made from my browser until I guess the timeouts expire.\n. I wouldn't consider it completely fixed. I'm having two issues with performance still. With `wrk` it performs well now, but with `wrk2` it falters and times out 2/3 of requests. The difference between the two is that `wrk2` tries to force-feed a given throughput level to the server:\n\n```\n> wrk2 -t4 -c10000 -d60s -R 1000000 http://localhost:3000/\nRunning 1m test @ http://localhost:3000/\n  4 threads and 10000 connections\n  Thread calibration: mean lat.: 6.798ms, rate sampling interval: 10ms\n  Thread calibration: mean lat.: 9223372036854776.000ms, rate sampling interval: 10ms\n  Thread calibration: mean lat.: 1.049ms, rate sampling interval: 10ms\n  Thread calibration: mean lat.: 9223372036854776.000ms, rate sampling interval: 10ms\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     0.95ms  495.12us  23.30ms   68.01%\n    Req/Sec   679.49    692.42     2.22k    77.23%\n  155888 requests in 1.01m, 21.26MB read\n  Socket errors: connect 8983, read 0, write 0, timeout 234398\nRequests/sec:   2575.48\nTransfer/sec:    359.66KB\n```\n\nThe same benchmark with Scala's http4s, for example, will handle 66k req/s on the same machine with the same test but the latency numbers will be expectedly through the roof. \n\nI also find that after running either `wrk` or `wrk2`, the Iron server is \"stuck\" for a while and won't handle any new requests made from my browser until I guess the timeouts expire.\n. ",
    "TyOverby": "So do I need a `default-features = false` for router too?\n. So do I need a `default-features = false` for router too?\n. ",
    "ReadmeCritic": ":tada: \n\nOh it's kinda random / based on trending repos\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. :tada: \n\nOh it's kinda random / based on trending repos\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "rnestler": "https://github.com/iron/iron/blob/1c37acbf3cacc2f0da91c0123bb4bfd6bf56809b/src/iron.rs#L9\nLooks like a public export of `hyper::server::Listening`.\nEdit: Ignore that, the sub-module iron is not public: https://github.com/iron/iron/blob/1c37acbf3cacc2f0da91c0123bb4bfd6bf56809b/src/lib.rs#L168\n. https://github.com/iron/iron/blob/1c37acbf3cacc2f0da91c0123bb4bfd6bf56809b/src/iron.rs#L9\nLooks like a public export of `hyper::server::Listening`.\nEdit: Ignore that, the sub-module iron is not public: https://github.com/iron/iron/blob/1c37acbf3cacc2f0da91c0123bb4bfd6bf56809b/src/lib.rs#L168\n. ",
    "NecroTechno": "Alright, awesome. Thanks!\n. Alright, awesome. Thanks!\n. ",
    "mvdnes": "Great! This will greatly improve the experience on Windows. Should I submit a PR removing the default or is there more work to be done?\n. Pushed a commit for testing with and without the ssl feature.\n. Great, thanks! :+1:\n. Great! This will greatly improve the experience on Windows. Should I submit a PR removing the default or is there more work to be done?\n. Pushed a commit for testing with and without the ssl feature.\n. Great, thanks! :+1:\n. ",
    "mcasper": "We got bytes!\n\n```\nthread '<main>' panicked at 'assertion failed: `(left == right)`\n (left: `[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`,\n right: `[72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33]`)', src/main.rs:33\n```\n. Oh wow, yeah that did the trick! \n\nSorry about that, and thank you very much :smile: \n. We got bytes!\n\n```\nthread '<main>' panicked at 'assertion failed: `(left == right)`\n (left: `[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`,\n right: `[72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33]`)', src/main.rs:33\n```\n. Oh wow, yeah that did the trick! \n\nSorry about that, and thank you very much :smile: \n. ",
    "dbrgn": "Would be great if this could be handled. Using the hyper crate explicitly just to access `Listening` or other types from hyper is unnecessary and can cause version conflicts.\n. Fixed and rebased.\n. It works locally :)\n. Would be great if this could be handled. Using the hyper crate explicitly just to access `Listening` or other types from hyper is unnecessary and can cause version conflicts.\n. Fixed and rebased.\n. It works locally :)\n. ",
    "shanegibbs": "This is a must for long polling.\n. This is a must for long polling.\n. ",
    "erikjohnston": "I want to be able to do something like this so that I can use a customized `SslContext`.\n\nAn alternative would be to allow starting iron with a completely preconfigured `hyper::server::Server`. As far as I can see, iron only needs two things: the name of the scheme used (i.e. http or https) and the local addr. Ideally we would be able to get both from the `hyper::server::Server`, but those don't seem to be currently exposed.\n. I want to be able to do something like this so that I can use a customized `SslContext`.\n\nAn alternative would be to allow starting iron with a completely preconfigured `hyper::server::Server`. As far as I can see, iron only needs two things: the name of the scheme used (i.e. http or https) and the local addr. Ideally we would be able to get both from the `hyper::server::Server`, but those don't seem to be currently exposed.\n. ",
    "zofrex": "I'm really keen to see a fix for #386 to land as well. I've also made a potential patch to resolve it but I'm not in love with my solution.\n\nRegarding the failed build above, I reproduced this locally but the error went away once I rebased onto master, so it's good to go on that front.\n\nTo aid in thinking about the interface (and perhaps document it if this gets merged), I've made a minimal example of using it:\n\n(I'm not 100% certain I'm doing this the easiest way possible so let me know if I'm missing something!)\n\n``` rust\nextern crate iron;\nextern crate hyper;\n\nuse iron::prelude::*;\nuse iron::status;\nuse iron::Protocol;\nuse std::net::TcpListener;\nuse hyper::net::HttpListener;\n\nfn main() {\n    fn hello_world(_: &mut Request) -> IronResult<Response> {\n        Ok(Response::with((status::Ok, String::from(\"Hello World!\"))))\n    }\n\n    let listener = TcpListener::bind(\"0.0.0.0:80\").unwrap();\n\n    let _i = Iron::new(hello_world)\n                 .listen_custom(None, HttpListener::from(listener), Protocol::Http, None)\n                 .unwrap();\n}\n```\n\nI really like the use of Option for the thread count (which might help reduce some of the repetition in this area if applied more broadly?). This is waaay simpler and more elegant a change than my own attempt at this, too. One thing - I'm not super thrilled with exposing hyper's implementation details this way, as it means I have to add hyper to my Cargo.toml and make sure to specify the same version hyper uses (is there a workaround for this?)\n. @Hoverbear I've upgraded to the latest Iron (0.4.0) and I don't see a way to accomplish my goals (bind to socket, drop privs, start Iron) without either this patch or #457. Currently I am maintaining my own fork of Iron and overriding the dependency in my project to do this.\n\nSo yes, as far as I know, this is still relevant \u2013\u00a0and an emphatic yes for interest :)\n. I'm really keen to see a fix for #386 to land as well. I've also made a potential patch to resolve it but I'm not in love with my solution.\n\nRegarding the failed build above, I reproduced this locally but the error went away once I rebased onto master, so it's good to go on that front.\n\nTo aid in thinking about the interface (and perhaps document it if this gets merged), I've made a minimal example of using it:\n\n(I'm not 100% certain I'm doing this the easiest way possible so let me know if I'm missing something!)\n\n``` rust\nextern crate iron;\nextern crate hyper;\n\nuse iron::prelude::*;\nuse iron::status;\nuse iron::Protocol;\nuse std::net::TcpListener;\nuse hyper::net::HttpListener;\n\nfn main() {\n    fn hello_world(_: &mut Request) -> IronResult<Response> {\n        Ok(Response::with((status::Ok, String::from(\"Hello World!\"))))\n    }\n\n    let listener = TcpListener::bind(\"0.0.0.0:80\").unwrap();\n\n    let _i = Iron::new(hello_world)\n                 .listen_custom(None, HttpListener::from(listener), Protocol::Http, None)\n                 .unwrap();\n}\n```\n\nI really like the use of Option for the thread count (which might help reduce some of the repetition in this area if applied more broadly?). This is waaay simpler and more elegant a change than my own attempt at this, too. One thing - I'm not super thrilled with exposing hyper's implementation details this way, as it means I have to add hyper to my Cargo.toml and make sure to specify the same version hyper uses (is there a workaround for this?)\n. @Hoverbear I've upgraded to the latest Iron (0.4.0) and I don't see a way to accomplish my goals (bind to socket, drop privs, start Iron) without either this patch or #457. Currently I am maintaining my own fork of Iron and overriding the dependency in my project to do this.\n\nSo yes, as far as I know, this is still relevant \u2013\u00a0and an emphatic yes for interest :)\n. ",
    "arathunku": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "SuprDewd": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "steveklabnik": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. This is very helpful :+1: \n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. This is very helpful :+1: \n. ",
    "Nercury": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "crackofdusk": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "darayus": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "shama": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "EduardoBautista": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "ucarion": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.. ",
    "iwinux": "oops...Sorry but I just checked out the commit history. Seems it is the doc that needs to be updated.\n. oops...Sorry but I just checked out the commit history. Seems it is the doc that needs to be updated.\n. ",
    "jimktrains": "Travis is failing because I didn't commit a dependency to openssl in Cargo.toml, but use it in the code. That may need to be refactored out, or the HTTPS server moved somewhere else?\n. Also, I'll eventually squash all of this, or rewrite some of the commit messages. I just realized my first one is non-informative.\n. I was coming back to this, but it looks like there is now a way to pass in a TLS server to handle the TLS-bits.. Travis is failing because I didn't commit a dependency to openssl in Cargo.toml, but use it in the code. That may need to be refactored out, or the HTTPS server moved somewhere else?\n. Also, I'll eventually squash all of this, or rewrite some of the commit messages. I just realized my first one is non-informative.\n. I was coming back to this, but it looks like there is now a way to pass in a TLS server to handle the TLS-bits.. ",
    "cetra3": "Just an update: some of the slowness happens due to DNS lookups in hyper, converting the request to an IP address resolves this.  The `Client::new()` call is probably the culprit, but not sure how to persist a client instance across multiple requests.\n. What's the status of this request? Looks like the urlencoded stuff has been resolved?. Just an update: some of the slowness happens due to DNS lookups in hyper, converting the request to an IP address resolves this.  The `Client::new()` call is probably the culprit, but not sure how to persist a client instance across multiple requests.\n. What's the status of this request? Looks like the urlencoded stuff has been resolved?. ",
    "frjonsen": "I suspect this bug is due to this: https://github.com/iron/iron/blob/master/src/iron.rs#L137\r\n\r\nWhen constructing a https server, Protocol::http() is used. This makes things like the iron-routers url_for! not work properly, because it constructs a http:// url even when using https.. Ah, yes, I see now I went through the issue a bit quickly, as it seemed similar enough to the issue I was having. Sorry about that.. I suspect this bug is due to this: https://github.com/iron/iron/blob/master/src/iron.rs#L137\r\n\r\nWhen constructing a https server, Protocol::http() is used. This makes things like the iron-routers url_for! not work properly, because it constructs a http:// url even when using https.. Ah, yes, I see now I went through the issue a bit quickly, as it seemed similar enough to the issue I was having. Sorry about that.. ",
    "shinriyo": "Hello @sunng87\nThank you for replying. :smiley: \nis it official for iron?\n\nI found before, and I tried it but it couldn't understand how to use it.\n\n:sos: \n\nI added `handlebars-iron = \"*\"` in my Cargo.toml\nI I append it.\n\n```\n    fn hello_world(_: &mut Request) -> IronResult<Response> {\n        let mut resp = Response::new();\n        let data = \"\";\n        resp.set_mut(Template::new(\"index\", data)).set_mut(status::Ok);\n        Ok(resp)\n    }\n```\n\nI ran `cargo run`.\nI said the error.\n\n```\nerror: no associated item named `new` found for type `Template` in the current scope\n```\n\nSo, I tried to use `Template` struct.\n`use rust-handlebars::Template;` and `use handlebars::Template;`\nbut, it didn't work... :cry: \n\np.s. I hope minimum helloworld code in your README. :+1: \n. @sunng87 \nThank you for replying.\nI found how to use `Template`.\n\n```\nuse hbs::{Template};\n```\n\nI fix like by your advice.\n``\n    fn hello_world(_: &mut Request) -> IronResult<Response> {\n        let mut resp = Response::new();\n        let data = String::new();\n        resp.set_mut(Template::new(\"index\", data)).set_mut(status::Ok);\n        Ok(resp)\n    }\n\n```\n\nI use `Router` like this\n```\n\nIron::new(router).http(\"localhost:3000\").unwrap();\n\n```\n\nHowever, the sample you shown said `Chain`. :exclamation:\nand, in line 103 comment saids `open http://localhost:3000/abc`, but I couldn't found where `abc` defined. :astonished:\n\nMy index.html template put in /public/ folder.\nmust I define where is template folder by `HandlebarsEngine`? :question:\n```\n. Hello @sunng87\nThank you for replying. :smiley: \nis it official for iron?\n\nI found before, and I tried it but it couldn't understand how to use it.\n\n:sos: \n\nI added `handlebars-iron = \"*\"` in my Cargo.toml\nI I append it.\n\n```\n    fn hello_world(_: &mut Request) -> IronResult<Response> {\n        let mut resp = Response::new();\n        let data = \"\";\n        resp.set_mut(Template::new(\"index\", data)).set_mut(status::Ok);\n        Ok(resp)\n    }\n```\n\nI ran `cargo run`.\nI said the error.\n\n```\nerror: no associated item named `new` found for type `Template` in the current scope\n```\n\nSo, I tried to use `Template` struct.\n`use rust-handlebars::Template;` and `use handlebars::Template;`\nbut, it didn't work... :cry: \n\np.s. I hope minimum helloworld code in your README. :+1: \n. @sunng87 \nThank you for replying.\nI found how to use `Template`.\n\n```\nuse hbs::{Template};\n```\n\nI fix like by your advice.\n``\n    fn hello_world(_: &mut Request) -> IronResult<Response> {\n        let mut resp = Response::new();\n        let data = String::new();\n        resp.set_mut(Template::new(\"index\", data)).set_mut(status::Ok);\n        Ok(resp)\n    }\n\n```\n\nI use `Router` like this\n```\n\nIron::new(router).http(\"localhost:3000\").unwrap();\n\n```\n\nHowever, the sample you shown said `Chain`. :exclamation:\nand, in line 103 comment saids `open http://localhost:3000/abc`, but I couldn't found where `abc` defined. :astonished:\n\nMy index.html template put in /public/ folder.\nmust I define where is template folder by `HandlebarsEngine`? :question:\n```\n. ",
    "samgiles": "Hey @reem, It would be awesome to get this feature merged, I'd be happy to make changes if you see any.\n. Hmm, nice idea, will take a look at doing that tomorrow, thanks.\n. Hey @reem, It would be awesome to get this feature merged, I'd be happy to make changes if you see any.\n. Hmm, nice idea, will take a look at doing that tomorrow, thanks.\n. ",
    "KalitaAlexey": "You may add BeforeMiddleware and AfterMiddleware. If you want middleware for both ends then you may add AroundMiddleware.\n. @untitaker It is lesser problem. Why does the compiler suggests me use `iron::Pluggable`?\n. I will try to reproduce bug and will open issue in **rustc** repo. Thanks.\n. You may add BeforeMiddleware and AfterMiddleware. If you want middleware for both ends then you may add AroundMiddleware.\n. @untitaker It is lesser problem. Why does the compiler suggests me use `iron::Pluggable`?\n. I will try to reproduce bug and will open issue in **rustc** repo. Thanks.\n. ",
    "dmitriyshmatov": "The processor intel i7-4980HQ with 8 threads, the performance test is invalid.\n\nPage https://github.com/iron/iron/wiki/How-to-Benchmark-hello.rs-Example\n\nSorry for bad English.\n. The processor intel i7-4980HQ with 8 threads, the performance test is invalid.\n\nPage https://github.com/iron/iron/wiki/How-to-Benchmark-hello.rs-Example\n\nSorry for bad English.\n. ",
    "LFalch": "I don't see any particularly good reason not to hide the default ports.\n. I don't see any particularly good reason not to hide the default ports.\n. ",
    "forgemo": "Bump!\n\nI do have the same use case: Lazy iterator of strings\nI would like to start streaming data to the client while the iterator is still being iterated over. \n\nThis is with the current Iron API not possible as far as I understand it.\n\nAm I missing something? Any tips?\n. Bump!\n\nI do have the same use case: Lazy iterator of strings\nI would like to start streaming data to the client while the iterator is still being iterated over. \n\nThis is with the current Iron API not possible as far as I understand it.\n\nAm I missing something? Any tips?\n. ",
    "kevinastone": "You just need to implement your own `WriteBody` trait implementation.  I wrote one that takes a `vec<u8>` as  toy:\n\n```\npub struct StreamResponse {\n    data: Vec<u8>,\n}\n\nimpl StreamResponse {\n    pub fn new(data: Vec<u8>) -> Self {\n        StreamResponse { data: data }\n    }\n}\n\nimpl WriteBody for StreamResponse {\n    fn write_body(&mut self, res: &mut ResponseBody) -> io::Result<()> {\n        for byte in self.data.clone() {\n            try!(res.write(&[byte]));\n            try!(res.flush());\n        }\n\n        Ok(())\n    }\n}\n```\n\n(I intentionally flush after every byte as a test, it's not designed to be performant)\n. On master, you can use `RedirectRaw` since it just takes a bare string.\n. I just used:\n\n```\nOk(Response::with((status::Found, Header(headers::Location(\"/something-relative\")))))\n```\n. Because I should depend on the version from iron.  I shouldn't have to keep my modifier dependency in sync with Iron's.\n. Missing a tag for `0.4.0`...\n. You just need to implement your own `WriteBody` trait implementation.  I wrote one that takes a `vec<u8>` as  toy:\n\n```\npub struct StreamResponse {\n    data: Vec<u8>,\n}\n\nimpl StreamResponse {\n    pub fn new(data: Vec<u8>) -> Self {\n        StreamResponse { data: data }\n    }\n}\n\nimpl WriteBody for StreamResponse {\n    fn write_body(&mut self, res: &mut ResponseBody) -> io::Result<()> {\n        for byte in self.data.clone() {\n            try!(res.write(&[byte]));\n            try!(res.flush());\n        }\n\n        Ok(())\n    }\n}\n```\n\n(I intentionally flush after every byte as a test, it's not designed to be performant)\n. On master, you can use `RedirectRaw` since it just takes a bare string.\n. I just used:\n\n```\nOk(Response::with((status::Found, Header(headers::Location(\"/something-relative\")))))\n```\n. Because I should depend on the version from iron.  I shouldn't have to keep my modifier dependency in sync with Iron's.\n. Missing a tag for `0.4.0`...\n. ",
    "ryansname": "Hi, I've just run into this problem as well. Here is a minimal working example of the problem, if you load [this](https://gist.github.com/Ryanl92/f973f79d8800277ac1013d257844a101) in your browser. (Well in Firefox 50, linux at least). The hyperium/hyper#309 suggests the problem is resolved in 1.10 though.\r\n\r\n. Hi, I've just run into this problem as well. Here is a minimal working example of the problem, if you load [this](https://gist.github.com/Ryanl92/f973f79d8800277ac1013d257844a101) in your browser. (Well in Firefox 50, linux at least). The hyperium/hyper#309 suggests the problem is resolved in 1.10 though.\r\n\r\n. ",
    "matthauck": "I'm able to repro this still with the latest versions of stuff: https://gist.github.com/matthauck/58756f0be5907673ded2254fba59f07a. Ah yes, that would be helpful. Posted. Interesting there are two versions of hyper listed... . `/shrug`  Hopefully...?\r\n\r\nThoughts on implementing a workaround for now? It seems to me pretty common that a request is not read (i.e. early return from middleware because some session header/cookie was not present.). Unclear what the timeline is for the release of that async branch of hyper.\r\n\r\nMaybe closing the connection when there is still data left to read after a request is done? I've implemented an after chain that reads data left on requests as a `link_after`, and it seems to have fixed it where I was running into it. This is not ideal since it could end up reading data forever (the reason https://github.com/hyperium/hyper/commit/5f432851882c6f5e2dbf4efea464978bc4d88700 was reverted), and I think it doesn't solve the early return case.. @untitaker: yeah, not advocating reading in all the data. That is not a good solution for the framework, just a middleware workaround for me I've added. I was suggesting iron could maybe drop the connection if it was not read all the way -- the `Request` object does not expose a way to do this, but thought maybe iron had a way to do this internally.\r\n\r\n@seanmonstar: interesting. the way this manifests in iron is that the remaining data from the original request becomes part of the method for the following request. See output in [the gist above](https://gist.github.com/matthauck/58756f0be5907673ded2254fba59f07a#file-log-txt). Maybe there is actually a bug in how iron is handling this beyond the known issue in sync hyper?\r\n. @sfackler: Are you referring to new or old behavior in hyper?. I'm able to repro this still with the latest versions of stuff: https://gist.github.com/matthauck/58756f0be5907673ded2254fba59f07a. Ah yes, that would be helpful. Posted. Interesting there are two versions of hyper listed... . `/shrug`  Hopefully...?\r\n\r\nThoughts on implementing a workaround for now? It seems to me pretty common that a request is not read (i.e. early return from middleware because some session header/cookie was not present.). Unclear what the timeline is for the release of that async branch of hyper.\r\n\r\nMaybe closing the connection when there is still data left to read after a request is done? I've implemented an after chain that reads data left on requests as a `link_after`, and it seems to have fixed it where I was running into it. This is not ideal since it could end up reading data forever (the reason https://github.com/hyperium/hyper/commit/5f432851882c6f5e2dbf4efea464978bc4d88700 was reverted), and I think it doesn't solve the early return case.. @untitaker: yeah, not advocating reading in all the data. That is not a good solution for the framework, just a middleware workaround for me I've added. I was suggesting iron could maybe drop the connection if it was not read all the way -- the `Request` object does not expose a way to do this, but thought maybe iron had a way to do this internally.\r\n\r\n@seanmonstar: interesting. the way this manifests in iron is that the remaining data from the original request becomes part of the method for the following request. See output in [the gist above](https://gist.github.com/matthauck/58756f0be5907673ded2254fba59f07a#file-log-txt). Maybe there is actually a bug in how iron is handling this beyond the known issue in sync hyper?\r\n. @sfackler: Are you referring to new or old behavior in hyper?. ",
    "seanmonstar": "Yea, it's a known issue in sync hyper (0.10 and before). The fix would be fairly difficult to do, and resources aren't really dedicated at the 0.10.x branch anymore.\r\n\r\nThe fix in async was basically to just close the connection if the full body wasn't read. It's the sanest default.\r\n\r\nAs for the bug, if I recall correctly, the only thing really happens is an error log line is generated and then the connection is dropped, when it tries to parse the remaining body as a new request.. I waited on that issue for a few days to allow discussion, it seems it's wrapped up. I'm away from the computer today, but I can probably finish the release tomorrow.. It's been wonky with openssl failing on the Mac box, and master hasn't seen any attention in a while. You can see the 0.10.x branch is passing here: https://travis-ci.org/hyperium/hyper/branches\r\n\r\nThe tokio branch was also passing yesterday, but I'm fiddling with the new released tokio crates today.. The current tokio-proto design is built with some sort of idea of middleware, coming from 2 different sides of the server problem.\r\n\r\n1. `ServerProto`: These are the things that receive some IO object, and process it into a `Request` and `Response` (not necessarily HTTP), and give those things to a `Service`. This is what `hyper::server::Http` is. A system of `ServerProto` middleware can exist. In fact, hyper's is one of them. There can exist other `ServerProto`s that are generic over one they wrap, such as the `TlsServer` in tokio-tls.\r\n\r\n2. `Service`: These are the middlewares that process the `Request`/`Response` pair, not really dealing with the underlying IO object. Since Iron is built around the idea of middleware, it may make sense to be able to use any `Service` wrapper. This allows something like the following:\r\n    \r\n    ```rust\r\n    let router = iron::Router::new(map_of_routes); // impl Service\r\n    let timed = foo::Timed::new(thirty_seconds, router); // impl Service\r\n    let log = iron::Log::new(log_opts, timed); // impl Service\r\n    return log;\r\n    ````\r\n\r\n----\r\n\r\nAll this to say, you could make `Iron` implement `ServerProto`. Maybe it takes an `Http`, maybe that's not exposed, I don't really know. But that'd allow others to chose to use `TcpServer`, or `TlsServer`, or `UnixServer`, or `QuicServer`, or whatever.\r\n\r\nIf you wanted an \"easy mode\", you could make `Iron::listen` wrap itself in a `TcpServer` or something.. I just realized that it may make sense to not even bother with `ServerProto`. Iron could be a collection of `Service`s. In which case, combining with hyper, it'd look like `Http::new().bind(addr, Iron::new(middlewares))`. And still with an `Iron::listen` easy mode if you prefer.. Yea, it's a known issue in sync hyper (0.10 and before). The fix would be fairly difficult to do, and resources aren't really dedicated at the 0.10.x branch anymore.\r\n\r\nThe fix in async was basically to just close the connection if the full body wasn't read. It's the sanest default.\r\n\r\nAs for the bug, if I recall correctly, the only thing really happens is an error log line is generated and then the connection is dropped, when it tries to parse the remaining body as a new request.. I waited on that issue for a few days to allow discussion, it seems it's wrapped up. I'm away from the computer today, but I can probably finish the release tomorrow.. It's been wonky with openssl failing on the Mac box, and master hasn't seen any attention in a while. You can see the 0.10.x branch is passing here: https://travis-ci.org/hyperium/hyper/branches\r\n\r\nThe tokio branch was also passing yesterday, but I'm fiddling with the new released tokio crates today.. The current tokio-proto design is built with some sort of idea of middleware, coming from 2 different sides of the server problem.\r\n\r\n1. `ServerProto`: These are the things that receive some IO object, and process it into a `Request` and `Response` (not necessarily HTTP), and give those things to a `Service`. This is what `hyper::server::Http` is. A system of `ServerProto` middleware can exist. In fact, hyper's is one of them. There can exist other `ServerProto`s that are generic over one they wrap, such as the `TlsServer` in tokio-tls.\r\n\r\n2. `Service`: These are the middlewares that process the `Request`/`Response` pair, not really dealing with the underlying IO object. Since Iron is built around the idea of middleware, it may make sense to be able to use any `Service` wrapper. This allows something like the following:\r\n    \r\n    ```rust\r\n    let router = iron::Router::new(map_of_routes); // impl Service\r\n    let timed = foo::Timed::new(thirty_seconds, router); // impl Service\r\n    let log = iron::Log::new(log_opts, timed); // impl Service\r\n    return log;\r\n    ````\r\n\r\n----\r\n\r\nAll this to say, you could make `Iron` implement `ServerProto`. Maybe it takes an `Http`, maybe that's not exposed, I don't really know. But that'd allow others to chose to use `TcpServer`, or `TlsServer`, or `UnixServer`, or `QuicServer`, or whatever.\r\n\r\nIf you wanted an \"easy mode\", you could make `Iron::listen` wrap itself in a `TcpServer` or something.. I just realized that it may make sense to not even bother with `ServerProto`. Iron could be a collection of `Service`s. In which case, combining with hyper, it'd look like `Http::new().bind(addr, Iron::new(middlewares))`. And still with an `Iron::listen` easy mode if you prefer.. ",
    "yazaddaruvala": "@reem what are your thoughts on releasing a version of sync-iron where the backend is async-hyper?\n\nBasically make it extremely easy for people to migrate over and test the new backend.\n\nI guess the question is, do you think the cost of implementing a sync shim on top of hyper is low enough to warrant the added testing?\n. @reem what are your thoughts on releasing a version of sync-iron where the backend is async-hyper?\n\nBasically make it extremely easy for people to migrate over and test the new backend.\n\nI guess the question is, do you think the cost of implementing a sync shim on top of hyper is low enough to warrant the added testing?\n. ",
    "KodrAus": "For discoverability I think it would be good to keep this issue around and open in some form until `iron` provides a `futures` based (or whatever it ends up being) implementation for asynchronous request handling.\n. For discoverability I think it would be good to keep this issue around and open in some form until `iron` provides a `futures` based (or whatever it ends up being) implementation for asynchronous request handling.\n. ",
    "rix0rrr": "I do agree, but at the same time I don't really have the time, or a choice, right now :)\n. I do agree, but at the same time I don't really have the time, or a choice, right now :)\n. ",
    "mitsuhiko": "For what it's worth this problem still exists. From what I can tell you need to use the plugin crate explicitly?. The only re-export is in the prelude and from what I can tell this re-export does not work.. Oh, maybe it's because the type gets renamed to Pluggable? In any case the experience is very confusing.. Then in addition to the compiler error the docs are still wrong. It says the reexport is in prelude.. I would propose not renaming it. Because what brought me to this issue here is not the docs but the compiler error.. For what it's worth this problem still exists. From what I can tell you need to use the plugin crate explicitly?. The only re-export is in the prelude and from what I can tell this re-export does not work.. Oh, maybe it's because the type gets renamed to Pluggable? In any case the experience is very confusing.. Then in addition to the compiler error the docs are still wrong. It says the reexport is in prelude.. I would propose not renaming it. Because what brought me to this issue here is not the docs but the compiler error.. ",
    "bluss": "Yeah I don't completely understand how they decided to solve it. But it looks like upstream rust now ignores lint-related failures in cargotest, which means that iron could stop building due to lint changes upstream, and cargotest does not block on that.\n. I will underline that such lint changes are most often improvements, as in for example, finding more unused items than before.\n. @reem thanks for looking at it. I think I want to abandon this now. iron is a library and cargo is a binary, so it's a bit different anyway.\n. Yeah I don't completely understand how they decided to solve it. But it looks like upstream rust now ignores lint-related failures in cargotest, which means that iron could stop building due to lint changes upstream, and cargotest does not block on that.\n. I will underline that such lint changes are most often improvements, as in for example, finding more unused items than before.\n. @reem thanks for looking at it. I think I want to abandon this now. iron is a library and cargo is a binary, so it's a bit different anyway.\n. ",
    "carols10cents": "> IIRC @reem mentioned that he wanted to refactor the API around Iron requests/urls as well, I hope this will eliminate all those costly conversions.\n\nYes, I think there's definitely room for improvement. Perhaps iron could hold onto the `url::Url` within its `Url` type instead of converting?\n. So is merging this in dependent on trying the refactoring to hold on to `url::Url` directly? If so, mind if I give it a try?\n. Forgiveness > permission... https://github.com/iron/iron/pull/453\n. @reem awesome, done! That makes the implementations way nicer-- fewer `.to_owned()`s all over the place :)\n. YAAAYY!!!! \ud83c\udf86\ud83c\udf86\ud83c\udf86\ud83c\udf86\ud83c\udf86\ud83c\udf86 Thank you @reem !!! \u2764\ufe0f \u2764\ufe0f \u2764\ufe0f \u2764\ufe0f  \n. > IIRC @reem mentioned that he wanted to refactor the API around Iron requests/urls as well, I hope this will eliminate all those costly conversions.\n\nYes, I think there's definitely room for improvement. Perhaps iron could hold onto the `url::Url` within its `Url` type instead of converting?\n. So is merging this in dependent on trying the refactoring to hold on to `url::Url` directly? If so, mind if I give it a try?\n. Forgiveness > permission... https://github.com/iron/iron/pull/453\n. @reem awesome, done! That makes the implementations way nicer-- fewer `.to_owned()`s all over the place :)\n. YAAAYY!!!! \ud83c\udf86\ud83c\udf86\ud83c\udf86\ud83c\udf86\ud83c\udf86\ud83c\udf86 Thank you @reem !!! \u2764\ufe0f \u2764\ufe0f \u2764\ufe0f \u2764\ufe0f  \n. ",
    "onur": "Any progress on this? I am getting this warning when I try to build iron with latest cargo (5a26b65):\n\n```\n$ cargo build\nwarning: TOML file found which contains invalid syntax and will soon not parse\nat `/home/onur/.cargo/registry/src/github.com-1ecc6299db9ec823/url-0.5.9/Cargo.toml`.\n\nThe TOML spec requires newlines after table definitions (e.g. `[a] b = 1` is\ninvalid), but this file has a table header which does not have a newline after\nit. A newline needs to be added and this warning will soon become a hard error\nin the future.\n```\n\nAnd I can't already build iron 0.3 with cratesfyi. We really need url 1 support soon I guess.\n. Any progress on this? I am getting this warning when I try to build iron with latest cargo (5a26b65):\n\n```\n$ cargo build\nwarning: TOML file found which contains invalid syntax and will soon not parse\nat `/home/onur/.cargo/registry/src/github.com-1ecc6299db9ec823/url-0.5.9/Cargo.toml`.\n\nThe TOML spec requires newlines after table definitions (e.g. `[a] b = 1` is\ninvalid), but this file has a table header which does not have a newline after\nit. A newline needs to be added and this warning will soon become a hard error\nin the future.\n```\n\nAnd I can't already build iron 0.3 with cratesfyi. We really need url 1 support soon I guess.\n. ",
    "phillipCouto": "You would loot at the url value in the request input to your handler.\n. You would loot at the url value in the request input to your handler.\n. ",
    "KenanSulayman": "You can peek into the `Host` header. Simply match that against your `www` prefixed TLD and you're ready to go\n. It's initialized here: [src/iron.rs#L154](https://github.com/iron/iron/blob/16c858ec2901e2992fe5e529780f59fa8ed12903/src/iron.rs#L154).\n\nI'd go with something like this:\n\n```\npub fn listen_with<A: ToSocketAddrs, S: Server::http + Server::https>(\n    mut self, server: S, addr: A, threads: usize,\n    protocol: Protocol, timeouts: Option<Timeouts>\n) -> HttpResult<Listening> {\n```\n.  It effectively sends the request to the Handler functions and processes the output. The instantiation is still in listen_with\n. You can peek into the `Host` header. Simply match that against your `www` prefixed TLD and you're ready to go\n. It's initialized here: [src/iron.rs#L154](https://github.com/iron/iron/blob/16c858ec2901e2992fe5e529780f59fa8ed12903/src/iron.rs#L154).\n\nI'd go with something like this:\n\n```\npub fn listen_with<A: ToSocketAddrs, S: Server::http + Server::https>(\n    mut self, server: S, addr: A, threads: usize,\n    protocol: Protocol, timeouts: Option<Timeouts>\n) -> HttpResult<Listening> {\n```\n.  It effectively sends the request to the Handler functions and processes the output. The instantiation is still in listen_with\n. ",
    "shepmaster": "There appears to be a [pull request for this](https://github.com/iron/iron.github.io/pull/25).\n. and [iron-test](https://github.com/iron/iron-test) (depends on router, urlencoded). There appears to be a [pull request for this](https://github.com/iron/iron.github.io/pull/25).\n. and [iron-test](https://github.com/iron/iron-test) (depends on router, urlencoded). ",
    "alanhoff": "That was supper informative! Many thanks :-)\n. That was supper informative! Many thanks :-)\n. ",
    "beanieboi": "@SkylerLipthay I stumbled across the same issue and your comment was super helpful! Thank you!. @SkylerLipthay I stumbled across the same issue and your comment was super helpful! Thank you!. ",
    "xpe": "I got more information:\n\n```\n\u276f RUST_BACKTRACE=1 cargo run\n     Running `target/debug/my-server`\nListening { socket: V6([::1]:3000) }\nmy-server(19639,0x700000607000) malloc: *** error for object 0x7f992be036d0: pointer being freed was not allocated\n*** set a breakpoint in malloc_error_break to debug\nerror: Process didn't exit successfully: `target/debug/my-server` (signal: 6, SIGABRT: process abort signal)\n```\n. I got more information:\n\n```\n\u276f RUST_BACKTRACE=1 cargo run\n     Running `target/debug/my-server`\nListening { socket: V6([::1]:3000) }\nmy-server(19639,0x700000607000) malloc: *** error for object 0x7f992be036d0: pointer being freed was not allocated\n*** set a breakpoint in malloc_error_break to debug\nerror: Process didn't exit successfully: `target/debug/my-server` (signal: 6, SIGABRT: process abort signal)\n```\n. ",
    "Cobrand": "Is it possible to have 2 docs generated ? One for iron with ssl features, and another for iron without ssl features ? Or maybe we can only generate with ssl features and tag them appropriately in the docs (saying that these methods / structs / ... are only available with `--features ssl` ?)\n\nAnother quick question - but maybe here is not the right place - why not make ssl a default feature that you can disable if needed ?\n. Is it possible to have 2 docs generated ? One for iron with ssl features, and another for iron without ssl features ? Or maybe we can only generate with ssl features and tag them appropriately in the docs (saying that these methods / structs / ... are only available with `--features ssl` ?)\n\nAnother quick question - but maybe here is not the right place - why not make ssl a default feature that you can disable if needed ?\n. ",
    "flosse": "@Hoverbear thx!\n. @Hoverbear It's still unclear for me :(\nIt would be great to get an working example, so that I can replace my `out` with something like `res.body`: \n\n``` rust\nlet mut out: Vec<u8> = vec!(); // <--- this should be replaced with the body\nwrite!(out, \"foo: {}\", 42);\n```\n. https://gist.github.com/flosse/da963de2bbb466bdca09c23757b070ce\n. @Hoverbear thx!\n. @Hoverbear It's still unclear for me :(\nIt would be great to get an working example, so that I can replace my `out` with something like `res.body`: \n\n``` rust\nlet mut out: Vec<u8> = vec!(); // <--- this should be replaced with the body\nwrite!(out, \"foo: {}\", 42);\n```\n. https://gist.github.com/flosse/da963de2bbb466bdca09c23757b070ce\n. ",
    "BenjaminGill-Metaswitch": "No - rustc 1.12.0-nightly (1225e122f 2016-07-30) is perfectly happy compiling iron 0.3.\n. No - rustc 1.12.0-nightly (1225e122f 2016-07-30) is perfectly happy compiling iron 0.3.\n. ",
    "lunemec": "Ah, as it turns out, it was not a bug in Iron or in Params library, the code just needed to be changed from :\n\n```\nreq.get_ref::<Params>().unwrap()\n```\n\nto :\n\n```\n    let params_map = match params {\n        Ok(params) => params,\n        Err(error) => return Ok(Response::with((status::BadRequest, error.description())))\n    };\n```\n\nThis works for incorrect JSON data or for too large request body.\n. Ah, as it turns out, it was not a bug in Iron or in Params library, the code just needed to be changed from :\n\n```\nreq.get_ref::<Params>().unwrap()\n```\n\nto :\n\n```\n    let params_map = match params {\n        Ok(params) => params,\n        Err(error) => return Ok(Response::with((status::BadRequest, error.description())))\n    };\n```\n\nThis works for incorrect JSON data or for too large request body.\n. ",
    "ssemakin": "I've managed to fix my issue by changing:\n\n`Iron::new(router).http(\"localhost:3000\").unwrap();`\n\nto\n\n`Iron::new(router).http(\"127.0.0.1:3000\").unwrap();`\n\nNot sure which way would be more correct though. \n\nSo please feel free to close this issue if you decide so.\n. I would definitely think something is funny going on with my setup but again, as I mentioned in the initial post running 127.0.0.1/localhost interchangeably on other services on my machine works fine. So yeah, it is puzzling.\n\nHere is how my _ifconfig_ output looks like, let me know if you want me to run a different command:\n\n```\nlo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384\n        options=3<RXCSUM,TXCSUM>\n        inet6 ::1 prefixlen 128\n        inet 127.0.0.1 netmask 0xff000000\n        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1\n        nd6 options=1<PERFORMNUD>\ngif0: flags=8010<POINTOPOINT,MULTICAST> mtu 1280\nstf0: flags=0<> mtu 1280\nen0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1453\n        ether ac:bc:32:a4:48:83\n        inet6 fe80::aebc:32ff:fea4:4883%en0 prefixlen 64 scopeid 0x4\n        inet 192.168.1.105 netmask 0xffffff00 broadcast 192.168.1.255\n        nd6 options=1<PERFORMNUD>\n        media: autoselect\n        status: active\nen1: flags=963<UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX> mtu 1500\n        options=60<TSO4,TSO6>\n        ether 6a:00:01:11:e9:e0\n        media: autoselect <full-duplex>\n        status: inactive\nen2: flags=963<UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX> mtu 1500\n        options=60<TSO4,TSO6>\n        ether 6a:00:01:11:e9:e1\n        media: autoselect <full-duplex>\n        status: inactive\nbridge0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n        options=63<RXCSUM,TXCSUM,TSO4,TSO6>\n        ether ae:bc:32:4a:07:00\n        Configuration:\n            id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0\n            maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200\n            root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0\n            ipfilter disabled flags 0x2\n        member: en1 flags=3<LEARNING,DISCOVER>\n                ifmaxaddr 0 port 5 priority 0 path cost 0\n        member: en2 flags=3<LEARNING,DISCOVER>\n                ifmaxaddr 0 port 6 priority 0 path cost 0\n        nd6 options=1<PERFORMNUD>\n        media: <unknown type>\n        status: inactive\np2p0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 2304\n        ether 0e:bc:32:a4:48:83\n        media: autoselect\n        status: inactive\nawdl0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1484\n        ether 16:e4:6c:2a:7a:48\n        inet6 fe80::14e4:6cff:fe2a:7a48%awdl0 prefixlen 64 scopeid 0x9\n        nd6 options=1<PERFORMNUD>\n        media: autoselect\n        status: active\n```\n. I've managed to fix my issue by changing:\n\n`Iron::new(router).http(\"localhost:3000\").unwrap();`\n\nto\n\n`Iron::new(router).http(\"127.0.0.1:3000\").unwrap();`\n\nNot sure which way would be more correct though. \n\nSo please feel free to close this issue if you decide so.\n. I would definitely think something is funny going on with my setup but again, as I mentioned in the initial post running 127.0.0.1/localhost interchangeably on other services on my machine works fine. So yeah, it is puzzling.\n\nHere is how my _ifconfig_ output looks like, let me know if you want me to run a different command:\n\n```\nlo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384\n        options=3<RXCSUM,TXCSUM>\n        inet6 ::1 prefixlen 128\n        inet 127.0.0.1 netmask 0xff000000\n        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1\n        nd6 options=1<PERFORMNUD>\ngif0: flags=8010<POINTOPOINT,MULTICAST> mtu 1280\nstf0: flags=0<> mtu 1280\nen0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1453\n        ether ac:bc:32:a4:48:83\n        inet6 fe80::aebc:32ff:fea4:4883%en0 prefixlen 64 scopeid 0x4\n        inet 192.168.1.105 netmask 0xffffff00 broadcast 192.168.1.255\n        nd6 options=1<PERFORMNUD>\n        media: autoselect\n        status: active\nen1: flags=963<UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX> mtu 1500\n        options=60<TSO4,TSO6>\n        ether 6a:00:01:11:e9:e0\n        media: autoselect <full-duplex>\n        status: inactive\nen2: flags=963<UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX> mtu 1500\n        options=60<TSO4,TSO6>\n        ether 6a:00:01:11:e9:e1\n        media: autoselect <full-duplex>\n        status: inactive\nbridge0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n        options=63<RXCSUM,TXCSUM,TSO4,TSO6>\n        ether ae:bc:32:4a:07:00\n        Configuration:\n            id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0\n            maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200\n            root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0\n            ipfilter disabled flags 0x2\n        member: en1 flags=3<LEARNING,DISCOVER>\n                ifmaxaddr 0 port 5 priority 0 path cost 0\n        member: en2 flags=3<LEARNING,DISCOVER>\n                ifmaxaddr 0 port 6 priority 0 path cost 0\n        nd6 options=1<PERFORMNUD>\n        media: <unknown type>\n        status: inactive\np2p0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 2304\n        ether 0e:bc:32:a4:48:83\n        media: autoselect\n        status: inactive\nawdl0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1484\n        ether 16:e4:6c:2a:7a:48\n        inet6 fe80::14e4:6cff:fe2a:7a48%awdl0 prefixlen 64 scopeid 0x9\n        nd6 options=1<PERFORMNUD>\n        media: autoselect\n        status: active\n```\n. ",
    "adrianbrink": "I think the most feasible way is to add it in [iron.rs](https://github.com/iron/iron/blob/master/src/iron.rs) as a new method in the implementation of Iron.\n\n`pub fn with_server(handler: H, server: Server) -> Iron<H>`\n\nWhat do you think @reem ?\n\nPS: Could someone explain to me how Handler works here? It is a trait defined in hyper, but in the implementation block in iron.rs it is not fully implemented. However in the hello_world example, we pass a Request closure to the new function instead of a Handler. I checked in the [hyper docs](http://ironframework.io/doc/iron/request/struct.Request.html) and it Request doesn't implement Handler.\nAny help on this would be appreciated.\n. How come that we also implement the Handler trait from hyper.\n\n`impl<H: Handler> ::hyper::server::Handler for Iron<H> {`\n\nin [iron.rs](https://github.com/iron/iron/blob/master/src/iron.rs)\n. I think the most feasible way is to add it in [iron.rs](https://github.com/iron/iron/blob/master/src/iron.rs) as a new method in the implementation of Iron.\n\n`pub fn with_server(handler: H, server: Server) -> Iron<H>`\n\nWhat do you think @reem ?\n\nPS: Could someone explain to me how Handler works here? It is a trait defined in hyper, but in the implementation block in iron.rs it is not fully implemented. However in the hello_world example, we pass a Request closure to the new function instead of a Handler. I checked in the [hyper docs](http://ironframework.io/doc/iron/request/struct.Request.html) and it Request doesn't implement Handler.\nAny help on this would be appreciated.\n. How come that we also implement the Handler trait from hyper.\n\n`impl<H: Handler> ::hyper::server::Handler for Iron<H> {`\n\nin [iron.rs](https://github.com/iron/iron/blob/master/src/iron.rs)\n. ",
    "vojtechkral": "Firefox headers:\n\n```\nAccept-Encoding: gzip, deflate\nAccept-Language: cs-CZ,en-GB;q=0.8,en-US;q=0.5,en;q=0.3\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nConnection: keep-alive\nContent-Length: 524626\nContent-Type: multipart/form-data; boundary=---------------------------24775772147415635372086994\nDNT: 1\nHost: localhost:3000\nReferer: http://localhost:3000/\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0\n```\n\n... I don't really see a difference appart maybe from the cache\n. I also noticed this only happens with `multipart/form-data`, when I send the data appended to the request raw, there's no problem even with much larger files.\n. Hi. I managed to fixed this - the problem was actually on the front end where the body payload was embeded in a wrong encoding. Damn JavaScript. Sorry for the noise!\n. Firefox headers:\n\n```\nAccept-Encoding: gzip, deflate\nAccept-Language: cs-CZ,en-GB;q=0.8,en-US;q=0.5,en;q=0.3\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nConnection: keep-alive\nContent-Length: 524626\nContent-Type: multipart/form-data; boundary=---------------------------24775772147415635372086994\nDNT: 1\nHost: localhost:3000\nReferer: http://localhost:3000/\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0\n```\n\n... I don't really see a difference appart maybe from the cache\n. I also noticed this only happens with `multipart/form-data`, when I send the data appended to the request raw, there's no problem even with much larger files.\n. Hi. I managed to fixed this - the problem was actually on the front end where the body payload was embeded in a wrong encoding. Damn JavaScript. Sorry for the noise!\n. ",
    "llompartg": "Hi\r\n\r\nIs this still open / pending?. Hi\r\n\r\nIs this still open / pending?. ",
    "vignesh-sankaran": "@Hoverbear Yep I do plan on using LE but am generating my own certs with OpenSSL in the dev environment for now\n\nThanks @untitaker, that did the trick\n. @Hoverbear Yep I do plan on using LE but am generating my own certs with OpenSSL in the dev environment for now\n\nThanks @untitaker, that did the trick\n. ",
    "iron-bot": "Good news everyone! Recovered iron-bot, sent @untitaker and @Hoverbear collaborator invites on the build-docs repo.\n\n(hehe wrong account, this is @reem)\n. Good news everyone! Recovered iron-bot, sent @untitaker and @Hoverbear collaborator invites on the build-docs repo.\n\n(hehe wrong account, this is @reem)\n. ",
    "Synesso": "Yes, curl works.\n\nAlso, if I run `python -m SimpleHTTPServer`, I can access those pages from\nScala OK.\n\nOn 30 September 2016 at 17:05, Markus Unterwaditzer <\nnotifications@github.com> wrote:\n\n> Do other clients work while the JVM client fails?\n> \n> On Thu, Sep 29, 2016 at 11:54:30PM -0700, Jeremy Mawson wrote:\n> \n> > ```\n> > git clone https://github.com/iron/iron.git\n> > (cd iron && cargo run --example hello)\n> > ```\n> > \n> > ```\n> > $ curl \"http://localhost:3000/\"\n> > Hello world!\n> > ```\n> > \n> > but\n> > \n> > ```\n> > $ scala\n> > scala> scala.io.Source.fromURL(\"http://localhost:3000/\").mkString\n> > java.net.ConnectException: Connection refused\n> > ```\n> > \n> > I found this issue when my own Iron app suddenly stopped accepting\n> > requests. I raised a [stackoverflow question](http://\n> > stackoverflow.com/questions/39781623/localhost-iron-\n> > server-curl-connects-but-scala-cannot), but then it started working\n> > again. A few hours later, the app is no longer accepting requests from the\n> > JVM once more.\n> > - OSX 10.11.6\n> > - cargo 0.13.0-nightly (9399229 2016-09-14)\n> >   also tested with\n> > - cargo 0.13.0-nightly (19cfb67 2016-09-28)\n> > \n> > ## \n> > \n> > You are receiving this because you are subscribed to this thread.\n> > Reply to this email directly or view it on GitHub:\n> > https://github.com/iron/iron/issues/484\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/iron/iron/issues/484#issuecomment-250674694, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AABVY8ijsJq04T6E0CAqRuoNL4oHLxFOks5qvLS-gaJpZM4KKyBW\n> .\n. I can confirm that it worked with my app at some stage, and then stopped\nagain. I have not yet seen it work once more. I did not capture the changes\nwhich flipped it from working to not working and back again, but I wasn't\ntouching networking code in either client or server app.\n\nOn 30 September 2016 at 18:09, Andrew Hobden notifications@github.com\nwrote:\n\n> Can you confirm that it is still an intermittent problem if you connect\n> from 127.0.0.1?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/iron/iron/issues/484#issuecomment-250685381, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AABVY8eBER7u0F0dOxO2lg4wNyeheKilks5qvMO0gaJpZM4KKyBW\n> .\n. If I modify hello.rs to bind to 127.0.0.1 instead of localhost, it works\nfrom Scala with either 127.0.0.1 or localhost.\nWhilst hello.rs binds to localhost, nothing works from Scala (yet works\nfrom curl).\n\nOn 30 September 2016 at 18:14, Andrew Hobden notifications@github.com\nwrote:\n\n> Could it be related to #476 https://github.com/iron/iron/issues/476?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/iron/iron/issues/484#issuecomment-250686224, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AABVY0WYU4HEliCh9Ft-KHf7sfPhDgpoks5qvMTPgaJpZM4KKyBW\n> .\n. ##\n\n# Host Database\n\n#\n\n# localhost is used to configure the loopback interface\n\n# when the system is booting.  Do not change this entry.\n\n##\n127.0.0.1 localhost\n#127.0.0.1 art.local\n255.255.255.255 broadcasthost\n::1             localhost\n\nI commented out the last line and it now works. So yes, same issue.\n\nThank you\n\nOn 30 September 2016 at 18:25, Andrew Hobden notifications@github.com\nwrote:\n\n> Okay can you give me the output of your hosts file? Please see this\n> comment from @untitaker https://github.com/untitaker #476 (comment)\n> https://github.com/iron/iron/issues/476#issuecomment-241730172\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/iron/iron/issues/484#issuecomment-250688303, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AABVYwwTuWS0tUvp1IrOzrJwdq_Hhgweks5qvMdrgaJpZM4KKyBW\n> .\n. Indeed!\n. Yes, curl works.\n\nAlso, if I run `python -m SimpleHTTPServer`, I can access those pages from\nScala OK.\n\nOn 30 September 2016 at 17:05, Markus Unterwaditzer <\nnotifications@github.com> wrote:\n\n> Do other clients work while the JVM client fails?\n> \n> On Thu, Sep 29, 2016 at 11:54:30PM -0700, Jeremy Mawson wrote:\n> \n> > ```\n> > git clone https://github.com/iron/iron.git\n> > (cd iron && cargo run --example hello)\n> > ```\n> > \n> > ```\n> > $ curl \"http://localhost:3000/\"\n> > Hello world!\n> > ```\n> > \n> > but\n> > \n> > ```\n> > $ scala\n> > scala> scala.io.Source.fromURL(\"http://localhost:3000/\").mkString\n> > java.net.ConnectException: Connection refused\n> > ```\n> > \n> > I found this issue when my own Iron app suddenly stopped accepting\n> > requests. I raised a [stackoverflow question](http://\n> > stackoverflow.com/questions/39781623/localhost-iron-\n> > server-curl-connects-but-scala-cannot), but then it started working\n> > again. A few hours later, the app is no longer accepting requests from the\n> > JVM once more.\n> > - OSX 10.11.6\n> > - cargo 0.13.0-nightly (9399229 2016-09-14)\n> >   also tested with\n> > - cargo 0.13.0-nightly (19cfb67 2016-09-28)\n> > \n> > ## \n> > \n> > You are receiving this because you are subscribed to this thread.\n> > Reply to this email directly or view it on GitHub:\n> > https://github.com/iron/iron/issues/484\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/iron/iron/issues/484#issuecomment-250674694, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AABVY8ijsJq04T6E0CAqRuoNL4oHLxFOks5qvLS-gaJpZM4KKyBW\n> .\n. I can confirm that it worked with my app at some stage, and then stopped\nagain. I have not yet seen it work once more. I did not capture the changes\nwhich flipped it from working to not working and back again, but I wasn't\ntouching networking code in either client or server app.\n\nOn 30 September 2016 at 18:09, Andrew Hobden notifications@github.com\nwrote:\n\n> Can you confirm that it is still an intermittent problem if you connect\n> from 127.0.0.1?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/iron/iron/issues/484#issuecomment-250685381, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AABVY8eBER7u0F0dOxO2lg4wNyeheKilks5qvMO0gaJpZM4KKyBW\n> .\n. If I modify hello.rs to bind to 127.0.0.1 instead of localhost, it works\nfrom Scala with either 127.0.0.1 or localhost.\nWhilst hello.rs binds to localhost, nothing works from Scala (yet works\nfrom curl).\n\nOn 30 September 2016 at 18:14, Andrew Hobden notifications@github.com\nwrote:\n\n> Could it be related to #476 https://github.com/iron/iron/issues/476?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/iron/iron/issues/484#issuecomment-250686224, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AABVY0WYU4HEliCh9Ft-KHf7sfPhDgpoks5qvMTPgaJpZM4KKyBW\n> .\n. ##\n\n# Host Database\n\n#\n\n# localhost is used to configure the loopback interface\n\n# when the system is booting.  Do not change this entry.\n\n##\n127.0.0.1 localhost\n#127.0.0.1 art.local\n255.255.255.255 broadcasthost\n::1             localhost\n\nI commented out the last line and it now works. So yes, same issue.\n\nThank you\n\nOn 30 September 2016 at 18:25, Andrew Hobden notifications@github.com\nwrote:\n\n> Okay can you give me the output of your hosts file? Please see this\n> comment from @untitaker https://github.com/untitaker #476 (comment)\n> https://github.com/iron/iron/issues/476#issuecomment-241730172\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/iron/iron/issues/484#issuecomment-250688303, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AABVYwwTuWS0tUvp1IrOzrJwdq_Hhgweks5qvMdrgaJpZM4KKyBW\n> .\n. Indeed!\n. ",
    "sanmai-NL": "Thanks @Hoverbear.\n. @untitaker: I can confirm that `curl -f -v \"http://[::1]:8000/\"` works as expected with `iron` `v0.5.1`.. Thanks @Hoverbear.\n. @untitaker: I can confirm that `curl -f -v \"http://[::1]:8000/\"` works as expected with `iron` `v0.5.1`.. ",
    "FranklinYu": "@untitaker I think that pull request has made it to master? No?. @untitaker I think that pull request has made it to master? No?. ",
    "AndiDog": "I'm trying to make an example with all variants, including the `router@0.4.0` crate, but get all kinds of build errors.\n\n```\nextern crate iron;\nextern crate router;\n\nuse iron::prelude::*;\nuse iron::headers::ContentType;\nuse iron::status;\nuse router::Router;\n\nfn variant1(_: &mut Request) -> IronResult<Response> {\n    Ok(Response::with((ContentType::json().0, status::Ok, \"{}\")))\n}\n\nfn main() {\n    let mut router = Router::new();\n\n    router.get(\"/1\", variant1, \"variant1\");\n\n    Iron::new(router).http(\"localhost:3000\").unwrap();\n}\n```\n\nBuild output:\n\n```\ncargo run --example content_type\n   Compiling iron v0.4.0 (file:///Users/asommer/dev/extern/iron)\nerror[E0281]: type mismatch: the type `fn(&mut iron::Request<'_, '_>) -> std::result::Result<iron::Response, iron::IronError> {variant1}` implements the trait `for<'r, 'r, 'r> std::ops::Fn<(&'r mut iron::Request<'r, 'r>,)>`, but the trait `for<'r, 'r, 'r> std::ops::Fn<(&'r mut iron::request::Request<'r, 'r>,)>` is required (expected struct `iron::request::Request`, found struct `iron::Request`)\n  --> examples/content_type.rs:16:12\n   |\n16 |     router.get(\"/1\", variant1, \"variant1\");\n   |            ^^^\n   |\n   = note: required because of the requirements on the impl of `iron::middleware::Handler` for `fn(&mut iron::Request<'_, '_>) -> std::result::Result<iron::Response, iron::IronError> {variant1}`\n\nerror[E0281]: type mismatch: the type `fn(&mut iron::Request<'_, '_>) -> std::result::Result<iron::Response, iron::IronError> {variant1}` implements the trait `for<'r, 'r, 'r> std::ops::FnOnce<(&'r mut iron::Request<'r, 'r>,)>`, but the trait `for<'r, 'r, 'r> std::ops::FnOnce<(&'r mut iron::request::Request<'r, 'r>,)>` is required (expected struct `iron::request::Request`, found struct `iron::Request`)\n  --> examples/content_type.rs:16:12\n   |\n16 |     router.get(\"/1\", variant1, \"variant1\");\n   |            ^^^\n   |\n   = note: required because of the requirements on the impl of `iron::middleware::Handler` for `fn(&mut iron::Request<'_, '_>) -> std::result::Result<iron::Response, iron::IronError> {variant1}`\n\nerror[E0277]: the trait bound `for<'r, 'r, 'r> router::Router: std::ops::Fn<(&'r mut iron::Request<'r, 'r>,)>` is not satisfied\n  --> examples/content_type.rs:18:5\n   |\n18 |     Iron::new(router).http(\"localhost:3000\").unwrap();\n   |     ^^^^^^^^^ trait `for<'r, 'r, 'r> router::Router: std::ops::Fn<(&'r mut iron::Request<'r, 'r>,)>` not satisfied\n   |\n   = note: required because of the requirements on the impl of `iron::Handler` for `router::Router`\n   = note: required by `<iron::Iron<H>>::new`\n\nerror[E0277]: the trait bound `for<'r, 'r, 'r> router::Router: std::ops::FnOnce<(&'r mut iron::Request<'r, 'r>,)>` is not satisfied\n  --> examples/content_type.rs:18:5\n   |\n18 |     Iron::new(router).http(\"localhost:3000\").unwrap();\n   |     ^^^^^^^^^ trait `for<'r, 'r, 'r> router::Router: std::ops::FnOnce<(&'r mut iron::Request<'r, 'r>,)>` not satisfied\n   |\n   = note: required because of the requirements on the impl of `iron::Handler` for `router::Router`\n   = note: required by `<iron::Iron<H>>::new`\n\nerror: no method named `http` found for type `iron::Iron<router::Router>` in the current scope\n  --> examples/content_type.rs:18:23\n   |\n18 |     Iron::new(router).http(\"localhost:3000\").unwrap();\n   |                       ^^^^\n   |\n   = note: the method `http` exists but the following trait bounds were not satisfied: `router::Router : iron::Handler`\n\nerror: aborting due to 5 previous errors\n\nerror: Could not compile `iron`.\n```\n\nCan you help?\n. I've updated the commit to use different handlers, chosen by command line argument, defaulting to first one.\n. I'm trying to make an example with all variants, including the `router@0.4.0` crate, but get all kinds of build errors.\n\n```\nextern crate iron;\nextern crate router;\n\nuse iron::prelude::*;\nuse iron::headers::ContentType;\nuse iron::status;\nuse router::Router;\n\nfn variant1(_: &mut Request) -> IronResult<Response> {\n    Ok(Response::with((ContentType::json().0, status::Ok, \"{}\")))\n}\n\nfn main() {\n    let mut router = Router::new();\n\n    router.get(\"/1\", variant1, \"variant1\");\n\n    Iron::new(router).http(\"localhost:3000\").unwrap();\n}\n```\n\nBuild output:\n\n```\ncargo run --example content_type\n   Compiling iron v0.4.0 (file:///Users/asommer/dev/extern/iron)\nerror[E0281]: type mismatch: the type `fn(&mut iron::Request<'_, '_>) -> std::result::Result<iron::Response, iron::IronError> {variant1}` implements the trait `for<'r, 'r, 'r> std::ops::Fn<(&'r mut iron::Request<'r, 'r>,)>`, but the trait `for<'r, 'r, 'r> std::ops::Fn<(&'r mut iron::request::Request<'r, 'r>,)>` is required (expected struct `iron::request::Request`, found struct `iron::Request`)\n  --> examples/content_type.rs:16:12\n   |\n16 |     router.get(\"/1\", variant1, \"variant1\");\n   |            ^^^\n   |\n   = note: required because of the requirements on the impl of `iron::middleware::Handler` for `fn(&mut iron::Request<'_, '_>) -> std::result::Result<iron::Response, iron::IronError> {variant1}`\n\nerror[E0281]: type mismatch: the type `fn(&mut iron::Request<'_, '_>) -> std::result::Result<iron::Response, iron::IronError> {variant1}` implements the trait `for<'r, 'r, 'r> std::ops::FnOnce<(&'r mut iron::Request<'r, 'r>,)>`, but the trait `for<'r, 'r, 'r> std::ops::FnOnce<(&'r mut iron::request::Request<'r, 'r>,)>` is required (expected struct `iron::request::Request`, found struct `iron::Request`)\n  --> examples/content_type.rs:16:12\n   |\n16 |     router.get(\"/1\", variant1, \"variant1\");\n   |            ^^^\n   |\n   = note: required because of the requirements on the impl of `iron::middleware::Handler` for `fn(&mut iron::Request<'_, '_>) -> std::result::Result<iron::Response, iron::IronError> {variant1}`\n\nerror[E0277]: the trait bound `for<'r, 'r, 'r> router::Router: std::ops::Fn<(&'r mut iron::Request<'r, 'r>,)>` is not satisfied\n  --> examples/content_type.rs:18:5\n   |\n18 |     Iron::new(router).http(\"localhost:3000\").unwrap();\n   |     ^^^^^^^^^ trait `for<'r, 'r, 'r> router::Router: std::ops::Fn<(&'r mut iron::Request<'r, 'r>,)>` not satisfied\n   |\n   = note: required because of the requirements on the impl of `iron::Handler` for `router::Router`\n   = note: required by `<iron::Iron<H>>::new`\n\nerror[E0277]: the trait bound `for<'r, 'r, 'r> router::Router: std::ops::FnOnce<(&'r mut iron::Request<'r, 'r>,)>` is not satisfied\n  --> examples/content_type.rs:18:5\n   |\n18 |     Iron::new(router).http(\"localhost:3000\").unwrap();\n   |     ^^^^^^^^^ trait `for<'r, 'r, 'r> router::Router: std::ops::FnOnce<(&'r mut iron::Request<'r, 'r>,)>` not satisfied\n   |\n   = note: required because of the requirements on the impl of `iron::Handler` for `router::Router`\n   = note: required by `<iron::Iron<H>>::new`\n\nerror: no method named `http` found for type `iron::Iron<router::Router>` in the current scope\n  --> examples/content_type.rs:18:23\n   |\n18 |     Iron::new(router).http(\"localhost:3000\").unwrap();\n   |                       ^^^^\n   |\n   = note: the method `http` exists but the following trait bounds were not satisfied: `router::Router : iron::Handler`\n\nerror: aborting due to 5 previous errors\n\nerror: Could not compile `iron`.\n```\n\nCan you help?\n. I've updated the commit to use different handlers, chosen by command line argument, defaulting to first one.\n. ",
    "bspeice": "I couldn't find any examples on how to route to things that weren't static functions. This adds the ability to encapsulate other state that can be used in responses\n. OK. It shouldn't be hard to do the same example in both cases, I'll get the pull requests whipped up later today.\n. Closing, as there's already an example of struct-based responses in the routing example.\n. No, the actual [examples/simple_routing.rs](https://github.com/iron/iron/blob/master/examples/simple_routing.rs) uses a struct-based handler. I don't know my PR would qualify as redundant.\nIt's pretty trivial to remove the routing dependency, I can go ahead and clean it up here if you want.\n. I couldn't find any examples on how to route to things that weren't static functions. This adds the ability to encapsulate other state that can be used in responses\n. OK. It shouldn't be hard to do the same example in both cases, I'll get the pull requests whipped up later today.\n. Closing, as there's already an example of struct-based responses in the routing example.\n. No, the actual [examples/simple_routing.rs](https://github.com/iron/iron/blob/master/examples/simple_routing.rs) uses a struct-based handler. I don't know my PR would qualify as redundant.\nIt's pretty trivial to remove the routing dependency, I can go ahead and clean it up here if you want.\n. ",
    "drusellers": "Although this has been closed, this is a huge need. Iron has great support for static functions, but the next step is how do I get my, for lack of a better word, `controller` vibe going on?\n. Although this has been closed, this is a huge need. Iron has great support for static functions, but the next step is how do I get my, for lack of a better word, `controller` vibe going on?\n. ",
    "kocoten1992": "It working again, thank you :+1: \n. It working again, thank you :+1: \n. ",
    "JoshLambda": "**TL;DR:** Project 1 and 4 seem a bit weird in the sense that they don't seem to practically address a user base with real life use cases. Project 2 offers the most features and examples, but is heavily tied to Redis which can be a problem. On my opinion project 3 seems practical and modular, thus the most promising for further evolution.\n\n..........\n\nA subjective view on those 4 projects:\n\n**1** - [Daniel Griffen/iron_session](https://crates.io/crates/iron_session)\n\nPros:\n- expiring sessions with encrypted cookies\n\nCons:\n- abandoned project\n- undocumented\n- no examples\n\n**2** - [hikelee/session](https://crates.io/crates/session)\n\nPros:\n- expiring sessions with encrypted cookies\n- has an example with login/password auth\n\nCons:\n- heavily tied to Redis\n\n**3** - [untitaker/iron-sessionstorage](https://crates.io/crates/iron-sessionstorage)\n\nPros:\n- encrypted cookies\n- multiple possible datastores (so far: client side with cookies, or Redis _[edit: Redis support is wip]_)\n- a basic example\n- some documentation\n\nCons:\n- no expiring sessions\n- some examples missing (login/password auth, Redis)\n\n**4** - [iron/session](https://github.com/iron/session)\n\nPros:\n- iron official repository\n\nCons:\n- no actual web-session features (just an abstract key/value datastore)\n- provided example doesn't make much sense for a webapp\n. OK, I updated my comment.\n. Iron was created with the idea of being a micro-framework with plug-ins (see [Philosophy](https://github.com/iron/iron#philosophy)). It gives the freedom to choose plug-ins independently. As @untitaker said above there isn't to much of a loss of time if they are all referenced on the front page. The drawback I would rather see is that quite often plug-ins tend to get less development than the core. The reason for this discussion about sessions plug-ins is a rather good example.\n. [This example](https://github.com/kaj/nickel-jwt-session/blob/master/examples/server-secure-multiple-routes.rs) for Nickel is really good, it would be great if we had something like that for Iron.\nIt clearly separate public and auth'ed routes in two groups. And for public routes you still get the session values if already logged-in.\n. Well, this file isn't part of the library, it's an example file located in /example. \nThe library itself doesn't do more than your own implementation (a key/value storage with cookies). The whole auth logic is contained in this example file only.\nStill it provides good reusable code, which I think is part of framework value and great for user productivity.\n. That's simply perfect. It will help me and many others with getting started.\nThanks!\n. **TL;DR:** Project 1 and 4 seem a bit weird in the sense that they don't seem to practically address a user base with real life use cases. Project 2 offers the most features and examples, but is heavily tied to Redis which can be a problem. On my opinion project 3 seems practical and modular, thus the most promising for further evolution.\n\n..........\n\nA subjective view on those 4 projects:\n\n**1** - [Daniel Griffen/iron_session](https://crates.io/crates/iron_session)\n\nPros:\n- expiring sessions with encrypted cookies\n\nCons:\n- abandoned project\n- undocumented\n- no examples\n\n**2** - [hikelee/session](https://crates.io/crates/session)\n\nPros:\n- expiring sessions with encrypted cookies\n- has an example with login/password auth\n\nCons:\n- heavily tied to Redis\n\n**3** - [untitaker/iron-sessionstorage](https://crates.io/crates/iron-sessionstorage)\n\nPros:\n- encrypted cookies\n- multiple possible datastores (so far: client side with cookies, or Redis _[edit: Redis support is wip]_)\n- a basic example\n- some documentation\n\nCons:\n- no expiring sessions\n- some examples missing (login/password auth, Redis)\n\n**4** - [iron/session](https://github.com/iron/session)\n\nPros:\n- iron official repository\n\nCons:\n- no actual web-session features (just an abstract key/value datastore)\n- provided example doesn't make much sense for a webapp\n. OK, I updated my comment.\n. Iron was created with the idea of being a micro-framework with plug-ins (see [Philosophy](https://github.com/iron/iron#philosophy)). It gives the freedom to choose plug-ins independently. As @untitaker said above there isn't to much of a loss of time if they are all referenced on the front page. The drawback I would rather see is that quite often plug-ins tend to get less development than the core. The reason for this discussion about sessions plug-ins is a rather good example.\n. [This example](https://github.com/kaj/nickel-jwt-session/blob/master/examples/server-secure-multiple-routes.rs) for Nickel is really good, it would be great if we had something like that for Iron.\nIt clearly separate public and auth'ed routes in two groups. And for public routes you still get the session values if already logged-in.\n. Well, this file isn't part of the library, it's an example file located in /example. \nThe library itself doesn't do more than your own implementation (a key/value storage with cookies). The whole auth logic is contained in this example file only.\nStill it provides good reusable code, which I think is part of framework value and great for user productivity.\n. That's simply perfect. It will help me and many others with getting started.\nThanks!\n. ",
    "hikelee": "Why not put the session middleware in iron crate? i think a web framework should have basic componments such as session,params,routers and so on. it waste developers' time to look around in crates.io for these basic functions.\n. Why not put the session middleware in iron crate? i think a web framework should have basic componments such as session,params,routers and so on. it waste developers' time to look around in crates.io for these basic functions.\n. ",
    "bbigras": "Maybe the sessions link from the README should be removed since it now points to https://github.com/iron-graveyard/session. Maybe the sessions link from the README should be removed since it now points to https://github.com/iron-graveyard/session. ",
    "pocket7878": "@untitaker Thank you for your comment. Ok, I'll take that approach!\n. @untitaker Thank you for your comment. Ok, I'll take that approach!\n. ",
    "icefoxen": "Interestingly, generating your response this way also infinite loops (and uses up all your memory):\n\n```\n    let mut bvec = Vec::new();\n    buffer.read_to_end(&mut bvec).unwrap();\n    let bcurses = io::Cursor::new(bvec);\n    let br = BodyReader(bcurses);\n    Ok(Response::with((status::Ok, br)))\n```\n\nSo it appears that the issue with this might be in Hoedown's `Buffer::read()` function...\n. Yep, it's Hoedown's fault, I've submitted a bug there: https://github.com/blaenk/hoedown/issues/6\n. Interestingly, generating your response this way also infinite loops (and uses up all your memory):\n\n```\n    let mut bvec = Vec::new();\n    buffer.read_to_end(&mut bvec).unwrap();\n    let bcurses = io::Cursor::new(bvec);\n    let br = BodyReader(bcurses);\n    Ok(Response::with((status::Ok, br)))\n```\n\nSo it appears that the issue with this might be in Hoedown's `Buffer::read()` function...\n. Yep, it's Hoedown's fault, I've submitted a bug there: https://github.com/blaenk/hoedown/issues/6\n. ",
    "echochamber": "Its not uncommon for libraries/frameworks to link to other projects that were built using those. Its the only \"real world\" example of a site built with iron I've seen so far.\n. Its not uncommon for libraries/frameworks to link to other projects that were built using those. Its the only \"real world\" example of a site built with iron I've seen so far.\n. ",
    "ernestas-poskus": "If you plan to make middlewares async it might brake expected behavior where authorization or alike middleware must go first.\n. > Maybe we should give a more explicit error from the Http1Transaction::parse().\r\n\r\nsounds good\r\n\r\n> BTW, I think this issue should be moved to hyper : )\r\n\r\ntrue. If you plan to make middlewares async it might brake expected behavior where authorization or alike middleware must go first.\n. > Maybe we should give a more explicit error from the Http1Transaction::parse().\r\n\r\nsounds good\r\n\r\n> BTW, I think this issue should be moved to hyper : )\r\n\r\ntrue. ",
    "hayd": "Hyper's tokio branch is now in master. https://github.com/hyperium/hyper/commit/2d2d5574a698e74e5102d39b9a9ab750860d92d1. Hyper's tokio branch is now in master. https://github.com/hyperium/hyper/commit/2d2d5574a698e74e5102d39b9a9ab750860d92d1. ",
    "MJDSys": "I've started digging into the meat of this issue (Async Iron on Async Hyper, based off of #523).  However, I'm running some lifetime issues.\r\n\r\nBasically, when my ```async_handle``` function returns, I can't have references to either the handler or the request hanging around, as the response isn't constructed until later.  For requests, I've tried stepping around this by moving in a ```Request``` instead of passing a ```&mut Request```, and producing a ```Request``` as part of the output.  I'm not super happy about this though, as it leaks the details of the ```Chain``` into ```async_handle```'s interface.  Also there is now an ugly tuple to return.  The trait is currently:\r\n```rust\r\n/// `AsyncHandler`s are responsible for handling all requests by returning a future that yields the actual response.\r\npub trait AsyncHandler: Send + 'static {\r\n    /// Produce a `Future` that handles the given request that produces an appropriate response or error.\r\n    fn async_handle(&self, Request) -> BoxIronFuture<(Request, Response)>;\r\n}\r\n\r\n// where BoxIronFuture is a helper type defined as:\r\npub type BoxIronFuture<T> = Box<futures::Future<Item=T, Error=IronError>>;\r\n```\r\n\r\nHowever, if anything in ```&self``` is needed, it needs to be cloned into the future.  This is a problem implementing Chain, as the ```Vec```s of middleware are needed to decide how to proceed, but I can't keep a reference to them.  I've currently fixed it by avoiding ```BoxFuture,``` which requires the ```Future``` to be ```Send``` (since we are not currently sending the future across threads, which I'm not sure is a valid assumption?).  I then store a ```Vec<Rc<*Middleware>>``` instead of ```Vec<Box<*Middleware>>```, but I'm not super happy about that.  If I use ```BoxFuture, Vec<Arc<*Middleware>>``` isn't enough, as ```*Middleware``` isn't ```Sync```.  I'm not sure if it's a problem to require ```*Middleware``` to be ```Sync``` though.\r\n\r\nI tried making the ```&self``` in ```async_handle``` ```'static```, but due to Hyper not allowing its handler to be ```'static```, that doesn't work.  So it seems I'm stuck with an ```Rc```.\r\n\r\nI'm thinking the ```Vec<Rc<*>>``` needs to be a ```Rc<Vec<Box<*>>>``` to avoid some ```Box<Future<>>``` in ```Chain```, but that's an optimization with a separate discussion.\r\n\r\nAlso reem/rust-plugin#14 remains a problem.  For now, I've removed the ```Extensible``` implementation and used a ```SendMap``` directly.. @bfrog My current implementation in #527 currently is single threaded, and the AsyncHandler's don't require Sync+Send.  However, the Request does need to be Send due to needing Handler implementations needing to be run on a thread pool, and thus requiring the Request to be sendable across threads (and thus anything you put in the request's extensions needs to be Sendable).\r\n\r\nI don't know if the Iron devs will want to change that.. Yep, that should work fine.  The only problem is that you can't do any long work in the async_handle function, as you block the IO as well.  I'm looking to start using my branch for a project, and I'm looking to use tokio_postgres to talk to my database for that reason.  You might also have to share that one connection across several requests, but at least you don't have to worry about threading :). @untitaker It looks like hyper removed https support from the tokio branch.  If I disable the tls feature for now, is that ok?  I think any other option will take a lot more work + time.  I'll work on that along with the async support.. I pushed a change that makes the body in the Request struct just hold the Stream from Hyper for now.  If Iron wants to wrap that in the future, that can always change.\r\n\r\nThere are two issues remaining before I can get an async Iron working:\r\n  - [x] Hyper removed SSL support, so I'm not sure how we want to handle it.  I think if another library exposes an ssl layer to tokio, it would be easy to wrap Hyper in that.  I'll investigate that later.\r\n  - [ ] My first attempt at an AsyncHandler trait looked like: ```fn async_handle(&self, &mut Request) -> BoxIronFuture<Response>;```.  However, when trying to implement AsyncHandler for Handler, the compiler was not happy about the TypeMap in Response as Response needs to be Send (which TypeMap isn't).  Trying to change the TypeMap to a SendMap then breaks the integration with the plugin crate, and trying to change plugin to be generic over all the different TypeMaps is turning out to be very difficult.  I think a few projects rely on this functionality, so I'll continue to try chasing this down.. I've pushed some commits to bring back https support in Iron.  Due to the way dependency works, I'm not sure having the native-tls-example feature is, as native-tls now a direct dependency through tokio-tls.\r\n\r\nI'm also not sure if the complexity of Iron::https is worth the simplification of Iron::listen.  My initial implementation of listen instead took a stream of futures that returned emitted the Io object.  listen could easily wait on the future without blocking the thread, but it meant the http function need to wrap every TcpStream in a future.  I've posted an initial version here: https://github.com/MJDSys/iron/blob/async2/src/iron.rs#L123 .  If you prefer that version, let me know and I'll update the last commit.. I fixed the typo, and readded the feature gate for ssl.  Let me know if there are any other changes wanted to land this PR.\r\n\r\nIn the mean time, I'll start thinking about async_handler again.. Ping!  I've pushed a new commit to make the branch work against the latest mater branch of Hyper.  Any other work needed before this can be merged?\r\n\r\nI'm working on the proper async handler, but it's blocked currently by issues with the plugin crate, which I'm working on.. @untitaker Yep np. @reem @Hoverbear could you please review this PR?  Any comments/suggestions?. Ping!  I've updated this PR to work against the latest hyper changes.  Is there anything else blocking this merge?. @sfackler Fair enough!  If that is the case, I'll just keep this PR working against latest master, but won't bother pinging until there is a release.  Let me know either way.. @sunng87 @untitaker I can update this PR to the official release probably sometime this weekend.  The only large remaining issue is how to handle SSL.  The current implementation ties us to openssl, but it would be nice to avoid that direct dependency.\r\n\r\nI can take a stab at it again when I do the update, though if anyone has any suggestions I'd be happy to hear them!  Alternately, this could go in with the openssl dependency so people can start experimenting, and we fix it before release.  I'd be happy to help with that effort too.. Ok, this PR is updated against the latest hyper release.  The only remaining problem is ssl.  My problem is that there is no generic tls mechanism for tokio, and tokio doesn't provide a generic way do deal with listeners.\r\n\r\nIron::listen at least allows for someone to construct their own tls handler on top of a TcpListener without having to deal with Hyper.  One improvement may be to return the server future, to avoid taking in the tokio reactor, but I'm not sure if that is useful.  I'm happy to implement any ideas people come up with.\r\n\r\nOne last idea: I could have Iron convert into an IronService (in replacement for RawService) (or have Iron implement NewService somehow), so someone could setup their own instance of hyper, and use Iron on top.  I'm not sure about this though.. Hi all,\r\n\r\nSorry this took a while to come back to.  I was working to understand how tokio-proto worked with hyper (it all makes sense now, but there are some unclear parts from just reading documentation/implemented traits).  Anyways, now the Iron struct directly implements the NewService trait, which makes it trivial to work with hyper/tokio-proto, which can be seen in the http/https methods and the hello_custom_config example.\r\n\r\nThe around example no longer works as expected though, as the server is started as soon as http/https is called, and thus only a single server is started.  If it's ok that the http/https methods start the server and never return, I'll fix the example to configure LoggerMode based on an argument.\r\n\r\nIf wanted I can clean up the git history some to reduce the number of commits, but I figured getting the newest version of the code out was more important.\r\n\r\nAlso, what is the status on #533?  Should that land before this?  As I mentioned, that shouldn't be a problem and I can easily fix up my history to be formatted appropriately after it lands.. @dorfsmay @untitaker I'm happy to do whatever as well.  If you wish to merge #533 first, I can rebase on top of that, maintaining the rustfmt runs.  In fact I suspect there is some git trickery I could do to make that trivial :).\r\n\r\nOr we can merge #523, then redo #533 on top.  Whatever works for the iron project.. I've started digging into the meat of this issue (Async Iron on Async Hyper, based off of #523).  However, I'm running some lifetime issues.\r\n\r\nBasically, when my ```async_handle``` function returns, I can't have references to either the handler or the request hanging around, as the response isn't constructed until later.  For requests, I've tried stepping around this by moving in a ```Request``` instead of passing a ```&mut Request```, and producing a ```Request``` as part of the output.  I'm not super happy about this though, as it leaks the details of the ```Chain``` into ```async_handle```'s interface.  Also there is now an ugly tuple to return.  The trait is currently:\r\n```rust\r\n/// `AsyncHandler`s are responsible for handling all requests by returning a future that yields the actual response.\r\npub trait AsyncHandler: Send + 'static {\r\n    /// Produce a `Future` that handles the given request that produces an appropriate response or error.\r\n    fn async_handle(&self, Request) -> BoxIronFuture<(Request, Response)>;\r\n}\r\n\r\n// where BoxIronFuture is a helper type defined as:\r\npub type BoxIronFuture<T> = Box<futures::Future<Item=T, Error=IronError>>;\r\n```\r\n\r\nHowever, if anything in ```&self``` is needed, it needs to be cloned into the future.  This is a problem implementing Chain, as the ```Vec```s of middleware are needed to decide how to proceed, but I can't keep a reference to them.  I've currently fixed it by avoiding ```BoxFuture,``` which requires the ```Future``` to be ```Send``` (since we are not currently sending the future across threads, which I'm not sure is a valid assumption?).  I then store a ```Vec<Rc<*Middleware>>``` instead of ```Vec<Box<*Middleware>>```, but I'm not super happy about that.  If I use ```BoxFuture, Vec<Arc<*Middleware>>``` isn't enough, as ```*Middleware``` isn't ```Sync```.  I'm not sure if it's a problem to require ```*Middleware``` to be ```Sync``` though.\r\n\r\nI tried making the ```&self``` in ```async_handle``` ```'static```, but due to Hyper not allowing its handler to be ```'static```, that doesn't work.  So it seems I'm stuck with an ```Rc```.\r\n\r\nI'm thinking the ```Vec<Rc<*>>``` needs to be a ```Rc<Vec<Box<*>>>``` to avoid some ```Box<Future<>>``` in ```Chain```, but that's an optimization with a separate discussion.\r\n\r\nAlso reem/rust-plugin#14 remains a problem.  For now, I've removed the ```Extensible``` implementation and used a ```SendMap``` directly.. @bfrog My current implementation in #527 currently is single threaded, and the AsyncHandler's don't require Sync+Send.  However, the Request does need to be Send due to needing Handler implementations needing to be run on a thread pool, and thus requiring the Request to be sendable across threads (and thus anything you put in the request's extensions needs to be Sendable).\r\n\r\nI don't know if the Iron devs will want to change that.. Yep, that should work fine.  The only problem is that you can't do any long work in the async_handle function, as you block the IO as well.  I'm looking to start using my branch for a project, and I'm looking to use tokio_postgres to talk to my database for that reason.  You might also have to share that one connection across several requests, but at least you don't have to worry about threading :). @untitaker It looks like hyper removed https support from the tokio branch.  If I disable the tls feature for now, is that ok?  I think any other option will take a lot more work + time.  I'll work on that along with the async support.. I pushed a change that makes the body in the Request struct just hold the Stream from Hyper for now.  If Iron wants to wrap that in the future, that can always change.\r\n\r\nThere are two issues remaining before I can get an async Iron working:\r\n  - [x] Hyper removed SSL support, so I'm not sure how we want to handle it.  I think if another library exposes an ssl layer to tokio, it would be easy to wrap Hyper in that.  I'll investigate that later.\r\n  - [ ] My first attempt at an AsyncHandler trait looked like: ```fn async_handle(&self, &mut Request) -> BoxIronFuture<Response>;```.  However, when trying to implement AsyncHandler for Handler, the compiler was not happy about the TypeMap in Response as Response needs to be Send (which TypeMap isn't).  Trying to change the TypeMap to a SendMap then breaks the integration with the plugin crate, and trying to change plugin to be generic over all the different TypeMaps is turning out to be very difficult.  I think a few projects rely on this functionality, so I'll continue to try chasing this down.. I've pushed some commits to bring back https support in Iron.  Due to the way dependency works, I'm not sure having the native-tls-example feature is, as native-tls now a direct dependency through tokio-tls.\r\n\r\nI'm also not sure if the complexity of Iron::https is worth the simplification of Iron::listen.  My initial implementation of listen instead took a stream of futures that returned emitted the Io object.  listen could easily wait on the future without blocking the thread, but it meant the http function need to wrap every TcpStream in a future.  I've posted an initial version here: https://github.com/MJDSys/iron/blob/async2/src/iron.rs#L123 .  If you prefer that version, let me know and I'll update the last commit.. I fixed the typo, and readded the feature gate for ssl.  Let me know if there are any other changes wanted to land this PR.\r\n\r\nIn the mean time, I'll start thinking about async_handler again.. Ping!  I've pushed a new commit to make the branch work against the latest mater branch of Hyper.  Any other work needed before this can be merged?\r\n\r\nI'm working on the proper async handler, but it's blocked currently by issues with the plugin crate, which I'm working on.. @untitaker Yep np. @reem @Hoverbear could you please review this PR?  Any comments/suggestions?. Ping!  I've updated this PR to work against the latest hyper changes.  Is there anything else blocking this merge?. @sfackler Fair enough!  If that is the case, I'll just keep this PR working against latest master, but won't bother pinging until there is a release.  Let me know either way.. @sunng87 @untitaker I can update this PR to the official release probably sometime this weekend.  The only large remaining issue is how to handle SSL.  The current implementation ties us to openssl, but it would be nice to avoid that direct dependency.\r\n\r\nI can take a stab at it again when I do the update, though if anyone has any suggestions I'd be happy to hear them!  Alternately, this could go in with the openssl dependency so people can start experimenting, and we fix it before release.  I'd be happy to help with that effort too.. Ok, this PR is updated against the latest hyper release.  The only remaining problem is ssl.  My problem is that there is no generic tls mechanism for tokio, and tokio doesn't provide a generic way do deal with listeners.\r\n\r\nIron::listen at least allows for someone to construct their own tls handler on top of a TcpListener without having to deal with Hyper.  One improvement may be to return the server future, to avoid taking in the tokio reactor, but I'm not sure if that is useful.  I'm happy to implement any ideas people come up with.\r\n\r\nOne last idea: I could have Iron convert into an IronService (in replacement for RawService) (or have Iron implement NewService somehow), so someone could setup their own instance of hyper, and use Iron on top.  I'm not sure about this though.. Hi all,\r\n\r\nSorry this took a while to come back to.  I was working to understand how tokio-proto worked with hyper (it all makes sense now, but there are some unclear parts from just reading documentation/implemented traits).  Anyways, now the Iron struct directly implements the NewService trait, which makes it trivial to work with hyper/tokio-proto, which can be seen in the http/https methods and the hello_custom_config example.\r\n\r\nThe around example no longer works as expected though, as the server is started as soon as http/https is called, and thus only a single server is started.  If it's ok that the http/https methods start the server and never return, I'll fix the example to configure LoggerMode based on an argument.\r\n\r\nIf wanted I can clean up the git history some to reduce the number of commits, but I figured getting the newest version of the code out was more important.\r\n\r\nAlso, what is the status on #533?  Should that land before this?  As I mentioned, that shouldn't be a problem and I can easily fix up my history to be formatted appropriately after it lands.. @dorfsmay @untitaker I'm happy to do whatever as well.  If you wish to merge #533 first, I can rebase on top of that, maintaining the rustfmt runs.  In fact I suspect there is some git trickery I could do to make that trivial :).\r\n\r\nOr we can merge #523, then redo #533 on top.  Whatever works for the iron project.. ",
    "Diggsey": "The current behaviour WRT `Chain::link` seems like a bug or at the very least a footgun - there's no situation where you want to interleave before/after middleware like that, such that you run `A_before, B_before, A_after, B_after`.\r\n\r\nIMO, `link_after`, `link_before` and `link` should follow how `link_around` works - that is, `link_before` should be reversed, such that later items run before everything already linked. Now you can just make sure that use use `link(logger)` as your last modification.. The current behaviour WRT `Chain::link` seems like a bug or at the very least a footgun - there's no situation where you want to interleave before/after middleware like that, such that you run `A_before, B_before, A_after, B_after`.\r\n\r\nIMO, `link_after`, `link_before` and `link` should follow how `link_around` works - that is, `link_before` should be reversed, such that later items run before everything already linked. Now you can just make sure that use use `link(logger)` as your last modification.. ",
    "zoumi": "http://ironframework.io/doc/iron/headers/struct.Cookie.html\r\niron::headers::Cookie should be Cookie(pub Vec<Cookie>) in hyper\r\nnot Cookie{...} in crate cookie\r\n\r\nWhat is the status of this crate?. http://ironframework.io/doc/iron/headers/struct.Cookie.html\r\niron::headers::Cookie should be Cookie(pub Vec<Cookie>) in hyper\r\nnot Cookie{...} in crate cookie\r\n\r\nWhat is the status of this crate?. ",
    "lilith": "I also wonder why `SO_REUSEADDR` isn't working (apparently)\r\n```\r\n\r\n    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> {\r\n        init();\r\n\r\n        let sock = Socket::new(addr, c::SOCK_STREAM)?;\r\n\r\n        // On platforms with Berkeley-derived sockets, this allows\r\n        // to quickly rebind a socket, without needing to wait for\r\n        // the OS to clean up the previous one.\r\n        if !cfg!(windows) {\r\n            setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR,\r\n                       1 as c_int)?;\r\n        }\r\n\r\n        // Bind our new socket\r\n        let (addrp, len) = addr.into_inner();\r\n        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) })?;\r\n\r\n        // Start listening\r\n        cvt(unsafe { c::listen(*sock.as_inner(), 128) })?;\r\n        Ok(TcpListener { inner: sock })\r\n    }\r\n```. I also wonder why `SO_REUSEADDR` isn't working (apparently)\r\n```\r\n\r\n    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> {\r\n        init();\r\n\r\n        let sock = Socket::new(addr, c::SOCK_STREAM)?;\r\n\r\n        // On platforms with Berkeley-derived sockets, this allows\r\n        // to quickly rebind a socket, without needing to wait for\r\n        // the OS to clean up the previous one.\r\n        if !cfg!(windows) {\r\n            setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR,\r\n                       1 as c_int)?;\r\n        }\r\n\r\n        // Bind our new socket\r\n        let (addrp, len) = addr.into_inner();\r\n        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) })?;\r\n\r\n        // Start listening\r\n        cvt(unsafe { c::listen(*sock.as_inner(), 128) })?;\r\n        Ok(TcpListener { inner: sock })\r\n    }\r\n```. ",
    "dsboo": "#311.  @untitaker thanks for your review, i change that, please review again.. #311.  @untitaker thanks for your review, i change that, please review again.. ",
    "Boscop": "Thanks!. No, I'm listening on 0.0.0.0:3000. In my `.env`:\r\n```ini\r\nFULL_URL=http://192.168.178.35:3000\r\nLISTEN_AT=0.0.0.0:3000\r\n```\r\nThe FULL_URL is so that redirects work on the phone..\r\nAFAIK it wouldn't even be possible to access the server from the phone if it listened at 127.0.0.1. No, I had that problem before, but then I allowed the exe on both private and public networks.\r\nBefore that I got `ERR_CONNECTION_TIMED_OUT` on the phone (refused to connect), after that I got the content, but in some cases it fails and only loads the site to ~75% before this error happens. Then I refresh and it succeeds. I definitely think it's not a firewall issue.. This project can't be served with a simple file server because it's using maud to render the html and needs db access etc. \r\nBut I tested another project (the Polymer starter kit) with `python -m SimpleHTTPServer` (I don't have Python 3 installed.) and when I access it from my phone through the wifi router, I noticed it loads very slowly, although it still finishes getting the whole page in the end.\r\nMaybe there is a cutoff point, if it would have taken slightly longer, I would see the same result as with iron?\r\nBut why would it take so long to load it via LAN, the wifi router is a modern Fritzbox router.\r\n. Nevermind, I found out it panics when the file doesn't exist, so I'm doing this now:\r\n```rust\r\n\tif path.exists() {\r\n\t\tOk(Response::with((status::Ok, path)))\r\n\t} else {\r\n\t\tOk(Response::with(status::NotFound))\r\n\t}\r\n```. Thanks!. No, I'm listening on 0.0.0.0:3000. In my `.env`:\r\n```ini\r\nFULL_URL=http://192.168.178.35:3000\r\nLISTEN_AT=0.0.0.0:3000\r\n```\r\nThe FULL_URL is so that redirects work on the phone..\r\nAFAIK it wouldn't even be possible to access the server from the phone if it listened at 127.0.0.1. No, I had that problem before, but then I allowed the exe on both private and public networks.\r\nBefore that I got `ERR_CONNECTION_TIMED_OUT` on the phone (refused to connect), after that I got the content, but in some cases it fails and only loads the site to ~75% before this error happens. Then I refresh and it succeeds. I definitely think it's not a firewall issue.. This project can't be served with a simple file server because it's using maud to render the html and needs db access etc. \r\nBut I tested another project (the Polymer starter kit) with `python -m SimpleHTTPServer` (I don't have Python 3 installed.) and when I access it from my phone through the wifi router, I noticed it loads very slowly, although it still finishes getting the whole page in the end.\r\nMaybe there is a cutoff point, if it would have taken slightly longer, I would see the same result as with iron?\r\nBut why would it take so long to load it via LAN, the wifi router is a modern Fritzbox router.\r\n. Nevermind, I found out it panics when the file doesn't exist, so I'm doing this now:\r\n```rust\r\n\tif path.exists() {\r\n\t\tOk(Response::with((status::Ok, path)))\r\n\t} else {\r\n\t\tOk(Response::with(status::NotFound))\r\n\t}\r\n```. ",
    "robinst": "It's one of the places where I looked for it. We can also put it in more than one place, that's not a bad thing for documentation. Where would you want to put it instead?. Sorry for keeping this open. I'll look into adding another example.. This should probably use the RFC style using `rustfmt-nightly` instead. But that's not ready yet (it's still changing quite a bit): https://github.com/rust-lang-nursery/rustfmt#rustfmt--. Agreed! I wonder if there's a nice way to make them more visible from the docs here: https://docs.rs/iron/0.5.1/iron/\r\n\r\n(I didn't know about the examples before, and the docs itself are really minimal.). @SkylerLipthay It looks like you introduced this feature, mind having a look? Would be appreciated!. Thanks!. Oh, I was looking for when the last release was and noticed that there's a `0.5-maintenance` branch. Should I have made the PR against that branch for it to be included in the next 0.5 release?. Ok, thanks. Maybe @untitaker or @Hoverbear: It would be cool to get a 0.6.0 release with the changes in master since 0.5.1: https://github.com/iron/iron/compare/0.5.1...master :tada:\r\n\r\n(Seems like iron using async hyper is still some time away, so it's probably worth having some more releases before that.). I opened a new issue about getting a release out.. Yes please, it's one of the most confusing parts of Iron IMO. (Disclaimer: I'm not a maintainer.). @reem @untitaker ?. See here for why this is being held up (problems with permissions on crates.io): https://github.com/iron/urlencoded/issues/68. @untitaker thank you! Here's a pull request for router: https://github.com/iron/router/pull/141. Thanks @shepmaster, added to the list. And staticfile depends on iron-test... I think this would fix #528, right?. It's one of the places where I looked for it. We can also put it in more than one place, that's not a bad thing for documentation. Where would you want to put it instead?. Sorry for keeping this open. I'll look into adding another example.. This should probably use the RFC style using `rustfmt-nightly` instead. But that's not ready yet (it's still changing quite a bit): https://github.com/rust-lang-nursery/rustfmt#rustfmt--. Agreed! I wonder if there's a nice way to make them more visible from the docs here: https://docs.rs/iron/0.5.1/iron/\r\n\r\n(I didn't know about the examples before, and the docs itself are really minimal.). @SkylerLipthay It looks like you introduced this feature, mind having a look? Would be appreciated!. Thanks!. Oh, I was looking for when the last release was and noticed that there's a `0.5-maintenance` branch. Should I have made the PR against that branch for it to be included in the next 0.5 release?. Ok, thanks. Maybe @untitaker or @Hoverbear: It would be cool to get a 0.6.0 release with the changes in master since 0.5.1: https://github.com/iron/iron/compare/0.5.1...master :tada:\r\n\r\n(Seems like iron using async hyper is still some time away, so it's probably worth having some more releases before that.). I opened a new issue about getting a release out.. Yes please, it's one of the most confusing parts of Iron IMO. (Disclaimer: I'm not a maintainer.). @reem @untitaker ?. See here for why this is being held up (problems with permissions on crates.io): https://github.com/iron/urlencoded/issues/68. @untitaker thank you! Here's a pull request for router: https://github.com/iron/router/pull/141. Thanks @shepmaster, added to the list. And staticfile depends on iron-test... I think this would fix #528, right?. ",
    "nicoburns": "> I just realized that it may make sense to not even bother with ServerProto. Iron could be a collection of Services. In which case, combining with hyper, it'd look like Http::new().bind(addr, Iron::new(middlewares)). And still with an Iron::listen easy mode if you prefer.\r\n\r\nThis would mirror how ExpressJS works: https://expressjs.com/en/4x/api.html#app.listen. > I just realized that it may make sense to not even bother with ServerProto. Iron could be a collection of Services. In which case, combining with hyper, it'd look like Http::new().bind(addr, Iron::new(middlewares)). And still with an Iron::listen easy mode if you prefer.\r\n\r\nThis would mirror how ExpressJS works: https://expressjs.com/en/4x/api.html#app.listen. ",
    "Thomspoon": "Wondering what the progress on this is? I'd love to help where I can.. Wondering what the progress on this is? I'd love to help where I can.. ",
    "RobertWHurst": "Is there any update here? My company is building a payments processor using Iron and we will need async for performance reasons.. Is there any update here? My company is building a payments processor using Iron and we will need async for performance reasons.. ",
    "xliiv": "Solution for my own question:\r\nhttps://github.com/iron/iron-test/blob/master/src/request.rs#L57. Solution for my own question:\r\nhttps://github.com/iron/iron-test/blob/master/src/request.rs#L57. ",
    "dorfsmay": "@Hoverbear When I looked at adding tests, I realised they'd all be exactly the same as for Url parse().\r\n\r\nI guess we could add one simple positive + one simple negative test to ensure the code is not broken, then rely on parse() for the rest? Let me know what you think.. @Hoverbear Would make sense to cancel this PR (there really was no worked involved), put a moratorium on big PRs until the current ones are being merged, and start this initiative again after that?\r\n\r\nEdit:\r\nThinking more about this.... Alternatively, you could ask the author of #523 to run `cargo fmt` on their branch and commit/push it, and the merge would then become exactly the same as before. Any way we cut it, it'll require coordination, but I do believe it's worth it in the long term.. Why not starting an area now? Even if it's not pretty, it'll encourage people to add to it as they learn. In fact not being pretty might irk somebody enough to improve it!\r\n\r\n. Another issue with linking to blogs etc... is time rot. As Iron is getting changed, external blogs won't be updated, while internal docs have both more chances to be updated and getting complaints about (and being updated as a consequence).. I'd go one step further, let's pic a popular markup in order not to be coupled with a tool.\r\n\r\nAny suggestions?. What I meant was to be careful not getting into specialized markup that comes, and can only be rendered, with a specific tool. Any suggestion for a tool?. https://docs.rs/iron/0.5.1/iron-sessionstorage redirects to https://docs.rs/iron/0.5.1/iron/\r\n\r\nNo mention of session nor cookies anywhere in that page.. I cloned the iron-session repo, \"cargo doc\" and went through it's documentation.\r\n\r\nThere is no easy was to get the value of a cookie outside of a session. Cookies are used for a lot of things outside session, turning feature flags on, routing in blue/green environment, etc...\r\n\r\nAlso, cookies are just a form of sepcialised header. As far as I am concerned, iron/headers is missing the concept of cookies. It deals with the http header/concept of \"Set-Cookie\" with https://docs.rs/iron/0.5.1/iron/headers/struct.SetCookie.html but does not deal at all with http header/concept of \"Cookie\", even though it is one of the most used header on the internet!\r\n\r\nCan we add that concept directly into iron/headers? Are there any strong objections to it (don't want to waste time on a PR that'll be rejected on philosophical ground)?. Thanks for the link to iron-sessionstorage doc. No bad link, I had gone to iron docs, and replaced the name, so my own fault.\r\n\r\n`Iron has structs for Cookie and Set-Cookie`\r\n\r\nI must be missing something. I hate to ask for things I should be able to find myself, but can you point me to Iron's struct for \"cookie\"?\r\n\r\nI cannot find it in the doc. I did a fetch/pull on iron and \"ag -i cookie\" is not return anything.. @Hoverbear When I looked at adding tests, I realised they'd all be exactly the same as for Url parse().\r\n\r\nI guess we could add one simple positive + one simple negative test to ensure the code is not broken, then rely on parse() for the rest? Let me know what you think.. @Hoverbear Would make sense to cancel this PR (there really was no worked involved), put a moratorium on big PRs until the current ones are being merged, and start this initiative again after that?\r\n\r\nEdit:\r\nThinking more about this.... Alternatively, you could ask the author of #523 to run `cargo fmt` on their branch and commit/push it, and the merge would then become exactly the same as before. Any way we cut it, it'll require coordination, but I do believe it's worth it in the long term.. Why not starting an area now? Even if it's not pretty, it'll encourage people to add to it as they learn. In fact not being pretty might irk somebody enough to improve it!\r\n\r\n. Another issue with linking to blogs etc... is time rot. As Iron is getting changed, external blogs won't be updated, while internal docs have both more chances to be updated and getting complaints about (and being updated as a consequence).. I'd go one step further, let's pic a popular markup in order not to be coupled with a tool.\r\n\r\nAny suggestions?. What I meant was to be careful not getting into specialized markup that comes, and can only be rendered, with a specific tool. Any suggestion for a tool?. https://docs.rs/iron/0.5.1/iron-sessionstorage redirects to https://docs.rs/iron/0.5.1/iron/\r\n\r\nNo mention of session nor cookies anywhere in that page.. I cloned the iron-session repo, \"cargo doc\" and went through it's documentation.\r\n\r\nThere is no easy was to get the value of a cookie outside of a session. Cookies are used for a lot of things outside session, turning feature flags on, routing in blue/green environment, etc...\r\n\r\nAlso, cookies are just a form of sepcialised header. As far as I am concerned, iron/headers is missing the concept of cookies. It deals with the http header/concept of \"Set-Cookie\" with https://docs.rs/iron/0.5.1/iron/headers/struct.SetCookie.html but does not deal at all with http header/concept of \"Cookie\", even though it is one of the most used header on the internet!\r\n\r\nCan we add that concept directly into iron/headers? Are there any strong objections to it (don't want to waste time on a PR that'll be rejected on philosophical ground)?. Thanks for the link to iron-sessionstorage doc. No bad link, I had gone to iron docs, and replaced the name, so my own fault.\r\n\r\n`Iron has structs for Cookie and Set-Cookie`\r\n\r\nI must be missing something. I hate to ask for things I should be able to find myself, but can you point me to Iron's struct for \"cookie\"?\r\n\r\nI cannot find it in the doc. I did a fetch/pull on iron and \"ag -i cookie\" is not return anything.. ",
    "Eilie": "@untitaker https://github.com/iron/iron/blob/master/examples/hello.rs. @untitaker Alright, I was using old binary(building with `--release` manually) so hello.rs works fine indeed. I'm sorry. The code that triggers such response is following:\r\n```\r\nextern crate iron;\r\n#[macro_use]\r\nextern crate router;\r\n\r\nuse iron::prelude::*;\r\nuse iron::status;\r\nuse router::Router;\r\n\r\nfn hello_controller(req: &mut Request) -> IronResult<Response> {\r\n    let ref query = req.extensions.get::<Router>().unwrap().find(\"name\").unwrap();\r\n    Ok(Response::with((status::Ok, *query)))\r\n}\r\n\r\nfn main() {\r\n    let router = router!(\r\n        hello: get \"/hello/:name\" => hello_controller\r\n    );\r\n\r\n    Iron::new(router).http(\"127.0.0.1:3000\").unwrap();\r\n}\r\n```\r\n\r\nBuilding it with `--release` and wrk command is `wrk --latency -t12 -c100 -d10s http://127.0.0.1:3000/name/foo`. @sfackler @untitaker Ohhh.. Feeling retarded, sorry about that. That explains everyhting, thank you guys a lot!  . I've tried to follow example from https://github.com/iron/logger to setup simple logger but also failed because I'm using iron router instead of Chain thing.. @untitaker https://github.com/iron/iron/blob/master/examples/hello.rs. @untitaker Alright, I was using old binary(building with `--release` manually) so hello.rs works fine indeed. I'm sorry. The code that triggers such response is following:\r\n```\r\nextern crate iron;\r\n#[macro_use]\r\nextern crate router;\r\n\r\nuse iron::prelude::*;\r\nuse iron::status;\r\nuse router::Router;\r\n\r\nfn hello_controller(req: &mut Request) -> IronResult<Response> {\r\n    let ref query = req.extensions.get::<Router>().unwrap().find(\"name\").unwrap();\r\n    Ok(Response::with((status::Ok, *query)))\r\n}\r\n\r\nfn main() {\r\n    let router = router!(\r\n        hello: get \"/hello/:name\" => hello_controller\r\n    );\r\n\r\n    Iron::new(router).http(\"127.0.0.1:3000\").unwrap();\r\n}\r\n```\r\n\r\nBuilding it with `--release` and wrk command is `wrk --latency -t12 -c100 -d10s http://127.0.0.1:3000/name/foo`. @sfackler @untitaker Ohhh.. Feeling retarded, sorry about that. That explains everyhting, thank you guys a lot!  . I've tried to follow example from https://github.com/iron/logger to setup simple logger but also failed because I'm using iron router instead of Chain thing.. ",
    "Technius": "Is there an issue tracking a list of things to be documented? I'd like to contribute, but I'm not quite sure where to begin.. Is there an issue tracking a list of things to be documented? I'd like to contribute, but I'm not quite sure where to begin.. ",
    "DavidBM": "I'm using this in my code:\r\n\r\n``` rust\r\nuse slog::*;\r\n\r\nuse iron::{typemap, BeforeMiddleware};\r\nuse iron::prelude::*;\r\n\r\n\r\npub struct LoggerMiddleware {\r\n\tpub logger: Logger\r\n}\r\n\r\nimpl LoggerMiddleware {\r\n\tpub fn new (logger: &Logger) -> LoggerMiddleware{\r\n\t\tLoggerMiddleware {logger: logger.new(o!(\"module\" => \"LoggerMiddleware\"))}\r\n\t}\r\n}\r\n\r\npub struct Value(Logger);\r\n\r\nimpl typemap::Key for LoggerMiddleware { type Value = Value; }\r\n\r\nimpl BeforeMiddleware for LoggerMiddleware {\r\n\tfn before(&self, req: &mut Request) -> IronResult<()> {\r\n\t\tlet logger = self.logger.new(o!(\"route\" => format!(\"{}\", req.url)));\r\n\t\treq.extensions.insert::<LoggerMiddleware>(Value(logger));\r\n\t\tOk(())\r\n\t}\r\n}\r\n\r\npub trait LoggerReqExt {\r\n\tfn get_logger(&self) -> Logger;\r\n}\r\n\r\nimpl <'a, 'b>LoggerReqExt for Request <'a, 'b> {\r\n\tfn get_logger(&self) -> Logger {\r\n\t\tlet &Value(ref logger) = self.extensions.get::<LoggerMiddleware>().unwrap();\r\n\r\n\t\tlogger.clone()\r\n\t}\r\n}\r\n```\r\n\r\nand then in your function, \r\n```rust\r\nlet logger = req.get_logger();\r\n```. I'm using this in my code:\r\n\r\n``` rust\r\nuse slog::*;\r\n\r\nuse iron::{typemap, BeforeMiddleware};\r\nuse iron::prelude::*;\r\n\r\n\r\npub struct LoggerMiddleware {\r\n\tpub logger: Logger\r\n}\r\n\r\nimpl LoggerMiddleware {\r\n\tpub fn new (logger: &Logger) -> LoggerMiddleware{\r\n\t\tLoggerMiddleware {logger: logger.new(o!(\"module\" => \"LoggerMiddleware\"))}\r\n\t}\r\n}\r\n\r\npub struct Value(Logger);\r\n\r\nimpl typemap::Key for LoggerMiddleware { type Value = Value; }\r\n\r\nimpl BeforeMiddleware for LoggerMiddleware {\r\n\tfn before(&self, req: &mut Request) -> IronResult<()> {\r\n\t\tlet logger = self.logger.new(o!(\"route\" => format!(\"{}\", req.url)));\r\n\t\treq.extensions.insert::<LoggerMiddleware>(Value(logger));\r\n\t\tOk(())\r\n\t}\r\n}\r\n\r\npub trait LoggerReqExt {\r\n\tfn get_logger(&self) -> Logger;\r\n}\r\n\r\nimpl <'a, 'b>LoggerReqExt for Request <'a, 'b> {\r\n\tfn get_logger(&self) -> Logger {\r\n\t\tlet &Value(ref logger) = self.extensions.get::<LoggerMiddleware>().unwrap();\r\n\r\n\t\tlogger.clone()\r\n\t}\r\n}\r\n```\r\n\r\nand then in your function, \r\n```rust\r\nlet logger = req.get_logger();\r\n```. ",
    "quadrupleslap": "Sorry, I was trying to ask if UniCase was only being used in comparisons, and so didn't need to be exposed by the external API. This is very slightly annoying because it means you sometimes have to add a `unicase` dependency to `Cargo.toml` just to add a single header.. Sorry, I was trying to ask if UniCase was only being used in comparisons, and so didn't need to be exposed by the external API. This is very slightly annoying because it means you sometimes have to add a `unicase` dependency to `Cargo.toml` just to add a single header.. ",
    "sanpii": "For information, iron requires unicase 1.4 (not 2.0).. For information, iron requires unicase 1.4 (not 2.0).. ",
    "yinpeng": "A reverse proxy like nginx server may help you.. A reverse proxy like nginx server may help you.. ",
    "dessalines": "No reason to use nginx if Iron is already a webserver. Every webserver should have ssl support. . Not really. You can use linux routing tables to redirect incoming traffic to your application's web server port, so adding an extra layer is entirely unnecessary. . No reason to use nginx if Iron is already a webserver. Every webserver should have ssl support. . Not really. You can use linux routing tables to redirect incoming traffic to your application's web server port, so adding an extra layer is entirely unnecessary. . ",
    "piedoom": "Pardon if I'm wrong, but in production wouldn't you almost always want to use an nginx reverse proxy to the application?  . Pardon if I'm wrong, but in production wouldn't you almost always want to use an nginx reverse proxy to the application?  . ",
    "TheWaWaR": "Wow, thanks! Seems a great solution. I'll test it soon!. Solved, thanks again!. Wow, thanks! Seems a great solution. I'll test it soon!. Solved, thanks again!. ",
    "CodingPower472": "What's happening with this pull request. What's happening with this pull request. ",
    "selaux": "Thanks, that was what I was looking for. Sorry for not searching properly first \ud83d\ude09 .. Thanks, that was what I was looking for. Sorry for not searching properly first \ud83d\ude09 .. ",
    "vishalcjha": "Used Rocket framework to do same and it is giving same error. Looks like problem is either with serde-json or hyper as both use them. . Used Rocket framework to do same and it is giving same error. Looks like problem is either with serde-json or hyper as both use them. . ",
    "plumenator": "I ran the code snippet below (combined your code with the official example) and benchmarked by running `curl localhost:3000/?[1-10]` and averaging the printed response times.\r\n\r\nThen I put them in a Google [spreadsheet](https://docs.google.com/spreadsheets/d/1xDFgSZ3ULwwcJehR-AEVu9Dh9-VNGJAe2l1aWiAQ5rM/edit?usp=sharing)  and calculated the percentage change in the average response time. For ten successive runs, it only increased by about 3.54%.\r\n\r\nIt would be helpful if you could provide some details about your benchmark. Did you use GET or POST? What was the size of the payload?\r\n\r\n```rust\r\nextern crate iron;\r\nextern crate time;\r\n\r\nuse iron::prelude::*;\r\nuse iron::{BeforeMiddleware, AfterMiddleware, typemap};\r\nuse time::precise_time_ns;\r\nuse std::io::Read;\r\n\r\nstruct ResponseTime;\r\n\r\nimpl typemap::Key for ResponseTime { type Value = u64; }\r\n\r\nimpl BeforeMiddleware for ResponseTime {\r\n    fn before(&self, req: &mut Request) -> IronResult<()> {\r\n        req.extensions.insert::<ResponseTime>(precise_time_ns());\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl AfterMiddleware for ResponseTime {\r\n    fn after(&self, req: &mut Request, res: Response) -> IronResult<Response> {\r\n        let delta = precise_time_ns() - *req.extensions.get::<ResponseTime>().unwrap();\r\n        println!(\"Request took: {} ms\", (delta as f64) / 1000000.0);\r\n        Ok(res)\r\n    }\r\n}\r\n\r\nfn hello_world(req: &mut Request) -> IronResult<Response> {\r\n    // let mut body = String::new();\r\n    let mut bytes = Vec::new();\r\n    // let mut lbytes = vec![0;100];\r\n\r\n    // NOTICE: I checked, those reads are successful and return the correct value.\r\n    req.body.read_to_end(&mut bytes).unwrap();\r\n    // Or\r\n    // req.body.read(&mut lbytes).unwrap();\r\n    // Or\r\n    // req.body.read_to_string(&mut body).unwrap();\r\n\r\n    Ok(Response::with((iron::status::Ok, \"Hello World!\")))\r\n}\r\n\r\nfn main() {\r\n    let mut chain = Chain::new(hello_world);\r\n    chain.link_before(ResponseTime);\r\n    chain.link_after(ResponseTime);\r\n    Iron::new(chain).http(\"localhost:3000\").unwrap();\r\n}\r\n```. Good to know!. I ran the code snippet below (combined your code with the official example) and benchmarked by running `curl localhost:3000/?[1-10]` and averaging the printed response times.\r\n\r\nThen I put them in a Google [spreadsheet](https://docs.google.com/spreadsheets/d/1xDFgSZ3ULwwcJehR-AEVu9Dh9-VNGJAe2l1aWiAQ5rM/edit?usp=sharing)  and calculated the percentage change in the average response time. For ten successive runs, it only increased by about 3.54%.\r\n\r\nIt would be helpful if you could provide some details about your benchmark. Did you use GET or POST? What was the size of the payload?\r\n\r\n```rust\r\nextern crate iron;\r\nextern crate time;\r\n\r\nuse iron::prelude::*;\r\nuse iron::{BeforeMiddleware, AfterMiddleware, typemap};\r\nuse time::precise_time_ns;\r\nuse std::io::Read;\r\n\r\nstruct ResponseTime;\r\n\r\nimpl typemap::Key for ResponseTime { type Value = u64; }\r\n\r\nimpl BeforeMiddleware for ResponseTime {\r\n    fn before(&self, req: &mut Request) -> IronResult<()> {\r\n        req.extensions.insert::<ResponseTime>(precise_time_ns());\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl AfterMiddleware for ResponseTime {\r\n    fn after(&self, req: &mut Request, res: Response) -> IronResult<Response> {\r\n        let delta = precise_time_ns() - *req.extensions.get::<ResponseTime>().unwrap();\r\n        println!(\"Request took: {} ms\", (delta as f64) / 1000000.0);\r\n        Ok(res)\r\n    }\r\n}\r\n\r\nfn hello_world(req: &mut Request) -> IronResult<Response> {\r\n    // let mut body = String::new();\r\n    let mut bytes = Vec::new();\r\n    // let mut lbytes = vec![0;100];\r\n\r\n    // NOTICE: I checked, those reads are successful and return the correct value.\r\n    req.body.read_to_end(&mut bytes).unwrap();\r\n    // Or\r\n    // req.body.read(&mut lbytes).unwrap();\r\n    // Or\r\n    // req.body.read_to_string(&mut body).unwrap();\r\n\r\n    Ok(Response::with((iron::status::Ok, \"Hello World!\")))\r\n}\r\n\r\nfn main() {\r\n    let mut chain = Chain::new(hello_world);\r\n    chain.link_before(ResponseTime);\r\n    chain.link_after(ResponseTime);\r\n    Iron::new(chain).http(\"localhost:3000\").unwrap();\r\n}\r\n```. Good to know!. ",
    "daniel-Q6wUOI": "@plumenator I did a POST request with a normal user login, about 40bytes. I haven't been working in rust for a while, so yeah. For more research I need some time.. @plumenator I tested your code, and it works now. I really have no idea what I did wrong, cause it works with the same code now. Reached ~320k requests per second again. Thanks.. @plumenator I did a POST request with a normal user login, about 40bytes. I haven't been working in rust for a while, so yeah. For more research I need some time.. @plumenator I tested your code, and it works now. I really have no idea what I did wrong, cause it works with the same code now. Reached ~320k requests per second again. Thanks.. ",
    "mrenoon": "It seems that this is due to the `hyper` version being used in `iron` is 0.10 which does not support Warning header yet. However, when you are dealing with a `headers: &mut Headers` , you can get/set the raw Warning headers like so:\r\n```\r\nlet warnings = match headers.get_raw(\"Warning\") {\r\n        Some(warning) => std::str::from_utf8(&warning[0]).unwrap(),\r\n        None => \"No warning.\",\r\n};\r\n```\r\n```\r\nheaders.set_raw(\"Warning\", vec![b\"Warning: 110\".to_vec()]);\r\n```. It seems that this is due to the `hyper` version being used in `iron` is 0.10 which does not support Warning header yet. However, when you are dealing with a `headers: &mut Headers` , you can get/set the raw Warning headers like so:\r\n```\r\nlet warnings = match headers.get_raw(\"Warning\") {\r\n        Some(warning) => std::str::from_utf8(&warning[0]).unwrap(),\r\n        None => \"No warning.\",\r\n};\r\n```\r\n```\r\nheaders.set_raw(\"Warning\", vec![b\"Warning: 110\".to_vec()]);\r\n```. ",
    "kw217": "Yes, this fixes #528 .. Arguably it should go in Hyper _as well_, but the code in Iron should do the right thing too. I think this is fixed in Hyper 0.11 anyway, but Iron is still using Hyper 0.10.. Yes, this fixes #528 .. Arguably it should go in Hyper _as well_, but the code in Iron should do the right thing too. I think this is fixed in Hyper 0.11 anyway, but Iron is still using Hyper 0.10.. ",
    "clarfon": "Shouldn't this be included in Hyper, not Iron?. Shouldn't this be included in Hyper, not Iron?. ",
    "xcstream": "maybe it's not a problem about iron. maybe it's not a problem about iron. ",
    "kamyuentse": "That seems an upstream issue, related to hyper.. Here is the log:\r\n```\r\nDEBUG:tokio_core::reactor                       : loop poll - Duration { secs: 0, nanos: 20752 }\r\nDEBUG:tokio_core::reactor                       : loop time - Instant { t: 51416623642944 }\r\nTRACE:tokio_core::reactor                       : event Ready {Readable | Writable} Token(4)\r\nTRACE:tokio_core::reactor                       : event Ready {Readable} Token(3)\r\nTRACE:tokio_proto::streaming::pipeline::advanced: Pipeline::tick\r\nTRACE:hyper::proto::conn                        : Conn::poll()\r\nTRACE:hyper::proto::conn                        : Conn::read_head\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 8192])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 16384])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 32768])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 65536])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 131072])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 262144])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 524288])\r\n==> DEBUG:hyper::proto::io                          : MAX_BUFFER_SIZE reached, closing\r\n==> TRACE:hyper::proto::conn                        : State::close_read()\r\n==> DEBUG:hyper::proto::conn                        : parse error (Message head is too large) with 524288 bytes\r\nTRACE:tokio_proto::streaming::pipeline::advanced: process_out_frame\r\nDEBUG:tokio_core::reactor                       : loop process - 2 events, Duration { secs: 0, nanos: 64262730 }\r\nDEBUG:tokio_core::reactor                       : loop poll - Duration { secs: 0, nanos: 50111 }\r\nDEBUG:tokio_core::reactor                       : loop time - Instant { t: 51416687986125 }\r\nTRACE:tokio_core::reactor                       : event Ready {Readable} Token(0)\r\nDEBUG:tokio_core::reactor                       : consuming notification queue\r\nDEBUG:tokio_core::reactor                       : dropping I/O source: 1\r\nDEBUG:tokio_core::reactor                       : loop process - 1 events, Duration { secs: 0, nanos: 103557 }\r\nDEBUG:tokio_core::reactor                       : loop poll - Duration { secs: 0, nanos: 9430 }\r\nDEBUG:tokio_core::reactor                       : loop time - Instant { t: 51416688114513 }\r\nDEBUG:tokio_core::reactor                       : loop process - 0 events, Duration { secs: 0, nanos: 27283 }\r\n```\r\n\r\nThe reason is that the buffer size of the `head` hit the MAX_BUFFER_SIZE, then the server drops the connection.\r\n\r\nMaybe we should give a more explicit error from the `Http1Transaction::parse()`.\r\n\r\nBTW, I think this issue should be moved to [hyper](https://github.com/hyperium/hyper) : ). The performance depends on your **network quality**. Maybe the best way to fix it is to link your PC to datacenter via fiber directly.. Because iron based on hyper 0.10.x currently, which use sync IO.. That seems an upstream issue, related to hyper.. Here is the log:\r\n```\r\nDEBUG:tokio_core::reactor                       : loop poll - Duration { secs: 0, nanos: 20752 }\r\nDEBUG:tokio_core::reactor                       : loop time - Instant { t: 51416623642944 }\r\nTRACE:tokio_core::reactor                       : event Ready {Readable | Writable} Token(4)\r\nTRACE:tokio_core::reactor                       : event Ready {Readable} Token(3)\r\nTRACE:tokio_proto::streaming::pipeline::advanced: Pipeline::tick\r\nTRACE:hyper::proto::conn                        : Conn::poll()\r\nTRACE:hyper::proto::conn                        : Conn::read_head\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 8192])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 16384])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 32768])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 65536])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 131072])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 262144])\r\nTRACE:hyper::proto::h1::parse                   : Request.parse([Header; 100], [u8; 524288])\r\n==> DEBUG:hyper::proto::io                          : MAX_BUFFER_SIZE reached, closing\r\n==> TRACE:hyper::proto::conn                        : State::close_read()\r\n==> DEBUG:hyper::proto::conn                        : parse error (Message head is too large) with 524288 bytes\r\nTRACE:tokio_proto::streaming::pipeline::advanced: process_out_frame\r\nDEBUG:tokio_core::reactor                       : loop process - 2 events, Duration { secs: 0, nanos: 64262730 }\r\nDEBUG:tokio_core::reactor                       : loop poll - Duration { secs: 0, nanos: 50111 }\r\nDEBUG:tokio_core::reactor                       : loop time - Instant { t: 51416687986125 }\r\nTRACE:tokio_core::reactor                       : event Ready {Readable} Token(0)\r\nDEBUG:tokio_core::reactor                       : consuming notification queue\r\nDEBUG:tokio_core::reactor                       : dropping I/O source: 1\r\nDEBUG:tokio_core::reactor                       : loop process - 1 events, Duration { secs: 0, nanos: 103557 }\r\nDEBUG:tokio_core::reactor                       : loop poll - Duration { secs: 0, nanos: 9430 }\r\nDEBUG:tokio_core::reactor                       : loop time - Instant { t: 51416688114513 }\r\nDEBUG:tokio_core::reactor                       : loop process - 0 events, Duration { secs: 0, nanos: 27283 }\r\n```\r\n\r\nThe reason is that the buffer size of the `head` hit the MAX_BUFFER_SIZE, then the server drops the connection.\r\n\r\nMaybe we should give a more explicit error from the `Http1Transaction::parse()`.\r\n\r\nBTW, I think this issue should be moved to [hyper](https://github.com/hyperium/hyper) : ). The performance depends on your **network quality**. Maybe the best way to fix it is to link your PC to datacenter via fiber directly.. Because iron based on hyper 0.10.x currently, which use sync IO.. ",
    "segfo": "\r\nI mistook a branch. Close. \r\nI mistook a branch. Close. ",
    "Jonh000001": "**This is not about the number of requests per second**\r\n\r\n> When I try to open the hello world page in my browser from my machine I only get a response from the Iron after 60 seconds, when the test is done.\r\n\r\nMy question is **why** Iron doesn't answer to clients with slow connection under performance test\r\n\r\nNginx during the same test  (`wrk...`) will show its welcome page\r\nSimultaneously VM -> nginx and My PC > nginx\r\nVM\r\n`Requests/sec:  20266.25`\r\nPC\r\n`Requests/sec:   1405.94`\r\n\r\n\r\nLooks like that something blocking Iron.... \r\n. **This is not about the number of requests per second**\r\n\r\n> When I try to open the hello world page in my browser from my machine I only get a response from the Iron after 60 seconds, when the test is done.\r\n\r\nMy question is **why** Iron doesn't answer to clients with slow connection under performance test\r\n\r\nNginx during the same test  (`wrk...`) will show its welcome page\r\nSimultaneously VM -> nginx and My PC > nginx\r\nVM\r\n`Requests/sec:  20266.25`\r\nPC\r\n`Requests/sec:   1405.94`\r\n\r\n\r\nLooks like that something blocking Iron.... \r\n. "
}