{
    "Gozala": "Here is two issues that being discovered by tests:\n\nhttp://github.com/kriskowal/q/issues/issue/3\nhttp://github.com/kriskowal/q/issues/#issue/2\n. Actually the second test failure is also caused by this:\nhttp://github.com/kriskowal/q/pull/1#L3R109\n. This was an error in test apparently and here is the fix:\n\nhttps://github.com/kriskowal/q/issues/#issue/7 \n. Ok I'll update test cases accordingly and will include them into the pull request\n. Fix in https://github.com/kriskowal/q/issues/#issue/7\n. This was checked in by changeset: \n\nhttps://github.com/kriskowal/q/commit/d17f07c5475dcbb3d62c94c3f912ed43af756280\n. This is basically the same as http://github.com/kriskowal/q/issues/#issue/5\n. system module was also loaded but it was not defined in dependencies this was breaking it on [teleport](https://github.com/Gozala/teleport/)\n. In fact I have version of test-commonjs somewhere that can run tests in browser, using some AMD like module loader. It's far from being pretty but it runs tests and logs results to the screen. I could share it with you if that helps, but I'm not able to put much effort in making it first-class for now.\n. @domenic Ok I'll try to do it over the weekend & maybe provide a patch for q that would do that!\n. To be more precise we use minimalistic **Q** subset with addition of `promised` decorator in Add-on SDK:\nhttps://addons.mozilla.org/en-US/developers/docs/sdk/latest/packages/api-utils/promise.html\n\nIdea behind is just to ease expression of computation on promise values. So instead of having utilities like `Q.all` we just expect users to use `promised(Array)`.\n\nI have no idea how that would work with remote promises, but I guess in exact same way as `Q.all` would.\n. @domenic meta-promise was experiment that should be pretty easy to update to make it compatible with all JS engines supporting Proxies. Although from that experience I learned that making promises too much like regular objects was very confusing. I think syntax in the ES proposals http://wiki.ecmascript.org/doku.php?id=strawman:concurrency is probably a best way to go about it: \n\n``` js\nfiles!filter(function (name) {\n  return (name.slice(-3) === '.js');\n});\n```\n\nMakes it obvious for reader that operation happens eventually rather then now.\n\nI also have experimented with that approach in clojurescript where you have much more control of a language\nhttps://github.com/Gozala/eventual-cljs and seem to like it the most so far.\n. > @Gozala Without new syntax, what about something like files.eventually.filter(...). I'm doing something similar in Chai as > Promised.\n\nI guess that may work, but don't know if it's distinct enough for users to spot though. Still I think `promised` decorator is kind of more obvious and works on js engines today, althouh it's not very compatible with OOP style. But since I tend to go functional most of the time following worked extremely well:\n\n``` js\npromised(filter)(function(name) {\n  return (name.slice(-3) === '.js');\n}, files)\n```\n. @domenic BTW if you have access to generators than you can use `yield` to wait for a promise resolution. I have played with that idea quite a while ago: https://github.com/Gozala/actor\n. Just recalled that @dherman has a well maintained library http://taskjs.org/ that implements very similar idea\n. @domenic Oh BTW as of https://gist.github.com/1372013 I think most of the things you do there are better of in the streams land, in my opinion plain promises are not well suited for representing sequential values. Although you can build streams using promises which I tried https://github.com/Gozala/streamer/wiki/stream \n. In fact we don't implement `Q.when` and do resolve promises in the same turn of event loop, mainly because some capabilities are only exposed across the call stack of the event handler and attempt to use them in next turn will fail.\n. +1 That's how `promised` decorator works in addon-sdk\nSee [Consuming promises section](https://addons.mozilla.org/en-US/developers/docs/sdk/latest/packages/api-utils/promise.html) for more details. You can also find implementation here:\nhttps://github.com/mozilla/addon-sdk/blob/master/packages/api-utils/lib/promise.js#L179-223\n. In our implementation `this` passed to the decorated function will also be treated as promise and passed to the original function. Would be great if implementation in Q was compatible with it.\n. @ForbesLindesay Any reason not to ? I in general treat `this` as an implicit argument that can be passed in an awkward manner. There for I have cases where `this` is maybe a promise.\n. I personally like `promised` decorator as it reduces API surface one need to learn for working with promises\nto an absolute minimum which is `promised` itself for all transformations and `then` for final consumption.\nFor example problem described above could have being solved as follows:\n\n```\nvar getUserInfo = promised(rawGetUserInfo)\nvar user = promised(function(email, user) {\n  return { email: email, user: user }\n})\n\nvar email = getEmail(...)\nvar myUser = user(email, getUserInfo(email))\n```\n\nAlso it's very likely to have some utility functions in toolbox already that can\ncompose without any extra code:\n\n```\nvar getUserInfo = promised(rawGetUserInfo)\nvar user = promised(record(\"email\", \"user\"))\nvar email = getEmail()\nvar myUser = user(email, getUserInfo(email)\n```\n\nwhere record is:\n\n``` js\nfunction record() {\n  var names = Array.prototype.slice.call(arguments)\n  return function() {\n    var values = arguments\n    return reduce.names(function(result, name, index) {\n      result[name] = values[index]\n      return result\n    }, {})\n  }\n}\n```\n. Another interesting consequence of describing computations via `promised` functions is that\nany synchronous computation can be easily turned into async by just decorating functions involved\nin that computation. \n. I have pointed out in  #152 reason why I do like `promised` wrapper and why I proposed it for inclusion to **Q**.\nhttps://github.com/kriskowal/q/issues/152#issuecomment-11758945\n\nI have not took q-comm into consideration, mainly because remote promises feel special anyway. Either way I won't be too broken hearted if this will  go away since **Q** API surface has grown enough for me not to be comfortable using it.\n. Here is two issues that being discovered by tests:\n\nhttp://github.com/kriskowal/q/issues/issue/3\nhttp://github.com/kriskowal/q/issues/#issue/2\n. Actually the second test failure is also caused by this:\nhttp://github.com/kriskowal/q/pull/1#L3R109\n. This was an error in test apparently and here is the fix:\n\nhttps://github.com/kriskowal/q/issues/#issue/7 \n. Ok I'll update test cases accordingly and will include them into the pull request\n. Fix in https://github.com/kriskowal/q/issues/#issue/7\n. This was checked in by changeset: \n\nhttps://github.com/kriskowal/q/commit/d17f07c5475dcbb3d62c94c3f912ed43af756280\n. This is basically the same as http://github.com/kriskowal/q/issues/#issue/5\n. system module was also loaded but it was not defined in dependencies this was breaking it on [teleport](https://github.com/Gozala/teleport/)\n. In fact I have version of test-commonjs somewhere that can run tests in browser, using some AMD like module loader. It's far from being pretty but it runs tests and logs results to the screen. I could share it with you if that helps, but I'm not able to put much effort in making it first-class for now.\n. @domenic Ok I'll try to do it over the weekend & maybe provide a patch for q that would do that!\n. To be more precise we use minimalistic **Q** subset with addition of `promised` decorator in Add-on SDK:\nhttps://addons.mozilla.org/en-US/developers/docs/sdk/latest/packages/api-utils/promise.html\n\nIdea behind is just to ease expression of computation on promise values. So instead of having utilities like `Q.all` we just expect users to use `promised(Array)`.\n\nI have no idea how that would work with remote promises, but I guess in exact same way as `Q.all` would.\n. @domenic meta-promise was experiment that should be pretty easy to update to make it compatible with all JS engines supporting Proxies. Although from that experience I learned that making promises too much like regular objects was very confusing. I think syntax in the ES proposals http://wiki.ecmascript.org/doku.php?id=strawman:concurrency is probably a best way to go about it: \n\n``` js\nfiles!filter(function (name) {\n  return (name.slice(-3) === '.js');\n});\n```\n\nMakes it obvious for reader that operation happens eventually rather then now.\n\nI also have experimented with that approach in clojurescript where you have much more control of a language\nhttps://github.com/Gozala/eventual-cljs and seem to like it the most so far.\n. > @Gozala Without new syntax, what about something like files.eventually.filter(...). I'm doing something similar in Chai as > Promised.\n\nI guess that may work, but don't know if it's distinct enough for users to spot though. Still I think `promised` decorator is kind of more obvious and works on js engines today, althouh it's not very compatible with OOP style. But since I tend to go functional most of the time following worked extremely well:\n\n``` js\npromised(filter)(function(name) {\n  return (name.slice(-3) === '.js');\n}, files)\n```\n. @domenic BTW if you have access to generators than you can use `yield` to wait for a promise resolution. I have played with that idea quite a while ago: https://github.com/Gozala/actor\n. Just recalled that @dherman has a well maintained library http://taskjs.org/ that implements very similar idea\n. @domenic Oh BTW as of https://gist.github.com/1372013 I think most of the things you do there are better of in the streams land, in my opinion plain promises are not well suited for representing sequential values. Although you can build streams using promises which I tried https://github.com/Gozala/streamer/wiki/stream \n. In fact we don't implement `Q.when` and do resolve promises in the same turn of event loop, mainly because some capabilities are only exposed across the call stack of the event handler and attempt to use them in next turn will fail.\n. +1 That's how `promised` decorator works in addon-sdk\nSee [Consuming promises section](https://addons.mozilla.org/en-US/developers/docs/sdk/latest/packages/api-utils/promise.html) for more details. You can also find implementation here:\nhttps://github.com/mozilla/addon-sdk/blob/master/packages/api-utils/lib/promise.js#L179-223\n. In our implementation `this` passed to the decorated function will also be treated as promise and passed to the original function. Would be great if implementation in Q was compatible with it.\n. @ForbesLindesay Any reason not to ? I in general treat `this` as an implicit argument that can be passed in an awkward manner. There for I have cases where `this` is maybe a promise.\n. I personally like `promised` decorator as it reduces API surface one need to learn for working with promises\nto an absolute minimum which is `promised` itself for all transformations and `then` for final consumption.\nFor example problem described above could have being solved as follows:\n\n```\nvar getUserInfo = promised(rawGetUserInfo)\nvar user = promised(function(email, user) {\n  return { email: email, user: user }\n})\n\nvar email = getEmail(...)\nvar myUser = user(email, getUserInfo(email))\n```\n\nAlso it's very likely to have some utility functions in toolbox already that can\ncompose without any extra code:\n\n```\nvar getUserInfo = promised(rawGetUserInfo)\nvar user = promised(record(\"email\", \"user\"))\nvar email = getEmail()\nvar myUser = user(email, getUserInfo(email)\n```\n\nwhere record is:\n\n``` js\nfunction record() {\n  var names = Array.prototype.slice.call(arguments)\n  return function() {\n    var values = arguments\n    return reduce.names(function(result, name, index) {\n      result[name] = values[index]\n      return result\n    }, {})\n  }\n}\n```\n. Another interesting consequence of describing computations via `promised` functions is that\nany synchronous computation can be easily turned into async by just decorating functions involved\nin that computation. \n. I have pointed out in  #152 reason why I do like `promised` wrapper and why I proposed it for inclusion to **Q**.\nhttps://github.com/kriskowal/q/issues/152#issuecomment-11758945\n\nI have not took q-comm into consideration, mainly because remote promises feel special anyway. Either way I won't be too broken hearted if this will  go away since **Q** API surface has grown enough for me not to be comfortable using it.\n. ",
    "kriskowal": "The behavior is expected; the idea is that promises need to be a uni-directional communication channel for security reasons. For example, a dozen consumers might be given the same resolver so that they can race to provide the resolution, but they should not be able to observe whether they won the race.  That's what I heard from Tyler Close or Mark Miller anyway.\n\nThanks for the cases. I'll have more time to do integration for a while.\n. Please review https://github.com/kriskowal/q/commit/e045fb5329fc5ea4eb202e55b98ee741fd25e4ec\n. This has been done for months.\n. Some of these are now in master, others are in experimental. Thanks.\n. This is a bug. Thanks.\n. Fixed in 4a944a1 / master.\n. By cursory inspection, this has been fixed. Please reopen if you find otherwise.\n. It would look something like:\n\n```\n// accepts a collection name and returns a promise\n// for an array of all of the collection.column names\n// to which the collection can be joined.\nvar collectColumnNames = function (\n    collectionName,\n    columnNames, // not part of the API\n    collectionNames // not part of the API\n) {\n    // the collection to populate\n    columnNames = columnNames || [];\n\n    // A memo to prevent infinite recursion\n    collectionNames = collectionNames || {};\n    if (collectionNames[collectionName])\n        return;\n    collectionNames[collectionName] = true;\n\n    // reduce and forEach can both be used to iterate\n    // with promises either in parallel or serial\n    return collection.reduce(function (prev, row) {\n        var result = row.reduce(function (prev, column) {\n            if (isLookupColumn(column) {\n                var result = collectColumnNames(\n                    column.collectionName,\n                    columnName,\n                    collectionNames\n                );\n\n                // async join in parallel\n                return Q.when(prev, function () {\n                    return result;\n                });\n            } else {\n                columnNames.push(collectionName + \".\" + column.name);\n                // this is the actual result value:\n                return columnNames;\n            }\n        }, columnNames);\n\n        // async join in parallel:\n        return Q.when(prev, function () {\n            return result;\n        });\n    }, columnNames);\n};\n```\n. collection is any array or array-like-object, provided presumably by you from mongodb. Bear in mind that I don't fully understand your requirements, so I just implemented _something_ that might be instructive rather than something functional. The idea is to grasp the use of Array.prototype.reduce in conjunction with Q.when to do parallel or serial joins of asynchronous tasks. Error propagation is implicit.\n. There are several other instances in the README, even in that example, where Q was not explicated.\n. If adding the Q. makes it more clear, I think it's a good idea.\n. Thanks\n. The reason was to support a convention that all modules that can be used as scripts (micro-frameworks) would reach each-other by placing their exports in global[\"/\" + id]. This is guaranteed to not conflict with any other globals. global[id.toUpperCase()] is sufficient for something like Q, but isn't sufficient for something like \"q-comm/browser\", which has hyphens and slashes.\n\nIn any case, I'm accepting this patch because it makes the system more clear in the micro-framework case, which is going to be far more common, than the case where a bunch of CommonJS scripts are installing themselves with script tags before require machinery has been set up.  I will come up with another convention for the more complicated cases.\n\nAlso, I've been thinking that packaging systems might be able to bypass loading certain modules like \"json\" and \"q\" if a global variable like JSON or Q already exists in the environment. This would spare HTTP requests when functionality has already been provided. So, \"Q\" works better for that case anyway.\n. Oh, really sorry about that. I didn't finish the job last night. You'll find that I've moved the q/util and q/queue modules and merged them to the qq package due to NPM's change to no longer expose any module except the main module.\n\nhttps://github.com/kriskowal/qq\n. I hope recent changes to README help.\n. Landed in v0.4.2. Published to NPM. There were no problems with the merge and branch rebase, so whatever you did worked fine.  I think the define.amd check is over-engineered and will probably get in the way eventually, but it's not causing errors now any more than leaving it off would, so I'm going to let it slide for now.\n. Sorry for taking my time on this one. These are now in master.\n. It seems more likely that this issue is caused by the reduce property being enumerable. The syntax is fine. Unfortunately, we can't fix that. \"resolve\" probably needs to be implemented to use the array protocol (using a for(;;) loop on array.length) instead of using a (for (in)) loop. Where is \"resolve\" from?\n. @cosborn, good idea in theory, but if you're using es5-shim, it's only going to do a half-hearted attempt to make it non-enumerable. i think i just need to use Object.prototype.hasOwnProperty.call in this for-loop.\n. Should be fixed in new push. Please reopen if the issue remains.\n. Might as well. My wedding is tomorrow. Give me a week. :) if you send a patch, shim defineproperty first in the shims section. \n. This has been on the back of my mind for a while. Tracking resolved/unresolved promises is also good for what you did earlier for waterfall analysis. We definitely need something, perhaps the ability to create Q sandbox instances that can create a report of the outstanding promise graph.\n\n```\nvar {Q, pool} = Q.create({debug: false});\nvar promise = Q.defer('annotation').promise;\nassert.deepEqual(\n   pool,\n   [{promise: promise, annotation: 'annotation'}],\n   'promise pool contents'\n);\npromise.resolve();\nassert.equal(0, pool.length);\n```\n\nI'll be away for a week, so I will probably not be able to have a lively discussion for a while. That said, I do want to have more dialog with friends and supporters. We need to be a more tightly knit group and I need to be more conscious of how Q is being used in the wild.\n. `end()` is very much a stopgap, which is why I favor it over `.done()`.  There are two cases where we will find ourselves editing the end of promise chains.  The first is when you have to add another step.  After a `done`, you have to walk back and forth to switch the previous `done` to `then` and add a `done`.  With `end`, you just chain a new `then` between the previous and the end.  The latter case, when good visualization tools for the state of a promise graph are available, it is my hope that `.end()` calls will become vestigial and trivial to remove.\n\nHowever, I still think there would be value in introducing promise `domains` (pools as it were, but I think `domains` is going to catch on).\n. It\u2019s time to put this issue to bed. There are three directions being pursued.\n1. Domains exist. This mostly obviates the need for pools, which would probably not be ergonomic in the long run.\n2. Discussion about `end` vs `done` has run its course.\n3. Options are being explored for debugger extensions that surface transient unhandled rejected and pending promises, either through a separate window or logging and unlogging.\n\nThanks, @asutherland. This is the longest lasting, most relevant issue we have.\n. Numerous apologies and thanks. I'll fix this next week. Presently on the road for my wedding. :)\n. I\u2019ve merged https://github.com/kriskowal/q/pull/25\n. Cool, thanks.\n. All the old code blocks have finally been purged. Thanks for the tip. Check out the new README.\n. There are a couple functions recently added to assist in this case.\n\n``` javascript\nreturn Q.ncall(doSomething, a, b)\n```\n\nOr\n\n``` javascript\nreturn Q.node(doSomething)(a, b)\n```\n\nI have been playing with the idea of adding deferred.node() like your suggestion for a couple days. I\u2019ll keep that in mind, but I hope that these functions help for now.\n. Your recommendations are upcoming in the next major release.\n\nhttps://github.com/kriskowal/q/compare/v0.7.2...master\n. Also, jQuery\u2019s:\n\n``` javascript\nwhen(a, b, c)\n.then(function (a, b, c) {\n})\n```\n\nIs equivalent to Q\u2019s\n\n``` javascript\nQ.all([a, b, c])\n.spread(function (a, b, c) {\n})\n```\n\nWe should perhaps have a catalog of patterns.  `then` and `spread` both support the value or promise return in their callbacks like jQuery `pipe`.\n\nBecause `when`\u2019s arguments are optional, you can do this exactly like jQuery\u2026\n\n``` javascript\nQ.when(x).then(function (x) {\n    \u2026\n})\n```\n. @ThomasBurleson, in Q, chained .then calls are the same as jQuery chained .pipe calls. Q does not do parallel processing on the same promise for each .then call: .then returns a new promise for the return value, returned promise, returned rejection, or thrown exception of either the callback or the errback. Since there\u2019s only one callback or errback for each .then call, and only one or the other will be called, which callback resolves the returned promise is unambiguous.  If you want to do parallel processing on the same promise in Q, you have to do this:\n\n``` javascript\nvar p = getPromise();\np.then(function () {\n    return \"a\";\n}) // returns a promise for \"a\"\np.then(function () {\n    return \"b\";\n}) // returns a promise for \"b\"\n```\n. Prompted by this discussion, I\u2019ve started a Wiki page for jQuery users.\n\nhttps://github.com/kriskowal/q/wiki/jQuery\n. @ThomasBurleson Thanks for your insights as well. You put a voice to jQuery users that I could address in the above wiki article.\n. The purpose of calling `nextTick` in this case is not so much to permit interleaving, but to force deterministic interleaving of the callbacks. Callbacks are required to occur in future turns, instead of occurring either on the stack _or_ in a future turn. Using `nextTick` increases the robustness of everything built on top of Q.\n\nIt\u2019s relatively straightforward to safely handle a readable stream in conjunction with promises.\n\nhttps://github.com/kriskowal/q-io/blob/master/q-io.js#L13-100\n\n(Needs further work to support throttling, but has been indispensable for my stack.)\n. Thanks. The documentation needs another pass for clarity, for sure. `nextTick` reads as \u201ccalled in a future turn of the event loop\u201d throughout `README.md`\n\nexcerpt:\n\n## `when(value, fulfilled_opt, rejected_opt)`\n\nArranges for `fulfilled` to be called:\n-   with the value as its sole argument\n-   in a future turn of the event loop\n-   if and when the value is or becomes a fully resolved\n\nArranges for `rejected` to be called:\n-   with a value respresenting the reason why the object will\n  never be resolved, typically an `Error` object.\n-   in a future turn of the event loop\n-   if the value is a promise and\n  -   if and when the promise is rejected\n\nReturns a promise:\n-   that will resolve to the value returned by either of the\n  callbacks, if either of those functions are called, or\n-   that will be rejected if the value is rejected and no\n  `rejected` callback is provided, thus forwarding\n  rejections by default.\n\nThe value may be truly **any** value.  It can be a function.\nIt can be a promise.\n\nEither callback may be falsy, in which case it will not be\ncalled.\n\nGuarantees:\n-   `fulfilled` will not be called before when returns.\n-   `rejected` will not be called before when returns.\n-   `fulfilled` will not be called more than once.\n-   `rejected` will not be called more than once.\n-   If `fulfilled` is called, `rejected` will never be called.\n-   If `rejected` is called, `fulfilled` will never be called.\n-   If a promise is never resolved, neither callback will\n  ever be called.\n. Now tracking as #31.\n. Agreed. However, swallowing exceptions is desirable behavior since it unifies synchronous and asynchronous exception handlers. I wavered on this for a while, but Irakli Gozashvili convinced me it was necessary for the flipside developer ergonomics.\n\nThe present stopgap is to terminate all promise chains with a .end() call.\n\n``` javascript\nfunction main() {\n  // foo returns a promise, but we don't look at the return so we lose.\n  return foo(promiseLoaded());\n}\n\nmain().end();\n```\n\nI am playing with the idea of having another stop-gap solution: using console.log to write a live array to the console. I would then add exceptions to the array when they are swallowed, and remove them when they are handled.\n\nIt would be much more awesome to extend Firebug with something like Causeway, where I could use something like a `console.events` API to expose the causal graph of promises: a bar for each promise from when it was created to when it was resolved, whether it was fulfilled or rejected, what other promises were waiting for it, the stack trace at the point of creation, the stack trace at the point of failure, that kind of thing.\n\n(Issues are in markdown format. You can use Github\u2019s proprietary extension to Markdown for literal bodies: three backticks on top and on bottom. If you want syntax highlighting, put the file extension on the same line as the initial backticks.)\n. Causeway is a distributed debugger.\n\nhttp://wiki.erights.org/wiki/Causeway\n\nMarkM talked about it in Belgium recently. http://www.youtube.com/watch?v=w9hHHvhZ_HY\n\nhttp://www.erights.org/elang/tools/causeway/\n. @johnjbarton I certainly have ambitions for a live visualization.\n. @IgorMinar this is how Q worked about a year ago. Unfortunately it\u2019s harder to go back than to go forward.\n. @IgorMinar I was logging the exception _and_ forwarding a rejection. This led to dirty and confusing double-logging if the rejection was handled properly.\n\nI was also of the mind that exceptions would be decreed to be programmer errors and rejections were for intentional errors. However, this did not pan out in practice. A lot of existing systems throw exceptions for non-error cases, and these _do_ need to get trapped in rejections. Having all thrown exceptions reported in every frame is not an option, and terminating a services because of an asynchronously handled exception is not an option. It\u2019s really quite tricky. It would be a much better option to just visualize the promise graph for debugging purposes.\n. @igorminar It really just isn\u2019t practical. A lot of these functions only throw in exceptional conditions, so a cautious developer would have to try/catch every third party function.\n\nI really am considering a gamut of solutions. One of them discussed earlier with @asutherland would be to allow the promise library to be instantiated with logging emitters. It\u2019s still on the table if someone has the time.\n. I believe this issue has played out. We have `done()` as an ugly stopgap for explicitly surfacing programmatic errors. We will have promise debuggers soon, for the other cases.\n. @axelson https://github.com/kriskowal/q#the-end\n. @randallb Q.onerror is a thing that exists.\n. @randallb Sorry, that went out too soon. It probably does not do what you want. Q.onerror gets called for unhandled rejections that would get rethrown. It does not report errors that have been caught but have not been handled. There is a limbo for errors, where they might be observed and handled in a future turn. In the trivial case:\n\n``` js\nvar rejected = Q.reject(new Error('boo'));\nQ.delay(1000, function () {\n    return rejected;\n}).done();\n```\n\nThis is too trivial a case. The problem will show up if you use promise queues or asynchronous iterators / readers, since the producer and the consumer operate independently.\n\n``` js\nvar reader = Reader([1, 2, 3, 4])\n.map(function (value) {\n    if (value % 2) throw new Error('how odd');\n});\n\n// later...\nreader.next().catch(function (error) {\n});\n```\n\nSo while we could surface unhandled errors in the same event loop turn like RSVP, it would be noisy for legitimate cases.\n\nI need to refresh my context, but there are ongoing plans to surface other events like, ondefer, onresolve, onreject, onhandle that would be able to drive an inspector that would show \"pending deferred\" promises and \"rejected unhandled\" promises for any given moment.\n. @n2liquid WeakMap is what it is for good reasons and is deliberately not for this use-case. There is a proposed WeakRef that provides a post mortem notification callback. We had to wait for TC39 to specify an event loop to get Promise. We\u2019ll have to wait for TC39 to specify garbage collection before we\u2019ll get WeakRef. Maybe we\u2019ll get it someday, but that sounds hard. Members TC39 would prefer not to introduce a feature that would increase the observable differences between engines and specifying GC could seriously paint the language into a corner.\n. Fixed by #34\n. Duplicate of #32 fixed by pull #34. Thanks!\n. The stack trace is helpful. The problem is that Opera checks the argument count instead of coercing the argument to undefined. Easy fix.\n. Sure. I'll get that out to you all this weekend. Sorry for the delay,\nI thought I had already done it.\n\n(tiny keyboard)\n\nOn Jan 13, 2012, at 7:43 PM, Davis Clark\nreply@reply.github.com\nwrote:\n\n> can we get an npm publish please? I am in need of the fix for q.all on empty arrays.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/kriskowal/q/issues/36\n. On Fri, Jan 13, 2012 at 8:10 PM, Kris Kowal cowbertvonmoo@gmail.com wrote:\n\n> Sure. I'll get that out to you all this weekend. Sorry for the delay,\n> I thought I had already done it.\n\nYou can use v0.8.1. It has a couple fixes, including Q.all. It also\ncomes with a minfied version. Thanks!\n\nKris Kowal\n. Thanks!\n. I want to keep the tutorial on the README. Most folks will only ever see the README and decide whether to buy Q based on what\u2019s there.\n\nI agree regarding the API sections.\n. @jrburke I like the idea of a problem statement, but I hesitate to characterize the benefits of using promises to just addressing the pyramid of doom, particularly because other libraries like @caolan\u2019s async do that job pretty well. It\u2019s a worthy problem to solve, but error propagation, reducing \"chat delays\" in distributed programs, POLA, and OCap philosophy are all part of the value. What you see is just the beginning: promise-aware debuggers and visualizers, progress monitors, cancellation propagation, and such other things fit in the architecture of a promise library.\n\n@DomenicDenicola I think lifting examples is the better strategy. A lot of the preamble is specific to folks coming from \".Net\". I want to keep the sale\u2019s pitch in the README, and I think the tutorial is it. We could rotate the reference and examples out and into the Wiki.\n. @jrburke I\u2019ll give it a shot. Thanks for the idea.\n. I would prefer for the `nextTick` underlying implementation to be injected somehow, rather than patched on post-instantiation. There are no securability issues if it\u2019s injected, but there are security implication if we allow it to be replaced.\n\nBear in mind that this implementation of the Q interface does not make security guarantees. It just strives to behave identically to a hypothetical secure implementation like ref_send or makeQ.  It is intended to pave the way, not be the way.  That is, while it does make a lot of guarantees about the order of events (which are good for robustness in general), it does not guarantee that mutually suspicious programs could share the Q interface or share promise objects without fear of interference.  To do so, it would have to freeze a lot more.\n\nThis is a tricky situation. @cadorn, does the MessageChannel implementation of `nextTick` not work in the Addon SDK?  I am thinking that the event-queue should be entirely subsumed by Q at this point.\n. @cadorn Does the addon runtime provide a `reuqire.async(id, cb, eb)` hook?\n. IE10 implemented setImmediate? Neato. Let\u2019s use it.\n. Oh, yeah. Left over from when there was a for loop. Thanks for the catch. Manual var hoisting strikes again!\n. Solid. I\u2019m sure it\u2019s safe to document, but I see documentation as a commitment to support.\n\nWould it make sense to reflect `bind` on the promise interface too? `promiseForFunction.bind(thisp, 1, 2, 3).invoke(null, 4, 5, 6)`. Does it make sense not to?\n. It\u2019s not a real need. It can wait.\n. I would have agreed some time ago that any function call should implicitly Q.all(arguments) before forwarding a message, but there are legitimate cases for passing a literal promise as an argument and the overhead of Q.all might not be desired. Please feel free to bring the issue up on q-continuum@googlegroups.com.\n\n``` javascript\nQ.ref(__filename)\n.then(function (fileName) {\n    return Q.ncall(FS.readFile, FS, fileName)\n})\n.then(function (c) {\n    console.log(c);\n})\n.end()\n```\n. I suppose it\u2019s a decent assumption that Node functions aren\u2019t going to accept promises, so `ncall` and `node` would **probably** never need to receive a promise as an argument.\n\nPromises can be used as proxies for remote objects.  If that\u2019s the case, you can send messages without waiting for the promise to be fulfilled.  This makes piplining possible and is one of the best reasons to use Q for distributed systems.  To wait for resolution would be a waste of time.  As you point out, though, it is unlikely (but not impossible!) that you are going to pass a promise through a Node style function.\n\nI\u2019m still wary of establishing an expectation that other functions, like `Q.invoke` will do this for you implicitly.  It is certainly too much magic\u2122 for most Q cases.\n. I like `setImmediate`. I\u2019ve experimented with shimming it and using it, but it does not make sense to shim it in Q.\n\nPart of this is that `nextTick(cb)` is the only part of the signature we need and `nextTick` does not have to implement handle tracking or variadic argument forwarding like `setImmediate(cb(...args), ...args):handle`. It would be a waste of both weight and performance to properly shim `setImmediate`.  I would even use a global `nextTick` before considering _using_ a global ``setImmediate because of this consideration.\n\n``` javascript\nvar nextTick = global.nextTick || global.setImmediate || nextTickShim;\n```\n\nI do want to axe the `enqueue` module dependency. It is a legacy from Narwhal, which I think we should leave behind.\n\nIn the `nextTick` shim, I would also like to empty the queue in a single event to speed things up and make some diagnostics less noisy.\n. Sure. I\u2019m seeing it weight in at 2.07KiB. The throbbing and rotating is a bit too much though :D\n. That\u2019s about right. At least, I don\u2019t have better ideas.\n\nThe `reduce` function is a bit dense for most folks, so I usually show a way to do it with `forEach` too.\n\n``` javascript\nvar previous = Q.resolve();\n[foo, bar].forEach(function (f) {\n    previous = Q.when(previous, f);\n});\nreturn previous;\n```\n\nI agree we should put a couple more of these advanced cases into the readme, and ship the API reference out to the wiki or better.\n. Omitting the Q.resolve() should be discouraged and it was omitted in error. In the case of single and empty arrays, omitting the initial promise affects the return type or whether any work gets done.  And forget about `Q.wait`: it is way less confusing to just use the primitive `then` or `when` it is based on.\n\nThanks for handling the doc move!\n\nIt\u2019s also really important to include the solution for conditional continuation or branching, but I\u2019m not sure how to introduce it. You\u2019re basically creating a linked-list of functions, and you have to use `reduceRight` so you get a handle to the first function in the array.  It\u2019s a bit mind-bendy.\n\nIt would be nice to make an example that doesn\u2019t need an external library.\n. I see. You want the array of promises when all of them are resolved. I also see you can\u2019t build this on top of the existing `all`.\n\nI would call it `allResolved`.  There\u2019s precedent for `every` and `some` being opposites (javascript array), as well as `any` and `all` being opposites (python).  But, this isn\u2019t really an opposite since it returns a promise for an array of promises, not fulfilled values.\n\nWe should also consider redrawing the array so that it guarantees that every element is a promise. As written, it tolerates an array of mixed values and promises, so you\u2019re not guaranteed that you can call promise.isFulfilled() on each.\n\nThe other thing is that you might want to separate the rejections and fulfillments into separate arrays. Perhaps you can elaborate more on how you\u2019re going to use this. There might be a better way from a control-flow perspective.\n\nCan you run this by the Q-Continuum mailing list?\n. Actually landed in https://github.com/kriskowal/q/commit/cf20e5ea66b6ca09935753965157a17db25b1d8e\n. I\u2019ve got a pull request open for promise support in Jasmine.\n\nhttps://github.com/pivotal/jasmine/pull/202\n. Ok. If Buster doesn\u2019t work out, we can use Jasmine instead. It\u2019s relatively straightforward to monkey-patch jasmine.Block.execute.\n. Landed in v0.8.5\n. Please feel free to shoot down this idea: `deferred.nodeback()`\n. I like the idea. I would call it `install`.\n\nI am reticent to monkey-patch though. Part of the purpose of the library is to encourage patterns that will continue to function in one of MarkM\u2019s VATs. This might be worth batting around on the q-continuum mailing list to see if we hear objections from our mentors in the security business.\n\nOn one hand, I like the idea of encouraging standards-track patterns through monkey-patching. I am on the other hand not sure whether this would qualify.\n. A `Q.fcall` however might be in order, to avoid the `thisp`.\n. I have decided not to modify the function prototype in this library. I would however be willing to entertain this more ambitious mission in my long-neglected QQ project. I would also be willing to entertain giving anyone interested in the library ownership of the project.\n\nI think object-first variants of Q.call, Q.apply, and Q.bind would be confusing in the presence of the existing function prototype methods of the same name. I do agree that they make more sense visually, but there\u2019s always Q.invoke and Q.post for method calls. Q.invoke(object, \"name\", \u2026args) and Q.post(object, name, [args]).\n\nI will entertain here a pull request for Q.fcall and Q.fbind for no-thisp variants of Q.call and Q.bind. Naturally, the same methods would be reflected on promises as promise.fcall and promise.fbind. Let\u2019s track the discussion of those features on the pull request. I am closing this issue as won\u2019t fix.\n. Yes, however, it would still be good to show the asynchronous boundaries in the stack trace.\n\nIt might be useful to model this with chains of exceptions, or exception-like objects.\n\nOne thought I considered (and clearly, you have also) is that we might use Error.captureStackTrace to bless deferred objects with .stack getters.  We can then construct an error chain as we propagate through.  The .stack might also be useful for producing a waterfall diagram with expandable stack traces.\n\nThe feature would obviously have to be detected so we can fall back to a less inspectable version of Q at run time.\n. ```\nError: boo!\n    at c:\\Users\\Domenic\\Programming\\test\\test.js:11:15\nFrom previous event:\n    at doYAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:10:xx)\n    at doZAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:16:xx)\n    at c:\\Users\\Domenic\\Programming\\test\\test.js:19:xx\n```\n\nWhere there is some delimiter separating the stack traces from each event, indicating that the program yielded between those frames.  This is a good hint that there was an opportunity for other code to run in between.\n\nAt this point you\u2019re way ahead of me. My thought was that we could get away with just instrumenting deferreds since that\u2019s where everything ultimately comes from.  Even `when` calls `defer` before yielding. I\u2019m not 100% sure on what the right approach is.\n. This issue might also involve or solve another lingering issue: It\u2019s really nice when programmers have the foresight to rewrite errors at interface boundaries.  So, if you\u2019re using the FS module, you would get an error message related to what you were attempting to do, rather what the FS module was attempting to do with the operating system.  Something like, \"Failed to read such and such file\" instead of \"File descriptor not opened for read\".  The problem is that usually you lose some insight at these boundaries.  It strikes me that exceptions should inherently support chaining, so you can both have a friendly face and the ability to dig deeper into the issue by expanding the next error in the chain.\n. LongMueller will certainly help! Thanks.\n. I agree that we should trace all the functions that were visited in preparation, but don\u2019t sweat blood over it. I think this is already useful.\n. Landed in v0.8.5\n. 100%. Let\u2019s rename `node` to `nbind` and create an `napply` to flesh it out.\n\nFor migration purposes, let\u2019s then create an alias for `nbind` called `node` and make a note in the change log that it will be removed in the next backward-incompatible release.\n. We certainly do not need to support `new` in our `bind` implementation.\n. I fully endorse the removal of the Narwhal code. It\u2019s removal implies that we can remove the bootstrapping magic for \"require\" or \"serverSideRequire\" in the header.\n\nI am waffling on \"setImmediate\". We could probably lose that too. But if you want it, we can keep it.\n\nIt strikes me that the queue logic might be simplified.\n\nI think we should land this pull request at least with the simplified bootstrapping. Consider my other comments optional and feel free to merge these yourself, @domenic.\n. Looks much cleaner. Thanks.\n. Released v0.8.3 with this new feature. Published to NPM. Thanks.\n. Too issuesome to land.\n. Good call. Future implementations of the generator specification will support a pure return in a generator which will be implicitly converted into the ReturnValue exception. We can try to shim this with a Q.return(value) function.  I presume that all engines that support generators (just SpiderMonkey, as far as I know) support keyword properties, so this should be fine.\n\n``` javascript\nvar generator = Q.async(function () {\n    var ten = yield 10;\n    var twenty = yield ten + 10;\n    var thirty = yield twenty + 10;\n    Q.return(thirty + 10);\n});\n\ngenerator()\n.then(function (forty) {\n    assert.equals(forty, 40);\n})\n.end()\n```\n. It would emit events, yes. I will look up the branch I was working on and post back here. This is a delicate feature. \n. This is the experiment ec9264879ac39b077d2e378aa5db484857a5d0a9\n\nFeel free to ignore it if you have a novel idea.  The requirement is that we be able to attach a progress listener on a promise in a shallow fashion.  The progress messages should not propagate since they are meaningless downstream, but should perhaps be adaptable from a previous link in the chain.  It is an interesting problem.\n. This looks pretty good. Yes, let\u2019s run it by the Continuum.\n. @domenic, @igorminar, I\u2019ve updated the description to contain a breakdown of all the discussions we\u2019ve had on the topic.\n. In short, Q will not implement cancellation on promises. There is an opportunity for another library to introduce an alternative primitive that requires explicit forking and has a single-producer to single-consumer binding relationship. Such a library would have the same interface as Q but the implementation would be very different, and would compromise the unidirectional communication guarantees that Q provides. Q can be used for cancellation if you set up an API to creatively pass a cancellation resolver (express capability to cancel) as an argument and use the promise internally to observe the impatience or disinterest of the consumer.\n\nhttps://github.com/kriskowal/gtor/blob/master/cancelation.md\n. @tolmasky There is an interface that is strongly analogous to promises that I tentatively call tasks. Tasks only differ from promises in that they are _unicast_ (meaning single-consumer and explicitly forkable) and therefore _cancelable_. They have the same interface but differ in behavior. The implementation of `race` would behave as you describe for tasks. Similarly, `all` would cancel all outstanding tasks if a single task fails. A promise cannot make the same assumptions because it is _broadcast_, which confers other benefits, like easy memoization and safe distribution. I encourage you to look over my General Theory article.\n\nhttps://github.com/kriskowal/gtor/blob/master/task.js\nhttps://github.com/kriskowal/gtor/blob/master/README.md\n. That\u2019s the idea. The intention of the design, however, is to provide enough information to an optional external interface to produce useful debugging information for a running system, without entraining all of the interface logic in Q.  This feature should be developed in tandem with some kind of waterfall or tree visualization, preferably with arrows connecting causes and effects and icons or colors denoting the state of each promise. Ideally we could get such an interface on track to be included in Web Inspector or Firebug.\n\nAlso, ideally this interface would be able to receive messages for _remote_ events as well, but let\u2019s not push it.\n. @Tuskan360 the latest release already does this as a stopgap. It posts \"Should be empty: []\" to the console log. This is a live array of all the rejections that have no handlers attached. When you create a rejection, the corresponding error gets added. When it is handled, it is removed from the array.\n. Looking forward to trying this out!\n. @domenic I\u2019ve got my share of gists piled up. It sounds like a good idea to gather them all up. We can worry about narrative and organization later.\n. On Sun, May 13, 2012 at 6:00 PM, Steve Marx\nreply@reply.github.com\nwrote:\n\n> IE9 (no idea about other versions) seems to only define window.console if the developer tools are open. Q calls console.log and thus won't (fully) work in IE9. Everything past the call to console.log presumably doesn't get executed, but it's hard to verify, given that this is a Heisenbug. (Opening the dev tools will cause Q to work fine.)\n> \n> There's only one call to console.log in q.js, but I didn't understand its purpose well enough to just create a pull request. I would suggest wrapping console.log in an `if (window.console !== undefined)` or simply removing the call.\n> \n> FYI, a workaround is to include this line of script above the script tag pulling in q.js: `if (window.console === undefined) window.console = { log: function () { } };`\n\nOops. I can fix this either by not calling it or shimming it. This is\na problem in other browsers too!\n\nKris\n. Nice catch, @domenic. I think we should (1) factor out our use of Function.prototype.bind. That should be relatively easy.\n. We can drop Node v0.4 support, I think. I can alter .travis.yml.\n. Sure\n. @domenic I would like to retain a copy of ref send in the repository to make it easier to study the project. Perhaps we can create a directory for it and put other related bits in there.  Maybe `archive`, or subsume it under `design`.\n. Embarrassing. Thank you.\n. @danfuzz, In Q, `promise.when` is an alias that forwards to promise.then. `promise.then` in turn is implemented with Q.when. Internally, this uses the \"when\" message. The words bear the same meaning, but the implementation is wishy-washy about which work should be used for static (Q.when) and dynamic (promise.then, (but also aliased as promise.when)). Q assimilates objects that implement \"then\" (thenables) into Q promises, but it does not do the same for \"whenables\" because such things do not exist in the wild.\n\nIt\u2019s a bit of a mess, being stuck between the trends in JavaScript and trends in forebears like E.\n\nMy inclination is to keep Q.when and promise.then, and remove promise.when so at least you can go by the rule \"what makes sense when spoken\", but on the other hand, MarkM\u2019s favoring Q(promise).when in the Concurrency Strawman, which I would like to support.\n\nWhat I mean by the mnemonic, these are the natural choices of words, and the corresponding implied usage in Q.\n\n\"When A, B\", Q.when(A, B)\n\n\"A then B\", A.then(B)\n. @forbeslindesay This looks like a good fix to me.\n\nLet\u2019s make tests to verify the progression.\n\n@domenic I would like to move in the direction of using Jasmine and eventually removing the previous CommonJS testing scaffold.  However, we can\u2019t do that until continuous integration with Travis on Node makes use of the Jasmine specs.  Maybe we can even use PhantomJS with Travis to do continuous integration for WebKit.\n. @gozala has previously recommended (privately) that we add `Q.promised` as a function decorator that guarantees that the return value is a promise, and guarantees that all arguments are fulfilled before calling.  This is a function that he uses in his work at Mozilla. I am hesitant because, for remote objects, using \"when\" actually ought to be very uncommon, favoring the message passing forms, like \"get\" and \"post\". It would be common to pass an unresolved promise to a function and for the function to interact with the unresolved promise through asynchronous message passing.\n\nThat probably does not diminish the utility of a wrapper for synchronizing arguments. I will entertain the introduction of `Q.promised`.  I\u2019m not sure about the color though.  Does anyone have a better idea for the name?\n. Let\u2019s close this issue and open a new issue for an orthogonal `Q.promised` function decorator.\n. The way remote promises should work (they are presently broken in Q-Comm) is that the promise will be locally resolved in \u00bd RTT from the remote resolution.  The local resolution will have the promise API for passing messages to the remote promise.  Like this:\n\n``` javascript\nvar remote = getRemotePromise();\nremote.get('a') // works here, and will resolve in \u00bd RTT of remote resolution\nremote.then(function (remote) {\n    remote.get('a') // will resolve in 1 + \u00bd full RTT after remote resolution\n   // a minimum of 2 round trips from the previous event\n})\n```\n\nAs you can see, \"when\" will _always_ introduce latency by waiting for synchronization.  The only reason to wait for a remote promise is to way for synchronization side-effects, which should be relatively rare for performance reasons.\n. Blocking on #78.\n. I\u2019m open either way. Anything that helps me not look like Don Quixote for supporting Q is a win.\n. I\u2019m actually open to the change. Mirroring JavaScript\u2019s semantics was the original reason for the choice, but at the end of the day, that is a non-goal (as exemplified by switching from call to fcall & al), and the suggested semantics would be strictly more useful.\n. I have considered making `.end` forward to non-catching callbacks, exiting the purview of the promise system and returning to plain CPS.\n. Oh, not necessarily Node\u2019s CPS style.  `.end(callback, errback)` is what I have in mind, and both callback and errback would not consume exceptions. A different method that explicitly mentions Node would be appropriate for transferring control to a node callback. I don\u2019t think we have one of those yet either.\n. `nend(cb)` does return a promise but it\u2019s only to make it easier to test. I might remove it and use waitsFor and a spy in the spec.\n. @domenic I need to read this thread top-to-bottom again. I haven\u2019t made a decision, and have not committed to `nend` and `done` and `ndone` are still on the table.\n. `nend` needs a different name. I\u2019ll buy `done` as you propose.\n. `nend` stands for \"if the user provides a nodeback, transfer control to Node-style continuation passing. otherwise, return the promise, so this function can be used by both promise consumers and nodeback providers\". That\u2019s a mouthful and might be hard to capture, but I\u2019ll buy up to three words and no more than 80 characters.\n. Some potential seeds for the name:\n- cb\n- toNode\n- toNodeback\n- maybeToNodeback\n- ambidextrous\n- ambi\n. - honeyBadger\n- nodeCompatible\n. - supportNode\n. We could postpone displaying the message to the first time an error is captured. https://github.com/kriskowal/montage/blob/master/core/promise.js#L710-736\n. https://github.com/motorola-mobility/montage/blob/master/core/promise.js#L710-736\n. @domenic I\u2019m still isolating issues locally with one of my projects on the latest release. Let it cook for a bit. No longer than a week.\n. Published 0.8.6 to NPM. Updated, tagged, and pushed.\n\n@domenic Let me know what your NPM user name is. I\u2019ll give you publish rights so if it turns out to be a lemon, you can publish a patch release.  Lydia and I will be on foot, far from the nearest road or cell reception for about a week, starting tomorrow, returning on the 10th.\n. I will entertain a `Q.onerror = handler` API for this, but not this patch as-is.\n. @e4f, ah right. Will have to think more on it.\n. @domenic Let\u2019s remove the defense of `exports` and add `onerror` and `longStackTraceLimit`.\n. Looks good from cursory inspection to me too.\n. Ah, yeah. That is an error. @domenic that looks fine.\n. @forbeslindesay If you use RequireJS and Jam in your projects, I would be willing to delegate that job to you. I cannot be trusted with the responsibility.\n. Thanks!\n. @briancavalier I\u2019ve reproduced and came to the same conclusion. There is a cycle where Q and When are taking turns coercing eachother\u2019s promises with their `resolve` methods. As part of this process, they both call `.then` on the other.\n\n`when` can break the cycle by attempting to normalize the promise to a fulfilled value with `promise.valueOf()`. I\u2019ll send a patch.  I imagine `Q` could do something similar, but I don\u2019t see an implementation of `valueOf` or `nearer`.\n. @domenic I suspect so. I\u2019m favoring `valueOf` since the default implementation is harmless.\n. We might be able to infer from the arguments length provided to the node resolver whether to provide a single value or an array of values as the promise resolution.  It\u2019s clunky, but it would work.\n. @shockie Does this pattern suggested by @domenic work for you? If so, I\u2019m inclined to close the issue.\n\n``` javascript\nQ.ninvoke(mysql.connection, \"query\", \"SELECT * FROM table\")\n.spread(function (rows, fields) {\n    // ...\n});\n```\n. I\u2019m on the fence on this one.\n\nSome issues are that the library is getting bloated, though this would be a minor offender, and it might be better to have a name like `thenResolve` to avoid overloading the already double variations of `resolve`. I do like it though, and have wanted this myself.\n. @domenic that has been my experience as well.\n. I\u2019m also +0 for `thenResolve`. That rounds to an even +1. Pull requests welcome.\n\n@domenic Let\u2019s track a refactor separately. I\u2019ll add my comments to that issue.\n. @jamesmgreene The file structure won\u2019t change in the 1.0 timeline. It might change in the 2.0 timeline, but probably not this drastically. The trouble with the Promise API is that every additional method on the promise interface is exposed on every promise. That said, I did do an experiment in [Montage](https://github.com/montagejs/montage/blob/v0.11.0/core/promise.js) to make the Q object itself extensible by way of Q.create(descriptors, promiseDescriptors). This facilitated parallel extension to each of the promise interfaces (DeferredPromise, RejectedPromise, FulfilledPromise). The experiment relied heavily on an OOP style which lost implicit method binding, so some hybrid approach might be in order.\n. See: #361 \n. Alright, I\u2019ll entertain it as an experiment. It does have the theoretical flaw that progress through a conjunction is not necessarily bound by the progress of a single operand, but you can work around that case explicitly.\n\nConsider this case:\n\n``` javascript\nvar A = fast();\nvar B = slow();\nvar C = Q.when(A, function () {\n    return B;\n});\n```\n\nI\u2019m curious how that plays out. I\u2019m guessing that you get a journey to 100%, then a drop to whatever the progress on B is at that moment, and a slow progression back up to 100%.  That, or you go quickly to 100% and stall.  I would have to experiment, but I\u2019m presently working on something else.\n. Thanks for the legwork. The jsfiddle is insightful.\n. I like the idea of translating the progress in the progback. It would also follow that progress is a single value, so we should need to lock down the arity of the progress emitter.\n\nIt is probably okay, for the purpose of progress notifications, to assume that the operation will not fail, and to reset the progress to the resolution of the handler.  It is probably also okay to assume that a finally clause will not cause further delay (though this is not a guarantee).\n\nMaybe it is okay for progress to pass-through by default, and to be able to adapt the progress in the progback.  We would probably also need ways to compose progress values from other promises in the progback, perhaps analogously to how we compose promises in callbacks and errbacks.\n\nPerhaps progress values need to be promises themselves so we can use the same composition techniques.\n\n``` javascript\nvar A = chicagoToBoston();\nvar B = bostonToChicago();\nvar C = Q.progress(A, function (aProgress) {\n    return Q.progress(B, function (bProgress) {\n        return // ?\n    });\n});\n```\n. @domenic I\u2019ll leave it to you to decide whether to merge #121.\n. This is in master.\n. This is in master.\n. @suedama1756 I sympathize. I did not invent this API \u2014 I copied Tyler Close\u2019s ref_send and elements from Mark Miller\u2019s E including the terminology. I was also tricked by the API into thinking that resolution and rejection were opposites. This was the first implementation of `isResolved`:\n\nhttps://github.com/kriskowal/q/blob/bae841881c44f413d1502ee44c323d66a478c025/lib/q.js#L213-218\n\nI later fixed it and added `isFulfilled`.\n\nThe confusion comes from the fact that Deferred has `deferred.reject(error)` is shorthand for `deferred.resolve(Q.reject(error))`, and `deferred.resolve` does double-duty for `deferred.resolve(promise)` and `deferred.resolve(value)`. The original promise library only had `promise` and `resolve`, so there was little confusion that `resolve` was for all three: `fulfill`, `reject` and postpone.\n\nThe problem might be mitigated by adding `deferred.fulfill` as a shorthand for `deferred.resolve(Q.fulfill(value))`, but that would not be particularly useful since `resolve` checks for non-promise values internally.\n\nIt would not make sense to relieve `resolve` of the responsibility of discerning promises and values because the return values of functions can be either, and resolve handles both cases.\n\nIn any case, I write this so you know that I don\u2019t dismiss your arguments off-hand. It is a genuine puzzle, turning the library I found into something people can actually learn, debug, and deploy.\n. :+1:\n. Okay. Let\u2019s make a note to remove `end` in the v0.9 timeline and to inform Mark Miller that the concurrency strawman would be out of sync in that regard.\n. Thanks for tracking this. I\u2019ll try to make a decision today; we have enough options.\n. :+1: `nodeify`, I choose you.\n. That\u2019s not so bad.\n\nLet\u2019s not worry about `Q.master` at this time. It is not locked down yet.\n\nTesting the module loader shims is out of scope, unless a supporter makes a test that fits in our scaffold. I imagine it would involve adding a dev dependency and using an iframe.\n\nWe could probably mock a generator for `Q.async`.\n. I\u2019m okay with this for the v0.9.0 timeline. I do want to get to 100%, so going to move this out. We can mock a generator to get coverage for Q.async and Q.return off Firefox. Q.master can be speced in the context of Q-Connection, but not many folks are using it and it could change.  I\u2019ll look into teasing the second if (done) out.\n. Stale. We should do another code coverage campaign perhaps in 1.0, but closing this for 0.9.\n. Also, inform Mark Miller that the concurrency strawman would be out of sync.\n. @domenic mentioned the change of end/done in a thread to Mark, so this is all wrapped up.\n. Callbacks are issued in the order that they are scheduled. It corresponds in this case with a breadth first traversal of the tree of promises you\u2019ve created.\n. It\u2019s the same situation. I\u2019ve annotated it with comments that indicate a breadth-first traversal. Note that \"fin3\" comes at node 6, \"fin1\" at node 7, and \"fin2\" at node 8.\n\n``` javascript\npromise // 1\n    .then(function(v){ // 4\n        console.log(\"then1\");\n    })\n    .fin(function(){ // 7\n        console.log(\"fin1\");\n    })\n    .end();\n\npromise // 2\n    .then(function(v){ // 5\n        console.log(\"then2\");\n    })\n    .fin(function(){ // 8\n        console.log(\"fin2\");\n    })\n    .end();\n\n\npromise // 3\n    .fin(function(){ // 6\n        console.log(\"fin3\");\n    })\n    .end();\n```\n. Take a look at the implementation. Everything is composed from `then` and `nextTick`. The `nextTick` might make a callback occur later than a parallel chain, but in general, everything follows from the same principles.  For what it\u2019s worth, Q does not go to great pains to ensure a particular scheduling order. If you need a particular order, synchronize with a promise.\n\nhttps://github.com/kriskowal/q/blob/master/q.js#L1590-1605\n. Looks like a legitimate case to me. We should add it to the test suite.\n. Well, I had hoped that would never come to be an issue, alas. So much for being clever.\n\nWe will have to rename `valueOf` to something to the effect of \u201cfollow the chain of transfers from promise, to promise, to the fulfillment value if possible, and return whatever value lies at the end of the chain\u201d or in promise-speak \u201creturn the most resolved form of this promise\u201d, which aligns with the name `near` or `nearer` in the vernacular of the TC39 Concurrency Strawman and the Ref Send Q API.\n. @domenic I suppose that would do the trick. Perhaps a quick-fix in the `valueOf` function, which already does some checks to make sure it doesn\u2019t blow up.\n. On Sunday, November 4, 2012, Domenic Denicola wrote:\n\n> Wow, I didn't know we returned promises from deferred.(resolve|reject).\n> And I think it's clearly a bug that we return differently each time. I'm\n> definitely in favor of always returning undefined; @kriskowalhttps://github.com/kriskowal\n> ?\n> \n> That's fine. I find it unlikely that the return value is used by anyone,\n> and if so, that they should.\n. I really don\u2019t. I\u2019ll defer to your judgement, @domenic. In the end, we will just need more practice with progress to get a better idea. I reserve the right to ax it outright in the future if it turns out that the feature is useless or hazardous.\n. On Sat, Nov 24, 2012 at 5:05 PM, Domenic Denicola\nnotifications@github.comwrote:\n\n> I'll try running it by the continuum then but my natural instinct is to\n> throw in nextTick, as dangerous as that can be.\n> \n> Sounds sane to me.\n. The first log is because I added a stack trace to deprecate. It is not an error.\n\nThe second stack trace is definitely an error.\n. For what it\u2019s worth, we could extract the relevant file and line number and just display that in the deprecation message instead of dumping the whole trace. That\u2019s all I think we need to make it easier to track down and update deprecated lines.\n. That is certainly a backward-incompatible change. Alas. We might have to put it back and maybe find a way to radiate a warning if it\u2019s used (no idea how, just thinking aloud here) and remove it in v0.9.0.\n. I still want to discourage the pattern. The fact that it works even though it is not correct usage is confusing.\n. Alright, we\u2019ll play it that way until we get significant back-pressure from users.\n\nIf we didn\u2019t have so much piled up under deprecation warnings, and so many plans for changes right now, I would say it\u2019s time for a 1.0.0.\n. @geowa4 Seems like a valid simplification to me.\n. @ForbesLindesay @domenic It is fine in general, because `object.valueOf()` falls to `Object.prototype.valueOf`, which returns `this`\u2026unless object is an heir of null.\n. @domenic and technically it is overridden for boxed types like `new Number(10).valueOf()`. Date is the only one where I could see it being a genuine problem to user `valueOf` though.\n. I can\u2019t help but suspect we will see this problem a lot unless we do something about it. It would be completely within our power to coerce a string into an exception.\n. There were two motives for changing `Q.call(func, thisp, ...args)` to `Q.fcall(func, ...args)`.\n1. Q.fcall will be used for RPC and will probably cross language boundaries. `thisp` has no place there.\n2. I intend in v0.9 to align Q with the Mark Miller\u2019s Q strawman and make Q into a function. Functions have their own notions of `call`, `apply`, and `bind`, so those methods of Q had to be moved to make room.\n\n`ncall`, `napply`, and `nbind` are different beasts. They cannot function without a proper `thisp`, so it makes sense to retain them in that interface.\n\nSo, while I can see that there is a mismatch and that is confusing, I don\u2019t think we can change. That said, suggestions are always welcome.\n. To clarify, @thesmart is recommending that we remove `thisp` from the `n*` methods and requiring folks to call `.bind` if they want an alt `thisp`. I could buy that, but we would need to also take the opportunity to rename the methods and deprecate the old ones. People are using them.\n\nThankfully, I was never satisfied with the names, and we\u2019re moving in the direction of more verbose alternatives like `nodeCall`, `nodeBind`, and `nodeApply`.\n\nAnother consideration is that I intend to rename `invoke` to `send` in v0.9, so `nodeSend` and `nodePost`.\n. Or `callNode`, `bindNode`, and `applyNode`.\n. @domenic We can take that up with Mark Miller. My basis for choosing \"invoke\" was an imagined alignment between the method names of a Proxy and Promise handlers. Of course, even the matter of _whether_ Proxy handlers will support an \"invoke\" method is unsettled, though the present notion seems to be that such a method will not be supported at all.\n. \u2026there just seems little question that if Proxy handlers supported method invocation, it would be called \"invoke\" as I\u2019ve done here.\n. I\u2019ll buy `nsend` (or `ninvoke`), `npost`, `nfcall`, `nfapply`, and `nfbind`. That should probably resolve the confusion, and I\u2019ll leave it as an open issue whether to retain or deprecate `ncall`, `napply`, and `bind`.\n. Looks good to me.\n\nLooks like continuous integration timed out for one of the engines, but is presently passing. I\u2019m not worried about landing this change.\n. Do you have a moment to add a test case that failed before this change and passes after?\n. Alright, thanks. I guess that\u2019s not something we can put in the suite, but it proves the point.\n. We have a `promise.timeout(ms)` method. Got a moment to try that approach. I would not mind if you would squash (using `git rebase -i`) the commits and force push to your branch (`git push -f`). Don\u2019t try it if you haven\u2019t done it before though; I can do it on my end.\n. @domenic Is this fixed with the redo on long traces?\n. That\u2019s odd since the `.fail(noop)` constitutes handling the exception. Maybe there is an error in the code that maintains the parallel error and rejection arrays.\n. I may have fixed this with d5f46b9d1dfe786c49d535a5812991deabb2ac68. I will attempt to reproduce.\n. Yes, on my side, memory usage grows unbounded before d5f46b9 but is level after the change. Rejections were getting duplicated in the unhandled rejection log. Thanks.\n. Thanks for catching this.\n. Thanks. With a fresh look at the example, the reason you\u2019re getting the rejection is that Q displays the log at the first time anything is rejected.\n\n@domenic and I were just thinking of an alternative view of `nextTick` that might be useful. We could postpone displaying the log until the next tick queue empties, which would make the pernicious appearance of the log happen less frequently at least.\n\nAs always, the real solution to this problem is to make extensions for all browsers and environments that shows a live view of all pending and rejected promises.  We could detect the existence of such an extension and silence the log entirely.\n. We are not making progress on this issue. Perhaps when evergreen engines all have a promise inspector per #361 it will be practical to remove the console.log stopgap.\n. I have been thinking about it for other reasons. We'll track the issue\nhere.\n. I would close this issue and open some new ones:\n- create a method akin to `Q.all` that replaces the properties of an object that are promises with their fulfillment values and fulfills to that selfsame object, or rejects on the first fail.\n- for further consideration: use `Q.spread` implicitly to resolve the arguments of all message dispatchers, thus `promise.put(key, promiseForValue)` would work, which might be useful for Q connection and has at least once been recommended by @gozala. This would obviate the need for the `Q.promised` wrapper. I am rounding back to this idea. The reason for not doing this is that it becomes impossible (presently) for a promise to be passed as an argument without `then`ing on it, which would be a problem for remote promises. However, I am thinking of adding a remote promise wrapper that would resolve to itself instantly, which would solve that problem. I\u2019m also thinking of `push` and `pull` methods on promises.\n. Thanks @slaks!\n. Thanks @arikon. I\u2019ll look for opportunities.\n. I have done an OO design of Q with an identical API elsewhere, to address these performance issues. That design unfortunately exposed private data which I observed was inevitably abused, no matter how many underscores were added to those properties. In principle, it is certainly faster and puts less pressure on the garbage collector.\n\nMy intent is to do another iteration of Q that uses WeakMap in the v0.10 timeline. I might be able to address performance issues with that version without breaking encapsulation.\n. It would be a simple matter to remove the isFulfilled optimization.\n. This for the v0.8 branch.\n. k\n. This would be shallow. I had `deep` in QQ and it turned out to be a hazard, so I will not bring it back.\n\nI would prefer to allow the user to explicitly distinguish whether they want to the value to be treated as an object or a collection. I would like `Q.all` to be able to handle array-alike objects in the future (if it does not already), and implicitly distinguishing an array-alike from an object that just happens to have the same properties would be too much cleverness for my taste.\n. `for in` should be sufficient for this one.\n\n`all` would delegate to `forEach`, but we still have to consider the case where arrays do not implement their own.\n. Punting to a future release.\n. Making the tough call here. Q will not support this feature.\n. The negative impact I expect from this is that a remote invocation passing a remote promise would wait a full round trip before delivering the invocation message. This case is probably enough of a reason to close this issue.\n\nThis one case is enough that I\u2019m convinced I do not even have to ask @erights whether this is a bad idea. Summarily, closing.\n. Superseded by #162.\n. @forbeslindesay I\u2019m not keen on maintaining this file in parallel with package.json. I presume that these both pull directly from Github. If you would like to maintain this file in parallel, why don\u2019t we publish your repo as the authoritative version for that ecosystem.\n. @forbeslindesay Yes, you\u2019re welcome to add it to the README in the section describing supported platforms.\n. @arikon I could buy that too. It\u2019s more work for me, but at least that would guarantee that I would not forget to make, commit, and push the changes to component.json.\n. This is not the most productive place to have this debate. I have opinions, but no interest in debating them, especially here where they won\u2019t be heard by the makers of `component` and `bower`. I bent Q to support RequireJS, even though I\u2019m ideologically opposed, so there is precedent for concessions. The responsibility of supporting and testing these alternatives just has to rest in someone else\u2019s hands.\n. @forbeslindesay Since the implementation does not satisfy your intuition in either case, recognizing the state of foreign promises is an orthogonal issue.\n. Needs spec.\n. This is like `nodeify` in that it returns a promise if you don\u2019t specify a callback. `done` returns `undefined` unconditionally and captures errors in `callback` and `errback`, so it does not escape the promise \u201cdomain\u201d.\n. The use-case is just like `nodeify`. You want to provide a function that supports traditional continuation-passing-style (the `cb(v)`, `eb(e)` kind instead of the `nb(e, v)` kind), but users can opt-in to using promises by omitted in the callback and errback.\n\nThe promise usage:\n\n``` javascript\ndoAsync(a, b, c).then().done()\n```\n\nWith the callback pattern, exceptions must escape the promise \u201cdomain\u201d, so an exception thrown by `cb` halts the program, and an exception thrown by `doAsync` goes to `eb`, and if no `eb` halts the program.\n\n``` javascript\ndoAsync(a, b, c, cb, eb)\n```\n\nAnd the pattern for providing the feature:\n\n``` javascript\nfunction doAsync(a, b, c, cb, eb) {\n    return work(a, b, c)\n    .pass(cb, eb);\n}\n```\n. @domenic It\u2019s a good point. Most precedent for cb/eb is from Python Twisted. There is some precedent in the W3C geolocation API http://dev.w3.org/geo/api/spec-source.html and win/fail is common in Phonegap. This interface would allow this kind of API to migrate gracefully without forcing users to learn about promises.\n. Dropping.\n. Needs spec.\n. @domenic I believe so. Did I get the deprecate call wrong? I can\u2019t imagine what else would cause the problem.\n. Yeah, perhaps unwisely.\n. They would also need to support `rejectedPromise.valueOf().exception` to identify rejected promises. I\u2019m not married to `.valueOf()`, for what it\u2019s worth. The same could be solved with the `.nearer()` name per the concurrency strawman, or `.nearest()` or `mostResolved()`.\n. @forbeslindesay, this just means that we must always check isPromise first.\n. This is as solved as it\u2019s going to get in this forum, I think. Let me know if you think otherwise.\n. Also looks good to me.\n. @mike-spainhower Thanks for letting us know. I should try to find a good summary of progress on all the performance issues with frozen objects.\n. Yeah, this looks good to me.\n. This is a duplicate of #159, which is open and accepted. Thank you for weighing in.\n. For future reference and reproduction, the above data were extracted from a query that @isaacs graciously put together.\n\nhttp://isaacs.iriscouch.com/registry/_design/scratch/_view/dependentVersions?startkey=[%22q%22]&endkey=[%22q%22,{}]&group_level=3\n. This is as done as it\u2019s going to be.\n. First, thanks for contributing, @pcottle. Unfortunately, this does not actually solve the problem but rather masks errors that might otherwise need to be displayed. Note that around line 661, the only condition when `displayErrors` is called immediately precedes adding an error to the list (which arguably should be before, but we are depending on a live console for this to work at all).\n\nhttps://github.com/pcottle/q/blob/9d0d64021ea5d4a46d69acaaed989b5e6d2941b8/q.js#L661\n\nA proper solution for this would be to revise `nextTick` to flush an internal event queue and only to call `displayErrors` if there are any outstanding errors before yielding to the parent event loop.\n. I may be misreading (you might try a pull request next time so we can see the patch), but I suspect that `spread` does what you want.\n\n``` javascript\nQ.spread([oneP, twoP, threeP], function (one, two, three) {\n});\n```\n\nA good reason not to make this change in `when` is that it would mandate that all promises must be promises for arrays.\n. Thanks @forbeslindesay. @redsandro, please feel free to reply with further questions or close the issue if this answers your question.\n. @redsandro, Please reopen if you\u2019re not satisfied.\n. @redsandro, it is the case that exceptions thrown in any callback managed by Q are converted into asynchronous exceptions (rejected promises). You can escape this \u201cpromise domain\u201d by executing a callback with setTimeout, or Q.nextTick, or any other mechanism that executes your callback in a separate event. You can also just call `.done()` at the end of your promise chain and that will convert any asynchronous exceptions back into synchronous exceptions.\n. Closing. Please reopen if symptoms persist. Post an `npm-error.log` if you can.\n. I\u2019m super-hesitant to add to Q; much more inclined to remove at this point. I think we have all the small, combinable primitives we need, and a lot of the sugar we don\u2019t.\n\nIn any case, this example resembles a [Schwartzian transform](http://en.wikipedia.org/wiki/Schwartzian_transform), which is a cool pattern I get a lot of traction out of.\n\nI\u2019m not sure how reusable `step` is. It strikes me that you\u2019d get a cleaner and more pipelinable result with `invoke/post`, provided that each mutator returned `this`.\n\n``` javascript\nfunction doStuff(input) {\n    return Q(new Foo())\n        .invoke(\"step1\", input)\n        .invoke(\"step2\", input)\n        .invoke(\"step3\", input)\n}\n```\n. I\u2019m adding this spec,\n\n``` javascript\n    it(\"assimilates a thenable in allResolved\", function () {\n        return Q.allResolved([\n            {then: function (win, fail) {\n                win(10);\n            }}\n        ])\n        .then(function (promises) {\n            expect(promises[0].isPending()).toBe(false);\n            expect(promises[0].isFulfilled()).toBe(true);\n            expect(promises[0].isRejected()).toBe(false);\n        });\n    });\n```\n\nAnd it passes. Note that Q.isResolved is not in v0.9 since we migrated to using Q.isPending.\n. Deferring with a timeout fails:\n\n``` javascript\n    it(\"assimilates a pending thenable in allResolved\", function () {\n        return Q.allResolved([\n            {then: function (win, fail) {\n                setTimeout(function () {\n                    win(10);\n                }, 100);\n            }}\n        ])\n        .then(function (promises) {\n            expect(promises[0].isPending()).toBe(false);\n            expect(promises[0].isFulfilled()).toBe(true);\n            expect(promises[0].isRejected()).toBe(false);\n        });\n    });\n```\n. Thanks, I\u2019ll take this.\n. Awesome, been waiting for that bit of good news. I wonder which callback resolves the returned promise if you provide more than one fulfillment or rejection handler.\n. It\u2019s also grossly inaccurate now, and should be rewritten entirely.\n. Damn, @domenic. You killed it.\n. Jury is still out\u2026\n. Tests pass now. Lots of ugly errors on the console, but that\u2019s fine for the tests.\n. I\u2019m a bit mystified about what\u2019s going on in the context of Jasmine, but outside of Jasmine, the simple case works. Not sure that this will be okay in the long run, but want to give it some bake time.\n. @domenic You\u2019re more than welcome to port the suite to anything you like. I like what I see coming out of the promise/a+ specs, and yeah, testling/testacular would be winful.\n. The results of that benchmark are odd. I wonder what the engine is doing to get around O(n) shift.\n\nIn any case, you\u2019ve done a marvelously rigorous benchmark. Many thanks.\n. @domenic that would either leak, or they would have to chose to copy back to offset zero to avoid growing the underlying allocation periodically. I would not put it past them, but it\u2019s still amortized O(length).\n\nI did a little peek and it seems that the list case is dominated by lots of discrete allocations and probably also shape changes (since nodes aren't declared with both value and next properties in that example). I made another spec that uses a free list and the picture is rather different.\n\nhttp://jsperf.com/list-vs-array-queue\n. I\u2019ll have to think about it. My instinct at this point is make the code simpler, but nextTick is very hot code too. I should compare performance of a real-world performance-sensitive load on Node and in the browser. Performance gains in nextTick have a multiplying affect on promise code. A lot of performance gains in Q boil down to avoiding nextTick at all.\n. @rkatic That implies that free list had no impact on the previous revisions and the performance gain was entirely based on declaring nodes with all their eventual properties. That\u2019s a bit hard to believe and I will need to verify it.\n. Thanks, @rkatic. I love the care going into this change.\n. The problem is that you have to use the `.progress` call directly on the promise producing the notifications, which you can do using the third callback argument of `then`, or by using the `progress` method _before_ the `then` call.\n\nThis is because it is nearly impossible to infer, and no default inference is dominant, how much more time a promise will take to be fulfilled if you call `then` on it.  The callback might return another promise with its own progress notifications.\n\nI\u2019ve been putting my incomplete thoughts down about this, here https://gist.github.com/4569136\n\nSuffice it to say, progress propagation is not well-understood in any research or prior art I know of. Whether we should even try to incorporate progress notifications on promises is dubious, because it will result in a lot of confusion like this.\n. @iamwilhelm I don\u2019t think we can make it possible to call .progress after .then, but _any_ help syncing the documentation or making things more clear is greatly appreciated.\n. @iamwilhelm Please at least temporarily discard my advice. I need to bone up on how this works. @domenic is the expert on how our progress notification works.\n. Awesome, thanks.\n. I\u2019m pretty unsatisfied with `nf*`, in general. It strikes me that binding `this` is a pretty common need. I wonder whether we were too hasty in eliminating `n*`.\n. I\u2019ve been mulling `qify`, which I\u2019ve seen elsewhere.\n. The node-specificness is actually important, since we could conceivably work with multiple callback patterns.\n. Green light for Q.denodeify for v0.9.\n. I presume that this is now invalid.\n. I think I\u2019ll buy it. We can adjust as necessary, but it looks good to me.\n. Landed. Really wanted this for v0.9.\n. I gave Istanbul a try. Thumbs up.\n. @domenic I just might.\n. It\u2019s a tough call. If we keep keywords as the primary recommended interface (which is consistent with the decision on TC39 to use collection.delete), we should document them like promise[\"delete\"] to make it clear that they are special. My intuition is that, for the time being, fin/fail/del are the primary interface, and the keywords are aliases highly recommended for CoffeeScript.\n. I\u2019m content.\n. @domenic This is not something we have worried about in a long time. Please consider closing, or revisiting.\n. @pudgeball Can you describe an example and expected behavior for the case you have in mind just to verify that this is the same case?\n. I\u2019ll remove it from .npmignore. Thanks.\n. I\u2019m going to leave it around in the off-chance it saves some-one\u2019s bacon to be able to mark a value with a then method as a non-promise.\n. Supposing you were using: https://github.com/polotek/procstreams\n\nA procstream has a then method, but is not a promise.\n\n``` javascript\nfunction getStream() {\n    return prepareToGetStream()\n    .then(function () {\n        return Q.fulfill(procstream(\"cat README.md\"));\n    })\n}\n```\n. At the end of the day, if this is the only valid use-case, naming it Q.notAPromise(value) might steer folks away from misery.\n. Yeah. Revising the name again: Q.nonPromise(x).\n. This time, not finally.\n. Accepting #195 in lieu of this.\n. We need to put `nbind` back.\n. I think we should stick with Q.nbind.\n. @domenic Yes, I think we should push back on Jam on this one. I also have nonstandard extensions package.json in Mr/Montage that fall back to the root of the package.json. @caolan\n. This is not the intended behavior of promise.all(). The promise should be a promise for an array of promises.\n\n``` javascript\nQ([p1, p2, p3]).all()\n```\n. @Skalman something like:\n\n``` javascript\nreturn Q(f1())\n.then(function (a1) {\n    return Q.all([a1, f2(), f3()])\n})\n.spread(function (a1, a2, a3) {\n    return f4();\n})\n```\n. Assigning this to @domenic to get it out of the triage queue, but again, this is a great task for a member of the community.\n. How do you feel about making `promised` implicit to message dispatch?\n. Punting this to a future version. I need to play with the idea of implicit `promised` in both the general and specific cases.\n. I believe that generators make this a non-issue. Closing. Please feel free to reopen if you have strong feelings about this direction.\n. I\u2019m punting this. No more milestone.\n. I\u2019m putting this on the 1.0 milestone. Let\u2019s re-evaluate which methods we will retain on the constructor and the prototype. We can shoot for a leaner Q in this backward-incompatible release.\n. The comparative simplicity of this solution is desirable on its own. Are you sure enough, @rkatic, that this would be a good merge? If you are, I\u2019ll take it.\n. I\u2019m not going to worry about exception report order.\n. Yes.\n. \u3003\n. It is a Unicode DITTO MARK, meaning \u201cexactly what @domenic said\u201d, which did include a +1.\n. Yes, returning a thenable implicitly attempts to coerce that to a promise. Marking objects with \"then\" methods that are not indeed promises is probably the only legitimate use of `Q.fulfill` and one our forebears have probably not accounted for.\n. @rkatic It is not so much a question of willing as able. Detecting whether an object is a thenable or just happens to have a \"then\" method is very messy. If it is not a thenable promise, we should not be calling its then method, and even calling the then method is not sufficient in every case to distinguish it from a promise, a badly behaving promise, a poorly implemented promise, or not a promise at all.\n. Let\u2019s take a step back and sleep on this. @rkatic is right that no valid promise implementation would call `onFulfilled` with a promise, unless that promise is for an object that was fulfilled remotely and cannot become a value locally.\n. In the time since this issue opened there was extensive deliberation on recursive flattening and monads on ES-Discuss. @domenic, @erights, what was the resolution of that discussion and how does it apply to Q?\n. Reminder. The ink is drying on the ES6 promise specification. Let\u2019s note the decisions here and wrap it up.\n. If I may state the same more politically, we would be happy to send our users that are interested in using NuGet to your solution.\n\nThank you. It\u2019s amazing how many of these there are now and we\u2019re just overwhelmed. To make this practical, we need to distribute the workload to people who are interested in using and thus verifying that the solution works with these systems.\n. Version numbers are in package.json and in Git tags e.g., `v0.1.19` in Github, or \"0.1.19\" in package.json.\n. The is mailing list, Q-Continuum, mentioned in the README https://groups.google.com/forum/#!forum/q-continuum\n\nI\u2019ll try to be proactive about mentioning updates there. So far, watching the repo has been the most reliable way to see new tags.\n\nI don\u2019t want to bring the nuspec upstream. Thank you for offerring though.\n. Vicious cycle detection would entail a check in deferred.resolve(value) to verify that Q.resolve(value).mostResolved() is not equal to deferred.\n. Well, that\u2019d be a bit odd, wouldn\u2019t it.\n. I\u2019m going to leave it alone for now.\n. Thanks.\n. Yes, this is definitely a real bug. This solution is good, in the short term. In the long term, I would like to introduce a `mostResolved` or `nearer` that will always return the last _promise_ in the chain, and not follow fulfillment to the corresponding value. Using that would fix the problem too.\n. Yes, back to our rapid release cycle like we had in 0.8.\n. Let\u2019s talk about some specific API\u2019s that we want to make more convenient and see if there\u2019s a pattern we can classify, or if it would be better to make custom wrappers for each.\n\nSome DOM API\u2019s that would obviously benefit from promises are the `document.ready` promise, XHR (would benefit from Q-JSGI), and IndexDB.\n\nI\u2019ll follow up if I catch a break and can illustrate some of the patterns.\n. I would venture that `q-io` and a new `q-dom` support the cases in combination. My intention is to eventually mirror all the `q-io` interfaces with browser implementations that\u2019d be automatically selected by https://github.com/montagejs/mr and https://github.com/montagejs/mop. I don\u2019t know whether Browserify supports alternate browser implementation mappings but we\u2019d ideally use the same info in `package.json`.\n\nI don\u2019t think there\u2019s enough homogeneity among DOM API\u2019s to have a general purpose promise adaptor. There certainly is a degree of homogeneity in each subsystem, like `onerror` and `onsuccess` handlers in IndexDB.\n. @itsnotvalid It would be sensible to factor it out. We may or may not. There\u2019s a tension between effort needed to migrate, having a minimal API surface, and having a convenient and complete API surface. One thing that would help unlock the tension is extensible promise API\u2019s, which come with their own level of madness but are distinctly possible.\n. I would like to mine this ticket for Q-IO and Q-DOM issues, but this is otherwise closed. We do not plan to build anything special into Q proper.\n. Thanks!\n. @omares, no, thank you. We are supposed to take care of that before publishing a version. I\u2019ll make a note of it.\n. Yeah, I want it there, even though it serves no purpose but to illustrate the size on the wire.\n. In general, you need to call timeout in the event that you want to begin counting. If you need to begin counting after some other stages, you need to do it inside a `then` or `spread` block after those stages. You seem to have it worked out.\n. I\u2019m going to assume that no bug was found in this process. Please reopen if otherwise.\n. Don\u2019t do any further work until I firmly say whether I\u2019m committed to the change and the name. One data point is that I\u2019ve experimented with adding this feature at least three times and at some point exiled the work to branches.\n\nIf I do commit to adding this feature, it will open a flood-gate for related features. I will need to be comfortable with the overall vision. That would entail having Q.reduce and Q.forEach with sequential semantics. All these methods would need to be added to the Promise prototype as well.\n\nI will also want to use Q.fcall to dispatch messages to promised callbacks.\n. I\u2019m declining. I agree that it\u2019s useful, but not useful enough to expand the surface of the Q core library. The case it simplifies can be express fairly succinctly in terms of primitives.\n\n``` javascript\npromises.invoke(\"map\", callback, thisp).all()\n```\n\n`spread` exists perhaps because I am not entirely consistent in my verdicts, but I think that manual array destucturing is a pretty painful _and_ common problem. It certainly will be deprecated when ES6  becomes common.\n. I am reopening. I have reconsidered.\n. I am going to add `map`, `reduce`, and `forEach`. The semantics of `map` will be slightly different\u2014the `all` to the result will not be implied. The promises could be aggregated in opportunistic order using `reduce`, which will be implemented similarly to `all`.\n. Subsumed in #337\n. It\u2019s a good idea. I have not decided whether to take it.\n. I\u2019ve decided to accept this change when it\u2019s ready. Please document as \u201cexperimental\u201d.\n. I'm going to resist adding this to the core lib. At this point need to focus on making Q subclassable. \n. @redsandro Tough call. `undefined` is a perfectly meaningful fulfillment value, but a promise is not.\n. Use !promise.isPending() as your guard. Generally though, use \"then\" unless\nyou really need to optimize.\n\nOn Tuesday, March 19, 2013, Redsandro wrote:\n\n> Hmm.. this is true. Back when things took time in my node script, I was\n> getting used to being able to use valueOf() that I forgot to check that\n> this is actually documented in the API wiki.\n> \n> I guess in stead of checking for undefined I can do something like if\n> (myPromise.valueOf().constructor && myPromise.valueOf().constructor.name== 'Promise')for now, and start converting all such occurances in my code to a\n> callback-stype wrapper functions to pass along promised values.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/237#issuecomment-15151588\n> .\n. We might have to amputate.\n. For one, `resolvedPromises` will always be an array.  You could use `resolvedPromises.filter(function (promise) {return promise.isFulfilled()}).map(function (promise) {return promise.valueOf()}` to get the array of fulfilled promises, silently discarding any broken promises.\n\nAre you sure you don\u2019t want to use `Q.all` instead?\n. @Redsandro It is not on the promise prototype. You can do it inside your handler. You could also do it with a message though\u2026\n\n``` javascript\nQ.allResolved(promises)\n.invoke(\"filter\", function (promise) {\n    return promise.isFulfilled();\n})\n.invoke(\"map\", function (promise) {\n    return promise.valueOf();\n})\n```\n. Try then...fail. Done means done and returns nothing. It also lets\nexceptions leave the \"domain\".\n\nOn Thursday, March 21, 2013, Alex Osh wrote:\n\n> Why it is not possible to use chaining done(..).fail(...)?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/241\n> .\n. Fail/catch is the appropriate way to handle rejection.\n\nOn Thursday, March 21, 2013, Alex Osh wrote:\n\n> Can I use .fail() to handle rejection or it is not appropriate?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/241#issuecomment-15233054\n> .\n. It seems to me that we need a `makeVariadicNodeResolver` if the number of resolution values is not determinate.\n\nMaking `resolve` variadic is not an option. Promises fulfill to only one value. That value may be an array. Guessing whether to spread is too-much-magic.\n. @killdream That is a possibility. Q.spreading could just be @domenic\u2019s suggestion for variadic, jquery-alike `Q.when`, which would necessarily replace the current semantics.\n. We can expose a method to explicitly release a Q instance.\n. I\u2019ve added a Q.release in branch gh-244. Please let me know if that solves the problem and we\u2019ll merge it.\n. Version 2 of Q is not released. It is in npm but not with the \"latest\" tag. Not sure how CDN.js deals with this, but I presume that the client picks the exact version they want.\n. `spread` is a stopgap for rest/spread structuring/destructuring arguments coming soon to JS.\n\n``` javascript\nP1.doSomething()\n.then(function (one) {\n})\n.then(function ([one, two]) {\n})\n.catch(function (error) {\n})\n```\n. Might run it by the Qx project.\n. Thanks. Probably something simple.\n. This should be fixed at 4a637eef5efa12a3105e71c8b847aa533f832ea5. The minified files were out of sync.\n. That makes sense. We rewrite the stacks so we can add the previous stack trace. Perhaps we should try another approach.\n. @mjijackson Yeah, I would entertain this.\n. It\u2019s a good argument.\n. @ravi There\u2019s a nuance there.\n\n`deferred.reject(reason)` is really a synonym for `deferred.resolve(Q.reject(reason))`.  The argument of `resolve` can be a promise in any state\u2014or\u2014a `value` which gets implicitly boxed as a fulfilled promise for that value (`Q(value)`).\n\nSo, `resolve` can actually transition a deferred to _any_ state, `pending` (through resolving to a deferred promise), `rejected` (through resolving to a rejected promise), or `fulfilled` (through resolving to a fulfilled promise, or simply to a value).\n. The name changes are fine. Looks like it needs a rebase.\n. Thanks\n. We are still working on this one. Not ready for merge.\n. Fixes #261 \n. This has been obsoleted by #337. The central notion is that `close` and `closed` will no longer be necessary. Instead `Queue` will merely be an asynchronous transport for iterations as in ES6 generators. The iterations will carry information like `{value}` or `{value, done: true}`, where the latter implies that the stream has closed.\n. The \"longStacks\" configuration property looks fine as described. I might call it \"longStackSupport\". The default should be \"off\". Long stack support is useless if it does not get shown by debuggers. In the long run, we could escape the problem with a custom debugger, but for now, let\u2019s continue munging the Error\u2019s \"stack\" property.\n. I\u2019ll re-qualify my statement. Long stack support is useless if does not get\nshown.\n. @domenic @tgriesser Using an environment switch or detecting the inspector sound good to me.\n\nAs @erights is likely to mention, exposing `promise.source` is a capability leak and for a secure version, we should put that in a side table and expose it only to debuggers. When we go modular, I\u2019ll bring the WeakMap shim in as a dependency so we can do this properly.\n. Sounds good. I don\u2019t think it needs to be name spaced.\n. I\u2019ve rolled this into #339 which should land for the next version.\n. These have been merged.\n. Yeah, that\u2019ll do the job. We\u2019ll land this. Thanks for the tip.\n. @rkatic do you approve of this change? I do intend to modularize Q, but want to land this first.\n. @domenic Let\u2019s spin off a `next-turn` or `asap` (hahahahahah) package ASAP. We can beat it to death ad nauseam.\n\n(further maniacal laughter elided)\n\nI do not believe that we catch exceptions before nextTick in all cases. Quick scan shows `nodeify` in particular.\n. By @domenic, I mean @rkatic. We would be delighted to put this in your purview and will gladly help in any way we can, including package management if that will help.\n. Superseded by #316\n. I am considering making Q extensible. That would unlock the possibility of factoring out extensions and making a small Q core. I believe there\u2019s an issue for that.\n. @lfac-pt I did this for a fork I did for MontageJS. There would be a `Q.extend(promiseMethods, qMethods)` which would return a `Q` function. It works by augmenting the prototype of all three promise subtypes in parallel (deferred promise, fulfilled promise, rejected promise). However, this version of Q does not use prototypical inheritance much so it might not work out and will certainly not work the same. One thing I intend to do in the course of _this_ issue is to back promises with a WeakMap as in @erights\u2019s `makeQ.js`, which will probably open a door for extensibility.\n\nThe ramifications of having promises with different type signatures, especially for different eventual types of the fulfillment values, make it necessary to have the ability to dynamically cast generic promises to more specific promises on the fly. As such, it will be necessary to add a `.as(Q)` method to promises, e.g.,\n\n``` javascript\nreturn Q(getUserName())\n.then(function (user) { // regardless of subtyping, `then` always returns a basic promise\n    return getRecordsForUserName(user.name);\n})\n.as(EventualArray) // hypothetical Q subtype for eventual/remote arrays\n.reduceEagerly(function (balance, userRecord) {\n    return balance + userRecord.balance;\n})\n```\n\n``` javascript\nPromise.prototype.as = function (Type) {\n    return Type(this);\n};\n```\n. See #394 \n. Very cool. We\u2019ll have to look into making a Saucelabs account.\n. Made an account for myself. I would not mind step by step instructions to make this work.\n. Suffice it to say that I\u2019m not a Ruby fellow. I\u2019m blocked on running `travis` and getting:\n\n`rubygems.rb:230:in `activate': can't activate backports (~> 2.6, runtime) for [\"travis-1.2.0\"], already activated backports-3.3.0 for [\"gh-0.11.2\", \"travis-1.2.0\"] (Gem::LoadError)`\n\nLooks like dependency hell to me, but someone got around this problem by relinking Ruby in Brew. This did not work for me, but then again, I\u2019m not all that big of a Brewer either.\n\nIt\u2019s a shame because I could probably get past this by copying a few OpenSSL commands and filling in the blanks.\n. I gave this a shot again. I have `travis` working properly. The NPM installation, however, fails on my machine. `npm cache clear` \u2014 no dice.\n. @bernil No, I\u2019ve had the problem before and NPM was working fine at the time. I might need to manually purge my cache.\n. I was about to complain, but I think I got confused. You seem to have done what I would have done, in implementing the deprecated valueOf in terms of the new inspect. Will make a closer review.\n. I agree that they should be consistent. I\u2019m torn on which way. I think making a fresh array is less likely to get me lynched, but I do see the \u201cwasteful garbage collector churn mob\u201d out back and I work with some of them.\n. One thing we have going for us is that no-one is likely to notice either way.\n. @rkatic We all agree that consistency is where we must eventually be. This inconsistency came about because @domenic and I wrote these methods separately and each assumed the other had total knowledge of the status quo. You have done us both a favor in pointing out the inconsistency, which all parties here revile.\n. I really like @rkatic\u2019s proposal.\n. Pardon. I am assuming that this whole consistency requirement is a settled issue and resolving ambiguities accordingly. My preference is to apply the insight of one suggestion to both `all` and `allSettled`. Based on this assumption, our collected insights boil down to some options:\n1. Both functions should receive `(inputs, opt_outputs)` and `opt_outputs` should default to a fresh array. If one wants to reuse the same array, it is a matter of passing it as both arguments.\n2. Both functions should receive `(inputs, opt_outputs)` and `opt_outputs` should default to `inputs`. If one wants to produce a fresh array, it is a matter of passing `[]` to the second argument.\n3. Both functions should receive `(inputs)` only. The inputs are reused for the output. If one wants the output to be a fresh array, it is a matter of calling `(inputs.slice())`.\n\nI like the first option.\n. @rkatic, You\u2019re right, problem 2 (`arrayOfArray.map(Q.all)`) makes Options 1 & 2 unavailable as far as I\u2019m concerned. I\u2019m not willing to engage in machinations to detect the meaning of the second argument. That leaves only Option 3 (one argument, use slice if you want a new array), or the unmentioned option (always produce a fresh array, provide no option for reducing memory costs).\n. To be clear, we have not. Decision still pending.\n. > \u201cThere can only be one!\u201d \u2014 McCleod\n\nWe are turning traces off by default in a future release. They will be opt-in thereonout.\n. I actually am wondering whether I might beg a code review from @erights. Is this consistent with the direction of the language? Is this mature?\n. Thanks for this article @andywingo, http://wingolog.org/archives/2013/05/08/generators-in-v8\n. I\u2019m inclined to land this before a thorough review and deal with the consequences as they come. I expect that there will be wonky issues with CSP and the eval to feature test. Not necessarily that it will fail generally, but that it will fail when it should pass. I respect the decision to completely separate and replicate the inner algorithm for Q.async so it\u2019s easier to delete the old path. It will be worth noting that we will not remove the shim _when Firefox upgrades its generators_ but _when no one is using the old generators on Firefox_, presumably a much later date, unless we force forward and leave such users stranded in a backward version of Q (a good option too).\n. I don\u2019t see anything that we can change, unless there\u2019s a way to feature-test for Harmony generators without using `eval`. I will land this as-is.\n. @domenic This is prepped for release. Let me know if you want anything else in v0.9.4.\n. This is a great catch. Thank you so much.\n. Assigning to myself.\n. I presume it throws with a syntax error on compile.\n. Assigning to @domenic, praying he has an idle moment. Of course, this is a _great_ task for a member of the community looking to provide a high impact contribution without too much hassle.\n. It\u2019s true, @domenic\u2019s response was terse and hurried. I\u2019ll apologize on his behalf as his co-maintainer. Let\u2019s try to keep it technical, where we all do best.\n\nI agree that the order of magnitude of difference is suspicious. We\u2019ll have do a profile and see where it went wrong.\n\nThank you for updating with JavaScript. It does help _me_ since I don\u2019t use much CoffeeScript tooling. I know Domenic does and his comments were for my benefit.\n. I think this is moot. The plan is to factor our next \"tick\" implementation into an `asap` package-module-function and use it by that name.\n. \u2026pending the factor into CommonJS modules with browserify standalone. Issues pending there.\n. We would do this in a backward incompatible release. Users of next tick would be advised to use the ASAP package directly.\n. ASAP is live, https://github.com/kriskowal/asap\n. Will be fixed with #394 \n. @ravi, I\u2019m pretty sure that won\u2019t work. This variation on `Q.all` might do the trick for this _specific_ case, because it checks whether the aggregate promise is still pending and only calls `deferred.reject` in that case.\n\n``` javascript\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var countDown = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            if (isFulfilled(promise)) {\n                promises[index] = valueOf(promise);\n            } else {\n                ++countDown;\n                when(promise, function (value) {\n                    promises[index] = value;\n                    if (--countDown === 0) {\n                        deferred.resolve(promises);\n                    }\n                }, function (error) {\n                    if (deferred.promise.isPending()) {\n                        deferred.reject(error);\n                    } // otherwise ignore the error; it\u2019s been handled\n                });\n            }\n        }, void 0);\n        if (countDown === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n```\n. Duly poked. What else is blocking a patch release? Perhaps we should tackle this too.\n. @ravi, No, you\u2019d `Q.stopUnhandledRejectionTracking()` globally.\n. I\u2019m going to favor a patch now rather than wait for these. Both problems fall firmly in the realm of Hard\u2122.\n. @ravi That\u2019s right. If you want to process the failures of all the inputs, you would need to do something like:\n\n``` javascript\nreturn Q.all(promises.map(function (promise) {\n    return promise.catch(function (error) {\n        // process every individual failure\n        throw error; // then invalidate the whole\n    });\n}))\n.then(function (values) {\n    // all promises succeeded\n}, function (error) {\n    // first failure of any, invalidating the whole\n})\n```\n. We are removing the unhandled rejection tracking code for the time being. Further work will be needed to create state snapshots for promise inspectors, but I am hoping this issue does not surface in the new incarnation.\n. Let\u2019s keep it in the repo. It\u2019s just simpler.\n. @domenic No, we can axe the min.js.gz.\n. Are you sure we should have an implicit `done()` on the end of `spawn()`? Do we imagine that this would only be used at the top level of some promise work, and we would only use `async` to do work that might return a promise?\n. As @domenic, I am reluctant to mix values and errors contingent on success or failure of input promises.\n\nWe do plan to release `allSettled`.\n. `allSettled` landed. I\u2019m closing this since the desired behavior is simple enough to compose in terms thereof. Thank you for posting, @adjohnson916!\n. In the interest of preventing bloat and keeping a focused scope, I\u2019m not inclined to virtualize `if` blocks.\n. @domenic, yes please!\n. This looks good. Would you like me to merge this and cut the release?\n. Yes, and once we\u2019ve got something that generates good numbers, we should regress it over our commit log and see how we\u2019ve been doing.\n. Sounds good to me.\n. @mpj I believe that @stefanpenner also has a benchmark he uses to tune RSVP. By that benchmark, last I checked, when.js was really good, but most of the libraries designed for speed did well. Q is designed at a higher level of abstraction and does more to protect private state than the rest of the pack, which comes at a significant performance cost. I have been re-evaluating that trade-off in the experimental v2 branch, but if speed is your primary concern, you\u2019re willing to opt-out of the Q ecosystem, and you have no desire to use promises as proxies for remote objects, you should for sure go with one of the others.\n\nI have used @stefanpenner\u2019s benchmark to evaluate Q.\n\nhttps://github.com/stefanpenner/promise_benchmarks\n. My intent is to generate the \u201cUMD\u201d rendition of Q with either Browserify or Closure Compiler, as I believe you earlier recommended, as a first step toward modularizing.\n. Superseded by #317\n. I am not sure this belongs in Q. Can you enumerate (some or all of) what interfaces this can be used with, where they are implemented, and whether they are likely to become standard? It seems likely to me that these will eventually migrate to W3C Promise.\n. Awesome. The recent failures are my fault, in trying to fix a problem with interop with earlier versions of Q, which requires further investigation on my part.\n. @rkatic good observation.\n\n@forbeslindesay, we need to be able to thread an alternate template through this process. The `bootstrap` line will not work with Montage (Montage\u2019s bootstrapping expects a generic \"promise\" module, not \"q\", which is of course debatable but matter-of-fact), the SES stuff is Q-specific and experimental. As far as I can tell, this means threading an alternate template through Grunt, Grunt-Browserify, Browserify, and UMD. Alternately, we\u2019ll have to roll our own solution.\n. @jrburke @briancavalier This commit moves the UMD version of Q into `release/q.umd.js` and `release/q.min.js`. I presume that this will be a backward-incompatible change for the AMD ecosystem. Will a minor version ramp be sufficient to avoid fallout within your community? What do we need to communicate this change to UMD users.\n\nThis is part of a move to introduce modularity to Q, and shuck dependencies out to other packages. I\u2019m not sure what the ramifications of this will be for the AMD world.\n. @rkatic, good points!\n\n@ForbesLindesay UMD does not need to support Montage\u2019s module system. It is CommonJS. The only reason that there is an additional case for Montage in Q is because Q is a dependency of Montage\u2019s CommonJS module loader (Mr), so it is one of four modules that have to be loaded with script-injection in the bootstrapping process. This is not a number that needs to scale or an effect any other UMD package needs to accommodate.\n\nAs for linking to an auto-generated build, @domenic has been arguing for it, but I really want to keep it easy to replicate this project\u2019s infrastructure.\n. @domenic @jrburke I am hoping to avoid a support nightmare, where thousands of users file an issue that they updated with Bower or Yajspm and Q no longer works with their configuration. I\u2019m wondering whether we can avoid that with Semver + CHANGES.md so that users can opt deliberately in.\n. We do not provide support for JamJS in this venue. Perhaps take it up with your package manager. v0.9.6 is in NPM and tagged on Github.\n. I\u2019ve verified the issue in cdnjs. Looks like the minified version lagged behind. We need to get a fresh release on there.\n\nI\u2019m gathering that this is one of those cases that will simply not happen unless we do it ourselves. If that\u2019s the case, we need automation.\n\nI am reminded of the Duke Atreides in Dune \u2014 \u201cWe have inherited the greatest wealth in the universe and the never-ending struggle to defend it.\u201d\n. Seems like cdnjs is pulling automatically these days. I don\u2019t intend to revisit this.\n. It seems likely that this would cause there to be a race to add work to the array before all the contained work completes. This probably would not end well.\n\nApart from that, it would be necessary to observe array content changes, which is something that @aadsm and I facilitated in https://github.com/montagejs/collections.\n\nI do not think we will do this and I hope my answer is not too dissatisfying.\n. Thank you.\n. It\u2019s not a bad idea, but I\u2019m in favor of keeping the current API.\n. It is _very_ interesting. However, I don\u2019t think it\u2019s practicable in Q. For one, we provide `n*` functions for browsers as well, where domains are not available. It becomes complicated, although not impossible, to have a conditional require that works both with or without Node.\n\nIt breaks my heart, because this is very clever and useful, but it would be wise to decline.\n. Your `delay` has the intended semantics of `delay`. I can\u2019t contrive in my imagination a use for `throttle`. Even if I needed it, I would:\n\n``` javascript\n.thenResolve(Q(value).delay(ms))\n```\n. I\u2019m also thinking that we should not delay rejection.\n. Thank you, @wmertens \n. I know it\u2019s not what you want to hear, but this would be too much magic for my taste. I\u2019ll let others pipe in before closing.\n. Please take a look at what\u2019s going on in #334. I\u2019m closing this particular pull for a variety of reasons, some of which I will outline in the source, but the big picture is I\u2019m making some large factoring changes for v0.10 that will align things better for making this work. Particularly, `all` will become suitable for generically waiting either for an \"iterable\" of promises to all be fulfilled, or pass non-iterables through. That\u2019ll cover arrays, generators, iterators, and promise queues, and pass everything else through.\n. @jlongster My notion is to use `all` instead of `Q` to coerce yielded values in `async`.\n. I\u2019m going to leave this open. There is a chance that an overload like this will fall into our lap with `all` being overloaded for \"iterables\".\n. I added @rkatic\u2019s `props` to the specs in my working copy. It does in fact work, though `result` is oddly an `Array` with named properties. In any case, I think that is as fixed as this issue is going to get.\n. The name `hash` really needs to be preserved for generating probably-unique consistent hashes on \"hashable\" objects. I\u2019m eliding a rant on the history of the practice of using \"hash\" as a synecdoche for \"hash table\" and will just say it causes confusion about the concepts.\n\nI am open to the idea of implementing such a method with a different name.\n. Q captures all errors, so that anything that is depending on their result asynchronously has an opportunity to be informed and handle the problem gracefully.\n\nIf you get to the end of a chain of promises, use `.done()` and it will explicitly surface any errors that were not handled.\n. For the record, supersedes\u2026\n\nFixes #326\n. Going with @wmertens PR.\n. This behavior is easy enough to compose from \"reduce\" and \"when\", with a more idiomatic (as @domenic mentions) effect with less API surface for folks to learn (as @killdream mentions). I\u2019m inclined to close and recommend applying this to a utility or just using primitives. I invoke \u201cThe Virtue of Unix\u201d, that is, the composition of small tools design well for a single purpose.\n\n``` javascript\n[f1, f2, f3].reduce(Q.when, Q())\n```\n. I think what might need to be clarified is that this is not a matter of flattening the pyramid with your existing functions. To be adapted to the promise-style, you no longer pass callbacks, but simply return values or promises in _any_ function. You would adapt your `step` or `nstep` functions to be `pstep` functions. You would only need to use `defer`, `resolve`, or `nf*` functions at the boundary between your promise-oriented functions and your non-promise functions. Does that make sense? What this should look like is:\n\n``` javascript\nfunction step1() {\n    // returns a promise\n}\n\nfunction step2(step1Value) {\n    // returns a promise\n}\n\nfunction report(step2Value) {\n    console.log(step2Value);\n    // implicitly returns undefined, albeit a promise for undefined\n}\n\nQ.fcall(step1)\n.then(step2)\n.then(report)\n.done();\n```\n. @domenic, I find your idea satisfying.\n. I actually kind of like the idea of making the progress/notification arguments free-form depending on the domain. Emitting (index, progress) updates sounds like a neat idea to me, that would make it easier to adapt those events to domain-specific progress.\n. Fixes #234, introducing Q.map.\n. Introduces `map`, `reduce`, `forEach`, `Queue` and handling of \"iterables\" in general.\n. I\u2019m running into much broader problems with this effort in general. It is proving difficult, once again (because I have tried this pretty much once a year since this project began :/) to make these operators compose well while chaining with back-pressure. I\u2019ll let you all know, but this might be a throw-away PR.\n. Bear in mind that I\u2019m still exploring this, but the general idea is that it should be possible to chain `map` calls, then aggregate with either `all`, `reduce`, or `forEach`. There should eventually be support for `flatten` (`flatMap` being composed of `map` and `flatten`), which could be interspersed among the `map` pipeline.\n\nI\u2019m synthesizing promises, streams, iterators, and FRP. FRP doesn\u2019t inherently do buffering or throttling or back pressure, but promises provide a good back-pressure signal, and each of these operations could take a buffer size argument. An infinite promise queue serves as a semaphore or throttle. In fact, infinite promise queues for iterations can serve as asynchronous iterators (as included at the end). So I can use infinite promise queues for streams internally.\n\nThe other dimension of the problem is remote objects. For that reason, I\u2019m moving `iterate` into the promise protocol so you can pipeline a number of parallel operations from a remote iterable.\n\nHere is the example I\u2019m mulling:\n\n``` javascript\nQ.map([1, 2, 3], function (n) {\n    return n * 2;\n})\n.map(function (n) {\n    return Q(n * 2).delay(1000);\n})\n.all()\n.then(function (a) {\n    console.log(a);\n})\n.done()\n```\n\nNote that there are two maps. The second map should not wait for the completion of the first. The second map should be complete in exactly 1 second, not 3, since all three delays should be in parallel.\n\nThen there\u2019s the issue of throttling. It should be possible for the input of these chained map operations to be an infinite promise queue of indefinite length.  It should be able to pass values through both steps as they arrive, and it should be possible to throttle to only have a certain number of outstanding promises.\n\nThe `all` operator should wait for the input stream to close.\n. Continuing at #337\n. This replaces #334, see that request for the conversation up to this point. The reason for the PR change was that I poorly judged the name of the branch and it seems like I can't re-root the PR.\n. I think I\u2019ve solved most of the composition problems. However, forEach is still the only method that limits parallelism, and none of the methods yet support back-pressure. I did experimentally find a way to reduce parallelism in `reduce` but there isn\u2019t much point until `map` supports back-pressure. This will involve creating a control system between the output queue and the consumption of input, so that only a certain amount of work can be scheduled between them.\n. Alright, rate control now works. All of the operations support a `parallelism` argument which limits the number of concurrent activities within the step and allows the consumer to limit the rate of production.\n\nStill need to go over the docs and JSHint, and clean up the code. I added Semaphore and Control types that need docs and probably some iteration.\n. Alright, I\u2019m done polishing. Ready for a review.\n. @domenic Breaking it into a module is even more problematic since a promise is a promise for an object of _any_ type. I do have some ideas for making the Q API inheritable and being able to cast promises to promises for more specific types, but that\u2019s a different issue to explore down the road.\n\nAs for the iterator API, it is only `next`. The generator API adds `throw`.  I\u2019m re-appropriating `throw` (though the meaning differs), and adding `return` and `yield` (n\u00e9e `send`), so that the producer side of the queue can marionnette the queue to behave as if it were a generator.  I need to swing back and rewrite the docs to that effect.\n. @domenic, the thing is that usually an object only has methods appropriate for its type. With a promise, since it\u2019s a proxy for what might be an object-as-a-map, it has `get`, `set`, `delete`, `has`, and `keys`. Since it\u2019s a proxy for what might eventually be an object-as-instance, it has `invoke` and `post`.  Since it might eventually be a function, it has `fcall` and `fapply`. Since it might be an iterable, it\u2019ll have `forEach`, `map`, `reduce`, and `buffer`.  It would make sense to give each \"face\" of a promise to have a different promise type, eventually someday even have specialized methods to reflect the eventual resolution. Might even be possible to generate these types based on sufficiently descriptive prototypes.\n\nI have explored this possibility in the past. One thing that becomes obvious is that the system has to become _very_ type-aware. Another trouble is that `then` must return a promise for the very most generic type of promise, since it is a promise for whatever the _callback_ returns and is not dependent at all on the type of the input promise. As such, it becomes necessary to introduce a method like `as(Type)` so that a promise can be cast to a more specific promise type. As you can see, it is a rabbit hole better suited to a structurally typed language.\n\nThe advantage is that the promises themselves can be broken up into smaller opt-in modules.\n\nMaybe we\u2019ll go down that road some day, but for now, I\u2019m just lumping all of these interfaces on a single promise prototype.\n. Rebased.\n. Already done, I think. Did I miss one?\n. @domenic. Thanks. I missed that one. I\u2019ll follow it up. Going to look into this Browserify thing. That\u2019s blocking most of the next release\u2019s plans.\n. We could, but this PR commits us to a backward-incompat release so I think I want to race to the finish.\n. @domenic New evidence suggests that fresh output arrays are a win. The input of `all` is not necessarily an array any more, and `allSettled`, as @rkatic points out, should never have been reusing the input.\n. This has been made obsolete. The changes were rolled into the `unroll` branch PR.\n. I had to rebase the promise streams work back out to a branch, so this issue remains. More info on the mailing list: https://groups.google.com/forum/#!topic/q-continuum/JE6zSshyC5s\n. @rkatic On closer inspection, these changes are in master, except for the docstring which I just hand-copied into my working copy and will land soon. Because of the rebase, you may need a fresh checkout of master. You may have attempted to pull from the rebased head, which would have failed.\n. @rkatic On even closer inspection, the problem _does_ still remain and I had lost track of my branches. I\u2019ll fix this.\n. Rebased on #339\n. @domenic, I would love to see the numbers.\n. Before then after.\n\n```\n              A single simple async operation\n  56,769 op/s \u2a20 with an immediately-fulfilled promise\n  70,630 op/s \u2a20 with an immediately-fulfilled promise\n\n 231,258 op/s \u2a20 with direct setImmediate usage\n 292,525 op/s \u2a20 with direct setImmediate usage\n\n     835 op/s \u2a20 with direct setTimeout(\u2026, 0)\n     809 op/s \u2a20 with direct setTimeout(\u2026, 0)\n\n              A fs.readFile\n\n   8,232 op/s \u2a20 directly, with callbacks\n   9,587 op/s \u2a20 directly, with callbacks\n\n   4,703 op/s \u2a20 with Q.nfcall\n   5,774 op/s \u2a20 with Q.nfcall\n\n   4,656 op/s \u2a20 with a Q.denodeify'ed version\n   5,923 op/s \u2a20 with a Q.denodeify'ed version\n\n   5,922 op/s \u2a20 with manual usage of deferred.makeNodeResolver\n   7,588 op/s \u2a20 with manual usage of deferred.makeNodeResolver\n\n              1000 operations in parallel\n\n      43 op/s \u2a20 with immediately-fulfilled promises\n      47 op/s \u2a20 with immediately-fulfilled promises\n\n     540 op/s \u2a20 with direct setImmediate usage\n     466 op/s \u2a20 with direct setImmediate usage\n\n              Chaining\n\n      47 op/s \u2a20 Chaining many already-fulfilled promises together\n      48 op/s \u2a20 Chaining many already-fulfilled promises together\n\n      65 op/s \u2a20 Chaining and then fulfilling the end of the chain\n      63 op/s \u2a20 Chaining and then fulfilling the end of the chain\n```\n. I screwed up the history on this one by pushing master before force pushing unroll. Sorry. See:\n\nhttps://github.com/kriskowal/q/compare/d144e138e29565aaf8dbc054be2f7f13dda274d5...f5a310cfc3310242a30507e8944d3277f6dc2520\n. This change could not land until v2. As it happens, notify and progress have been removed outright in v2, and if they are reintroduced, will not compose. Closing.\n. @tomdaub cancellation is an unrelated concern to progress/notify. Q promises have multiple consumer semantics, so cancellation is tricky. I am contemplating building a library with a \"task\" primitive that is similar to a promise but with explicit fork() and cancel(), and @domenic is actively working out whether promises can become cancelable promises with reference counting on observers.\n\nSee: https://github.com/kriskowal/gtor\n. @domenic, yes to explicitly saying we\u2019ll get around to it.\n. This will land in a separate library. Closing.\n. @domenic Agreed.\n. Good enough for me. If you care to follow up, please give it a run in JSHint. We put a space after `if` and curly braces around blocks, statements on new lines.\n. Thanks, @aaylward \n. This will be separated into a library.\n. This is right, but we can leave off q.montage.js and q.ses.js off for this pass.  For Montage and Mr, I think we\u2019ll abandon the current script-injection bootstrapping in favor of using Browserify to create our bootstrappers.  There\u2019s a chance my colleagues will not like that, in which case, we\u2019ll bring it back in, but, in general, I would favor pushing it out.\n\nTell us more about S3. Do we get a free account for being pro-social? How do we manage the API key? What steps do we need to take to keep it simple to fork the project infrastructure?\n. I\u2019m proposing:\n- q.js (source, CommonJS)\n- release/q.js (`<script>`, global Q, bundled with transitive dependencies using Browserify)\n- release/q.min.js (\u2026and minified)\n- release/q.amd.js (AMD (not UMD), not bundled)\n- release/q.amd.min.js (\u2026and minified)\n\nI approve of support for Volo, with a big thank you for playing along with `package.json`.\n\nI am entertaining the possibility of bringing in support for Bower and Component provided that their metadata are build products.\n- release/component.json\n- release/bower.json\n\n@domenic, you have my blessing to give S3 a chance.\n. Yeah, that\u2019s what I thought. For whatever reason, Gem is b\u00f8rked on my machine so that\u2019s a bit of a dead-end for me. I have tried installing the `travis` command in the past.\n. Alright, I got my Ruby/Gem situation figured out and `travis encrypt` works locally.\n. @jrburke,\n\nThe elimination of the tyranny of choice very concisely describes why Q subsumes its dependencies and pioneered the UMD approach. Which is to say, there is a part of me that agrees that Q should maintain its own _status quo_.\n\nHowever, when we spoke at JSConf, you mentioned also that Q is not palatable to the Dojo community, for among other reasons, Q subsumes its dependencies and those dependencies overlap with products Dojo already provides as independent modules. So we are confronted between a trade-off between the paradox of choice and modularity. In Q\u2019s nascence, I elected to chose the simple road. But Q has grown and the best way to make its size reflect its inner simplicity today would be to reduce it to its core and use packages and modules: ES5-Shim, ASAP, WeakMap, &c.\n\nThankfully the tool system and the _modus operandi_ of the community has evolved and modularity is practical today on all fronts.\n\nMy reasoning for having separate AMD and Script versions is that the AMD version need not bundle its dependencies, provided that all of the dependencies provide an AMD version as well. That probably will mean that the build will also need to include the info that popular AMD package managers need.\n. @domenic I like it.\n. @jrburke, Your observation that (1) in this branch is presently not bringing in dependencies is accurate, but this is, as you say, just step 1. In subsequent steps, we\u2019ll be using `require` to bring in `asap`, `es5-shim`, and eventually `weak-map`, all of which will be rigged the same way: source in CommonJS format, a built AMD version with the simple `define(cjs)` boilerplate (and itinerant metadata), and a built `<script>` version that subsumes all of the dependencies using Browserify.\n. @domenic, I\u2019m okay with the `amd/` prefix. I do not think that the `amd/` dir would ever need to slurp up the AMD versions from package dependencies though.\n. @domenic Ah, got it.\n. @domenic How far do you think `from-commonjs` is from being ready for a PR. It looks really good so far. Are we going to wait for S3 support and then hook Volo up with the published versions? Let\u2019s leave support for building bower.json and component.json to a later PR so we can get this in master sooner.\n. And there was much rejoicing!\n. Oh, dear. We have no story for allowing Volo users to lock to a specific version.\n. Perhaps instead of adding a Volo link to the package.json, we need to put a modified package.json in the release products and accumulate releases by version in S3.\n. Got it. `{version}` solves the problem.\n. Confirmed, however, if we move the `var call` line out of the function, we can have our cake and eat it.\n\nBearing in mind that if safety is your paramount, you should look at https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/makeQ.js?r=4779\n\nThese projects, Q and SES makeQ are moving in the direction of API compatibility, though I enjoy the liberty of getting user feedback on experiments here which does cause ephemeral divergence. I have had to make some tough calls favoring speed in some cases and flexibility (as in a settable `onerror`) over safety and security and am admittedly a student of security, not qualified to bring this library all the way as Mark Miller has with makeQ. Once Mark and I have more SES foundations set up to work in Node, I may revisit all of these decisions and point us back, but for now, we are not on track for security.\n. It is not for minification\u2014you\u2019ll note that we use a shim if `map` is not implemented on `Array.prototype`. It is a relatively recent addition to the language.\n. I should refrain from thank kind of speculation in my comments.\n. @alFReD-NSH Your framework should either be promise-aware or provide callbacks for signaling asynchronous completion.  If it is promise aware, you would just need to return a completion promise and your error would asynchronously propagate to that promise for the framework. The framework may even chose to use `.done()` as @kitcambridge points out, to surface the exception and halt the test runner. If your framework provides a callback, e.g., `done(error_opt)`, you would need to take your completion promise and call `.then(done, done)`.\n. @alFReD-NSH Agreed, that is why we have the \"Unhandled errors\" message; it ensures that if you do forget to handle an error, it will not be silent. Ideally we would have a debugger that shows the causal graph of all promises with stack traces. This tool could even show promises that cross process boundaries. It happens that Terry Stanley made a prototype for this called Causeway some time ago, but we have yet to bring it to browser debuggers. It is on the roadmap.\n\nI do sympathize with your sentiment. Unfortunately, quite a bit of the benefit of promises\u2014implicitly propagating errors asynchronously\u2014comes with this cost. We have tried where we could to minimize the risk. In my own use, avoiding unhandled errors has become as natural as avoiding infinite loops.\n. The crux of the problem is that in an asynchronous program, an unhandled error may be handled at a later turn, or by multiple subscribers. That is, an unhandled error is not necessarily an error that will never be handled. Not handling an error is not even necessarily a sign that there was a problem, if the promise was not necessary for the progress of the program.  We use `done` to explicitly distinguish the case where an unhandled error should terminate the program with an error or drop an non-redactable error to the console.\n\nThe errors in the `unhandledErrors` array do have stack traces. It is a shame they are not easy to expand at the console. It might be worth bringing @paulirish into the conversation.\n\nWe also intend to eventually provide hooks for debuggers, e.g., `console.ondefer`, `console.onresolve`. These hooks would drive a promise debugger extension or possibly even the browser\u2019s debugger itself. This would be very similar to your proposal.\n. This may be interference we should give further consideration.\n. Good enough for me. We\u2019ll leave it alone.\n. This is a very early draft. I will likely change the protocol before finalizing.\n. Supercedes #65\n. @magalhas The node/web inspector would need to implement a promises panel that communicates with this library service. As yet, this is not a reality.\n. I share the sentiment that too many features have creeped into Q, in general. @domenic has also expressed that he would like to punt more into modules. Mark Miller has (sagely) discouraged me to add streaming promises to Q proper. A moratorium is in effect. We are taking measures to make the transition from a one-script-pony to making use of CommonJS modules and NPM, which unlocks some possibilities. We culled a lot of creep in the leap to 0.9 and I plan to do the same in 0.10. Here\u2019s the roadmap.\n\nhttps://groups.google.com/forum/#!topic/q-continuum/JE6zSshyC5s\n\nThere are some obstacles, but the trajectory in general is: make q.js more focused.\n\nHowever, some things will not be leaving Q core:\n- object proxy methods `get`, `post`, `invoke`. However, `set` and `delete` would not be missed.\n- the second argument of `then`. `catch` is implemented in terms of `then`.\n- method aliases for pre-ES5. alas.\n\nThe Node and Generator methods are good candidates for punting into modules.\n\nI will entertain debate on `timeout` and `delay`. My feeling is that they provide a lot more convenience than cost.\n. Some resources for you:\n- https://github.com/promises-aplus/promises-spec\n- https://github.com/promises-aplus/promises-tests\n\nSome related efforts:\n- https://github.com/tildeio/rsvp.js\n- https://github.com/cujojs/when\n- https://npmjs.org/browse/keyword/promise\n\nI am going to close this issue. The process of modularizing is tracked on other tickets.\n. @fresheneesz Unfortunately, I have too many projects in dire need of my attention to be that generous with my time. It occurs to me that you could also get a lot of what I _would_ say upon review from this article:\n\nhttps://github.com/kriskowal/q/blob/master/design/README.js\n\nI can say that some of your reasoning for wanting a trimmed version of Q is that you may very well have only a subset of the problem that I am solving. I am generally happy to point folks in the direction of API compatible, specification-test-passing variants of Q if they don\u2019t need all the things Q does.\n. Thanks. This is a regression due to rebasing. I\u2019ll take care of it.\n. Was unable to reproduce on master. What version are you using, @surr-name?\n. Closing provisionally.\n. @surr-name Sounds to me like we need to roll out a patch release.\n. @surr-name Thank you for verifying. Glad to hear the problem is resolved.\n. @SET001 Q.all([]) should settle to [] immediately. There should be no need for the special case.\n. @SET001 I mean resolved, settled, and fulfilled. A promise can be resolved with any other promise, including pending or \"settled\" promises. \"settled\" includes \"fulfilled\" or \"rejected\".\n. Yeah, so it can cleanly fall in the 0.9 back-port branch.\n. This is a backward-incompatible change and should wait for a major (or 0.minor).\n. Perhaps I should rethink this so that it is still possible to programmatically retrieve the whole reason, but still only show the traces in the console.\n. Thanks, @domenic. Sounds good to me.\n. That\u2019s a lucky break. Maybe the `.git` internals vary from version to version. This makes me nervous.\n. @domenic Not merely nicer. That is great!\n. @domenic \n- let\u2019s leave the AMD raw. We are already assuming that AMD folks will be using AMD tooling to manage dependencies\u2014it is safe to assume they are using tooling for their build products.\n- It is up to you on how far you want to go to discourage hot-linking. You could even go so far as to provide `Content-type: application/octet-stream` and `Content-disposition: attachment`.\n- Based on what I see from the listing you generate, I think we should go with `{version}`, `commits/{hash}`. I presume that \u201clatest\u201d links to hash by branch name. Whatever makes sense to you for that one.\n. @domenic, I slept on it. I\u2019m pretty sure it\u2019s just a matter of moving some stuff in `become` into `defer`\u2019s `promiseDispatch`, and throwing a flag in there so that we only coerce once.\n. This seems to conflate `Q.async` and `Q.fbind`. I would prefer to keep them separate. Let me know if this is not what you intended.\n. This could be errant behavior on the part of Node\u2019s `inspect`.\n. @ExxKA `promise.toString` returns '[object Promsie]'. `inspect` returns an object describing the internal state of the promise, e.g., `{state: 'fulfilled', value: 10}`, but Node.js\u2019s `inspect` function, used by `console`, delegates to `inspect` methods expecting a string, or an object that can be inspected to produce a string. Node.js developers have been fiddling with `inspect` and the bug likely lies there.\n. I believe @erights may want to review these changes and contemplate the implications.\n. @erights Debugging, testing, and optimizing are the uses today. It is also the polymorphic basis for implementing methods like `nearer`, `mostResolved`, and the deprecated `valueOf`.\n. I should clarify. `nearer` is our implementation of `shorten` described on the Concurrency Strawman and receives very little use. `mostResolved` does not exist, but I have contemplated reimplementing `nearer` in terms of `mostResolved`. `mostResolved` would be responsible for following the promise chain to the last promise, and `nearer` or `shorten` would be responsible for unpacking the fulfillment value from the most resolved promise.\n. I would be content to dump `shorten`, `nearer`, `mostResolved`.\n\n`inspect` is used to optimize `all` and `allSettled`, as well as backing `isFulfilled`, `isRejected`, and `isPending`. We could stretch the `pending` state to cover `accepted` and keep things mostly working.\n. These are the affected tests if we stretch `accepted` over `pending`.\n\n```\nFailures:\n\n  1) inspect for a promise resolved to a rejected promise\n   Message:\n     Expected { state : 'pending' } to equal { state : 'rejected', reason : {  } }.\n   Stacktrace:\n     Error: Expected { state : 'pending' } to equal { state : 'rejected', reason : {  } }.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:817:44)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  2) inspect for a promise resolved to a fulfilled promise\n   Message:\n     Expected { state : 'pending' } to equal { state : 'fulfilled', value : 10 }.\n   Stacktrace:\n     Error: Expected { state : 'pending' } to equal { state : 'fulfilled', value : 10 }.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:828:44)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  3) promise states of deferred rejection\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:891:38)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  4) promise states of deferred rejection\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:892:37)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  5) promise states of deferred fulfillment\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:899:39)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  6) promise states of deferred fulfillment\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:901:37)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  7) promise states of isFulfilled side effects\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:937:46)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  8) promise states of isFulfilled side effects\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:939:48)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  9) promise states of isFulfilled side effects\n   Message:\n     Expected undefined to be 2.\n   Stacktrace:\n     Error: Expected undefined to be 2.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:940:50)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  10) all rejects after any constituent promise is rejected\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at /Users/kris/q/spec/q-spec.js:1102:42\n    at _fulfilled (/Users/kris/q/q.js:794:54)\n    at self.promiseDispatch.done (/Users/kris/q/q.js:823:30)\n    at Promise.promise.promiseDispatch (/Users/kris/q/q.js:756:13)\n    at /Users/kris/q/q.js:580:53\n    at flush (/Users/kris/q/q.js:108:17)\n    at process._tickDomainCallback (node.js:459:13)\n\n  11) delay should not delay rejection\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at /Users/kris/q/spec/q-spec.js:1659:41\n    at _fulfilled (/Users/kris/q/q.js:794:54)\n    at self.promiseDispatch.done (/Users/kris/q/q.js:823:30)\n    at Promise.promise.promiseDispatch (/Users/kris/q/q.js:756:13)\n    at /Users/kris/q/q.js:580:53\n    at flush (/Users/kris/q/q.js:108:17)\n    at process._tickDomainCallback (node.js:459:13)\n\n  12) unhandled rejection reporting doesn't report a resolve, then reject (gh-252)\n   Message:\n     Expected 1 to equal 0.\n   Stacktrace:\n     Error: Expected 1 to equal 0.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:2443:48)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\nFinished in 2.119 seconds\n180 tests, 287 assertions, 12 failures, 0 skipped\n```\n. If we promote acceptance to adoption at time of resolution if the accepted value is a branded promise, the fallout drops somewhat.\n\nAt the end of the day, I would not mind dumping `isFulfilled`, `isRejected`, and `isPending`, and all of the optimizations that use `inspect`. `inspect` could disappear entirely. I expect the only people who would be saddened would be the users\u2014I say only somewhat facetiously.\n\n```\nFailures:\n\n  1) promise states of deferred fulfillment\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:899:39)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  2) promise states of deferred fulfillment\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:901:37)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  3) promise states of isFulfilled side effects\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:937:46)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  4) promise states of isFulfilled side effects\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:939:48)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  5) promise states of isFulfilled side effects\n   Message:\n     Expected undefined to be 2.\n   Stacktrace:\n     Error: Expected undefined to be 2.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:940:50)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  6) unhandled rejection reporting doesn't report a resolve, then reject (gh-252)\n   Message:\n     Expected 1 to equal 0.\n   Stacktrace:\n     Error: Expected 1 to equal 0.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:2443:48)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\nFinished in 2.126 seconds\n180 tests, 287 assertions, 6 failures, 0 skipped\n```\n. I\u2019ll leave it to our resident Caltech physicist to put to record whether the uncertainty metaphor applies as well as it sounds!\n. > Users can never have too much information to make it easy to use your work. A responsible developer makes good code, documentation, and videos. Anything less is lazy.\n\nTrue enough. Still, this is a free service we provide in our spare time. You should look at @domenic\u2019s public contributions graph on his Github home page, or even mine. We appreciate your understanding.\n\nI\u2019ll be doing a presentation at Fluent next week. I did a presentation in Berlin in 2010. Domenic and Forebes Lindesay have done numerous good videos. We will take your advice and create an index of some of this ancillary documentation.\n. Ah, there it is. I remembered it but could not find it.\n. Try `Q(http).ninvoke(\"get\", \u2026)`. `nfcall` does not invoke with `this == http`, which may be contractually required.\n. To be clear, `.then(console.log)` only works in Node. In Browsers, `log` has to be bound to `console`, and in fact, will crash Safari 2 if it is not.\n. Thank you @dtudury. I got a smile and a laugh out of that and had to tell my wife. We do have a bit of a moratorium in place to stave off our feature creep. We\u2019re also in the process of dissolving Q into smaller modules to ease some of the tension on Q\u2019s surface, tending in the direction of fewer conveniences in the core and considering a feature to make the core extensible externally.\n. Shooting in the dark: Does Q.async work in Q 0.9.6 on Node 0.11.2?\n. Also, does Q.async work if you merge https://github.com/kriskowal/q/pull/366 locally? Support for SpiderMonkey generators makes `async` much more complicated than it will need to be going forward and that might be interfering.\n. @popasquat89 Thanks. Since 11 is in the unstable track, we are not likely to bend Q in any subtle way to support a generators that have already been fixed. Unless you find a compelling and succinct solution, I\u2019m inclined to close as \u201cwon\u2019t fix\u201d.\n. Feature has been killed.\n. Sorry, no. These methods will return undefined to signal completion. We\u2019ve vacillated, I know, but when using these to interact with remote objects, we don\u2019t want to send data back and forth unless we need to.\n. @dtudury Thanks for the pull request in any case. We appreciate that you care!\n. That\u2019s a shame. Let\u2019s add a note with references about why we\u2019re doing this.\n. That\u2019s about right. Thanks.\n. Merged, but rebased. I retained your authorship, but refined the comment a bit.\n\nhttps://github.com/kriskowal/q/compare/e33f9e1b2ec6e2b228f4aac1facd94ca7fe8ff34...dc92d37b55405841482aeddc6b9e6b5a95dffa88\n. You can, but it is not obvious or trivial and there is no clear default and automatic way to combine promise progress.  You have to do it manually based on how you expect the inputs to contribute to the output progress.\n\nFor example, if getAlice is expected to be relatively quick, and getBob is expected to take 3 time getAlice in perfect proportion, you can do this:\n\n``` javascript\nvar output = Q.defer();\noutput.resolve(getAlice().then(function (alice) {\n    return getBob(alice).progress(function (bobProgress) {\n        output.notify(.25 + bobProgress * .75);\n    });\n}, null, function (aliceProgress) {\n    output.notify(.25 * aliceProgress);\n});\nreturn output.promise;\n```\n\nNote that this is one of many ways to compose progress. There could be constant time overhead.  Alice and Bob could perform work in parallel, with one dominating the other. Alice and Bob might emit a different kind of information that could provide better insight, like actual time to completion estimates instead of percentages of total period.  `Q.all` provides input for parallel composite progress notifications like `{value, index}`, so you can update the aggregate progress based on the progress `value` for each `index`.\n\nSky is the limit.\n\nWe\u2019ll keep this ticket open to track the task of documenting these strategies.\n. Progress is deprecated. Removing in version 2. Not sure whether to get rid of the docs for progress entirely or explain the current, unsound behavior.\n. Merged at bcc50d69c37d149a0085f06242b7659fecae26cc\n. I\u2019m going to follow-up on these changes and remove the dependency on ES5-Shim. I think we will just raise the requirements on the engine to ES5 (that is, environments in which WeakMap is shimmable), and maintain the previous release train (alas).\n. I\u2019m getting:\n\n```\n},{\"asap\":1}],3:[function(require,module,exports){\nself[\"Q\"] = require(\"../../../../../Users/kris/q/q.js\");\n\n},{\"../../../../../Users/kris/q/q.js\":2}]},{},[3])\n;\n```\n\nIn my `release/q.js`, which probably means a path is a bit too explicit in the Browserify/Grunt build step.\n. Thanks, @rkatic. We\u2019ll block on that for sure.\n. Yeah, WeakMap is ES5 only. I forgot to consider that. We might be stranding folks in earlier versions of Q. That also implies that ES5-Shim would be completely wasted, since we would be raising our minimum operable version. I think we should consider the shift anyway.\n. Speaking of which, perhaps that needs to be called \u201caccepted thenable weakmap\u201d. I was going to say \u201ccasted\u201d instead of \u201ccoerced\u201d, but it occurs to me that we should make the mapping the moment a thenable is accepted, if we\u2019re doing the deferred coercion of thenables that appears to be in for ES6.\n. @domenic As for the private variables approach, I believe that\u2019s what @erights and his merry band of cypherpunks call \u201cbrands\u201d. They are tricky to get right, whereas it\u2019s pretty hard to mess up with WeakMap.\n. @domenic can I ask you to look at the failing specs locally and assess the situation regarding progress notifications?\n. I\u2019m rolling this into the modularity omnibus branch.\n. Thank you for the very thorough investigation. We will definitely embed a reference with the fix. Once we figure out what that\u2019s going to be. Holy expletive, what a mess!\n. @domenic Word.\n. This issue will be tracked here https://github.com/kriskowal/asap/issues/21\n\nWhen that issue is closed, we may elect to back-port the fix to the v0.9 branch of Q. v1.0 will benefit from the fix to ASAP through dependency.\n. Yeah, handling sequences is a pattern, and there are other ways to do them to boot. I think they\u2019re mentioned in the right place, but I could buy a PR that provides cross-linkage from the API to the tutorial to speed up discovery of this kind of thing. I know you wouldn\u2019t be asking if it wouldn\u2019t have helped to read relevant section of the tutorial sooner.\n. Ah, I see. We could help that misstep by providing a link to MDN in the tutorial.\n. ``` js\nreturn Q.try(function()\n{\n    if (!uri || typeof (uri) !== \"string\")\n        throw new TypeError(\"Invalid uri: \" + uri);\n    return Q(jQuery.ajax({\n        url: \"foobar.html\",\n        type: \"GET\"\n    }))\n    .then(function (xhr) {\n        if (xhr.status !== 200)\n            throw new Error(\"Unexpected response code\");\n        var data = xhr.responseJSON;\n        return data.uri;\n    })\n});\n```\n. Should probably be something we mention on https://github.com/kriskowal/q/wiki/Coming-from-jQuery, maybe even first thing. @domenic just rewrote that, and I just reread it, and I don\u2019t recall seeing it called out. @cowwoc, you might try your hand on the wiki.\n. Everything looks fine. I made some edits in an attempt to simplify. `Q.try` isn\u2019t necessary unless you\u2019re weary of `jQuery.ajax` throwing an error (maybe you are). `Q.defer` is nice, but `Q.promise` is the direction libraries are going, and it takes the place of the `Q.try` you had before.\n. @cowwoc Oh, my. Your best option is to create a record with all the properties of the xhr that are salient downstream, like `{responseText: xhr.responseText, status: xhr.status}`.\n\nWhat follows is mostly for @domenic to overhear, where I mumble about how we might make this case easier for you in the future.\n\nWe do not presently have a way to bless an object such that its `then` method will be ignored. We had `Q.fulfill` for a while, which could conceivably have served that purpose, and still might if we abuse our thenable coercion weakmap coming in 1.0.\n\nYou may know that promises are being brought into the JavaScript spec as we speak, and in that effort, there is an answer, but it is a little weird. With upcoming promises in the language, the promise system would not coerce a value to a promise unless you use `then`. These promises also have a `flatMap` which is like `then`, but would do what you need if you played nicely with it.\n. Seems related to how asynchronous traces are working in Chrome now. Each event\u2019s trace starts with an explanation of what underlying operation enqueued the event.\n. @STRd6, we have `Q.promise(function (resolve, reject) {}` today. This will probably become `new Promise(function (resolve, reject) {})` in the future, which is the direction the libraries are all converging upon for the pattern you\u2019re looking for. However, we also have a Promise constructor that we use to generate fulfilled, rejected, and remote promises, which does need to be a public API as well, which stands in the way. We\u2019ll have to work that out as well. It might be an okay situation to overload. In any case, the game is afoot.\n. Thanks for taking the time to PR, in any case.\n\nQ has a bit of a broader charter than jQuery\u2019s since it comes from a security background. It is not in-fact secure, but our intention is to remain API compatible with versions that do have a security mandate.  Part of that requires that promises and resolvers be separate authorities. As @domenic points out in the jQuery migration guide, it is easier to give than to take away, when it comes to authority.\n\nWe also have a mandate to support promises as proxies for remote objects. As a consequence, it would be difficult for Q whittle down to a single function interface, though we pack a lot of punch with just `Q` and `Q.promise`. Much of what remains is just for convenience, like `Q.all([])` instead of `Q([]).all()` or `Q.try(f)` instead of `Q(f).fcall()`, though it can be (and has been) argued that `all` (or anything except `then`, `get`, `post`, and `fapply`) has no business being on the promise prototype since it is outside the sufficient interface for proxying arbitrary eventual or remote values.\n. There is a relatively new API, `Q.race([promise1, promise2, promise3])`, but it may not have been documented yet. We\u2019ll track that with this ticket.\n. For what it\u2019s worth, I like you intuition on the name and will run the idea by @erights, steward of the API.\n. Case closed. Thanks @erights, @domenic.\n. Yeah, that\u2019s on my mind as well.\n. This is good. Let\u2019s do it.\n. #404 may address this issue.\n. Truth.\n. Let\u2019s keep this open to track the update to README\n. Ah, no branch to track. Will open an issue.\n. Uh oh, the `window.Touch` thing is a new problem. I\u2019m not willing to keep this feature off by default though.\n. See #413 v0.9 #412 for v1.0\n\nI don\u2019t plan to do anything for the PhantomJS case unless we can find a reliable differentiator.\n. @francoisfrisch do you recall why we added this exception and whether it is still relevant? If so, we need a new differentiator.\n. Addressed @domenic\u2019s review.\n. @ForbesLindesay As it were, it is not necessary for Q-IO. Q-IO takes the \"b\" argument to specify that you want bytewise data, and its omission implies \"utf-8\" by default.\n. See #416 for benchmark\n. Needs a note that this also addresses #369 \n. And also, since it addresses #369, obviates #372 \n. Thanks, and thanks for the tip on usage of V8 internal methods.\n. With the little benchmark we have in Q, here\u2019s a comparison.\n\nhttps://docs.google.com/spreadsheet/ccc?key=0An5phhxDkYDPdDg3V0prbVZkMzdDZ2NYZVRpTWxQWVE#gid=0\n\nThe top is the branch name, except for `rearch` with `--harmony`, which just enables the native `WeakMap` instead of the shim.\n. Closing. See: https://github.com/drses/weak-map/issues/1\n. Take a look at `allSettled`. `all` will stop at the first rejection.\n. Is it possible that you\u2019re adding values to the array _after_ calling `all` or `allSettled`? Neither of these methods react to changes to the array after they have been called.\n. If you could produce an isolated use case that we can run that does not work the way you expect it, we might be able to make this work for you. `Q.all` does not behave as you describe under normal conditions, so there must be something special about your situation that we do not know yet.\n. @cjmagee Can we have a gist and instructions to run it or a jsfiddle that reproduces the problem? Otherwise, we\u2019ll stitch the case together by typing out your screenshots and ask you to verify, but it won\u2019t be fast.\n. Having given this a fresh glance (a glance mind, I have not spent a lot of time on this) it occurs to me that this might be an issue with cancelation. Ideally, if any promise is rejected in `Q.all`, the others would be canceled. Q does not at this time support cancellation, and if it does, promises will no longer be inherently safe to give to multiple consumers, since they would be able to interfere by canceling. We could tack on an interface that would allow a promise to be explicitly forked for multiple consumers, or defended, preventing upstream cancelation and deep freezing the promise.\n\nLeaving this open for a rainy day.\n. I don\u2019t foresee having time to give this question justice. My apologies, but closing.\n. Oops.\n. I\u2019ve removed the warnings from the v0.9 branch, to be released in the next patch.\n. You may consider using `promise.thenResolve` and `promise.thenReject`, and `Q()` instead of `Q.resolve()`.\n\n``` js\nQ('a').thenResolve('b').then(function (res) {\n    console.log('test 1', res); // test 1 b\n});\n```\n. I don\u2019t intend to support unravelling yielded arrays of promises. This behavior strikes me as too much magic. Apart from that, I think we\u2019re already compliant. Please correct me if I\u2019m wrong.\n. Yes. Sorry for the interruption. We\u2019ve landed some changes very recently that alter the infrastructure. It used to be that q.js and q.min.js as checked in were sufficient to get started in a browser, but now q.js is CommonJS-only and we are building q.js and q.min.js for `<script>` tags and uploading them to S3 automatically. We will address this problem shortly.\n. For the interim, please see v0.9\u2019s branch https://github.com/kriskowal/q/tree/v0.9\n\nMaster is targeting the release of v0.10 and v1.0 and is unstable.\n. It would be possible to augment the `Deferred.prototype` on master, if Q were to export it.\n\nhttps://github.com/kriskowal/q/blob/master/q.js#L933\n\nIf Q were to use `Q.Deferred` with lazy binding in `Q.defer`, it would also be possible to subvert it.\n\nBearing in mind that this implementation of Q has relaxed quite from its security centric design. None of these cut-points will be extensible in a secured version of Q and it has been my policy in the past to discourage it.\n. I concur with @domenic. This would be a handy utility in a third-party package. I am trying to keep Q\u2019s weight down.\n. This is an interesting illustration of an idea that has been going around\u2014the use of a promise\u2019s progress channel as a source of a stream.\n\nI am going to leave this open for discussion and contemplation.\n. An implementation of the behavior of `any` already exists as `race` and we intend to keep it by that name.\n. In master, I\u2019ve removed support for SpiderMonkey/Pythonesque generators. Content Security Policies would also cause this code to misreport that ES6 generators were unavailable. The fix will come in a backward-incompatible release `v0.10.0`, and soon-after `v1.0.0`, hopefully soon.\n. `then` receives a function that will start the next stage. In this case, you can just use bind to partially apply `waitp`. `then` will call the resulting function when the previous completes.\n\n``` js\nwaitp(1000)\n  .then(waitp.bind(null, 500))\n  .then(waitp.bind(null, 1000))\n  .then(waitp.bind(null, 200))\n  .done(function () {\n    console.log('ok')\n  })\n```\n\nIn general, however, you would use a callback as the argument to `then`.\n. Please reopen if this did not answer your question.\n. I presume your changes are forthcoming. So far, we only have four of my commits that distinguish v0.9 from master, which are probably not what you intend. You might need to edit this PR to encompass the changes between your branch and either our master or v0.9.\n. The other commits are expected. I have forked the `master` branch from the `v0.9` branch. If you revise your target branch to `kriskowal/v0.9`, it will merge cleanly without my extra commits.\n. As @petkaantonov would say, `tasks.reduce(Q.when, Q())` would probably do what you want, but I would like to clarify the purpose of `Q.chain`. Is each task independent, or does it need to see the result of the previous task? Does it need to see the results of all previous tasks? Do you need a promise for the results of all tasks, or just a promise for the result of the last task? The `reduce(Q.when, Q()` idiom will pass the result of the previous task to the next task.\n\nThis idiom would pass the results of all previous tasks as arguments to each task, and ultimately return a promise for an array of all the results:\n\n``` js\nreturn tasks.reduce(function (results, task) {\n    return results.then(function (results) {\n        return Q.fapply(task, results).then(function (result) {\n            results.push(result);\n            return results;\n        });\n    });\n}, Q([]));\n```\n\nIn both cases, I\u2019m assuming that a task is a function that must be called in serial and returns a promise for the completion of the task.\n\nI\u2019m sure that there is a variation of this pattern that would suit the purposes of `Q.chain`.\n. Thank you for proposing this change. It is great to see what patterns of usage are common. However, there are so many small variations of this pattern, and it is so easy to create small utilities for each case, that it would be impractical to promote one above all the others. About three years ago, I was maintaining a library, QQ, where I fiddled with the idea of a `Q.step` method with the behavior of `tasks.reduce(Q.when, Q())`, inspired by @creationix\u2019s library by that name. I dropped it because it did not turn out to be useful in practice. At the end of the day, `then` is a powerful building block that can be composed a lot of different ways.\n\nI am tentatively closing this issue, but I would be very happy to continue this conversation to whittle your utility method down to its essence.\n. The `tasks.reduce(Q.when, Q())` pattern would execute the tasks sequentially, waiting for the promise returned by each task to be fulfilled before executing the next task. They would be executed in the order that they exist in the tasks array. If a task promise is rejected, it would stop the execution of the chain, but that can be prevented by catching the error in the task.\n\n``` js\nreturn function task() {\n    return makePromise().catch(function (error) {\n        // ignores the error, fulfills the resulting promise with `undefined`\n    })\n}\n```\n\nThis pattern will not work if the task chain is actually a queue or tree that grows in response to the results of previous tasks. If that\u2019s what you need, describe that further. There are elegant solutions for those cases as well.\n. You will be interested to know that `$.ajax()` returns a sort of promise that Q can use, so you do not need to pass a resolver. You just wrap the result in `Q`, and you can omit the success and error handlers. Also, `Q` has its own timeout mechanism, so you can use it or the jQuery one, whichever you prefer.\n\n``` js\nfunction ajaxTask(url) {\n    $.support.cors = true;\n    return Q($.ajax({\n        url: url,\n        type: \"GET\",\n        dataType: \"json\",\n        cache: false\n    })).timeout(5000);\n}\n```\n\nIf I understand this correctly, this is a simple matter of waiting for all of the ajax tasks to be resolved in parallel, and then proceed to look at the results in serial order. However, you do not want to stop on the first error. In that case, you have options. You can either catch and handle the error from each task and use `Q.all`, or you can use `Q.allSettled`, which waits for all promises to resolve and then gives you back the array of promises (instead of results). You can then unpack the values from the fulfilled promises.\n\n``` js\nreturn Q.allSettled(urls.map(ajaxTask))\n.then(function (resultPs) {\n    for (var i = 0; i < resultPs.length; i++) {\n        var resultP = resultsPs[i];\n        if (resultP.isFulfilled()) {\n            var result = resultP.inspect().value;\n            // \u2026\n        }\n    }\n})\n```\n. @jouni-kantola No, your information was accurate, but I missed the detail about calling display immediately. @petkaantonov seems to have got all the knobs right, and if you refresh his comment, it looks like he handles the error case as well now, using `$.noop`. You are in good hands.\n. My hard requirement is that by `v0.10`, we pick one function name for each behavior. I may grant special dispensation for the one-argument usage of `Q.try`, as it is equivalent to the one-argument usage of `Q.fcall`, but only for the one-argument case.\n\nAlso, I want feedback from @domenic and @erights. I will not release `v0.10` or `v1.0` without their blessing.\n\nI am open to reconsidering which names are deprecated and which are retained.\n\nThe method names should be consistent with analogies in the ES6 world. I favor the Proxy analogy. A promise is, after all, a proxy for a value displaced in space or time.\n\nI am sympathetic to abandoning the HTTP analogies established by `ref_send`: that means `post`. I have already changed `put` to `set`, to align with the proxy handler interface.\n\nWe will still need to retain _provisional_ spread variants, by whatever name. `apply` as the spread variant for `call` is uncontroversial, but `post` for `invoke` or `send` lacks a precedent.\n\nThe usage of `fapply` and `fcall` is an unfortunate aberration, and I will ditch it if there is a viable solution. It might be worthwhile to use `call` and `apply` on `Promise` and on `Promise.prototype`, where there is no problem with these names, and just retain `fcall` and `fapply` on Q. That is to say, the single-letter `apply` and `call` variants should not be considered strong precedent. They are not likely to exist in ES6+ because there is no overlap with `Function.prototype` on `Promise` or `Promise.prototype` like we have on `Q`.\n\nI am sympathetic to the argument that `mapply` for `mcall`, where `mcall` replaces `invoke` or `send`, because it is consistent with the `apply` for `call` and consistent with `fapply` and `fcall` variations, but if proxies support (or even _might_ eventually support) `invoke`, I want `invoke`, and that leaves no precedent for the spread variant. It is important to note that whatever name we chose for the spread variant will be _provisional_, because it will be _vestigial_ on ES6.\n. Also, to give you an idea of the time-table, I\u2019m not going to release `v0.10` unless it is faster than `Q`. At present, this is not the case. Performance improvements on the `WeakMap` shim may fix this. Flipping the architecture of `then` and `done` might help too. That is to say, this is not the only issue blocking the next release.\n. In the version 2 experimental branch, we have removed all aliases and only support ES5. The methods that remain are `call(thisp, ...args)`, `apply(thisp, args)`, and `invoke(name, ...args)`. These exist only on the promise prototype to avoid collision with `Function.prototype` on `Q`. `Q.fcall` has been replaced by `Q.try`. `Q.fbind` has been replaced with `Q.function`, but does not perform partial application. All of the f_, m_, and n\\* methods except `ninvoke` have been deprecated.\n\nThanks for the recommendations @Redsandro. We will continue enjoying the `m*` methods for the duration of the version 1 release train.\n. @domenic Even the first two cases you illustrate are not equivalent if the latter promises reject before the first resolves.\n. @ndkrempel `Q.all` was variadic by spec, but I elected to use an array because we don\u2019t have the spread operator yet. It is much more convenient to add the brackets than to add the `Q.all.apply(Q, \u2026)` idiom.\n. @ndkrempel Returning non-promise values from then-handlers, and passing non-promise values to `deferred.resolve` are analogous cases to yielding a non-promise. We always use `Q(valueOrPromise)` to promote values to promises.\n\n@jlongster asked for this feature some time ago. Although I wanted to make him happy then, and to make @ndkrempel happy now, I think that I will stand by the status quo. Explicit is better than implicit, at least in this case, and consistency is better than a dweomer, in the Perl sense, especially when it folds semantics in ways that are difficult to unfold.\n. Thank you.\n. Close enough. Thanks.\n. Thanks @tschaub. I was asleep at the wheel. I have sorted this out, I think. https://github.com/kriskowal/q/commit/db9220d714b16b96a05e9a037fa44ce581715e41\n. Thanks.\n. We have delegated this responsibility to @microjs. We do not have the inclination to maintain multiple package management solutions.\n. Progress notifications are on life-support in the version 1 release train. They will not be removed until version 2, but they are architecturally unsound and I do not plan to put further work into them.\n. Oh, in version 2, progress has been replaced with an \u201cestimated time to completion observer\u201d system. I do not think that long stack traces apply to observers.\n. This is indeed an area that requires further contemplation. It would be reasonable to guarantee that the progressed handler be guaranteed to receive at least one notification if `notify` is ever called, with the last-known progress. Would also be also be reasonable to guarantee that the `progressed` handler gets called before the `fulfilled` or `rejected` handlers, since these imply a 100% progress notification.\n. `v0.9` and `master` are the relevant branches. I\u2019ll do some house keeping to emphasize that fact.\n\n`master` is a hypothetical for all intents and purposes. A lot in there is unstable particularly regarding progress and notifications. I intend to revisit the topic.\n. Having contemplated the design further, I deem that the progress/notify system is architecturally unsound. I am replacing it in version 2 with estimated time to completion observers, which actually compose and do not suffer the problems observed here.\n. What is and isn\u2019t deprecated is still up in the air. @domenic has expressed that the constructor/prototype reflection is one of Q\u2019s endearing qualities. @erights and I agree that the API has gotten bloated, and I erred on the side of aggression in my latest refactor. This is still a topic of discourse.\n. Dust has settled. `Q.when` is here to stay in the `v2` branch.\n. Just a point of style, we use 4 spaces here. I\u2019ll let @domenic assess this otherwise.\n. Assigning to @domenic, in hopes that he finds time for it before I do :)\n. We have considered `thenCall`, `thenApply`, and `thenInvoke`, but haven\u2019t found substantial need. More often than not, when using `then`, you do want to see the result of the previous promise and using a promise purely to wait is relatively uncommon. I\u2019ve also been contemplating something like `thenDelegate` that would call methods of an object, like `resolve`, `reject`, `notify` as a means for closure avoidance and object reusability, but that has not come to fruition yet. Substantial changes to Q core would be necessary for that path to make sense (though, substantial refactoring is in progress).\n. I am considering this, not for the syntactic sugar, but because it would solve a problem with message pipelining.\n. Subsuming in #453 \n. I might take this. Going to think on it.\n. Thank you.\n. `thenCall`, `thenApply`, and `thenInvoke` might not just be useful sugar, but fill a gap in promise pipelining performance.\n. Oh, crossed wire. Previous comment does not apply to Node.js shorthands. It would be conceivable to have `thenNinvoke`.\n. I have implemented trial versions of then{Invoke,Call,Get} in v2.\n. @Redsandro v2 is a rewrite with a minimum environment of ES5, slimmed down, and not completely backward compatible with v1, though I have only changed things that I regret. It is no where near a stable state, so it would be premature to advertise, and going forward for some time, the API reference will not be stable. I am building additional infrastructure, starting with ASAP, to improve coverage on multiple fronts.\n. However, @Redsandro, I do continuously maintain CHANGES.md.\n. I still hope to address speed concerns in `v2`. The Bluebird author, @petkaantonov, does in fact know what he\u2019s doing when it comes to speed in ways I do not, but I\u2019m also not willing to go to the incredible lengths he has, e.g., doubling the size of the code, nor to specifically target V8 if it comes as an expense to slower engines (which is just a matter of measuring. there is a good chance Bluebird has serendipitous benefits in Firefox at least), and I can\u2019t sacrifice the message passing kernel since Q is designed for far references. Summarily, more research needed to bridge the performance gap, and if your use-cases are a good fit for Bluebird, and you can leave the Q ecosystem behind, you should consider using it.\n. It would make sense to have a grab bag of functions that would allow a promise chain to explicitly permit interleaving.\n\n``` js\nvar render;\nfunction yieldForRender(x) {\n    if (!render) {\n        render = Q.promise(function (resolve) {\n            setImmediate(function () {\n                render = undefined;\n                resolve();\n            });\n        });\n    }\n    return render.promise.thenResolve(x);\n}\n```\n\nUsage:\n\n``` js\ngetUser()\n.then(function (user) {\n    // \u2026\n})\n.then(waitForRender)\n.then(function (\u2026) {\n    // \u2026\n})\n```\n\nWait for reflow, wait for draw, wait for etc.\n\nThere is also the possibility that we will eventually expose a `makeQ(schedule)` method at some point in the future.\n. Uh oh. This implies that either the spec has changed, or the implementation has drifted away from the spec.\n. @ljharb There is probably a miscommunication here. The `new Promise(f(resolve, reject))` constructor does facilitate fulfilling a promise after its created.\n\n``` javascript\nvar deferred = Q.defer();\ndeferred.resolve(10);\nreturn deferred.promise;\n```\n\n``` js\nreturn new Promise(function (resolve) {\n    resolve(10);\n});\n```\n\nBut the `Promise` constructor does discourage passing or returning \u201cdeferred\u201d objects that house both the power to resolve and observe. These powers should be passed separately.\n. (previous comment was prematurely submitted, so please check back if you don\u2019t see the second code example in email)\n. Pending feedback from vert.x. See #460.\n. I keep trying to give @osteele his well-deserv\u00e8d Google-juice, and he just keeps moving his blog around :P\n. This is a duplicate of #150. It doesn\u2019t look like Vert.x has made any progress on this issue.\n. @kennethjor It still messes up static analysis. The `require` statement implies a dependency on a module that doesn\u2019t exist in most environments. This is not important for Node.js, but tools like Browserify, Mr, and Mop use static analysis to discover the working set of a module before execution, or before bundling. These tools can usually be tricked with expressions like `(require)(\"id\")`. You could do this. However\u2026\n\nI would prefer to put pressure back on Vert.x to expose `setImmediate` or `setTimeout` globally. This issue is ultimately a symptom of a Vert.x architecture bug, though they may disagree. I am leery of maintaining this nuance for a fringe engine since it doesn\u2019t get much exercise and penalizes other engines.\n\nThat said, I am not immune to the pressures to increase adoption and cross compatibility. Can we make an attempt to fix this in Vert.x before we commit to supporting this wart in Q (provided that require becomes parenthesized)?\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. @vishy1618 No, they\u2019ll get collected.\n\nClosing. Do follow up if you have further questions. This is just closed because there is nothing we are going to change in Q.\n. I tend to agree with @petkaantonov. I may end up redacting progress from Q entirely. We haven\u2019t figured it out yet.\n. @dts I concur that there is a concept of progress on promises, and it is compelling to expose it with our `notify` API if possible. The question is one of composition. Our present system assumes that each promise may communicate progress notifications directly consumable by something like a determinate or indeterminate progress widget, using values like 0 to 1. However, start time and estimated time to completion is probably more useful for composition purposes. This is further complicated by the \u201cprogress algebra\u201d necessary each time you call `then`.\n\nSo here\u2019s my analysis of the problem we need to solve:\n\nConsider a simple example of a `Q.delay` promise. Such a promise could theoretically provide progress \u201cnotifications\u201d of any level of granularity, but it would be sufficient for it to advertise that it should resolve in some number of milliseconds known at time of construction and _never_ updated. The user interface can animate at whatever rate and infer the percentage from the current time and the last known estimated time to completion.\n\nAn XHR is similar. Until a notification becomes available, we can assume that the estimated time to completion is indeterminate. At some point the response headers become available, and if those response headers contain a content length, we have a piece of a puzzle but no ground for an update on our estimated time of completion. However, thereafter we can measure the time between chunk arrivals, measure the size of each chunk, and produce an estimate for the throughput, then do some simple math from the time the promise was created, the time the headers were received, the content length, and the throughput estimate, to arrive at a new estimated time to complete. We might even do some weighted averaging.\n\nThen you use `then`. Assumptions are scarce, so we must do algebra case-by-case. The percentage so useful for a widget is useless for composition since the weights differ. \n\nAssuming that two promises are sequential: We have to take into account the estimated time to fulfill the input promise, an estimate for the time to compute in the handler, and the estimated time to fulfill the promise returned by the handler if any. Before the input promise is fulfilled, we must assume the time to complete the output, and after the input is fulfilled, we must account for the known time it took to complete. Anything that involves computation varies by system and would have to be measured and ideally trained over multiple runs, and may vary depending on the parameters, may vary by processor scheduling weather, or we can assume that it is negligible. Anything over a network depends on the bandwidth at the bottleneck and if that isn\u2019t the link from the ISP, it is dominated by weather.\n\nAssuming that the two promises are parallel, we have a predicament. The `then` method itself is not privy to the ongoing progress of the promise that will be returned by the handler. When either the input or handler promise produces a notification, we would ideally update the aggregate promise\u2019s ETA to the max of either. `Q.all` needs to do something similar.\n\nAs such, our API will need to be adjusted to thread the necessary parameters through and compose them appropriately. For one, promises will need a way to synchronously expose the last known or initial estimated time to completion, in addition to a way to subscribe to notifications when the estimate changes. Sounds like an FRP problem. We\u2019ll also have to retain and expose the start time for each promise in order to surface a percentage.\n\nWith due apologies, this is all the exposition I have time for at the moment. Please feel free to finish the thought. I sense that this is not far from an idea.\n. ``` js\n\n// Parallel delay between two promises\n\nvar p1 = Q.delay(1000);\nvar p2 = Q.delay(2000);\nreturn p1.thenResolve(p2)\n.progress([p1, p2], max);\n\n// Assuming that indeterminate progress is a \"viral contaigon\".\nfunction max(progresses) {\n    return progresses.reduce(function (prev, next) {\n        if (prev == null || next == null) {\n            return null;\n        } else {\n            return Math.max(prev, next);\n        }\n    }, void 0);\n}\n\n// Defining the progress method as\nfunction progress(promises, compose) {\n    var deferred = Q.defer();\n    var progresses = new Array(promises.length);\n    var observers = promises.map(function (promise, index) {\n        return promise.observeEtf(function (progress) {\n            progresses[index] = progress;\n            deferred.setEtf(compose(progresses));\n        });\n    });\n    return deferred.promise;\n}\n\n// ETF meaning estimated time to fulfillment. We're optimists.\n// Assuming existence of setEtf, getEtf, and observeEtf.\n// Where getEtf returns the last set ETF, or undefined.\n// Where setEtf sets the ETF and arranges for each observer be notified in a\n// subsequent event unless such a notifier has already been scheduled but\n// not yet dispatched.\n// Where observeEtf adds an observer to the promise, which will\n// be called in a future turn with the current ETF, albeit undefined, and after\n// each subsequent change. The ETF becomes the actual time of fulfillment\n// and dispatches a change as well.\n// Observers might become cancelable and might compose well with cancelable\n// promises if such a thing were to happen.\n\nvar p1 = Q.delay(1000);\nvar p2 = p1.then(function () {\n    return Q.delay(1000);\n});\nreturn p2.progress([p1, p2], function (p1, p2) {\n    if (p2 == null) {\n        return p1 + 1000;\n    } else {\n        return p2;\n    }\n});\n\n// Generalizing composition of parallel promises\n\nreturn Q.all([\n    Q.delay(1000),\n    Q.delay(2000),\n    Q.delay(3000)\n]);\n\n// Depends only on a pretty straightforward augmentation of existing all\nfunction all(questions) {\n    var countDown = 0;\n    var deferred = defer();\n    var answers = Array(questions.length);\n    Array.prototype.forEach.call(questions, function (promise, index) {\n        ++countDown;\n        promise = Q(promise);\n        promise.then(\n            function (value) {\n                answers[index] = value;\n                if (--countDown === 0) {\n                    deferred.resolve(answers);\n                }\n            },\n            deferred.reject\n        );\n    });\n    if (countDown === 0) {\n        deferred.resolve(answers);\n    }\n    return deferred.promise.progress(questions, max);\n}\n```\n. I am fixing progress with this change, which is now in the `v2` branch.\n\nhttps://github.com/kriskowal/q/pull/475/files\n. I do plan to expose a `Promise` object that meets the ES spec. That much is not hard. I am not planning on making it a polyfill \u2013 that is, to fall back to using the global Promise as the implementation if it exists. However, @erights and I might consider such a project and put it under https://github.com/drses.\n. As mentioned, we now expose `Q.Promise`. In the `v2` branch, it has the right interface, but a bit more work will be needed to bring it up to spec, with help from @domenic if he has time. Polyfilling is otherwise out of scope for Q, but is a good idea for a future project.\n. Thank you.\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. Textbook case of the tension between design principles and adoption / user happiness. Thanks for the feedback.\n. True enough.\n. I believe this has the opposite of the intended effect. The idea is for the array logged to the console to react to changes to its content, so that it contains only the rejections that are unhandled at a given time.\n. The issue is that errors can be handled asynchronously, but might not be handled at all. We cannot distinguish the two programmatically, so we show a \u201cbest guess\u201d, such that if an error is thrown, it is shown, and when it is handled, hidden. At any moment, you will only see the errors that have not yet been handled.\n. I can see the value of promoting primitives to full-fledged errors at the earliest convenience, to enable us to at least trace a bad error to its event of origin. I\u2019ve left this open and will entertain pull requests if someone beats me to it.\n. I am tempted to remove the feature entirely, which I intended to do once there was a viable promise debugger. All of these problems amount to misunderstanding the log entry or consoles failing to update. As for the viable promise debugger, work is ongoing both in the Ember inspector and the Montage inspector.\n. @cowwoc My hope is that you will not have to buy into Ember or Montage to take advantage of their promise debuggers. This will require some coordination about what protocol Q will use communicate with them (over the window message port).\n\nRegarding consoles that don\u2019t update https://github.com/kriskowal/q/issues/151\n\nThe console message is sent once and immediately when a rejection is created, regardless of whether it is subsequently handled. If it is subsequently handled, the relevant error should be removed from the array and the console should update the live list. It very well might not, but if the browser fails to update, there is nothing we can do from within Q to improve the situation.\n. @cowwoc handlers can be added in future events. That an error is not handled before the event queue flushes is not a perfect indication that the event will never be handled. Though it is a decent heuristic in practice, if the console does not update, there will be false negatives.\n. @cowwoc Astute observations all around. We _are_ indeed looking forward to post-mortem garbage collection hooks, perhaps in the ES7 timeline, though these have been discussed by TC39 for at least five years http://wiki.ecmascript.org/doku.php?id=strawman:weak_references.\n\nI agree that the console _should_ capture a snapshot.\n\nThis is my throw-away prototype for a Chrome Extension that adds a Promise panel https://github.com/montagejs/continuum\n\nThis is the issue pertaining to the development of the Promise tab in the Ember inspector https://github.com/tildeio/ember-extension/pull/76\n. @cowwoc Thanks for the tip on the WebKit behavior. If it snapshots when opened, it\u2019s useless for this purpose. We need to remove the feature outright and hope for postmortem GC or a promise inspector. At this point, the log is completely misleading.\n. @domenic I am tempted to remove all unhandled rejection tracking entirely. Do you want to keep the interface in the `v1` train and remove it entirely in `v2`?\n. @domenic I\u2019m proposing that we remove the log in `v1`, retain the current interface, and perhaps add the interface you\u2019re proposing as a temporary substitute. In the end, we need to implement an inspector protocol that provides those hooks.\n. @petkaantonov That is a better but not a perfect heuristic.\n\n``` js\nvar Queue = require(\"q/queue\");\nvar queue = new Queue();\nqueue.put(Q.reject());\n// \u2026 later\nqueue.get().catch(function () {\n});\n```\n. The producer and consumer are running in separate events. Ergo, `// \u2026 later`.\n. Note that until and unless the `respect` lands, the relevant differences are here:\n\nhttps://github.com/kriskowal/q/compare/respect...eta\n. Automatically closed when I renamed `master` to `v2`.\n. Merging into `v2`.\n. Here\u2019s my argument, and my apologies if there\u2019s heat coming off it.\n- Specs need to work in Mr and Node.js without much futzing. Jasmine and Mocha both require scripts outside the module system. Mocha and Chai are not loadable with Mr because they depend on `index.js` modules. Not a problem for Browserify, but on Mr, I debug without a build step.\n- To facilitate debugging, reporters need to display results inline with all output produced during a test. Both the Node.js and Browser reporters proposed here just note when a test begins on the console to make it obvious where to look when something is broken. I use coloring in Node.js to make these delimiters conspicuous without being distracting. I used console.group and console.groupEnd for the browser specs because they were there. I also used coloring to draw attention to certain lines of the summary depending on the big picture, like highlighting passes in green only if all tests pass, highlighting errors or skipped specs only if there are any.\n- Also, browser specs should use the page as a stage and the console for reporting. Fancy dynamic test result reporters in browsers make it difficult to identify which tests produced which console output, which makes tracing errors more difficult.\n- Jasmine tries too hard and in the wrong ways to emulate a domain for each spec. I do not want domains. I want exception containment to flow through promises. I do not mind if a spurious error causes the tests to fail prematurely since this will be relatively straightforward to isolate.\n- I do very much want the interface to be `describe`, `ddescribe` for focus, `xdescribe` for skip, `it`, `iit` for focus, `xit` for skip. Jasmine does not have this feature, Mocha has `.skip` and `.only` modifiers, which are awkward to causually insert and remove.\n- I also don\u2019t care for the natural language machinations. The only good reason to use the `expect` DSL is that it separates the expected from actual values, which makes it easier to explain failed assertions. This scaffold re-uses Object.is, Object.equals, Object.compare, and Object.has operators from MontageJS/Collections which have sensible meanings and modern implementations for handling reference cycles gracefully. I would rather re-use these primitives than re-implement them, or have slightly different implementations of them between the test scaffold and elsewhere I use them.\n- Specs need to work in Istanbul without much futzing. Mocha and Jasmine both support this, but with this scaffold, it is trivial.\n. This was automatically closed when I renamed the `master` branch.\n. I am going to merge this into `v2` although it is not final.\n. Thanks.\n. I can\u2019t account for the Github UI, but the changes did apply.\n. I gather that this wasn\u2019t even thrown as an exception. I was counting on that.\n. Not very nice of them. I can\u2019t withdraw support for SpiderMonkey in the `v1` timeline, but there are perhaps better ways to check, e.g., existence of a `StopIteration` global that is _hopefully_ not a shim.\n. We\u2019re trying to create a promise inspector protocol to address this problem. This would enable a variety of agents to surface the list of as-yet-unhandled rejections and still-pending deferred promises.\n\nhttps://gist.github.com/kriskowal/8948969\n. This is a good observation, and the result of my vacillating over the course of the last month. I\u2019ll add clarifications to the v1 and v2 readmes. \n. Addressed. Please take a look at the readmes in the v1 and v2 branches and let me know if the preamble statements are clear enough.\n. I have a pretty strong DRY policy. Mostly because I will reliably forget to update redundant information. I realize you are probably picking `q.js` out of the repository and using it as a script, but it\u2019s better to keep the `package.json`, `LICENSE`, and relevant modules together. Package managers generally do this.\n\nHowever, in the 2.0 timeline, we have _generated_ products for script tag and AMD usage, so we could introduce a system to inject version and license information.\n. See #434 \n. IRC, Freenode, `#promises`. Can coordinate a hangout from there if that\u2019s what you mean.\n. My intention is for the v2 release train to be experimental end-to-end, with v3 being the next stable. That would get us out of the must-be-perfect dead-lock so we can iron some of these things out. That I think fulfills the intention of a \"prerelease\", but lets us tinker a bit. It will be good to have these out in `npm` so we can fiddle with downstream implications, particularly for Q-Connection.\n\nWe are on the same page about progress and notify. I have removed them outright and might introduce something to replace its status notification behavior downstream using the same async reactive observer technique as the estimated time to completion feature.\n\nWe are on the same page about `invoke` and `try`. I would be fine with separating the internals for function calling and method invocation again. I did consolidate both behaviors into `post` per @erights and Tyler Close\u2019s implementation but would not mind separating them again.\n\nI am definitely going to introduce `Promise.prototype.call(thisp, ...args)`, `Promise.prototype.apply(thisp, args)`, and `Promise.prototype.bind(thisp, ...args)`, so that a promise for a function is \u201cisomorphic\u201d to a function. My intent is to ignore the troublesome `thisp`. I don\u2019t want to entrain Javascriptiness in the wire protocol, but perhaps such is inevitable. Perhaps we\u2019ll need to convert function calls with a non-global, defined `thisp` into invocations internally.\n\nSo in summary, I am fine with the variadic forms of method invocation and function calling being `invoke` and `call`, with perhaps `fcall` to omit the `thisp`, perhaps. With `try` playing, I could be convinced to eliminate `fcall` and `fapply` entirely from the public interface.\n\nHowever, we still need names for the non-variadic forms of `invoke` and `call`, currently `post` and `apply`. We don\u2019t have a spread operator yet. Perhaps we can eliminate them in the public interface since they're seldom used, but I don\u2019t want variadics in Q-Connection or the lowest levels of the Q implementation. I\u2019ll have to think and fiddle on your feedback for this.\n\nI agree that `post` no longer smells right. I don\u2019t know how firmly @erights and Tyler Close hold to that name. Between you (@domenic) and me, I felt strongly enough about `invoke` to get rid of `send`. I don\u2019t have an alternative name to replace `post`, apart from eliminating the non-variadic form entirely and using the `invoke` as the name on the wire even though the argument pattern doesn\u2019t match.\n\nI could buy `Q.method` with passing `thisp`.\n\nI am inclined to keep `is{Fullfilled,Rejected,Pending}` because they can be implemented to avoid creating a snapshot object.\n\nI\u2019m making `q/node` an implementation detail and exposing the entire Node.js interface regardless of whether you\u2019re using Q in Node.js or not. I believe you sold me on this. However, this is one Q feature I do not intend to push to standardization.\n\nI will either kill or keep passByCopy before v3. Much depends on what works out for Q-Connection v2 experimental.\n\n`then` in terms of `done` is still on the table. My preliminary essays did not work out.\n. Preliminary checklist for a v2.0.0 experimental release:\n- [x] clarify in CHANGES.md that there are no plans to support `progress` and `notify` hereafter. The interface and behavior are broken. Something else may be invented to fill the need for ad-hoc status change notifications.\n- [x] consider refactoring `post` into `invoke` and `call`.\n- [x] consider eliminating `fcall`, `fapply`, and `fbind` in favor of `call`, `apply`, and `bind` with `thisp`\n- [x] consider factoring `call`, `apply`, and `bind` such that they wrap `invoke` instead of `call` if they are given a meaningful `thisp`.\n- [x] consider replacing refactoring the `\"post\"` dispatch operator into `\"invoke\"` and `\"call\"` instead of using the null thisp to distinguish the cases. Note that `\"invoke\"` would replace `\"post\"` for method invocation messages despite that its first operand would be an array of arguments, not spread arguments like the `invoke` method.\n- [x] introduce `Q.method` to replace `Q.fbind`.\n- [x] make sure `nodeify` is in the right place (imlpemented in `node.js`, exposed in `q.js`)\n- leave passByCopy alone for now. MarkM needs it for DrSES, though we might go a different way for Q-Connection with push/pull.\n- implement then in terms of done at some point, but doesn't have to land immediately, assuming it works at all. It is also necessary that it be faster in the end than the current factoring.\n. Merged changes.\n. I rebased. It seems our entire conversation is lost to posterity.\n. As mentioned by @erights, that makes the Q object itself indistinguishable from a thenable. This is somewhat moot since Q is unlikely to be used as the resolution of a promise.\n\nHowever, I do like that the position of when and then mirrors their usage in natural English.\n- Go to the market _then_ buy some eggs.\n- _When_ you go to the market, please buy some eggs.\n. I don\u2019t intend to implement this. Like Bluebird\u2019s `bind(thisp)`, this interface would inevitably leak information and capabilities into parent stack frames or chained promises.\n. ``` js\nQ(null)\n.then(something)\n.then(something)\n.then(function (value) {\n    return doSomeQuery(value)\n    .timeout(2000, \"Query took too long\")\n})\n.done();\n```\n. In this case it is different only because the timer starts when `timeout` is called. Nesting it changes the time.\n. As a thought experiment, consider when the timer would start and when it would stop. These must be different times and a promise must be constructed and fulfilled between them.\n. How is the end of the chain to be communicated back up the chain? Also, promise chains can branch. Which end? If the chain is continued by a third party, does the timeout necessarily apply to all future work that begins with the returned promise?\n\nI hope that I am coming off more as the Plato than the adversary. My belief is that the idea will not work and that nesting nicely delineates where the intended work both begins and ends.\n. Understood. Thanks.\n. @domenic Promise.constructor can wait for `v2`, where promises are actually using constructors. Will need your review to be sure it does what you mean.\n. 1.0.1 published.\n. Seems npm publish hiccoughed. Upgraded npm and published anew. Should be up now.\n. @nillis Thanks for isolating that. We\u2019ll switch to using a dom observer in a future release.\n. `then` creates a new promise _for whatever result is produced by either the fulfillment handler or the rejection handler_. If you want to see an error pass through a `then`, you need to \u201ccatch and release\u201d.\n\n``` js\nreturn service.get()\n.then(function (data) {\n    console.log(\"GOT\", data);\n    return data;\n}, function (error) {\n    console.log(\"ERROR\", error);\n    throw error; // <- do this for the error to continue propagating\n});\n```\n\nThis is directly analogous to `try`, `catch`, and `throw`.\n\n``` js\ntry {\n    var data = service.get();\n} catch (error) {\n    console.log(\"ERROR\", error);\n    throw error;\n}\nconsole.log(\"GOT\", data);\nreturn data;\n```\n. You would get a resolution of `undefined` if you omit the `throw`, since an error handler can recover from a failure by returning the desired result, and if you omit `return` in a JavaScript function, it falls back to implicitly return, specifically return undefined.\n. Thank you for spotting that. We\u2019ll have to use `fcall` or some such.\n. @pornel This could use your review. #499 \n. Thanks @stubbornella \n. I have no idea. It should not in principle since v2 is entirely experimental, ES5 only, and somewhat broken; but if it does and someone can tell me how to prevent that, let me know.\n. @xogeny Thank you for finding this solution. I will leave this open. I\u2019m open to documenting these directions for Bower users, perhaps a link to the Wiki from the README.\n. I\u2019ve noted that you have to use `q#1.0.1` as the version of Q for Bower in the README.\n. Summarily, no. Such a feature would necessitate fibers, which come with plan interference hazards and break JavaScript\u2019s run-to-completion event semantics. Specifically, closures that capture variables in your scope may execute during _any_ function call, no matter how irrelevant that function call\u2019s work is, if it in turn needs to block.\n\nWe of course feel the pressure to make asynchronous code look like synchronous code to give it the appearance of simplicity. But beneath these solutions is merely a leaky half-hidden complexity. For this reason, we are moving toward the use of `Q.async` and generators, which allows us to _explicitly_ yield to the event loop in code that has the same form as synchronous analogues.\n. Not sure how I could have been right since I\u2019m pretty sure I misapprehended the question, but I like your idea for the solution. Alas that event handlers are synchronous. If you need to delay to decide whether to prevent propagation, you would probably need to synchronously stop the propagation and then manually re-dispatch later.\n. This might require more explanation. Usually the first step in a series of functions receives \u201cundefined\u201d as the argument of the first step, for which this example is sufficient. If I were to add this, I would add a new subsequent example and clarify that the \u201cfirstValue\u201d would be the sole argument to the first function.\n. @jimCresswell On reviewing the context, you are definitely not missing something. Merging.\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. Good question. Thank you for asking. We may have to address this question in the README.\n. @aexmachina Can you check which version you have? It should be 1.0.1, not 2.0.x. If it is 2.0.x, can you tell me how you obtained it? There may be a problem.\n\nOtherwise, I do hope / plan to deprecate nfcall in the v2 timeline, which will be an opt-in transition. When that time comes, the preferred usage will be `Q(object).ninvoke(\"method\", \u2026args)` or `var qfunction = Q.denodeify(nodefunction)` followed by `qfunction(\u2026args)` to call.\n. @aexmachina Please run `npm install q@1.0.1 --save` in your project root. You probably installed Q on the one day that 2.0.0 had the \"latest\" tag in npm. This has since been rectified. Q 2.0.0 is not stable, the interface has not been finalized, only works in engines that support ECMAScript 5, and might even be slower that Q 1.\n. Assigning to @domenic, for a boring weekend. I might rediscover and fix the issue when I port Saucelabs infrastructure to Q from Jasminum and ASAP.\n. It would certainly be possible for `done()` to return a singleton rejected \u201cdone\u201d promise. That might help in this particular case, which can be caused by refactoring.\n. Can another reviewer confirm for me that the existing narrative is correct?\n. @granteagon Thank you for taking the time to contribute and sorry that it ends with disappointment. Perhaps next time.\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. I like these ideas.\n. This appears to correspond to APN version 1.4.4, which depends on Q 0.9.x. I am not able to reproduce this problem with Q in isolation. Something in your application or environment must be defining \"delay\" as a read only property of Function.prototype. Please consider attempting to inspect your function prototype to ascertain where the existing \"delay\" property comes from.\n\nIt is not likely that this is an issue with Q itself.\n. No, the current behavior is consistent with the design and `fulfill` does not produce a promise for a promise. Throughout Q, returning a promise or a value from a function causes an eventual resolution for the wrapped value. Async methods must always return a promise, and returning a promise from within an async generator should defer resolution of the async function.\n. You are not the only one passionate about this design difference! Dart\u2019s Futures have this type signature and there was quite a bit of argument about how Promises should behave in ES6. However, recursive unwrapping of promises, and always returning promises, is the only behavior consistent with the design of Q, and we do not have static types like C# and Dart.\n\nThank you for correcting me on the behavior of `fulfill`. This was an experimental undocumented function and will be removed in the next major version.\n\nThe design you wish to achieve would be more similar to Dart\u2019s Futures, could conceivably be thenable, and could have strictly monadic type signatures. There are some wrinkles with this approach, particularly that you have to handle return values from handlers as well as generators differently. You could coerce non-future values and adopt existing futures, or you could mandate that handlers must return futures.\n\nThe merit of the Q promise design is that it is forward-thinking about working with remote objects. I believe the approach of having a \"then\" that only unboxes one level of promise does not play well in this scenario for performance reasons. With recursive unboxing, we can shorten promise chains, and we actually support this enhancement in the v2 branch.\n\nI am sympathetic to your concerns here, but Q is not flexible on this point. I am eager to see alternate implementations that explore the space you describe, as well as implementations that consider cancelable tasks with reference counting. I might take on one of these experiments myself, but outside the purview of Q. Please consider the issue rather thoroughly thought-out.\n. Thank you!\n. This is true, and I had hoped nobody would notice until version 2. Version 2 uses an internal WeakMap, which cannot be tricked, even if you use `Object.create(Q.Promise.prototype)`. It would be sensible to use instanceof in the v1.0 release train.\n. I\u2019ve landed this. This will be published in version 1.0.2.\n. My intent is to back-port recent changes to https://github.com/kriskowal/asap. Thank you for your pull request. We will be adopting its strategy.\n. See #396. In summary, not yet.\n. Thanks.\n. Thanks!\n. I have already make this change in the v2 branch. Will need to back-port.\n. There is a nascent effort to provide an equivalent feature in a library. Perhaps you can give @tatumizer a hand.\n\nhttps://github.com/tatumizer/circuit-js\n. You might have more luck if you frame the problem using an array of functions that return promises instead of an array of promises.\n\n``` js\nfunctions.reduce(Q.when, Q())\n.then(function () {\n    console.log(\"All stages completed\");\n})\n.done();\n```\n. The next interesting pattern is executing each sequential step contingent on the result of the previous. In that case, you would compose your functions wrapping the last with the previous until you wrap the first.\n\n``` js\nvar response = phases.reduceRight(function (nextApp, app) {\n    return function (request) {\n        var response = app(request);\n        if (response.status >= 400 && response.status < 500) {\n            return nextApp(request);\n        } else {\n            return response;\n        }\n    });\n}, function notFound(request) {\n    return {status: 400};\n})(request);\n```\n. As far as I can tell, you either want to wait for all the file checks to be completed, or you want the file checks to be executed in serial.\n\nTo run the file checks in parallel, obtaining a promise for the completion of all checks:\n\n``` js\nQ.all(files.map(function (file) {\n    var filePath = path.join(directoryPath, file);\n    return fileChecker.check(filePath, whatIf);\n}))\n.then(function () {\n    console.log('All done');\n})\n.done();\n```\n\nTo run the checks in serial, with a promise for all of them to complete, one common pattern is:\n\n``` js\nfiles.reduce(function (ready, file) {\n    return ready.then(function () {\n        var filePath = path.join(directoryPath, file);\n        return fileChecker.check(filePath, whatIf);\n    });\n}, Q())\n.then(function () {\n    console.log(\"All done\");\n})\n.done();\n```\n\nPlease consider following up on http://stackoverflow.com/. You\u2019ll get a lot more answers much more quickly than here. This channel should be reserved for problems that might necessitate changes to the library.\n. The sole distinction and in-fact purpose for `done` is that if an error is thrown from a handler, the promise library will not catch it. With `then`, such errors would be caught and be transformed into rejections on the promise that `then` returns. `done` does not return such a promise. My original intent for creating `end()`, which @domenic convinced me to rename `done(fulfilled_opt, rejected_opt)` presumably to cater to the jQuery crowd, was to make it possible for an exception to escape the `try/catch` in `then` and be surfaced as a synchronous error. If you only have `then`, you end up frequently inventing your own often error-prone `.catch(function (error) {console.log(error.stack)}` where you need to surface an unexpected exception.\n\n`Q.reject(new Error(\"foo\"))` creates an asynchronously rejected promise. The error can percolate to a handler. `onerror` is intended for rejections that were not handled as expected, because they made it all the way to the `.done()` at the end of a promise chain. Try `Q.reject(new Error(\"foo\")).done()`.\n. @AZielinski give it a shot. Throw a console.log in Q.reject. In many programs, this will cause much more noise than signal. Alternately, add a hook for when the nextTick queue is completely flushed and log all the rejections that have not been handled (which is pretty straightforward to track in Q.reject and Rejection#then. You\u2019ll still get false positives in some programs, e.g., any time you use a promise queue where the producer side is making rejections faster than the consumer is taking them up.\n\nFirefox just added a feature where, if a rejected promise is garbage collected, it surfaces the error. This is a great heuristic and a hint at the long term solution. There are a couple efforts to add insight about unhandled rejections and pending promises in inspectors.\n. Oh, you\u2019re begging some semantic distinction between errors and rejections. This implies that you would explicitly catch all errors that you would like to be handled as rejections and then manually call `Q.reject(error)` in all those cases, e.g.,\n\n``` js\nFS.read(fileName).then(function (text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return Q.reject(error);\n    }\n})\n```\n\nThis is the style that you have to use with jQuery promises, and in my opinion, largely defeats the benefit to using Q.\n. @AZielinski rejected promises propagate through chains of `then` until they hit `done`, just as exceptions pass through parent stack frames until they hit the bottom. Until we have better debugger support, you just need to remember to either return or `done()` every chain of promises.\n. Please see `denodeify` and `ninvoke`. There are also `nfcall` and `nfapply`, but they have a less certain future.\n. Data on queue support for browsers.\n\nhttps://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\nWe can drop MessageChannel leaving a very small segment of browsers falling back to setTimeout.\n\nExcept, as @stefanpenner points out, WebWorkers.\n. Need to back-port https://github.com/kriskowal/asap/pull/41\n. Replied.\n. The version 2 branch is CommonJS only. We do not have anything set up yet to give you a single JavaScript file with version 2 bundled with its dependencies.\n. I have colleagues who have been using progress and notify to propagate status messages.\n\nQ does need the specific utility of ETC. I don\u2019t think that utility can be tacked on in a library because the composition needs to occur in then, all, &c.\n\nI believe status messages will also require integration with the core.\n\nApproximations of the eventual value are an interesting case. A generic system for signaling may be in order. However, this crosses from the realm of promises to the realm of functional reactive programming.\n\nI will continue thinking about this. For now, if it dispels a sense of urgency, the v2 branch is flagged \"experimental\", subject to radical change, subject to discussion, and not advised as a foundation for any project at this time. The v1 branch will continue to support progress/notify indefinitely.\n. This is because `deferred.makeNodeResolver` has too much magic and not enough knobs. This has been rectified in the v2 release train, where we'll have an opportunity to make a backward incompatible change to makeNodeResolver. It may be possible to introduce the new behavior under a different name, but then there will be a migration to the side, and a migration back, which would be byzantine. I have decided to close this as wontfix, in the context of v1, fixed in v2, since in the v1 timeline, the problem can be worked around by not using denodeify and writing a custom wrapper at small expense.\n. Assigning to @domenic, to investigate at his leisure, if he will.\n. Thanks a bunch!\n. Thanks.\n. Sounds like you\u2019re calling `then` as a free function instead of as a method of the promise.\nThe following code would have the effect you describe:\n\n``` js\nvar then = promise.then;\nthen(fulfilled, reject);\n```\n. @pedroteixeira I will take it under consideration, but there is a limit to the amount of defensiveness that is practical for a JavaScript library to undertake, short of using Caja.\n. Thanks.\n. Hey, @dantman. Please to hear from you again.\n\nThe Q version 1.0 train will continue to be maintained indefinitely, supporting legacy browsers. If anything, I aim to increase compatibility with browsers deeper into the mists of time.\n\nThanks for pointing that out in CHANGES.md. That is not in sync with the current policy and is a relic from before 1.0 was released. That description applies accurately to the v2 branch and \"future\" release train, which I do not recommend anyone use at this time.\n. Fixed verbiage in CHANGES.md in v2 branch.\n. Good point. I have also been hoping to make a dedicated website for Q and related packages with searchable documentation. Stay tuned.\n. I\u2019ve always considered the audience beginners, but have equally always struggled to reach out to them. Perhaps more specifically, the audience of the Q readme has been shifting over the years, from reaching out to like minded people I needed to help support and promote, to skeptics who might already know the alternatives well enough to judge, and that is perhaps as far as we have gotten. The audience is moving and we may be overdue for a another iteration of the introduction.\n. Have you tried Q 1.0.1? Thank you for revealing the issue, but v2 is experimental so you might try the stable version.\n\nThat being said, this is a curious bug indeed!\n. I considered moving the Node specific adapters into a separate module in v2, but this significantly reduces the convenience of using them. Also, Node.js style callbacks do exist client side especially in conjunction with Browserify. And the penalty for having them is not very large. In v2, I\u2019ve scaled back to just supporting `ninvoke`, `nodeify`, `denodeify`, and an improved `makeNodeResolver`.\n\nWhile I would love to see dead code elimination, I\u2019m not sure we can facilitate it in Q, short of a global.Q_NONODE.\n. Duplicate of #328 \n. @Alexsey can you describe how this interferes with your application? The Collections package does shim some methods on Array.\n. I\u2019m bringing in the iterator shim from collections@future for remote streaming. I will need to find a middle road before q@future is prime time.\n\n@alexsey Please note that this is not a problem for the official release of Q, and Q version 2 is not recommended for anything but experimental use.\n. The most viable solution is to remove shimming in Collections and instead expose operator modules. cc @stuk\n. @stuk, In Python at least, the strategy for adding operators to lower level objects and allowing higher level objects to override is to expose an operator like `len(object)` that implements the behavior for lower level objects (checking the length of a builtin like list and set) and then if the type is unknown, delegate to a method if it exists, like `object.__len__()`.\n\nCollections provides `equals`, `compare`, and `iterate` operators.\nThese could conceivably be exposed the Python way instead of as `Object.equals`, `Object.compare`, and `Array.prototype.iterate()`.\nThe usage would become:\n\n``` js\nvar iterate = require(\"collections/iterate\");\niterate(collection);\n```\n\nFor now, the `iterate` operator would still have to delegate to `collection.iterate()` as a named method, but ES-next introduces `Symbol.iterate`. In keeping with that style, operator modules would probably export a `symbol` property on the operator, to allow higher level objects to safely add overrides for any operator module.\n\n``` js\nvar iterate = require(\"collections/iterate\");\nMySet.prototype[iterate.symbol] = function () {\n};\n```\n. Thanks, @Alexsey. I worry about breaking people\u2019s stuff with my moon shot branch.\n. You can use .done() at the end of promise chains to ensure they get surfaced. In the browser, this will log the error and continue. In Node.js, it will log and halt. You can override its behavior by assigning to Q.onerror which will have global effects.\n. Thanks.\n. Spread does implicitly call `all` internally. This is an interesting use case that challenges that decision.\n. Thanks.\n. Yes. Q can be loaded as a script tag, it can be loaded with RequireJS, and it can be loaded with any CommonJS client side module loader, e.g., Browserify, Mr, or Mop. Please stick to using version 1. Version 2 is not fully baked and not fully compatible.\n. Please consider this idiom:\n\n``` js\nQ.delay(minTime).thenResolve(promise)\n```\n. We will need to add it to the qooqbooq when such a thing exists.\n. For version 1, we would need to take into consideration that the require call would be discovered by static analyzers in other environments, which would in turn fail to find the module. I know that Mr can be tricked but not sure about Browserify et al.\n\nFor version 2, does the addon-sdk still support overlays?\n. This is by design. I apologize for being short on time to explain this. In short, `then` returns a new promise for the result of the handler, which may be undefined if you do not return anything explicitly. It does not return the same promise that it received.\n. I will defer to the ES6 Promise spec and fix either the behavior or the comment. Thank you for noticing the subtle difference. I believe that the behavior is correct and this comment is incorrect. Tobie Langel proposed a distinct `any` method that would behave as this comment describes.\n. I am likely to merge this.\n. I will have to come back and answer this question properly. I am sorry that I only have a moment for a terse reply since my wife and I are preparing to move.\n\nA chain of promises does not necessarily have a single, canonical, terminal promise. These chains can branch.\n\n``` js\nvar branchA = promise.then(A);\nvar branchB = promise.then(B);\n```\n\nThere also remains the problem that `last` would only be able to get to the end of a chain as currently written. The last promise in the chain might be pushed back by attaching a promise to the end of an existing chain.\n\nYou might alternately wish to cap _all_ the branches, and while you might mean well by it, this feature would break the Principle of Least Authority and opens the door for distant effect hazards.\n\nIn short, promises might not be the primitive you need to solve the problem you\u2019re considering. This sounds like a situation where an observable would be better suited, since you could throttle render messages.\n. Override Q.onerror. Otherwise, promises by design consume thrown exceptions so that they can be received by their dependencies. This introduces a class of programming errors that are unique to promises, but not avoidable at time of writing. Developer tools will be able to mitigate the disappearance of errors never to be handled and forever pending promises.\n. Thank you. We will not be including this feature.\n. Thanks. I\u2019ll change this to `typeof module === \"object\" && module && typeof module.exports === \"object\")`. We use strict equals for value checks. To be especially paranoid, also checking whether module is truthy since null is a typeof object.\n. Indeed. Thanks for noticing that. Checking for its existence seems good enough to me for now. Let me know if it fails to distinguish some environment where it turns out to be null.\n. @jfrumar As @kahnjw points out, the problem probably lies after the code you have elided. \"promise\" in this case is the result of the last method of the chain. If Q.ninvoke returned undefined, the expected error would be \"could not call method 'then' of undefined\". We have substantial evidence that \"then\" on a promise returns a promise. It is very likely that you need to remove `.done()` from the end of your chain since it is the only promise method that intentionally returns `undefined`. Please let us know.\n. Thanks. Pushed the tag. Sorry that I missed that step.\n. No, there are working implementations of these in Q-IO\u2019s v2 branch. That work in turn inspired the sketches in the https://github.com/kriskowal/gtor repo.\n. In Java (as in JavaScript) you catch and fail to log or rethrow, the error is consumed. That is not a fundamental difference.\n\nHowever, there is a fundamental difference between synchronous exceptions and asynchronous exceptions. The promise _must_ catch the exception so that it can be observed by _zero or more_ consumers in the future. It is possible that nobody will care about the failure, possible for multiple branches of logic to depend upon a promise and observe the failure, and possible for the failure to be cached until someone comes around and depends on the promise eventually.\n\nBecause of all of these scenarios, logging every error at the throw site generates substantial noise. If you have a sufficiently advanced promise graph browser, as you would with a technology like Causeway or Zipkin but which is not yet in devtools for the web, it would be possible to inspect the state of every promise and their causal chains. Barring that, it would be useful to see a snapshot of all of the \"pending\" and \"rejected but not yet handled\" promises at any point in time. Logging every failure at the call site would make it possible to see every error, but manually poring over the logs to determine whether that error has been handled, how many times it has been handled, and whether it will ever be handled, is not a viable debugging technique.\n. This breaks because of a change of order. I presume something is missing from this commit.\n. I have reverted this pull request from master. Please submit another with the complete set of changes if `npm test` passes all tests and the performance increase is verifiable.\n. I don\u2019t think that extensions like makeNodeResolver are viable with the \u201crevealing constructor\u201d strategy, or perhaps if there is agreement that the argument position should be foreverafter slated for a Node.js specific extension (unlikely). I recommend continuing to use `Q.defer()` for this case.\n. This seems reasonable to me.\n. Pull requests with tests welcome.\n. @pwmckenna Lazy binding everything might slow the library down. I would like visibility into that. Lazy binding Q itself would not be necessary if Q went back to delegating to Q.resolve, but again, that might slow the library down. In alternative approach would be to look into the tickets regarding instrumentation for a debugger. There\u2019s a PR that introduces a way to trap creation of pending promises, settling of pending promises, creation of rejected promises, and handling of rejected promises.\n. Publishing now.\n. Existing code depends on the ability to pass a function with optional or variadic arguments to promise.finally, e.g., promise.finally(stream.close) and promise.finally(server.close). Passing an argument would interfere with these cases, in the same way that array.forEach(console.log) displays the index and array on the same line. Early versions of finally experimented with passing the error or value but I found this to be less useful that the ability to pass variadic functions. It is possible to check the state of a promise within the finally block, e.g., promise.finally(() => promise.inspect()).\n. Having `always` and `finally` side by side would do more to confuse than illuminate. I\u2019m of the opinion that Q gives you all the tools you need as-is and that this sugar would not improve enough people\u2019s lives to pay for itself.\n. This is good. Thanks. I will try to find some time to review, land, publish this weekend or maybe an evening this week.\n. I am curious what about this workflow prevents using Q. Is is there a step that injects a 'use strict' directive? I would entertain this change if it were altered such that it did not preclude using Q as a script in other environments that do not provide 'window'.\n. I am going to land this because, even though there are conceivably environments that this change breaks, this case is likely more important for now. I will follow up by adding 'use strict'; to this block.\n. Good catch!\n. Q will not support this feature. This feature is not possible to implement in browsers. It is possible to implement in Node.js with a binary add-on but is antithetical to the concept of run-to-completion no-shared-memory event loop programming.\n\nBlocking on asynchronous work, regardless of whether you are using promises, will eventually cause the same problems as threads, that is, unexpected interleaving or \"plan interference\". With fibers in particular, it is possible for an asynchronous callback to fire asynchronously any time you call a function that eventually yields, and any function call is a candidate.\n\nThis is the Pandora\u2019s box that must remain closed.\n. `Q.when(promise1, promise2)` is not a feature of Q. You may be confusing it with jQuery\u2019s Bizarro World promises. `Q.when(x, f)` is in fact exactly and only equivalent to `Q(x).then(f)`, which is to say the value is auto-wrapped in a promise if it is not already a promise, and then we wait for it to be fulfilled. `Q.when` is useful in conjunction with `reduce` to do things that are similar but not the same as `Q.all`. The latter is able to abort faster if any promise rejects.\n. I am amenable to adding this feature. Feel free to send a pull request to v1 or v2 or both.\n. Thank you. This is good. I made some time to garden my open source projects this weekend but did not get to this. This is in the queue.\n. @hankduan There is no global list of promises. When you resolve a deferred, the corresponding promise will notify all of its subscribers as soon as possible by adding tasks to the micro event queue. Until a promise is resolved, it has no presence or relationship to the event queue. As such, a process may exit even if a promise remains pending. You can attempt to trap this event with `process.on('exit', function (code) {deferred.reject(new Error(blah))});` but at the end of the day, whatever entity is responsible for resolving the promise needs to keep the process alive (e.g., by holding a timer open, holding an open connection, holding a listening server).\n. Wrong base.\n. Q docs are overdue for a review. I\u2019ll provide a short answer here, and perhaps someone can give me a hand with the documentation itself.\n\nQ already exports Q.Promise, which supports the Promise constructor interface (see the change log for a version). I do not have plans as yet to monkey patch the global Promise constructor with Q in any future version, though optional subclassing might be feasible. Q will always support Q-Connection, by whatever means possible, which may imply using a special kind of promise for remote message passing, and the normal promise for local synchronization.\n\nAnd we do need to draw out the migration paths for each of these methods. Q version 2 has a somewhat streamlined interface.\n\nAnd, for my ambitions for promises in general that go beyond the scope of Q, see https://github.com/kriskowal/gtor\n. I think `promisehelpers` is a better home for this utility.\n. (But this is one of the better pull requests I\u2019ve seen. I recommend filing an issue to gauge interest in the future. Feels bad to say no when someone goes this far)\n. @timjacobi Propose the syntax you would like to see. In the Q version 2 ecosystem, Q-IO provides a stream reader that has concurrency limiting.\n\n``` js\nreturn Reader(asyncIterable)\n.map(function (value, index) {\n    // ...\n}, null, 1) // 1 limits concurrent jobs to 1\n.all()\n.then(function (array) {\n})\n```\n. @timjacobi I do not intend to incorporate this feature in Q. Q-IO provides this facility and if that is not satisfying, I recommend creating a library and adding it to our list https://github.com/kriskowal/q/wiki/Libraries\n. For long indefinite sequences of values, arrays and Q.all are the wrong\ntool. You have to upgrade to streams. Q-IO (v2) provides a readable stream\nthat implements asynchronous forEach(), reduce(), all(), etc, with optional\nconcurrency limits, which beyond 1 concurrent operation, relax the ordering\nconstraint of the stream.\n\nStreams are asynchronous iterators. I talk about this in an essay I wrote a\nyear ago, GToR github.com/kriskowal/gtor\n\nRough implementations exist for stream in the GToR repository and Q-IO v2\nhttps://github.com/kriskowal/q-io/tree/v2\n\nThese are somewhat on the frontier, so bring a willingness to fix bugs and\ncontribute upstream or fork. This is an area where there\u2019s opportunity to\nleave a mark.\n\nOn Thu, Jan 14, 2016 at 2:34 PM, Doug Molineux notifications@github.com\nwrote:\n\n> Jamming a large array of promises into Q.all() isn't scalable (especially\n> when you can't really tell how large it could grow). As a consequence we've\n> been forced to not use it anywhere where we are unsure of the size of the\n> array. In my opinion, A Q.sequenceAll would be an ideal and cleaner way\n> to fix this, rather than using a custom reduce method.\n> \n> It is reasonable to assume that many small implementations of this method\n> will probably not run into this issue, but as soon as we deployed our code\n> to a production environment we ran into this issue in many places.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/606#issuecomment-171803484.\n. Verified.\n. This has been fixed in v1.1.1. Please verify and close.\n. queue.js is included intentionally. I am amenable to shifting over to the \"files\" approach.\n. Thank you.\n. How do you propose we resolve this issue?\n. The part that doesn\u2019t fly for ES6 migration is iterable[Symbol.iterator], unless we can get symbols to implement the map interface before and after such that `Symbol.iterator.get(iterable)` would work before and after, with a Symbol shim.\n. @domenic That would be acceptable.\n. If you\u2019re on the Q/Q-IO version 2 _experimental_ branch, you can do the following for the same effect. 1 is the concurrency limit. `data` may be an array, an object that implements `iterate`, an iterator that implements `next`, a promise for any of the above, or even a remote promise for any of the above via Q-Connection. For higher concurrency values, order is not necessarily preserved.\n\n``` js\nvar Reader = require(\"q-io/reader\");\nvar runOnAll = new Reader(data).map(func, null, 1).all();\n```\n. @slawo Thanks for isolating the issue. Please take up this case at https://github.com/kriskowal/q-io/issues. We have a different set of maintainers at that repository. If you can drum up a failing test case and send me a PR on Q-IO, I would be especially appreciative.\n. @domenic. I agree. It seems that it is time to drop support for old Firefox. Unfortunately, this is a major version change since there are people using Q in Firefox extensions and probably depending on this feature. Yet those things might be upgraded, it's still a major change. Support for old FF has already been removed in the published versions of the v2 branch, so problem solved there.\n. It is very likely that I will need to do weird feature detection per iterator instance to make the heterogenous case work (where both styles are available and either might be used, or possibly even mixed). There are differences in the prototypes, but I will have to do some serious research to capture exactly and only old Firefox iterators without interfering with any other kind of iterator, including duck-iterators (which I will assume to be new-style to avoid going mad).\n. Use the latest, version 1 supports AMD still. Version 2 will eventually.\n. By latest, I mean what npm installs by default. Version 2 is published to npm but is still experimental so not default. There is remaining work to be done in the publishing process to generate the AMD and script tag build products.\n. It\u2019s very likely that you\u2019re not receiving the notification because the observer is not yet attached.\r\n\r\nThis is among the reasons that I replaced notifications with composable progress observers in v2. You get a notification immediately upon observation, with the last known value. Notifications don\u2019t have a specific domain or merge semantics.. This problem should be solved in libraries. In Q-IO, I\u2019m introducing an asynchronous iterator or stream reader. Such readers implement map, filter, forEach, all, &c and accept a concurrency limit argument beyond the standard Array method arguments, e.g., `new Reader([async?][iterable?]source).map(fn, thisp, concurrency)`.\n. @ramakrishnan That is available in Q-IO, but not in Q proper, but only in the experimental v2 releases. I\u2019ve run up against the ceiling of how much time I have to maintain further packages, so anyone willing to pare that out and own it, or backport it to Q-IO v1 and join the contributors/publishers for that package, would be welcome. Anyone willing to provide assistance in bringing v2 out of experimental phase should follow me on twitter and try to join me for open source office hours, which I usually hold every other Sunday at 14:00 PST.\n. @piglovesyou The thin wrapper for node/reader just pumps data into a buffer. The stream uses two promise queues internally, one of which provides promises for the write side, and the other provides promises for the read side. The buffer's size is the number of pre-solved promises in the queue to the writer. The `map`, `forEach`, `reduce` etc methods all accept a third argument which is the concurrency limit. This gets passed into the buffer constructor. I wish I had more time to help. I wrote about the general idea [here](https://github.com/kriskowal/gtor), which may help. The code is a bit of a mess and has at least one known bug. Please follow-up in the Q-IO issue tracker to keep Q notifications relevant for its contributors.\n. You are not alone in these thoughts. Much of the conversation about promises involves these issues.\n\nAs for `.done()`, Q is a dialog with the Promise spec, not an adherent. Q influenced the evolution of the spec and the evolution of the spec influences Q. `.done()` may or may not become vestigial as developer tools improve.\n\nAcross the board, developer tools are exposing a promise inspector which shows unhandled rejections. The thing about an unhandled rejection that makes them unsuitable for plain old logging is that they can be eventually handled. Also, since a promise can be observed by anyone at any time, a handler can be introduced asynchronously. This is anticipated by the design.\n\nDistinguishing operational errors from programmer errors is also a common topic. One could theoretically allow programmer errors to pass through and halt a program. This may or may not be desirable in production, mostly depending on whether a service is stateless, whether you manage your side-effects carefully, whether you can restart quickly, whether your availability matters more than your consistency, &c. So there is no one-size-fits-all for that. Using Q.reject to distinguish asynchronous operational errors from synchronous programmer errors is smart. Similarly, one could require Q.resolve for asynchronous resolution. At that point you have taken on all the burdens necessary to get rid of the recursive unwrapping feature of promises, then becomes equivalent to flatMap in the Monad world. But that\u2019s a different library with a backward incompatible change to its semantics. I won\u2019t even contemplate that for v2. That is not to say it is a bad idea.\n\nThe other issue is that promise chains branch and merge, as above. Ideally your whole program can be modeled as a single asynchronous function call with one way in and one way out, in which you would only ever call .done() once. That is admittedly difficult. Also, handling one branch of a promise chain does not necessarily mean that the root cause of an exception has also been handled by another branch of the promise chain. So, `a.then(b).done()` does not mean that `a.then(c).done()` should omit its `done()` clause, even though a rejected A promise would get reported twice.\n\nIn any case, I thank you for your thoughts. I am closing this issue for the purpose of triaging actionable issues. Continued discussion is welcome.\n. Please review #690\n. Please review #690. The intent is to retain support for windowless JavaScript contexts.\n. We have no interest in maintaining duplicate information for multiple package managers. If you can get what you need by adding information to package.json instead of replicating package.json, we would be amenable.\n. It\u2019s been an age since you submitted this and I\u2019m sorry for losing track of it. I have not triaged Q as often as I ought.\n\nI don\u2019t have a compelling reason to evade adding these checks. If you don\u2019t have time to work on this, I\u2019ll eventually address my feedback and land it myself.\n. Correct. v1 is master. v2 is unstable master.\n. Version 2 of Q has experimental support for passing a thisp as an argument to then. I do not intend to implement bind() because it leaks information downstream. This introduces a security hazard to the interface which, while perhaps unimportant to many users, it is important to discourage its use so that code written for promises remains portable to environments where safety is a concern.\n. My apologies for not responding. My notifications have been going to spam for a while and I\u2019ve just noticed.\n. Replied on link\u00e8d PR.\n. Thank you.\n. Keeping q.min.js in sync was more pain than it\u2019s worth. I recognize that this would be convenient, but it encourages an anti-pattern. You should be bundling and minifying the bundles. If you don\u2019t need to bundle, you almost certainly don\u2019t need to minify.\n. And thank you. I appreciate the feedback and if it turns out you\u2019re one of many, I always take a ticket as a sign.\n. @jcalfee There is a Q.onerror that you can use as a catch-all for unhandled errors once they hit a terminal .done(). I am amenable to @benjamingr\u2019s idea, especially in so far as it would be the beginning of debugger hooks.\n. I have completed a review locally and am good to merge this. Would be great to get :+1: from @domenic. Would be even better if you would follow up with a regression test to ensure that future work does not break this new feature.\n. Sorry for the delay. I have merged and published this as in v1.3.0. If you decide to follow-up with browser support for this feature with window events, or if you follow up with pending and settled events, take a moment to examine the prevailing style for white space in control flow blocks.\n. There are releases of v2 published to npm. Use npm install q@2 to get the latest release of the v2 branch. Also, expect breaking changes on patch releases. v2 is far from final. The same applies to many v2 branches of various projects I contribute to.\n. Thank you for the ideas. I will think about it.\n\nHowever, perhaps you should wait for the smoke to clear. I intend to announce a v2 release from which semver will be reinstated when it would be appropriate to start migrating dependees. The state of Q at present is so very experimental that you are likely to thrash needlessly on interface changes.\n. Do these environments also provide a bad process.nextTick?\n. Come back and re-open this if process.nextTick is bad on these fake Node environments. The isNode test just means that Q will use process.nextTick and check whether process.domain exists when necessary. It should not have any harmful side effects.\n. This has been addressed by @kahnjw in v1.2.1. Thanks for the tips.\n. For what it\u2019s worth, this shows most of the of effort necessary to add a feature to Q in terms of code, documentation, and tests. However, this is very similar to the existing Q.race, and combined with Q.allSettled, provides the same capabilities. I\u2019m inclined not to add this method to the interface. In the next major version, I am rather looking to reduce rather than grow Q.\n. The following pattern seems fitting.\n\n``` js\nreturn Q.race(promises)\n.then(function onFulfilled(first) {\n    // ...\n}, function onRejected(firstError) {\n    return Q.allSettled(promises)\n    .then(function (resolutions) {\n        // ...\n    });\n});\n```\n. Is this what you are describing? https://esdiscuss.org/topic/promise-any\n. I would accept a PR for the `any` as described by @tobie. It is the sensible dual to `all` and distinct from `race`. This is not quite ready and I will note where.\n. See #374 #328 #159\n. Per prior discussion, I do not intend to bring this feature to Q. Please consider using q-deep or publish a small module.\n. This looks good. Thank you for your time! If you do not have any further, I will carry this over the finish line next weekend.\n. @vergara Note the countDown variable in Q.all (which should be used to mirror style), that it gets incremented for each promise that array_reduce visits, then decremented for each promise that settles.\n. Note to self: update README and, when it lands, API reference.\n. Thanks. Coming soon to a minor release near you.\n. I am pretty sure I have seen a package that provides this feature. I don\u2019t intend to bring this feature into Q proper.\n. Sch\u00f6n dank.\n. Any assistance would be helpful.\n. I\u2019d accept a pull to throw if arguments.length !== 1. I would not create an ambiguous overload.\n. @dtheodor I believe what you are looking for is a Signal. I wrote up a long essay about finding the right tool for the job which might be insightful. https://github.com/kriskowal/gtor\n\n@havvy Thanks for your feedback. I find that people feel more welcome if you open by explaining how you understand their motivation.\n. Thanks for the discussion.\n. I am pushing way back on adding new features since feature creep has already gone too far. However, this is not a bad idea. Not because it is convenient, but because it conveys more information for the purpose of estimating time to completion. With the desugared version you illustrate, the resulting promise would not have a good way to infer time to fulfillment, but with `a.after(b)`, the ETF is clearly `max([a.etf, b.etf])`, just like `Q.all([a, b])`. As such, it might be good to implement `after` in terms of `all` in v2.\n\nI\u2019m on the fence, but these are my thoughts.\n. I try to keep concerns separate. I\u2019m sympathetic to the case for convenience, but this comes at a high cost in clarity. There is `Q.promised(f)` (among other things) for the one case, and `Q.async(g)` for the other.\n. Callback hell can be mitigated with or without promises. The first step you should consider is to flatten out our chain with small named functions that forward the state that needs to be captured by future / inner callbacks explicitly, and discarding things in scope that do not need to be carried forward. It may be helpful to create a state object that can capture these values and pass them forward. An affordance of promises is that these small functions can simply be chained with `then`.\n\n``` js\nvar fs = require(\"q-io/fs\");\nreturn fs.makeDirectory(filebox)\n.then(function () {\n    return fs.writeFile(file1, content1);\n}).then(function () {\n    return fs.writeFile(file2, content2);\n}).then(function () {\n    return fs.writeFile(file3, content3);\n}).done();\n```\n. With generators, this is only slightly different.\n\n``` js\nvar fs = require(\"q-io/fs\");\nQ.async(function *() {\n    yield fs.makeDirectory(filebox);\n    yield fs.writeFile(file1, content1);\n    yield fs.writeFile(file2, content2);\n    yield fs.writeFile(file3, content3);\n})().done();\n```\n\nAnd note that writing those files is probably parallelizable.\n\n``` js\nreturn fs.makeDirectory(filebox)\n.then(function () {\n    return Q.all([\n        fs.write(file1, content1),\n        fs.write(file2, content2),\n        fs.write(file3, content3)\n    ]);\n}).done();\n```\n\nAnd note that while parallelism is great, it can explode if you overwork a program, so if you've got enough files and you want to limit active parallelism, you might want to use a job queue of some sort. This is a feature of q-io@2, experimental.\n\n``` js\nnew Reader(files)\n.forEach(function (file) {\n    return fs.makeTree(fs.directory(file.path))\n    .then(function () {\n        return fs.write(file.path, file.content);\n    })\n}, this, 50).done();\n```\n. You are likely to receive a more timely response on stack overflow. You are welcome to keep this open as long as needful in the chance that someone drops by and has a moment, but please close this when you find an answer.\n. There\u2019s a bunch of writing on this topic, but in summary, a promise represents the return value or thrown error from a function call, either from the past or future. Since functions only return one value, you have to box and unbox multi-values as demonstrated above. Other designs run into strange complications.\n\nI hope that the work-around above settles well with you.\n. I hope that @bpq\u2019s summary is satisfying. From our README, always either .done() or return a promise.\n. This has been addressed in the v2 branch. This is a backward-incompatible change, so it can arrive no sooner than version 2, which is and will always be an opt-in upgrade. Version 2 also remains unstable until we have settled on what set of breaking changes we would like to make final.\n\nMy time lingering over the v2 trigger may have to come to an end soon.\n. True. Technically the \"last registered before the resolution\".\n. I would very much like to find some time, or assistance, to automate the process of building compatibility tables. I did this in ASAP https://github.com/kriskowal/asap\n. We have no intention of maintaining two separate but nearly identical package description formats by hand. I would accept a pull request that introduces functionality that replaces, augments, or subverts `npm version` and `npm publish` and correctly produce build artifacts for both Bower and npm from the existing source files without cluttering the working copy.\n. Thanks. I\u2019ll make sure the changes are pushed tonight.\n. pushed\n\nOn Tue, Apr 7, 2015 at 4:22 PM, TJ Rothwell notifications@github.com\nwrote:\n\n> Issue\n> - Changes has 1.2.0: CHANGES.md\n>   https://github.com/kriskowal/q/blob/v1/CHANGES.md\n> \n> Expected\n> - Releases should have a listing for v1.2.0 /releases\n>   https://github.com/kriskowal/q/releases\n> \n> Actual\n> - Releases _doesn't_ show v1.2.0 /releases\n>   https://github.com/kriskowal/q/releases\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/674.\n. This is expected behavior. Each call to .then creates a new promise for the return value or thrown exception of the rejected or fulfilled callback. Since you return undefined in both cases for the handlers of the first promise, the second promise is fulfilled with undefined.\n. Addendum: If you wish the exception to propagate to the second handler, rethrow.\n\n``` javascript\nvar q = require('q');\nvar fs = require('fs');\n\nfunction ReadMyFiles() {\n    return q.all([\n        q.nfcall(fs.readFile,'file1.txt','utf8'),\n        q.nfcall(fs.readFile,'fileee2.txt', 'utf8')  // fileee2.txt doesn't exist\n    ])\n}\n\nReadMyFiles()\n.then(\n    function(data) {\n        console.log('All files read!');\n    },\n    function(reason) {\n        console.log('Some file could not be read. Reason: ');\n        console.log(reason);\n                throw reason; // XXXXXXX\n    }\n)\n.then(\n    function(data) {\n        console.log('Fulfilled!');\n    },\n    function(reason){\n        console.log('Rejected');\n    }\n)\n```\n. 2.2.6 refers to parallel, not series, usage of `then`. Consider:\n\n``` js\nvar files = ReadMyFiles()\n\nfiles.then(\n    function(data) {\n        console.log('All files read!');\n    },\n    function(reason) {\n        console.log('Some file could not be read. Reason: ');\n        console.log(reason);\n    }\n)\n\nfiles.then(\n    function(data) {\n        console.log('Fulfilled!');\n    },\n    function(reason){\n        console.log('Rejected');\n    }\n)\n```\n. Unhelpful docs are a bug. Please let us know what we can do to make the Q README clearer. This is the relevant section:\n\nhttps://github.com/kriskowal/q#propagation\n. I would entertain a PR for this feature in the v1 branch, but feel this feature is highly antiquated in a world with module systems.\n. yes\n. This looks good to me. I will land and release this by end of weekend and hopefully sooner.\n. This is released in v1.2.1. Thanks for looking into this.\n. ``` js\nprocess.nextTick(function (error) {\n    throw error;\n})\n```\n\nHowever, that is what `done()` effectively does.\n\nSome folks have wondered whether it would be possible to automatically distinguish operational errors from programmer errors, throwing the latter and rejecting the former. Distinguishing errors is beyond the scope of Q, but it certainly is possible to:\n\n``` js\n.catch(function (error) {\n    if (!isOperational(error) {\n        process.nextTick(function () {\n            throw error;\n        });\n    }\n    throw error;\n})\n```\n. This seems reasonable and I would land this unless @domenic has strong opinions to the contrary. Bother me if I take no action between now and mid May. I do my open source gardening on weekends.\n. This is a great library. I am perfectly content for it to remain external to core. Please feel free to advertise it here https://github.com/kriskowal/q/wiki/Libraries\n. Deliberate, yes. Correct, no. Revised.\n. I\u2019m not sure how you ended up with `q@2`. `q@1.4.0` is latest in npm and you have to explicitly opt-in for version 2. There is some chance that version 2 got trapped in your package.json or shirnkwrap. Otherwise, I am unable to reproduce the problem locally.\n. Thanks!\n. Landed for v1 and I\u2019ve got a fix for v2 in my working copy. Closing this to get it out of the inbox.\n. `Q.all` does not have the ability to limit concurrency. It receives an array of input promises for work that has already started. Q-IO v2 provides a `Reader` that implements `map` with a concurrency limit that you adjust parametrically.\n\n``` js\nnew Reader(iterable)\n.map(function (value) {\n    // return promise\n}, null, config.development ? 1 : 100)\n.all()\n```\n. Reproduced locally. Investigating.\n. Missing `var`. The second call overwrites the global `defer` so the first timeout never resolves.\n. \"use strict\";\n. Thanks, but this is fine as written in my opinion.\n. Yes. then() returns a promise for the value returned, excpetion thrown, or promise resolved by onFulfilled or onRejected. Chaining is different than branching.\n. Deep in the annals of Q, you will find that this backward-incompatible change reverts a backward incompatible change that was made between 0.8 and 0.9. I decided that it would be suboptimal for Q-Connection to be hauling the serialized return value of these methods across the wire. @domenic also expressed distaste for chaining style methods, and I concur.\n\nWith the respect due for a proposal to make Q work the way I originally wrote it, this will not land in the v1 branch (because it is backward-incompatible) and probably won\u2019t land in the v2 branch (because it would lead to waste on the wire).\n. @benjamingr That would not work. The .set() method sends a message, which will arrive before the \"ignore\" message.\n. You will get a much faster response on stack overflow.\n. I have not had a moment to spare.\n\nPlease clarify what engine (Node.js?) you are using so we can dismiss the possibility that you are using actual threads. I presume you\u2019re using \"thread\" figuratively. If you are using \"thread\" literally, all bets are off.\n\nNote that you can do `deferred.resolve(this.doSomethingElse())` instead of hooking up the resolve/reject through then.\n\nThis might be something simple to isolate with a test case. I\u2019m ready to believe that progress listener code is undertested. It has been eliminated in v2.\n. Yes, we should fix this.\n. A PR is welcome.\n. Worth looking into. v2 has weak maps to assist with this kind of problem, but I\u2019ve been using them less and less because of the performance overhead.\n. Thanks. Sorry for the instability. I recently published a version of Collections that does not support shims. Q needs an update.\n. Oh, problem is that you\u2019ve pinned to the 2.0.0 exact version. This problem does not exist in version 2.0.3 since the collections dependency has been removed.\n. It\u2019s fair to say at this point that Q@^1 is Q forever. A version 2 has turned out to not be practical.. check your version of Q. latest patch of 2 does not depend on collections.\n. I advocate direct use of the reduce/Q.when/Q idiom. It\u2019s in the README https://github.com/kriskowal/q#sequences\n. In the future, please address this kind of question to Stack Overflow. There is a very active community that can help diagnose these issues quickly.\n\nThe problem in this case is because each iteration of the for loop is overwriting the deferred variable, so deferred.resolve in a future turn of the event loop is only being called on the last iteration. The other promises remain pending forever. The problem can be solved by capturing the deferred in a closure for each iteration, or simply capturing the result of `rp` and adding it to the array, since the deferred is superfluous in this case.\n. Change last line to have `.done()` on the end, which will cause exceptions to surface. There is a reference error in your console.log(e) expression. There is also a missing return in your test.\n. The name Q came from a proposal to TC39 by Mark Miller (@erights) which in turn came from a library by Tyler Close in Waterken with similar shape and purpose. I have the impression that it is short for \u201cevent queue\u201d since promises manage events, and the brevity is deliberate, to encourage folks to wrap promises they receive from others with `Q(promise).then...` instead of trusting `promise.then...` directly. Not all promises are made alike, but most can be tamed by virtue of thenability.\n. @erights That has not aged well. The main points about the limitations of using closures as objects to placate ADSafe became unnecessary in the world of ES5 and SES, so I altered the interface accordingly. The rest has varied in the details. Q no longer does valueOf. The treatment on variadic arguments varies by version as well. Version 2 eschews variadic arguments entirely for the internal handlers, grasping for performance.\n. I have a big request, if you can pull it off. A snapshot of a sample of stacks would be very useful to us, and a very powerful tool for you to use to debug similar issues going forward. What operating system are you using? If you are running on Linux, you could try SystemTap with [node-stap](https://github.com/uber/node-stap) to capture a flame graph. There are similar tools for other operating systems.\n. @nknapp We did intentionally omit synchronous state queries from Q for a long while and left them only for perf optimizations and debugging reasons. We do intentionally call handlers asynchronously, regardless of the state of the promise. If you need an order guarantee, `then` is there to ensure it.\n\nWe don\u2019t intentionally return false for this specific case, but it is an emergent behavior. Creating a special case would probably not be worthwhile, but I would certainly consider a change if it is simple.\n. That is certainly an option. You could also use [ASAP](https://github.com/kriskowal/asap) instead of setTimeout. You could also monkey patch that into `Promise.prototype.done`. Alternately, you could put your faith in the Chrome developer tools, which may even be automatically surfacing unhandled errors when promises get garbage collected.\n. The Q project does not directly support Bower. Anyone who is providing support for Q in Bower, please let these folks know where they can go to get this issue addressed.\n. This is more or less expected since Q v1 was designed to prove the API for promises, makes extensive use of closures internally for a semblance of clarity, and provides a layer of abstraction for remote objects that no other promise library to my knowledge yet does.\n\nI have taken some steps in the Q v2 release train to address some of these performance issues. I would love to see figures for that release train.\n. The v2 branch or npm i q@2 will get it for you.\n. Thanks for bringing up the issue. Much depends on whether this benchmark is indicative of real usage, but regardless I would love to see these metrics improve.\n\n\u201cpseudo recursion\u201d (event queuing) is handled by the ASAP library in v2. It may need some attention. There is a possibility that other implementations trade caution for speed and may be right to do so. There may also be \u201ctail queue\u201d optimization opportunities. There certainly are opportunities to simplify and improve developer experience on ASAP.\n. ASAP was factored out of Q in v2. Had hoped all those promise implementations would rally around our common ground and contribute. We might have to go and back port their observations.\n. Thanks, would gladly accept further changes of this kind. Consider using !callback for brevity and catching other invalid values, or typeof callback !== 'function' to catching an even broader set of invalid values.\n. Oh, please run the tests. Build broke due to a lint error I didn\u2019t notice.\n. Also, feel free to forward-port this kind of change to the v2 branch.\n. TravisCI also does npm run lint. I should probably just add that to npm test\u2019s suite.\n. Fixed lint errors on v1 and added lint to tests (and npm ls check).\n. Pull request for overridable Q.emit welcome.\n. Compatibility with domains is begrudgingly in-scope for Q. PR\u2019s to address issues with domains (with tests!) are welcome.\n. 2.x is pre-release. We do not maintain Bower\u2019s packages. Not sure who does.\n\nOn Thu, Nov 5, 2015 at 1:01 AM, ThomasCrvsr notifications@github.com\nwrote:\n\n> The last published version of Q on NPM is 1.4.1. When you install it with\n> Bower, the version is 2.x. I just wonder if v2 is stable or is this a\n> pre-release ? In the case of a pre-release, it might be relevant to tag it\n> as pre-release no ?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/742.\n. I should have used pre-release semver tags for the 2.0.0 train. Unfortunately, tags are not a mistake that can be unmade. Also, when the 2.x train is officially released, I don\u2019t intend for it to replace the 1.x train as \"latest\" for a long time, possibly never, because there is a general expectation that `npm install q` will give you the version everyone is using, whereas `npm install q@2` opts in for the 2.x version ecosystem.\n. PR welcome on v1 branch. I went a different way in the v2 branch. I am also not picky about Jasmine. I\u2019ve been using TAP for my recent work.\n. terminate your promise chain with `.done()`.\n. Yes, this was a regrettable decision, trying to avoid a usually-unnecessary array allocation. Unfortunately, to fix this requires a backward-incompatible release. As such, the behavior has been altered in the v2 branch. Of course, this is far from the only backward-compatibility break in the experimental version.\n\nhttps://github.com/kriskowal/q/blob/v2/q.js#L304\n. Good catch!\n. Thank you for your suggestion, @ykosbie. In the v2 branch, in an effort to simplify and minimize the common payload for Q, I have been deprecating and removing features, in favor of having these in supplementary libraries when possible. These are neat utilities which I recommend you publish in another package. You\u2019re welcome to add a reference to it in related libraries on the Wiki.\n. The commit hook might be amiss. I forced a recompile with the manual hook http://documentup.com/kriskowal/q/__recompile and it looks fine to me.\n. First glance, this looks like a legitimate improvement to me. cc @domenic for sanity check.\n\nPlease consider making some concessions for the prevailing style. Spaces around operators, fully-spelled variable names (array over arry, length over len).\n. I\u2019m compelled to leave the library as it stands. Undesirable as the behavior is in some cases, it is less surprising in the majority. Explicitly filling missing arguments at the call site seems safer than implicitly filling them in the library.\n\nRegardless, thank you for contributing.\n. Which version of Q and which version of which browser?\n. Thanks. Please consider using the stable version of Q (1.4.1).\n. Pull request welcome. Please isolate what makes the environment dissimilar from the ones Q already recognizes.\n. I propose that the feature should be enabled by the act of setting up an unhandled rejection handler, and otherwise disabled. PRs are welcome.\n. Window is not an available free variable in all environments.\n\nI am hoping that perhaps instead of a change like this, we could expose Q.ondefer, Q.onresolve, Q.onfulfill, Q.onreject, etc hooks for arbitrary promise inspector plugins. Maybe also simplify the existing code for tracing in Node.js, perhaps replacing the onUnhandledRejection error, or at least providing a better underlying mechanism for hooking it up.\n. Thank you!\n. Might be useful to share versions of Node.js and perhaps any modules that might be monkey-patching nextTick. Maybe do a search for occurrences of runAfter. There are no direct references to nextTick.runAfter in Q.\n. Pardon, I was on the wrong branch. Q does in fact have a nextTick.runAfter now.\n. Would anyone be able to Q.nextTick.toString() and manually verify that nextTick.runAfter is missing? Sounds like something is monkey-patching Q.\n. Thanks @mdressman. Let\u2019s keep this issue open to track how Q can be more resilient against this kind of monkey-patching. nextTick should close over its runAfter dependency instead of exposing it as public API.\n. Perhaps we can move it to a top level hook.\nOn Tue, Feb 23, 2016 at 12:56 AM Benjamin Gruenbaum <\nnotifications@github.com> wrote:\n\n> The rationale was to let people change the scheduler kind of like\n> bluebird's setScheduler. I don't think we should explicitly hide it.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/764#issuecomment-187606563.\n. :ok:\n. I recommend publishing this tool as a separate package. I am striving to make Q smaller.\n. This change will need to be cast in a way that does not break backward-compatibility, by preserving existing properties.. For context, I thought hard about this API and removed it entirely in the v2 branch in favor of an \"estimated time to completion\" observer, which has much more sensible composition semantics through \"any\" (min) and \"all\" (max). So what I want in the v1 branch isn\u2019t particularly relevant, but the semver contract with our users is that no minor or patch release will break existing usage.\r\n\r\nSo, whatever you change here has to be additive, not subtractive.. \u2026and the best way to guarantee it is additive is to add tests, no updates or removals.. result.reason should be an Error instance. as with throw, the language permits you to throw other things, but in practice, they should always be Error instances. This problem must be solved in the provider of somePromise or someOtherPromise.\n. This is behaving as designed. The timeout method (as with any other Q method) does not alter the state of the wrapped promise, which would constitute a plan interference hazard. Only the resolver has the power to reject the promise and the timeout method has no access to that capability. If you wish to be informed of the timeout, you must capture the timeout promise instead of the wrapped promise. This can be done by bringing the timeout into the loop around the work per iteration that must be accomplished in a timely fashion for the loop to continue.\n. Yeah, published v1.5.0 a couple hours ago.. So it is done. `master` is the primary branch.. A PR would be welcome.. The correct behavior in principle would be to propagate an \"all rejected\" exception if all of the inputs are rejected. I\u2019ll leave some space for my fellow maintainers to weigh in.. Released in v1.5.1. @timmfin Indeed. There was an unrelated change to the same feature.. Response codes are outside the scope of Q. The promise library only distinguishes fulfilled from rejected. This bug may apply to another library. Are you using Q-IO?. Use the \"latest\" version in npm, which is the most recent release in the version 1 train. Version 1 does not depend on the presence of a CommonJS module system.. You may have an exception trapped in an un-observed promise. Since you\u2019re using `then` with only a fulfillment handler, and not returning the promise returned by `then`, that can happen. Avoiding unnecessary use of `defer()` will help with this:\r\n\r\n```js\r\nfunction someFunction(value) {\r\n    return Q.all(array.map(otherFunction));\r\n}\r\n```. Released in v1.5.1. The behavior is expected; the idea is that promises need to be a uni-directional communication channel for security reasons. For example, a dozen consumers might be given the same resolver so that they can race to provide the resolution, but they should not be able to observe whether they won the race.  That's what I heard from Tyler Close or Mark Miller anyway.\n\nThanks for the cases. I'll have more time to do integration for a while.\n. Please review https://github.com/kriskowal/q/commit/e045fb5329fc5ea4eb202e55b98ee741fd25e4ec\n. This has been done for months.\n. Some of these are now in master, others are in experimental. Thanks.\n. This is a bug. Thanks.\n. Fixed in 4a944a1 / master.\n. By cursory inspection, this has been fixed. Please reopen if you find otherwise.\n. It would look something like:\n\n```\n// accepts a collection name and returns a promise\n// for an array of all of the collection.column names\n// to which the collection can be joined.\nvar collectColumnNames = function (\n    collectionName,\n    columnNames, // not part of the API\n    collectionNames // not part of the API\n) {\n    // the collection to populate\n    columnNames = columnNames || [];\n\n    // A memo to prevent infinite recursion\n    collectionNames = collectionNames || {};\n    if (collectionNames[collectionName])\n        return;\n    collectionNames[collectionName] = true;\n\n    // reduce and forEach can both be used to iterate\n    // with promises either in parallel or serial\n    return collection.reduce(function (prev, row) {\n        var result = row.reduce(function (prev, column) {\n            if (isLookupColumn(column) {\n                var result = collectColumnNames(\n                    column.collectionName,\n                    columnName,\n                    collectionNames\n                );\n\n                // async join in parallel\n                return Q.when(prev, function () {\n                    return result;\n                });\n            } else {\n                columnNames.push(collectionName + \".\" + column.name);\n                // this is the actual result value:\n                return columnNames;\n            }\n        }, columnNames);\n\n        // async join in parallel:\n        return Q.when(prev, function () {\n            return result;\n        });\n    }, columnNames);\n};\n```\n. collection is any array or array-like-object, provided presumably by you from mongodb. Bear in mind that I don't fully understand your requirements, so I just implemented _something_ that might be instructive rather than something functional. The idea is to grasp the use of Array.prototype.reduce in conjunction with Q.when to do parallel or serial joins of asynchronous tasks. Error propagation is implicit.\n. There are several other instances in the README, even in that example, where Q was not explicated.\n. If adding the Q. makes it more clear, I think it's a good idea.\n. Thanks\n. The reason was to support a convention that all modules that can be used as scripts (micro-frameworks) would reach each-other by placing their exports in global[\"/\" + id]. This is guaranteed to not conflict with any other globals. global[id.toUpperCase()] is sufficient for something like Q, but isn't sufficient for something like \"q-comm/browser\", which has hyphens and slashes.\n\nIn any case, I'm accepting this patch because it makes the system more clear in the micro-framework case, which is going to be far more common, than the case where a bunch of CommonJS scripts are installing themselves with script tags before require machinery has been set up.  I will come up with another convention for the more complicated cases.\n\nAlso, I've been thinking that packaging systems might be able to bypass loading certain modules like \"json\" and \"q\" if a global variable like JSON or Q already exists in the environment. This would spare HTTP requests when functionality has already been provided. So, \"Q\" works better for that case anyway.\n. Oh, really sorry about that. I didn't finish the job last night. You'll find that I've moved the q/util and q/queue modules and merged them to the qq package due to NPM's change to no longer expose any module except the main module.\n\nhttps://github.com/kriskowal/qq\n. I hope recent changes to README help.\n. Landed in v0.4.2. Published to NPM. There were no problems with the merge and branch rebase, so whatever you did worked fine.  I think the define.amd check is over-engineered and will probably get in the way eventually, but it's not causing errors now any more than leaving it off would, so I'm going to let it slide for now.\n. Sorry for taking my time on this one. These are now in master.\n. It seems more likely that this issue is caused by the reduce property being enumerable. The syntax is fine. Unfortunately, we can't fix that. \"resolve\" probably needs to be implemented to use the array protocol (using a for(;;) loop on array.length) instead of using a (for (in)) loop. Where is \"resolve\" from?\n. @cosborn, good idea in theory, but if you're using es5-shim, it's only going to do a half-hearted attempt to make it non-enumerable. i think i just need to use Object.prototype.hasOwnProperty.call in this for-loop.\n. Should be fixed in new push. Please reopen if the issue remains.\n. Might as well. My wedding is tomorrow. Give me a week. :) if you send a patch, shim defineproperty first in the shims section. \n. This has been on the back of my mind for a while. Tracking resolved/unresolved promises is also good for what you did earlier for waterfall analysis. We definitely need something, perhaps the ability to create Q sandbox instances that can create a report of the outstanding promise graph.\n\n```\nvar {Q, pool} = Q.create({debug: false});\nvar promise = Q.defer('annotation').promise;\nassert.deepEqual(\n   pool,\n   [{promise: promise, annotation: 'annotation'}],\n   'promise pool contents'\n);\npromise.resolve();\nassert.equal(0, pool.length);\n```\n\nI'll be away for a week, so I will probably not be able to have a lively discussion for a while. That said, I do want to have more dialog with friends and supporters. We need to be a more tightly knit group and I need to be more conscious of how Q is being used in the wild.\n. `end()` is very much a stopgap, which is why I favor it over `.done()`.  There are two cases where we will find ourselves editing the end of promise chains.  The first is when you have to add another step.  After a `done`, you have to walk back and forth to switch the previous `done` to `then` and add a `done`.  With `end`, you just chain a new `then` between the previous and the end.  The latter case, when good visualization tools for the state of a promise graph are available, it is my hope that `.end()` calls will become vestigial and trivial to remove.\n\nHowever, I still think there would be value in introducing promise `domains` (pools as it were, but I think `domains` is going to catch on).\n. It\u2019s time to put this issue to bed. There are three directions being pursued.\n1. Domains exist. This mostly obviates the need for pools, which would probably not be ergonomic in the long run.\n2. Discussion about `end` vs `done` has run its course.\n3. Options are being explored for debugger extensions that surface transient unhandled rejected and pending promises, either through a separate window or logging and unlogging.\n\nThanks, @asutherland. This is the longest lasting, most relevant issue we have.\n. Numerous apologies and thanks. I'll fix this next week. Presently on the road for my wedding. :)\n. I\u2019ve merged https://github.com/kriskowal/q/pull/25\n. Cool, thanks.\n. All the old code blocks have finally been purged. Thanks for the tip. Check out the new README.\n. There are a couple functions recently added to assist in this case.\n\n``` javascript\nreturn Q.ncall(doSomething, a, b)\n```\n\nOr\n\n``` javascript\nreturn Q.node(doSomething)(a, b)\n```\n\nI have been playing with the idea of adding deferred.node() like your suggestion for a couple days. I\u2019ll keep that in mind, but I hope that these functions help for now.\n. Your recommendations are upcoming in the next major release.\n\nhttps://github.com/kriskowal/q/compare/v0.7.2...master\n. Also, jQuery\u2019s:\n\n``` javascript\nwhen(a, b, c)\n.then(function (a, b, c) {\n})\n```\n\nIs equivalent to Q\u2019s\n\n``` javascript\nQ.all([a, b, c])\n.spread(function (a, b, c) {\n})\n```\n\nWe should perhaps have a catalog of patterns.  `then` and `spread` both support the value or promise return in their callbacks like jQuery `pipe`.\n\nBecause `when`\u2019s arguments are optional, you can do this exactly like jQuery\u2026\n\n``` javascript\nQ.when(x).then(function (x) {\n    \u2026\n})\n```\n. @ThomasBurleson, in Q, chained .then calls are the same as jQuery chained .pipe calls. Q does not do parallel processing on the same promise for each .then call: .then returns a new promise for the return value, returned promise, returned rejection, or thrown exception of either the callback or the errback. Since there\u2019s only one callback or errback for each .then call, and only one or the other will be called, which callback resolves the returned promise is unambiguous.  If you want to do parallel processing on the same promise in Q, you have to do this:\n\n``` javascript\nvar p = getPromise();\np.then(function () {\n    return \"a\";\n}) // returns a promise for \"a\"\np.then(function () {\n    return \"b\";\n}) // returns a promise for \"b\"\n```\n. Prompted by this discussion, I\u2019ve started a Wiki page for jQuery users.\n\nhttps://github.com/kriskowal/q/wiki/jQuery\n. @ThomasBurleson Thanks for your insights as well. You put a voice to jQuery users that I could address in the above wiki article.\n. The purpose of calling `nextTick` in this case is not so much to permit interleaving, but to force deterministic interleaving of the callbacks. Callbacks are required to occur in future turns, instead of occurring either on the stack _or_ in a future turn. Using `nextTick` increases the robustness of everything built on top of Q.\n\nIt\u2019s relatively straightforward to safely handle a readable stream in conjunction with promises.\n\nhttps://github.com/kriskowal/q-io/blob/master/q-io.js#L13-100\n\n(Needs further work to support throttling, but has been indispensable for my stack.)\n. Thanks. The documentation needs another pass for clarity, for sure. `nextTick` reads as \u201ccalled in a future turn of the event loop\u201d throughout `README.md`\n\nexcerpt:\n\n## `when(value, fulfilled_opt, rejected_opt)`\n\nArranges for `fulfilled` to be called:\n-   with the value as its sole argument\n-   in a future turn of the event loop\n-   if and when the value is or becomes a fully resolved\n\nArranges for `rejected` to be called:\n-   with a value respresenting the reason why the object will\n  never be resolved, typically an `Error` object.\n-   in a future turn of the event loop\n-   if the value is a promise and\n  -   if and when the promise is rejected\n\nReturns a promise:\n-   that will resolve to the value returned by either of the\n  callbacks, if either of those functions are called, or\n-   that will be rejected if the value is rejected and no\n  `rejected` callback is provided, thus forwarding\n  rejections by default.\n\nThe value may be truly **any** value.  It can be a function.\nIt can be a promise.\n\nEither callback may be falsy, in which case it will not be\ncalled.\n\nGuarantees:\n-   `fulfilled` will not be called before when returns.\n-   `rejected` will not be called before when returns.\n-   `fulfilled` will not be called more than once.\n-   `rejected` will not be called more than once.\n-   If `fulfilled` is called, `rejected` will never be called.\n-   If `rejected` is called, `fulfilled` will never be called.\n-   If a promise is never resolved, neither callback will\n  ever be called.\n. Now tracking as #31.\n. Agreed. However, swallowing exceptions is desirable behavior since it unifies synchronous and asynchronous exception handlers. I wavered on this for a while, but Irakli Gozashvili convinced me it was necessary for the flipside developer ergonomics.\n\nThe present stopgap is to terminate all promise chains with a .end() call.\n\n``` javascript\nfunction main() {\n  // foo returns a promise, but we don't look at the return so we lose.\n  return foo(promiseLoaded());\n}\n\nmain().end();\n```\n\nI am playing with the idea of having another stop-gap solution: using console.log to write a live array to the console. I would then add exceptions to the array when they are swallowed, and remove them when they are handled.\n\nIt would be much more awesome to extend Firebug with something like Causeway, where I could use something like a `console.events` API to expose the causal graph of promises: a bar for each promise from when it was created to when it was resolved, whether it was fulfilled or rejected, what other promises were waiting for it, the stack trace at the point of creation, the stack trace at the point of failure, that kind of thing.\n\n(Issues are in markdown format. You can use Github\u2019s proprietary extension to Markdown for literal bodies: three backticks on top and on bottom. If you want syntax highlighting, put the file extension on the same line as the initial backticks.)\n. Causeway is a distributed debugger.\n\nhttp://wiki.erights.org/wiki/Causeway\n\nMarkM talked about it in Belgium recently. http://www.youtube.com/watch?v=w9hHHvhZ_HY\n\nhttp://www.erights.org/elang/tools/causeway/\n. @johnjbarton I certainly have ambitions for a live visualization.\n. @IgorMinar this is how Q worked about a year ago. Unfortunately it\u2019s harder to go back than to go forward.\n. @IgorMinar I was logging the exception _and_ forwarding a rejection. This led to dirty and confusing double-logging if the rejection was handled properly.\n\nI was also of the mind that exceptions would be decreed to be programmer errors and rejections were for intentional errors. However, this did not pan out in practice. A lot of existing systems throw exceptions for non-error cases, and these _do_ need to get trapped in rejections. Having all thrown exceptions reported in every frame is not an option, and terminating a services because of an asynchronously handled exception is not an option. It\u2019s really quite tricky. It would be a much better option to just visualize the promise graph for debugging purposes.\n. @igorminar It really just isn\u2019t practical. A lot of these functions only throw in exceptional conditions, so a cautious developer would have to try/catch every third party function.\n\nI really am considering a gamut of solutions. One of them discussed earlier with @asutherland would be to allow the promise library to be instantiated with logging emitters. It\u2019s still on the table if someone has the time.\n. I believe this issue has played out. We have `done()` as an ugly stopgap for explicitly surfacing programmatic errors. We will have promise debuggers soon, for the other cases.\n. @axelson https://github.com/kriskowal/q#the-end\n. @randallb Q.onerror is a thing that exists.\n. @randallb Sorry, that went out too soon. It probably does not do what you want. Q.onerror gets called for unhandled rejections that would get rethrown. It does not report errors that have been caught but have not been handled. There is a limbo for errors, where they might be observed and handled in a future turn. In the trivial case:\n\n``` js\nvar rejected = Q.reject(new Error('boo'));\nQ.delay(1000, function () {\n    return rejected;\n}).done();\n```\n\nThis is too trivial a case. The problem will show up if you use promise queues or asynchronous iterators / readers, since the producer and the consumer operate independently.\n\n``` js\nvar reader = Reader([1, 2, 3, 4])\n.map(function (value) {\n    if (value % 2) throw new Error('how odd');\n});\n\n// later...\nreader.next().catch(function (error) {\n});\n```\n\nSo while we could surface unhandled errors in the same event loop turn like RSVP, it would be noisy for legitimate cases.\n\nI need to refresh my context, but there are ongoing plans to surface other events like, ondefer, onresolve, onreject, onhandle that would be able to drive an inspector that would show \"pending deferred\" promises and \"rejected unhandled\" promises for any given moment.\n. @n2liquid WeakMap is what it is for good reasons and is deliberately not for this use-case. There is a proposed WeakRef that provides a post mortem notification callback. We had to wait for TC39 to specify an event loop to get Promise. We\u2019ll have to wait for TC39 to specify garbage collection before we\u2019ll get WeakRef. Maybe we\u2019ll get it someday, but that sounds hard. Members TC39 would prefer not to introduce a feature that would increase the observable differences between engines and specifying GC could seriously paint the language into a corner.\n. Fixed by #34\n. Duplicate of #32 fixed by pull #34. Thanks!\n. The stack trace is helpful. The problem is that Opera checks the argument count instead of coercing the argument to undefined. Easy fix.\n. Sure. I'll get that out to you all this weekend. Sorry for the delay,\nI thought I had already done it.\n\n(tiny keyboard)\n\nOn Jan 13, 2012, at 7:43 PM, Davis Clark\nreply@reply.github.com\nwrote:\n\n> can we get an npm publish please? I am in need of the fix for q.all on empty arrays.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/kriskowal/q/issues/36\n. On Fri, Jan 13, 2012 at 8:10 PM, Kris Kowal cowbertvonmoo@gmail.com wrote:\n\n> Sure. I'll get that out to you all this weekend. Sorry for the delay,\n> I thought I had already done it.\n\nYou can use v0.8.1. It has a couple fixes, including Q.all. It also\ncomes with a minfied version. Thanks!\n\nKris Kowal\n. Thanks!\n. I want to keep the tutorial on the README. Most folks will only ever see the README and decide whether to buy Q based on what\u2019s there.\n\nI agree regarding the API sections.\n. @jrburke I like the idea of a problem statement, but I hesitate to characterize the benefits of using promises to just addressing the pyramid of doom, particularly because other libraries like @caolan\u2019s async do that job pretty well. It\u2019s a worthy problem to solve, but error propagation, reducing \"chat delays\" in distributed programs, POLA, and OCap philosophy are all part of the value. What you see is just the beginning: promise-aware debuggers and visualizers, progress monitors, cancellation propagation, and such other things fit in the architecture of a promise library.\n\n@DomenicDenicola I think lifting examples is the better strategy. A lot of the preamble is specific to folks coming from \".Net\". I want to keep the sale\u2019s pitch in the README, and I think the tutorial is it. We could rotate the reference and examples out and into the Wiki.\n. @jrburke I\u2019ll give it a shot. Thanks for the idea.\n. I would prefer for the `nextTick` underlying implementation to be injected somehow, rather than patched on post-instantiation. There are no securability issues if it\u2019s injected, but there are security implication if we allow it to be replaced.\n\nBear in mind that this implementation of the Q interface does not make security guarantees. It just strives to behave identically to a hypothetical secure implementation like ref_send or makeQ.  It is intended to pave the way, not be the way.  That is, while it does make a lot of guarantees about the order of events (which are good for robustness in general), it does not guarantee that mutually suspicious programs could share the Q interface or share promise objects without fear of interference.  To do so, it would have to freeze a lot more.\n\nThis is a tricky situation. @cadorn, does the MessageChannel implementation of `nextTick` not work in the Addon SDK?  I am thinking that the event-queue should be entirely subsumed by Q at this point.\n. @cadorn Does the addon runtime provide a `reuqire.async(id, cb, eb)` hook?\n. IE10 implemented setImmediate? Neato. Let\u2019s use it.\n. Oh, yeah. Left over from when there was a for loop. Thanks for the catch. Manual var hoisting strikes again!\n. Solid. I\u2019m sure it\u2019s safe to document, but I see documentation as a commitment to support.\n\nWould it make sense to reflect `bind` on the promise interface too? `promiseForFunction.bind(thisp, 1, 2, 3).invoke(null, 4, 5, 6)`. Does it make sense not to?\n. It\u2019s not a real need. It can wait.\n. I would have agreed some time ago that any function call should implicitly Q.all(arguments) before forwarding a message, but there are legitimate cases for passing a literal promise as an argument and the overhead of Q.all might not be desired. Please feel free to bring the issue up on q-continuum@googlegroups.com.\n\n``` javascript\nQ.ref(__filename)\n.then(function (fileName) {\n    return Q.ncall(FS.readFile, FS, fileName)\n})\n.then(function (c) {\n    console.log(c);\n})\n.end()\n```\n. I suppose it\u2019s a decent assumption that Node functions aren\u2019t going to accept promises, so `ncall` and `node` would **probably** never need to receive a promise as an argument.\n\nPromises can be used as proxies for remote objects.  If that\u2019s the case, you can send messages without waiting for the promise to be fulfilled.  This makes piplining possible and is one of the best reasons to use Q for distributed systems.  To wait for resolution would be a waste of time.  As you point out, though, it is unlikely (but not impossible!) that you are going to pass a promise through a Node style function.\n\nI\u2019m still wary of establishing an expectation that other functions, like `Q.invoke` will do this for you implicitly.  It is certainly too much magic\u2122 for most Q cases.\n. I like `setImmediate`. I\u2019ve experimented with shimming it and using it, but it does not make sense to shim it in Q.\n\nPart of this is that `nextTick(cb)` is the only part of the signature we need and `nextTick` does not have to implement handle tracking or variadic argument forwarding like `setImmediate(cb(...args), ...args):handle`. It would be a waste of both weight and performance to properly shim `setImmediate`.  I would even use a global `nextTick` before considering _using_ a global ``setImmediate because of this consideration.\n\n``` javascript\nvar nextTick = global.nextTick || global.setImmediate || nextTickShim;\n```\n\nI do want to axe the `enqueue` module dependency. It is a legacy from Narwhal, which I think we should leave behind.\n\nIn the `nextTick` shim, I would also like to empty the queue in a single event to speed things up and make some diagnostics less noisy.\n. Sure. I\u2019m seeing it weight in at 2.07KiB. The throbbing and rotating is a bit too much though :D\n. That\u2019s about right. At least, I don\u2019t have better ideas.\n\nThe `reduce` function is a bit dense for most folks, so I usually show a way to do it with `forEach` too.\n\n``` javascript\nvar previous = Q.resolve();\n[foo, bar].forEach(function (f) {\n    previous = Q.when(previous, f);\n});\nreturn previous;\n```\n\nI agree we should put a couple more of these advanced cases into the readme, and ship the API reference out to the wiki or better.\n. Omitting the Q.resolve() should be discouraged and it was omitted in error. In the case of single and empty arrays, omitting the initial promise affects the return type or whether any work gets done.  And forget about `Q.wait`: it is way less confusing to just use the primitive `then` or `when` it is based on.\n\nThanks for handling the doc move!\n\nIt\u2019s also really important to include the solution for conditional continuation or branching, but I\u2019m not sure how to introduce it. You\u2019re basically creating a linked-list of functions, and you have to use `reduceRight` so you get a handle to the first function in the array.  It\u2019s a bit mind-bendy.\n\nIt would be nice to make an example that doesn\u2019t need an external library.\n. I see. You want the array of promises when all of them are resolved. I also see you can\u2019t build this on top of the existing `all`.\n\nI would call it `allResolved`.  There\u2019s precedent for `every` and `some` being opposites (javascript array), as well as `any` and `all` being opposites (python).  But, this isn\u2019t really an opposite since it returns a promise for an array of promises, not fulfilled values.\n\nWe should also consider redrawing the array so that it guarantees that every element is a promise. As written, it tolerates an array of mixed values and promises, so you\u2019re not guaranteed that you can call promise.isFulfilled() on each.\n\nThe other thing is that you might want to separate the rejections and fulfillments into separate arrays. Perhaps you can elaborate more on how you\u2019re going to use this. There might be a better way from a control-flow perspective.\n\nCan you run this by the Q-Continuum mailing list?\n. Actually landed in https://github.com/kriskowal/q/commit/cf20e5ea66b6ca09935753965157a17db25b1d8e\n. I\u2019ve got a pull request open for promise support in Jasmine.\n\nhttps://github.com/pivotal/jasmine/pull/202\n. Ok. If Buster doesn\u2019t work out, we can use Jasmine instead. It\u2019s relatively straightforward to monkey-patch jasmine.Block.execute.\n. Landed in v0.8.5\n. Please feel free to shoot down this idea: `deferred.nodeback()`\n. I like the idea. I would call it `install`.\n\nI am reticent to monkey-patch though. Part of the purpose of the library is to encourage patterns that will continue to function in one of MarkM\u2019s VATs. This might be worth batting around on the q-continuum mailing list to see if we hear objections from our mentors in the security business.\n\nOn one hand, I like the idea of encouraging standards-track patterns through monkey-patching. I am on the other hand not sure whether this would qualify.\n. A `Q.fcall` however might be in order, to avoid the `thisp`.\n. I have decided not to modify the function prototype in this library. I would however be willing to entertain this more ambitious mission in my long-neglected QQ project. I would also be willing to entertain giving anyone interested in the library ownership of the project.\n\nI think object-first variants of Q.call, Q.apply, and Q.bind would be confusing in the presence of the existing function prototype methods of the same name. I do agree that they make more sense visually, but there\u2019s always Q.invoke and Q.post for method calls. Q.invoke(object, \"name\", \u2026args) and Q.post(object, name, [args]).\n\nI will entertain here a pull request for Q.fcall and Q.fbind for no-thisp variants of Q.call and Q.bind. Naturally, the same methods would be reflected on promises as promise.fcall and promise.fbind. Let\u2019s track the discussion of those features on the pull request. I am closing this issue as won\u2019t fix.\n. Yes, however, it would still be good to show the asynchronous boundaries in the stack trace.\n\nIt might be useful to model this with chains of exceptions, or exception-like objects.\n\nOne thought I considered (and clearly, you have also) is that we might use Error.captureStackTrace to bless deferred objects with .stack getters.  We can then construct an error chain as we propagate through.  The .stack might also be useful for producing a waterfall diagram with expandable stack traces.\n\nThe feature would obviously have to be detected so we can fall back to a less inspectable version of Q at run time.\n. ```\nError: boo!\n    at c:\\Users\\Domenic\\Programming\\test\\test.js:11:15\nFrom previous event:\n    at doYAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:10:xx)\n    at doZAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:16:xx)\n    at c:\\Users\\Domenic\\Programming\\test\\test.js:19:xx\n```\n\nWhere there is some delimiter separating the stack traces from each event, indicating that the program yielded between those frames.  This is a good hint that there was an opportunity for other code to run in between.\n\nAt this point you\u2019re way ahead of me. My thought was that we could get away with just instrumenting deferreds since that\u2019s where everything ultimately comes from.  Even `when` calls `defer` before yielding. I\u2019m not 100% sure on what the right approach is.\n. This issue might also involve or solve another lingering issue: It\u2019s really nice when programmers have the foresight to rewrite errors at interface boundaries.  So, if you\u2019re using the FS module, you would get an error message related to what you were attempting to do, rather what the FS module was attempting to do with the operating system.  Something like, \"Failed to read such and such file\" instead of \"File descriptor not opened for read\".  The problem is that usually you lose some insight at these boundaries.  It strikes me that exceptions should inherently support chaining, so you can both have a friendly face and the ability to dig deeper into the issue by expanding the next error in the chain.\n. LongMueller will certainly help! Thanks.\n. I agree that we should trace all the functions that were visited in preparation, but don\u2019t sweat blood over it. I think this is already useful.\n. Landed in v0.8.5\n. 100%. Let\u2019s rename `node` to `nbind` and create an `napply` to flesh it out.\n\nFor migration purposes, let\u2019s then create an alias for `nbind` called `node` and make a note in the change log that it will be removed in the next backward-incompatible release.\n. We certainly do not need to support `new` in our `bind` implementation.\n. I fully endorse the removal of the Narwhal code. It\u2019s removal implies that we can remove the bootstrapping magic for \"require\" or \"serverSideRequire\" in the header.\n\nI am waffling on \"setImmediate\". We could probably lose that too. But if you want it, we can keep it.\n\nIt strikes me that the queue logic might be simplified.\n\nI think we should land this pull request at least with the simplified bootstrapping. Consider my other comments optional and feel free to merge these yourself, @domenic.\n. Looks much cleaner. Thanks.\n. Released v0.8.3 with this new feature. Published to NPM. Thanks.\n. Too issuesome to land.\n. Good call. Future implementations of the generator specification will support a pure return in a generator which will be implicitly converted into the ReturnValue exception. We can try to shim this with a Q.return(value) function.  I presume that all engines that support generators (just SpiderMonkey, as far as I know) support keyword properties, so this should be fine.\n\n``` javascript\nvar generator = Q.async(function () {\n    var ten = yield 10;\n    var twenty = yield ten + 10;\n    var thirty = yield twenty + 10;\n    Q.return(thirty + 10);\n});\n\ngenerator()\n.then(function (forty) {\n    assert.equals(forty, 40);\n})\n.end()\n```\n. It would emit events, yes. I will look up the branch I was working on and post back here. This is a delicate feature. \n. This is the experiment ec9264879ac39b077d2e378aa5db484857a5d0a9\n\nFeel free to ignore it if you have a novel idea.  The requirement is that we be able to attach a progress listener on a promise in a shallow fashion.  The progress messages should not propagate since they are meaningless downstream, but should perhaps be adaptable from a previous link in the chain.  It is an interesting problem.\n. This looks pretty good. Yes, let\u2019s run it by the Continuum.\n. @domenic, @igorminar, I\u2019ve updated the description to contain a breakdown of all the discussions we\u2019ve had on the topic.\n. In short, Q will not implement cancellation on promises. There is an opportunity for another library to introduce an alternative primitive that requires explicit forking and has a single-producer to single-consumer binding relationship. Such a library would have the same interface as Q but the implementation would be very different, and would compromise the unidirectional communication guarantees that Q provides. Q can be used for cancellation if you set up an API to creatively pass a cancellation resolver (express capability to cancel) as an argument and use the promise internally to observe the impatience or disinterest of the consumer.\n\nhttps://github.com/kriskowal/gtor/blob/master/cancelation.md\n. @tolmasky There is an interface that is strongly analogous to promises that I tentatively call tasks. Tasks only differ from promises in that they are _unicast_ (meaning single-consumer and explicitly forkable) and therefore _cancelable_. They have the same interface but differ in behavior. The implementation of `race` would behave as you describe for tasks. Similarly, `all` would cancel all outstanding tasks if a single task fails. A promise cannot make the same assumptions because it is _broadcast_, which confers other benefits, like easy memoization and safe distribution. I encourage you to look over my General Theory article.\n\nhttps://github.com/kriskowal/gtor/blob/master/task.js\nhttps://github.com/kriskowal/gtor/blob/master/README.md\n. That\u2019s the idea. The intention of the design, however, is to provide enough information to an optional external interface to produce useful debugging information for a running system, without entraining all of the interface logic in Q.  This feature should be developed in tandem with some kind of waterfall or tree visualization, preferably with arrows connecting causes and effects and icons or colors denoting the state of each promise. Ideally we could get such an interface on track to be included in Web Inspector or Firebug.\n\nAlso, ideally this interface would be able to receive messages for _remote_ events as well, but let\u2019s not push it.\n. @Tuskan360 the latest release already does this as a stopgap. It posts \"Should be empty: []\" to the console log. This is a live array of all the rejections that have no handlers attached. When you create a rejection, the corresponding error gets added. When it is handled, it is removed from the array.\n. Looking forward to trying this out!\n. @domenic I\u2019ve got my share of gists piled up. It sounds like a good idea to gather them all up. We can worry about narrative and organization later.\n. On Sun, May 13, 2012 at 6:00 PM, Steve Marx\nreply@reply.github.com\nwrote:\n\n> IE9 (no idea about other versions) seems to only define window.console if the developer tools are open. Q calls console.log and thus won't (fully) work in IE9. Everything past the call to console.log presumably doesn't get executed, but it's hard to verify, given that this is a Heisenbug. (Opening the dev tools will cause Q to work fine.)\n> \n> There's only one call to console.log in q.js, but I didn't understand its purpose well enough to just create a pull request. I would suggest wrapping console.log in an `if (window.console !== undefined)` or simply removing the call.\n> \n> FYI, a workaround is to include this line of script above the script tag pulling in q.js: `if (window.console === undefined) window.console = { log: function () { } };`\n\nOops. I can fix this either by not calling it or shimming it. This is\na problem in other browsers too!\n\nKris\n. Nice catch, @domenic. I think we should (1) factor out our use of Function.prototype.bind. That should be relatively easy.\n. We can drop Node v0.4 support, I think. I can alter .travis.yml.\n. Sure\n. @domenic I would like to retain a copy of ref send in the repository to make it easier to study the project. Perhaps we can create a directory for it and put other related bits in there.  Maybe `archive`, or subsume it under `design`.\n. Embarrassing. Thank you.\n. @danfuzz, In Q, `promise.when` is an alias that forwards to promise.then. `promise.then` in turn is implemented with Q.when. Internally, this uses the \"when\" message. The words bear the same meaning, but the implementation is wishy-washy about which work should be used for static (Q.when) and dynamic (promise.then, (but also aliased as promise.when)). Q assimilates objects that implement \"then\" (thenables) into Q promises, but it does not do the same for \"whenables\" because such things do not exist in the wild.\n\nIt\u2019s a bit of a mess, being stuck between the trends in JavaScript and trends in forebears like E.\n\nMy inclination is to keep Q.when and promise.then, and remove promise.when so at least you can go by the rule \"what makes sense when spoken\", but on the other hand, MarkM\u2019s favoring Q(promise).when in the Concurrency Strawman, which I would like to support.\n\nWhat I mean by the mnemonic, these are the natural choices of words, and the corresponding implied usage in Q.\n\n\"When A, B\", Q.when(A, B)\n\n\"A then B\", A.then(B)\n. @forbeslindesay This looks like a good fix to me.\n\nLet\u2019s make tests to verify the progression.\n\n@domenic I would like to move in the direction of using Jasmine and eventually removing the previous CommonJS testing scaffold.  However, we can\u2019t do that until continuous integration with Travis on Node makes use of the Jasmine specs.  Maybe we can even use PhantomJS with Travis to do continuous integration for WebKit.\n. @gozala has previously recommended (privately) that we add `Q.promised` as a function decorator that guarantees that the return value is a promise, and guarantees that all arguments are fulfilled before calling.  This is a function that he uses in his work at Mozilla. I am hesitant because, for remote objects, using \"when\" actually ought to be very uncommon, favoring the message passing forms, like \"get\" and \"post\". It would be common to pass an unresolved promise to a function and for the function to interact with the unresolved promise through asynchronous message passing.\n\nThat probably does not diminish the utility of a wrapper for synchronizing arguments. I will entertain the introduction of `Q.promised`.  I\u2019m not sure about the color though.  Does anyone have a better idea for the name?\n. Let\u2019s close this issue and open a new issue for an orthogonal `Q.promised` function decorator.\n. The way remote promises should work (they are presently broken in Q-Comm) is that the promise will be locally resolved in \u00bd RTT from the remote resolution.  The local resolution will have the promise API for passing messages to the remote promise.  Like this:\n\n``` javascript\nvar remote = getRemotePromise();\nremote.get('a') // works here, and will resolve in \u00bd RTT of remote resolution\nremote.then(function (remote) {\n    remote.get('a') // will resolve in 1 + \u00bd full RTT after remote resolution\n   // a minimum of 2 round trips from the previous event\n})\n```\n\nAs you can see, \"when\" will _always_ introduce latency by waiting for synchronization.  The only reason to wait for a remote promise is to way for synchronization side-effects, which should be relatively rare for performance reasons.\n. Blocking on #78.\n. I\u2019m open either way. Anything that helps me not look like Don Quixote for supporting Q is a win.\n. I\u2019m actually open to the change. Mirroring JavaScript\u2019s semantics was the original reason for the choice, but at the end of the day, that is a non-goal (as exemplified by switching from call to fcall & al), and the suggested semantics would be strictly more useful.\n. I have considered making `.end` forward to non-catching callbacks, exiting the purview of the promise system and returning to plain CPS.\n. Oh, not necessarily Node\u2019s CPS style.  `.end(callback, errback)` is what I have in mind, and both callback and errback would not consume exceptions. A different method that explicitly mentions Node would be appropriate for transferring control to a node callback. I don\u2019t think we have one of those yet either.\n. `nend(cb)` does return a promise but it\u2019s only to make it easier to test. I might remove it and use waitsFor and a spy in the spec.\n. @domenic I need to read this thread top-to-bottom again. I haven\u2019t made a decision, and have not committed to `nend` and `done` and `ndone` are still on the table.\n. `nend` needs a different name. I\u2019ll buy `done` as you propose.\n. `nend` stands for \"if the user provides a nodeback, transfer control to Node-style continuation passing. otherwise, return the promise, so this function can be used by both promise consumers and nodeback providers\". That\u2019s a mouthful and might be hard to capture, but I\u2019ll buy up to three words and no more than 80 characters.\n. Some potential seeds for the name:\n- cb\n- toNode\n- toNodeback\n- maybeToNodeback\n- ambidextrous\n- ambi\n. - honeyBadger\n- nodeCompatible\n. - supportNode\n. We could postpone displaying the message to the first time an error is captured. https://github.com/kriskowal/montage/blob/master/core/promise.js#L710-736\n. https://github.com/motorola-mobility/montage/blob/master/core/promise.js#L710-736\n. @domenic I\u2019m still isolating issues locally with one of my projects on the latest release. Let it cook for a bit. No longer than a week.\n. Published 0.8.6 to NPM. Updated, tagged, and pushed.\n\n@domenic Let me know what your NPM user name is. I\u2019ll give you publish rights so if it turns out to be a lemon, you can publish a patch release.  Lydia and I will be on foot, far from the nearest road or cell reception for about a week, starting tomorrow, returning on the 10th.\n. I will entertain a `Q.onerror = handler` API for this, but not this patch as-is.\n. @e4f, ah right. Will have to think more on it.\n. @domenic Let\u2019s remove the defense of `exports` and add `onerror` and `longStackTraceLimit`.\n. Looks good from cursory inspection to me too.\n. Ah, yeah. That is an error. @domenic that looks fine.\n. @forbeslindesay If you use RequireJS and Jam in your projects, I would be willing to delegate that job to you. I cannot be trusted with the responsibility.\n. Thanks!\n. @briancavalier I\u2019ve reproduced and came to the same conclusion. There is a cycle where Q and When are taking turns coercing eachother\u2019s promises with their `resolve` methods. As part of this process, they both call `.then` on the other.\n\n`when` can break the cycle by attempting to normalize the promise to a fulfilled value with `promise.valueOf()`. I\u2019ll send a patch.  I imagine `Q` could do something similar, but I don\u2019t see an implementation of `valueOf` or `nearer`.\n. @domenic I suspect so. I\u2019m favoring `valueOf` since the default implementation is harmless.\n. We might be able to infer from the arguments length provided to the node resolver whether to provide a single value or an array of values as the promise resolution.  It\u2019s clunky, but it would work.\n. @shockie Does this pattern suggested by @domenic work for you? If so, I\u2019m inclined to close the issue.\n\n``` javascript\nQ.ninvoke(mysql.connection, \"query\", \"SELECT * FROM table\")\n.spread(function (rows, fields) {\n    // ...\n});\n```\n. I\u2019m on the fence on this one.\n\nSome issues are that the library is getting bloated, though this would be a minor offender, and it might be better to have a name like `thenResolve` to avoid overloading the already double variations of `resolve`. I do like it though, and have wanted this myself.\n. @domenic that has been my experience as well.\n. I\u2019m also +0 for `thenResolve`. That rounds to an even +1. Pull requests welcome.\n\n@domenic Let\u2019s track a refactor separately. I\u2019ll add my comments to that issue.\n. @jamesmgreene The file structure won\u2019t change in the 1.0 timeline. It might change in the 2.0 timeline, but probably not this drastically. The trouble with the Promise API is that every additional method on the promise interface is exposed on every promise. That said, I did do an experiment in [Montage](https://github.com/montagejs/montage/blob/v0.11.0/core/promise.js) to make the Q object itself extensible by way of Q.create(descriptors, promiseDescriptors). This facilitated parallel extension to each of the promise interfaces (DeferredPromise, RejectedPromise, FulfilledPromise). The experiment relied heavily on an OOP style which lost implicit method binding, so some hybrid approach might be in order.\n. See: #361 \n. Alright, I\u2019ll entertain it as an experiment. It does have the theoretical flaw that progress through a conjunction is not necessarily bound by the progress of a single operand, but you can work around that case explicitly.\n\nConsider this case:\n\n``` javascript\nvar A = fast();\nvar B = slow();\nvar C = Q.when(A, function () {\n    return B;\n});\n```\n\nI\u2019m curious how that plays out. I\u2019m guessing that you get a journey to 100%, then a drop to whatever the progress on B is at that moment, and a slow progression back up to 100%.  That, or you go quickly to 100% and stall.  I would have to experiment, but I\u2019m presently working on something else.\n. Thanks for the legwork. The jsfiddle is insightful.\n. I like the idea of translating the progress in the progback. It would also follow that progress is a single value, so we should need to lock down the arity of the progress emitter.\n\nIt is probably okay, for the purpose of progress notifications, to assume that the operation will not fail, and to reset the progress to the resolution of the handler.  It is probably also okay to assume that a finally clause will not cause further delay (though this is not a guarantee).\n\nMaybe it is okay for progress to pass-through by default, and to be able to adapt the progress in the progback.  We would probably also need ways to compose progress values from other promises in the progback, perhaps analogously to how we compose promises in callbacks and errbacks.\n\nPerhaps progress values need to be promises themselves so we can use the same composition techniques.\n\n``` javascript\nvar A = chicagoToBoston();\nvar B = bostonToChicago();\nvar C = Q.progress(A, function (aProgress) {\n    return Q.progress(B, function (bProgress) {\n        return // ?\n    });\n});\n```\n. @domenic I\u2019ll leave it to you to decide whether to merge #121.\n. This is in master.\n. This is in master.\n. @suedama1756 I sympathize. I did not invent this API \u2014 I copied Tyler Close\u2019s ref_send and elements from Mark Miller\u2019s E including the terminology. I was also tricked by the API into thinking that resolution and rejection were opposites. This was the first implementation of `isResolved`:\n\nhttps://github.com/kriskowal/q/blob/bae841881c44f413d1502ee44c323d66a478c025/lib/q.js#L213-218\n\nI later fixed it and added `isFulfilled`.\n\nThe confusion comes from the fact that Deferred has `deferred.reject(error)` is shorthand for `deferred.resolve(Q.reject(error))`, and `deferred.resolve` does double-duty for `deferred.resolve(promise)` and `deferred.resolve(value)`. The original promise library only had `promise` and `resolve`, so there was little confusion that `resolve` was for all three: `fulfill`, `reject` and postpone.\n\nThe problem might be mitigated by adding `deferred.fulfill` as a shorthand for `deferred.resolve(Q.fulfill(value))`, but that would not be particularly useful since `resolve` checks for non-promise values internally.\n\nIt would not make sense to relieve `resolve` of the responsibility of discerning promises and values because the return values of functions can be either, and resolve handles both cases.\n\nIn any case, I write this so you know that I don\u2019t dismiss your arguments off-hand. It is a genuine puzzle, turning the library I found into something people can actually learn, debug, and deploy.\n. :+1:\n. Okay. Let\u2019s make a note to remove `end` in the v0.9 timeline and to inform Mark Miller that the concurrency strawman would be out of sync in that regard.\n. Thanks for tracking this. I\u2019ll try to make a decision today; we have enough options.\n. :+1: `nodeify`, I choose you.\n. That\u2019s not so bad.\n\nLet\u2019s not worry about `Q.master` at this time. It is not locked down yet.\n\nTesting the module loader shims is out of scope, unless a supporter makes a test that fits in our scaffold. I imagine it would involve adding a dev dependency and using an iframe.\n\nWe could probably mock a generator for `Q.async`.\n. I\u2019m okay with this for the v0.9.0 timeline. I do want to get to 100%, so going to move this out. We can mock a generator to get coverage for Q.async and Q.return off Firefox. Q.master can be speced in the context of Q-Connection, but not many folks are using it and it could change.  I\u2019ll look into teasing the second if (done) out.\n. Stale. We should do another code coverage campaign perhaps in 1.0, but closing this for 0.9.\n. Also, inform Mark Miller that the concurrency strawman would be out of sync.\n. @domenic mentioned the change of end/done in a thread to Mark, so this is all wrapped up.\n. Callbacks are issued in the order that they are scheduled. It corresponds in this case with a breadth first traversal of the tree of promises you\u2019ve created.\n. It\u2019s the same situation. I\u2019ve annotated it with comments that indicate a breadth-first traversal. Note that \"fin3\" comes at node 6, \"fin1\" at node 7, and \"fin2\" at node 8.\n\n``` javascript\npromise // 1\n    .then(function(v){ // 4\n        console.log(\"then1\");\n    })\n    .fin(function(){ // 7\n        console.log(\"fin1\");\n    })\n    .end();\n\npromise // 2\n    .then(function(v){ // 5\n        console.log(\"then2\");\n    })\n    .fin(function(){ // 8\n        console.log(\"fin2\");\n    })\n    .end();\n\n\npromise // 3\n    .fin(function(){ // 6\n        console.log(\"fin3\");\n    })\n    .end();\n```\n. Take a look at the implementation. Everything is composed from `then` and `nextTick`. The `nextTick` might make a callback occur later than a parallel chain, but in general, everything follows from the same principles.  For what it\u2019s worth, Q does not go to great pains to ensure a particular scheduling order. If you need a particular order, synchronize with a promise.\n\nhttps://github.com/kriskowal/q/blob/master/q.js#L1590-1605\n. Looks like a legitimate case to me. We should add it to the test suite.\n. Well, I had hoped that would never come to be an issue, alas. So much for being clever.\n\nWe will have to rename `valueOf` to something to the effect of \u201cfollow the chain of transfers from promise, to promise, to the fulfillment value if possible, and return whatever value lies at the end of the chain\u201d or in promise-speak \u201creturn the most resolved form of this promise\u201d, which aligns with the name `near` or `nearer` in the vernacular of the TC39 Concurrency Strawman and the Ref Send Q API.\n. @domenic I suppose that would do the trick. Perhaps a quick-fix in the `valueOf` function, which already does some checks to make sure it doesn\u2019t blow up.\n. On Sunday, November 4, 2012, Domenic Denicola wrote:\n\n> Wow, I didn't know we returned promises from deferred.(resolve|reject).\n> And I think it's clearly a bug that we return differently each time. I'm\n> definitely in favor of always returning undefined; @kriskowalhttps://github.com/kriskowal\n> ?\n> \n> That's fine. I find it unlikely that the return value is used by anyone,\n> and if so, that they should.\n. I really don\u2019t. I\u2019ll defer to your judgement, @domenic. In the end, we will just need more practice with progress to get a better idea. I reserve the right to ax it outright in the future if it turns out that the feature is useless or hazardous.\n. On Sat, Nov 24, 2012 at 5:05 PM, Domenic Denicola\nnotifications@github.comwrote:\n\n> I'll try running it by the continuum then but my natural instinct is to\n> throw in nextTick, as dangerous as that can be.\n> \n> Sounds sane to me.\n. The first log is because I added a stack trace to deprecate. It is not an error.\n\nThe second stack trace is definitely an error.\n. For what it\u2019s worth, we could extract the relevant file and line number and just display that in the deprecation message instead of dumping the whole trace. That\u2019s all I think we need to make it easier to track down and update deprecated lines.\n. That is certainly a backward-incompatible change. Alas. We might have to put it back and maybe find a way to radiate a warning if it\u2019s used (no idea how, just thinking aloud here) and remove it in v0.9.0.\n. I still want to discourage the pattern. The fact that it works even though it is not correct usage is confusing.\n. Alright, we\u2019ll play it that way until we get significant back-pressure from users.\n\nIf we didn\u2019t have so much piled up under deprecation warnings, and so many plans for changes right now, I would say it\u2019s time for a 1.0.0.\n. @geowa4 Seems like a valid simplification to me.\n. @ForbesLindesay @domenic It is fine in general, because `object.valueOf()` falls to `Object.prototype.valueOf`, which returns `this`\u2026unless object is an heir of null.\n. @domenic and technically it is overridden for boxed types like `new Number(10).valueOf()`. Date is the only one where I could see it being a genuine problem to user `valueOf` though.\n. I can\u2019t help but suspect we will see this problem a lot unless we do something about it. It would be completely within our power to coerce a string into an exception.\n. There were two motives for changing `Q.call(func, thisp, ...args)` to `Q.fcall(func, ...args)`.\n1. Q.fcall will be used for RPC and will probably cross language boundaries. `thisp` has no place there.\n2. I intend in v0.9 to align Q with the Mark Miller\u2019s Q strawman and make Q into a function. Functions have their own notions of `call`, `apply`, and `bind`, so those methods of Q had to be moved to make room.\n\n`ncall`, `napply`, and `nbind` are different beasts. They cannot function without a proper `thisp`, so it makes sense to retain them in that interface.\n\nSo, while I can see that there is a mismatch and that is confusing, I don\u2019t think we can change. That said, suggestions are always welcome.\n. To clarify, @thesmart is recommending that we remove `thisp` from the `n*` methods and requiring folks to call `.bind` if they want an alt `thisp`. I could buy that, but we would need to also take the opportunity to rename the methods and deprecate the old ones. People are using them.\n\nThankfully, I was never satisfied with the names, and we\u2019re moving in the direction of more verbose alternatives like `nodeCall`, `nodeBind`, and `nodeApply`.\n\nAnother consideration is that I intend to rename `invoke` to `send` in v0.9, so `nodeSend` and `nodePost`.\n. Or `callNode`, `bindNode`, and `applyNode`.\n. @domenic We can take that up with Mark Miller. My basis for choosing \"invoke\" was an imagined alignment between the method names of a Proxy and Promise handlers. Of course, even the matter of _whether_ Proxy handlers will support an \"invoke\" method is unsettled, though the present notion seems to be that such a method will not be supported at all.\n. \u2026there just seems little question that if Proxy handlers supported method invocation, it would be called \"invoke\" as I\u2019ve done here.\n. I\u2019ll buy `nsend` (or `ninvoke`), `npost`, `nfcall`, `nfapply`, and `nfbind`. That should probably resolve the confusion, and I\u2019ll leave it as an open issue whether to retain or deprecate `ncall`, `napply`, and `bind`.\n. Looks good to me.\n\nLooks like continuous integration timed out for one of the engines, but is presently passing. I\u2019m not worried about landing this change.\n. Do you have a moment to add a test case that failed before this change and passes after?\n. Alright, thanks. I guess that\u2019s not something we can put in the suite, but it proves the point.\n. We have a `promise.timeout(ms)` method. Got a moment to try that approach. I would not mind if you would squash (using `git rebase -i`) the commits and force push to your branch (`git push -f`). Don\u2019t try it if you haven\u2019t done it before though; I can do it on my end.\n. @domenic Is this fixed with the redo on long traces?\n. That\u2019s odd since the `.fail(noop)` constitutes handling the exception. Maybe there is an error in the code that maintains the parallel error and rejection arrays.\n. I may have fixed this with d5f46b9d1dfe786c49d535a5812991deabb2ac68. I will attempt to reproduce.\n. Yes, on my side, memory usage grows unbounded before d5f46b9 but is level after the change. Rejections were getting duplicated in the unhandled rejection log. Thanks.\n. Thanks for catching this.\n. Thanks. With a fresh look at the example, the reason you\u2019re getting the rejection is that Q displays the log at the first time anything is rejected.\n\n@domenic and I were just thinking of an alternative view of `nextTick` that might be useful. We could postpone displaying the log until the next tick queue empties, which would make the pernicious appearance of the log happen less frequently at least.\n\nAs always, the real solution to this problem is to make extensions for all browsers and environments that shows a live view of all pending and rejected promises.  We could detect the existence of such an extension and silence the log entirely.\n. We are not making progress on this issue. Perhaps when evergreen engines all have a promise inspector per #361 it will be practical to remove the console.log stopgap.\n. I have been thinking about it for other reasons. We'll track the issue\nhere.\n. I would close this issue and open some new ones:\n- create a method akin to `Q.all` that replaces the properties of an object that are promises with their fulfillment values and fulfills to that selfsame object, or rejects on the first fail.\n- for further consideration: use `Q.spread` implicitly to resolve the arguments of all message dispatchers, thus `promise.put(key, promiseForValue)` would work, which might be useful for Q connection and has at least once been recommended by @gozala. This would obviate the need for the `Q.promised` wrapper. I am rounding back to this idea. The reason for not doing this is that it becomes impossible (presently) for a promise to be passed as an argument without `then`ing on it, which would be a problem for remote promises. However, I am thinking of adding a remote promise wrapper that would resolve to itself instantly, which would solve that problem. I\u2019m also thinking of `push` and `pull` methods on promises.\n. Thanks @slaks!\n. Thanks @arikon. I\u2019ll look for opportunities.\n. I have done an OO design of Q with an identical API elsewhere, to address these performance issues. That design unfortunately exposed private data which I observed was inevitably abused, no matter how many underscores were added to those properties. In principle, it is certainly faster and puts less pressure on the garbage collector.\n\nMy intent is to do another iteration of Q that uses WeakMap in the v0.10 timeline. I might be able to address performance issues with that version without breaking encapsulation.\n. It would be a simple matter to remove the isFulfilled optimization.\n. This for the v0.8 branch.\n. k\n. This would be shallow. I had `deep` in QQ and it turned out to be a hazard, so I will not bring it back.\n\nI would prefer to allow the user to explicitly distinguish whether they want to the value to be treated as an object or a collection. I would like `Q.all` to be able to handle array-alike objects in the future (if it does not already), and implicitly distinguishing an array-alike from an object that just happens to have the same properties would be too much cleverness for my taste.\n. `for in` should be sufficient for this one.\n\n`all` would delegate to `forEach`, but we still have to consider the case where arrays do not implement their own.\n. Punting to a future release.\n. Making the tough call here. Q will not support this feature.\n. The negative impact I expect from this is that a remote invocation passing a remote promise would wait a full round trip before delivering the invocation message. This case is probably enough of a reason to close this issue.\n\nThis one case is enough that I\u2019m convinced I do not even have to ask @erights whether this is a bad idea. Summarily, closing.\n. Superseded by #162.\n. @forbeslindesay I\u2019m not keen on maintaining this file in parallel with package.json. I presume that these both pull directly from Github. If you would like to maintain this file in parallel, why don\u2019t we publish your repo as the authoritative version for that ecosystem.\n. @forbeslindesay Yes, you\u2019re welcome to add it to the README in the section describing supported platforms.\n. @arikon I could buy that too. It\u2019s more work for me, but at least that would guarantee that I would not forget to make, commit, and push the changes to component.json.\n. This is not the most productive place to have this debate. I have opinions, but no interest in debating them, especially here where they won\u2019t be heard by the makers of `component` and `bower`. I bent Q to support RequireJS, even though I\u2019m ideologically opposed, so there is precedent for concessions. The responsibility of supporting and testing these alternatives just has to rest in someone else\u2019s hands.\n. @forbeslindesay Since the implementation does not satisfy your intuition in either case, recognizing the state of foreign promises is an orthogonal issue.\n. Needs spec.\n. This is like `nodeify` in that it returns a promise if you don\u2019t specify a callback. `done` returns `undefined` unconditionally and captures errors in `callback` and `errback`, so it does not escape the promise \u201cdomain\u201d.\n. The use-case is just like `nodeify`. You want to provide a function that supports traditional continuation-passing-style (the `cb(v)`, `eb(e)` kind instead of the `nb(e, v)` kind), but users can opt-in to using promises by omitted in the callback and errback.\n\nThe promise usage:\n\n``` javascript\ndoAsync(a, b, c).then().done()\n```\n\nWith the callback pattern, exceptions must escape the promise \u201cdomain\u201d, so an exception thrown by `cb` halts the program, and an exception thrown by `doAsync` goes to `eb`, and if no `eb` halts the program.\n\n``` javascript\ndoAsync(a, b, c, cb, eb)\n```\n\nAnd the pattern for providing the feature:\n\n``` javascript\nfunction doAsync(a, b, c, cb, eb) {\n    return work(a, b, c)\n    .pass(cb, eb);\n}\n```\n. @domenic It\u2019s a good point. Most precedent for cb/eb is from Python Twisted. There is some precedent in the W3C geolocation API http://dev.w3.org/geo/api/spec-source.html and win/fail is common in Phonegap. This interface would allow this kind of API to migrate gracefully without forcing users to learn about promises.\n. Dropping.\n. Needs spec.\n. @domenic I believe so. Did I get the deprecate call wrong? I can\u2019t imagine what else would cause the problem.\n. Yeah, perhaps unwisely.\n. They would also need to support `rejectedPromise.valueOf().exception` to identify rejected promises. I\u2019m not married to `.valueOf()`, for what it\u2019s worth. The same could be solved with the `.nearer()` name per the concurrency strawman, or `.nearest()` or `mostResolved()`.\n. @forbeslindesay, this just means that we must always check isPromise first.\n. This is as solved as it\u2019s going to get in this forum, I think. Let me know if you think otherwise.\n. Also looks good to me.\n. @mike-spainhower Thanks for letting us know. I should try to find a good summary of progress on all the performance issues with frozen objects.\n. Yeah, this looks good to me.\n. This is a duplicate of #159, which is open and accepted. Thank you for weighing in.\n. For future reference and reproduction, the above data were extracted from a query that @isaacs graciously put together.\n\nhttp://isaacs.iriscouch.com/registry/_design/scratch/_view/dependentVersions?startkey=[%22q%22]&endkey=[%22q%22,{}]&group_level=3\n. This is as done as it\u2019s going to be.\n. First, thanks for contributing, @pcottle. Unfortunately, this does not actually solve the problem but rather masks errors that might otherwise need to be displayed. Note that around line 661, the only condition when `displayErrors` is called immediately precedes adding an error to the list (which arguably should be before, but we are depending on a live console for this to work at all).\n\nhttps://github.com/pcottle/q/blob/9d0d64021ea5d4a46d69acaaed989b5e6d2941b8/q.js#L661\n\nA proper solution for this would be to revise `nextTick` to flush an internal event queue and only to call `displayErrors` if there are any outstanding errors before yielding to the parent event loop.\n. I may be misreading (you might try a pull request next time so we can see the patch), but I suspect that `spread` does what you want.\n\n``` javascript\nQ.spread([oneP, twoP, threeP], function (one, two, three) {\n});\n```\n\nA good reason not to make this change in `when` is that it would mandate that all promises must be promises for arrays.\n. Thanks @forbeslindesay. @redsandro, please feel free to reply with further questions or close the issue if this answers your question.\n. @redsandro, Please reopen if you\u2019re not satisfied.\n. @redsandro, it is the case that exceptions thrown in any callback managed by Q are converted into asynchronous exceptions (rejected promises). You can escape this \u201cpromise domain\u201d by executing a callback with setTimeout, or Q.nextTick, or any other mechanism that executes your callback in a separate event. You can also just call `.done()` at the end of your promise chain and that will convert any asynchronous exceptions back into synchronous exceptions.\n. Closing. Please reopen if symptoms persist. Post an `npm-error.log` if you can.\n. I\u2019m super-hesitant to add to Q; much more inclined to remove at this point. I think we have all the small, combinable primitives we need, and a lot of the sugar we don\u2019t.\n\nIn any case, this example resembles a [Schwartzian transform](http://en.wikipedia.org/wiki/Schwartzian_transform), which is a cool pattern I get a lot of traction out of.\n\nI\u2019m not sure how reusable `step` is. It strikes me that you\u2019d get a cleaner and more pipelinable result with `invoke/post`, provided that each mutator returned `this`.\n\n``` javascript\nfunction doStuff(input) {\n    return Q(new Foo())\n        .invoke(\"step1\", input)\n        .invoke(\"step2\", input)\n        .invoke(\"step3\", input)\n}\n```\n. I\u2019m adding this spec,\n\n``` javascript\n    it(\"assimilates a thenable in allResolved\", function () {\n        return Q.allResolved([\n            {then: function (win, fail) {\n                win(10);\n            }}\n        ])\n        .then(function (promises) {\n            expect(promises[0].isPending()).toBe(false);\n            expect(promises[0].isFulfilled()).toBe(true);\n            expect(promises[0].isRejected()).toBe(false);\n        });\n    });\n```\n\nAnd it passes. Note that Q.isResolved is not in v0.9 since we migrated to using Q.isPending.\n. Deferring with a timeout fails:\n\n``` javascript\n    it(\"assimilates a pending thenable in allResolved\", function () {\n        return Q.allResolved([\n            {then: function (win, fail) {\n                setTimeout(function () {\n                    win(10);\n                }, 100);\n            }}\n        ])\n        .then(function (promises) {\n            expect(promises[0].isPending()).toBe(false);\n            expect(promises[0].isFulfilled()).toBe(true);\n            expect(promises[0].isRejected()).toBe(false);\n        });\n    });\n```\n. Thanks, I\u2019ll take this.\n. Awesome, been waiting for that bit of good news. I wonder which callback resolves the returned promise if you provide more than one fulfillment or rejection handler.\n. It\u2019s also grossly inaccurate now, and should be rewritten entirely.\n. Damn, @domenic. You killed it.\n. Jury is still out\u2026\n. Tests pass now. Lots of ugly errors on the console, but that\u2019s fine for the tests.\n. I\u2019m a bit mystified about what\u2019s going on in the context of Jasmine, but outside of Jasmine, the simple case works. Not sure that this will be okay in the long run, but want to give it some bake time.\n. @domenic You\u2019re more than welcome to port the suite to anything you like. I like what I see coming out of the promise/a+ specs, and yeah, testling/testacular would be winful.\n. The results of that benchmark are odd. I wonder what the engine is doing to get around O(n) shift.\n\nIn any case, you\u2019ve done a marvelously rigorous benchmark. Many thanks.\n. @domenic that would either leak, or they would have to chose to copy back to offset zero to avoid growing the underlying allocation periodically. I would not put it past them, but it\u2019s still amortized O(length).\n\nI did a little peek and it seems that the list case is dominated by lots of discrete allocations and probably also shape changes (since nodes aren't declared with both value and next properties in that example). I made another spec that uses a free list and the picture is rather different.\n\nhttp://jsperf.com/list-vs-array-queue\n. I\u2019ll have to think about it. My instinct at this point is make the code simpler, but nextTick is very hot code too. I should compare performance of a real-world performance-sensitive load on Node and in the browser. Performance gains in nextTick have a multiplying affect on promise code. A lot of performance gains in Q boil down to avoiding nextTick at all.\n. @rkatic That implies that free list had no impact on the previous revisions and the performance gain was entirely based on declaring nodes with all their eventual properties. That\u2019s a bit hard to believe and I will need to verify it.\n. Thanks, @rkatic. I love the care going into this change.\n. The problem is that you have to use the `.progress` call directly on the promise producing the notifications, which you can do using the third callback argument of `then`, or by using the `progress` method _before_ the `then` call.\n\nThis is because it is nearly impossible to infer, and no default inference is dominant, how much more time a promise will take to be fulfilled if you call `then` on it.  The callback might return another promise with its own progress notifications.\n\nI\u2019ve been putting my incomplete thoughts down about this, here https://gist.github.com/4569136\n\nSuffice it to say, progress propagation is not well-understood in any research or prior art I know of. Whether we should even try to incorporate progress notifications on promises is dubious, because it will result in a lot of confusion like this.\n. @iamwilhelm I don\u2019t think we can make it possible to call .progress after .then, but _any_ help syncing the documentation or making things more clear is greatly appreciated.\n. @iamwilhelm Please at least temporarily discard my advice. I need to bone up on how this works. @domenic is the expert on how our progress notification works.\n. Awesome, thanks.\n. I\u2019m pretty unsatisfied with `nf*`, in general. It strikes me that binding `this` is a pretty common need. I wonder whether we were too hasty in eliminating `n*`.\n. I\u2019ve been mulling `qify`, which I\u2019ve seen elsewhere.\n. The node-specificness is actually important, since we could conceivably work with multiple callback patterns.\n. Green light for Q.denodeify for v0.9.\n. I presume that this is now invalid.\n. I think I\u2019ll buy it. We can adjust as necessary, but it looks good to me.\n. Landed. Really wanted this for v0.9.\n. I gave Istanbul a try. Thumbs up.\n. @domenic I just might.\n. It\u2019s a tough call. If we keep keywords as the primary recommended interface (which is consistent with the decision on TC39 to use collection.delete), we should document them like promise[\"delete\"] to make it clear that they are special. My intuition is that, for the time being, fin/fail/del are the primary interface, and the keywords are aliases highly recommended for CoffeeScript.\n. I\u2019m content.\n. @domenic This is not something we have worried about in a long time. Please consider closing, or revisiting.\n. @pudgeball Can you describe an example and expected behavior for the case you have in mind just to verify that this is the same case?\n. I\u2019ll remove it from .npmignore. Thanks.\n. I\u2019m going to leave it around in the off-chance it saves some-one\u2019s bacon to be able to mark a value with a then method as a non-promise.\n. Supposing you were using: https://github.com/polotek/procstreams\n\nA procstream has a then method, but is not a promise.\n\n``` javascript\nfunction getStream() {\n    return prepareToGetStream()\n    .then(function () {\n        return Q.fulfill(procstream(\"cat README.md\"));\n    })\n}\n```\n. At the end of the day, if this is the only valid use-case, naming it Q.notAPromise(value) might steer folks away from misery.\n. Yeah. Revising the name again: Q.nonPromise(x).\n. This time, not finally.\n. Accepting #195 in lieu of this.\n. We need to put `nbind` back.\n. I think we should stick with Q.nbind.\n. @domenic Yes, I think we should push back on Jam on this one. I also have nonstandard extensions package.json in Mr/Montage that fall back to the root of the package.json. @caolan\n. This is not the intended behavior of promise.all(). The promise should be a promise for an array of promises.\n\n``` javascript\nQ([p1, p2, p3]).all()\n```\n. @Skalman something like:\n\n``` javascript\nreturn Q(f1())\n.then(function (a1) {\n    return Q.all([a1, f2(), f3()])\n})\n.spread(function (a1, a2, a3) {\n    return f4();\n})\n```\n. Assigning this to @domenic to get it out of the triage queue, but again, this is a great task for a member of the community.\n. How do you feel about making `promised` implicit to message dispatch?\n. Punting this to a future version. I need to play with the idea of implicit `promised` in both the general and specific cases.\n. I believe that generators make this a non-issue. Closing. Please feel free to reopen if you have strong feelings about this direction.\n. I\u2019m punting this. No more milestone.\n. I\u2019m putting this on the 1.0 milestone. Let\u2019s re-evaluate which methods we will retain on the constructor and the prototype. We can shoot for a leaner Q in this backward-incompatible release.\n. The comparative simplicity of this solution is desirable on its own. Are you sure enough, @rkatic, that this would be a good merge? If you are, I\u2019ll take it.\n. I\u2019m not going to worry about exception report order.\n. Yes.\n. \u3003\n. It is a Unicode DITTO MARK, meaning \u201cexactly what @domenic said\u201d, which did include a +1.\n. Yes, returning a thenable implicitly attempts to coerce that to a promise. Marking objects with \"then\" methods that are not indeed promises is probably the only legitimate use of `Q.fulfill` and one our forebears have probably not accounted for.\n. @rkatic It is not so much a question of willing as able. Detecting whether an object is a thenable or just happens to have a \"then\" method is very messy. If it is not a thenable promise, we should not be calling its then method, and even calling the then method is not sufficient in every case to distinguish it from a promise, a badly behaving promise, a poorly implemented promise, or not a promise at all.\n. Let\u2019s take a step back and sleep on this. @rkatic is right that no valid promise implementation would call `onFulfilled` with a promise, unless that promise is for an object that was fulfilled remotely and cannot become a value locally.\n. In the time since this issue opened there was extensive deliberation on recursive flattening and monads on ES-Discuss. @domenic, @erights, what was the resolution of that discussion and how does it apply to Q?\n. Reminder. The ink is drying on the ES6 promise specification. Let\u2019s note the decisions here and wrap it up.\n. If I may state the same more politically, we would be happy to send our users that are interested in using NuGet to your solution.\n\nThank you. It\u2019s amazing how many of these there are now and we\u2019re just overwhelmed. To make this practical, we need to distribute the workload to people who are interested in using and thus verifying that the solution works with these systems.\n. Version numbers are in package.json and in Git tags e.g., `v0.1.19` in Github, or \"0.1.19\" in package.json.\n. The is mailing list, Q-Continuum, mentioned in the README https://groups.google.com/forum/#!forum/q-continuum\n\nI\u2019ll try to be proactive about mentioning updates there. So far, watching the repo has been the most reliable way to see new tags.\n\nI don\u2019t want to bring the nuspec upstream. Thank you for offerring though.\n. Vicious cycle detection would entail a check in deferred.resolve(value) to verify that Q.resolve(value).mostResolved() is not equal to deferred.\n. Well, that\u2019d be a bit odd, wouldn\u2019t it.\n. I\u2019m going to leave it alone for now.\n. Thanks.\n. Yes, this is definitely a real bug. This solution is good, in the short term. In the long term, I would like to introduce a `mostResolved` or `nearer` that will always return the last _promise_ in the chain, and not follow fulfillment to the corresponding value. Using that would fix the problem too.\n. Yes, back to our rapid release cycle like we had in 0.8.\n. Let\u2019s talk about some specific API\u2019s that we want to make more convenient and see if there\u2019s a pattern we can classify, or if it would be better to make custom wrappers for each.\n\nSome DOM API\u2019s that would obviously benefit from promises are the `document.ready` promise, XHR (would benefit from Q-JSGI), and IndexDB.\n\nI\u2019ll follow up if I catch a break and can illustrate some of the patterns.\n. I would venture that `q-io` and a new `q-dom` support the cases in combination. My intention is to eventually mirror all the `q-io` interfaces with browser implementations that\u2019d be automatically selected by https://github.com/montagejs/mr and https://github.com/montagejs/mop. I don\u2019t know whether Browserify supports alternate browser implementation mappings but we\u2019d ideally use the same info in `package.json`.\n\nI don\u2019t think there\u2019s enough homogeneity among DOM API\u2019s to have a general purpose promise adaptor. There certainly is a degree of homogeneity in each subsystem, like `onerror` and `onsuccess` handlers in IndexDB.\n. @itsnotvalid It would be sensible to factor it out. We may or may not. There\u2019s a tension between effort needed to migrate, having a minimal API surface, and having a convenient and complete API surface. One thing that would help unlock the tension is extensible promise API\u2019s, which come with their own level of madness but are distinctly possible.\n. I would like to mine this ticket for Q-IO and Q-DOM issues, but this is otherwise closed. We do not plan to build anything special into Q proper.\n. Thanks!\n. @omares, no, thank you. We are supposed to take care of that before publishing a version. I\u2019ll make a note of it.\n. Yeah, I want it there, even though it serves no purpose but to illustrate the size on the wire.\n. In general, you need to call timeout in the event that you want to begin counting. If you need to begin counting after some other stages, you need to do it inside a `then` or `spread` block after those stages. You seem to have it worked out.\n. I\u2019m going to assume that no bug was found in this process. Please reopen if otherwise.\n. Don\u2019t do any further work until I firmly say whether I\u2019m committed to the change and the name. One data point is that I\u2019ve experimented with adding this feature at least three times and at some point exiled the work to branches.\n\nIf I do commit to adding this feature, it will open a flood-gate for related features. I will need to be comfortable with the overall vision. That would entail having Q.reduce and Q.forEach with sequential semantics. All these methods would need to be added to the Promise prototype as well.\n\nI will also want to use Q.fcall to dispatch messages to promised callbacks.\n. I\u2019m declining. I agree that it\u2019s useful, but not useful enough to expand the surface of the Q core library. The case it simplifies can be express fairly succinctly in terms of primitives.\n\n``` javascript\npromises.invoke(\"map\", callback, thisp).all()\n```\n\n`spread` exists perhaps because I am not entirely consistent in my verdicts, but I think that manual array destucturing is a pretty painful _and_ common problem. It certainly will be deprecated when ES6  becomes common.\n. I am reopening. I have reconsidered.\n. I am going to add `map`, `reduce`, and `forEach`. The semantics of `map` will be slightly different\u2014the `all` to the result will not be implied. The promises could be aggregated in opportunistic order using `reduce`, which will be implemented similarly to `all`.\n. Subsumed in #337\n. It\u2019s a good idea. I have not decided whether to take it.\n. I\u2019ve decided to accept this change when it\u2019s ready. Please document as \u201cexperimental\u201d.\n. I'm going to resist adding this to the core lib. At this point need to focus on making Q subclassable. \n. @redsandro Tough call. `undefined` is a perfectly meaningful fulfillment value, but a promise is not.\n. Use !promise.isPending() as your guard. Generally though, use \"then\" unless\nyou really need to optimize.\n\nOn Tuesday, March 19, 2013, Redsandro wrote:\n\n> Hmm.. this is true. Back when things took time in my node script, I was\n> getting used to being able to use valueOf() that I forgot to check that\n> this is actually documented in the API wiki.\n> \n> I guess in stead of checking for undefined I can do something like if\n> (myPromise.valueOf().constructor && myPromise.valueOf().constructor.name== 'Promise')for now, and start converting all such occurances in my code to a\n> callback-stype wrapper functions to pass along promised values.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/237#issuecomment-15151588\n> .\n. We might have to amputate.\n. For one, `resolvedPromises` will always be an array.  You could use `resolvedPromises.filter(function (promise) {return promise.isFulfilled()}).map(function (promise) {return promise.valueOf()}` to get the array of fulfilled promises, silently discarding any broken promises.\n\nAre you sure you don\u2019t want to use `Q.all` instead?\n. @Redsandro It is not on the promise prototype. You can do it inside your handler. You could also do it with a message though\u2026\n\n``` javascript\nQ.allResolved(promises)\n.invoke(\"filter\", function (promise) {\n    return promise.isFulfilled();\n})\n.invoke(\"map\", function (promise) {\n    return promise.valueOf();\n})\n```\n. Try then...fail. Done means done and returns nothing. It also lets\nexceptions leave the \"domain\".\n\nOn Thursday, March 21, 2013, Alex Osh wrote:\n\n> Why it is not possible to use chaining done(..).fail(...)?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/241\n> .\n. Fail/catch is the appropriate way to handle rejection.\n\nOn Thursday, March 21, 2013, Alex Osh wrote:\n\n> Can I use .fail() to handle rejection or it is not appropriate?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/241#issuecomment-15233054\n> .\n. It seems to me that we need a `makeVariadicNodeResolver` if the number of resolution values is not determinate.\n\nMaking `resolve` variadic is not an option. Promises fulfill to only one value. That value may be an array. Guessing whether to spread is too-much-magic.\n. @killdream That is a possibility. Q.spreading could just be @domenic\u2019s suggestion for variadic, jquery-alike `Q.when`, which would necessarily replace the current semantics.\n. We can expose a method to explicitly release a Q instance.\n. I\u2019ve added a Q.release in branch gh-244. Please let me know if that solves the problem and we\u2019ll merge it.\n. Version 2 of Q is not released. It is in npm but not with the \"latest\" tag. Not sure how CDN.js deals with this, but I presume that the client picks the exact version they want.\n. `spread` is a stopgap for rest/spread structuring/destructuring arguments coming soon to JS.\n\n``` javascript\nP1.doSomething()\n.then(function (one) {\n})\n.then(function ([one, two]) {\n})\n.catch(function (error) {\n})\n```\n. Might run it by the Qx project.\n. Thanks. Probably something simple.\n. This should be fixed at 4a637eef5efa12a3105e71c8b847aa533f832ea5. The minified files were out of sync.\n. That makes sense. We rewrite the stacks so we can add the previous stack trace. Perhaps we should try another approach.\n. @mjijackson Yeah, I would entertain this.\n. It\u2019s a good argument.\n. @ravi There\u2019s a nuance there.\n\n`deferred.reject(reason)` is really a synonym for `deferred.resolve(Q.reject(reason))`.  The argument of `resolve` can be a promise in any state\u2014or\u2014a `value` which gets implicitly boxed as a fulfilled promise for that value (`Q(value)`).\n\nSo, `resolve` can actually transition a deferred to _any_ state, `pending` (through resolving to a deferred promise), `rejected` (through resolving to a rejected promise), or `fulfilled` (through resolving to a fulfilled promise, or simply to a value).\n. The name changes are fine. Looks like it needs a rebase.\n. Thanks\n. We are still working on this one. Not ready for merge.\n. Fixes #261 \n. This has been obsoleted by #337. The central notion is that `close` and `closed` will no longer be necessary. Instead `Queue` will merely be an asynchronous transport for iterations as in ES6 generators. The iterations will carry information like `{value}` or `{value, done: true}`, where the latter implies that the stream has closed.\n. The \"longStacks\" configuration property looks fine as described. I might call it \"longStackSupport\". The default should be \"off\". Long stack support is useless if it does not get shown by debuggers. In the long run, we could escape the problem with a custom debugger, but for now, let\u2019s continue munging the Error\u2019s \"stack\" property.\n. I\u2019ll re-qualify my statement. Long stack support is useless if does not get\nshown.\n. @domenic @tgriesser Using an environment switch or detecting the inspector sound good to me.\n\nAs @erights is likely to mention, exposing `promise.source` is a capability leak and for a secure version, we should put that in a side table and expose it only to debuggers. When we go modular, I\u2019ll bring the WeakMap shim in as a dependency so we can do this properly.\n. Sounds good. I don\u2019t think it needs to be name spaced.\n. I\u2019ve rolled this into #339 which should land for the next version.\n. These have been merged.\n. Yeah, that\u2019ll do the job. We\u2019ll land this. Thanks for the tip.\n. @rkatic do you approve of this change? I do intend to modularize Q, but want to land this first.\n. @domenic Let\u2019s spin off a `next-turn` or `asap` (hahahahahah) package ASAP. We can beat it to death ad nauseam.\n\n(further maniacal laughter elided)\n\nI do not believe that we catch exceptions before nextTick in all cases. Quick scan shows `nodeify` in particular.\n. By @domenic, I mean @rkatic. We would be delighted to put this in your purview and will gladly help in any way we can, including package management if that will help.\n. Superseded by #316\n. I am considering making Q extensible. That would unlock the possibility of factoring out extensions and making a small Q core. I believe there\u2019s an issue for that.\n. @lfac-pt I did this for a fork I did for MontageJS. There would be a `Q.extend(promiseMethods, qMethods)` which would return a `Q` function. It works by augmenting the prototype of all three promise subtypes in parallel (deferred promise, fulfilled promise, rejected promise). However, this version of Q does not use prototypical inheritance much so it might not work out and will certainly not work the same. One thing I intend to do in the course of _this_ issue is to back promises with a WeakMap as in @erights\u2019s `makeQ.js`, which will probably open a door for extensibility.\n\nThe ramifications of having promises with different type signatures, especially for different eventual types of the fulfillment values, make it necessary to have the ability to dynamically cast generic promises to more specific promises on the fly. As such, it will be necessary to add a `.as(Q)` method to promises, e.g.,\n\n``` javascript\nreturn Q(getUserName())\n.then(function (user) { // regardless of subtyping, `then` always returns a basic promise\n    return getRecordsForUserName(user.name);\n})\n.as(EventualArray) // hypothetical Q subtype for eventual/remote arrays\n.reduceEagerly(function (balance, userRecord) {\n    return balance + userRecord.balance;\n})\n```\n\n``` javascript\nPromise.prototype.as = function (Type) {\n    return Type(this);\n};\n```\n. See #394 \n. Very cool. We\u2019ll have to look into making a Saucelabs account.\n. Made an account for myself. I would not mind step by step instructions to make this work.\n. Suffice it to say that I\u2019m not a Ruby fellow. I\u2019m blocked on running `travis` and getting:\n\n`rubygems.rb:230:in `activate': can't activate backports (~> 2.6, runtime) for [\"travis-1.2.0\"], already activated backports-3.3.0 for [\"gh-0.11.2\", \"travis-1.2.0\"] (Gem::LoadError)`\n\nLooks like dependency hell to me, but someone got around this problem by relinking Ruby in Brew. This did not work for me, but then again, I\u2019m not all that big of a Brewer either.\n\nIt\u2019s a shame because I could probably get past this by copying a few OpenSSL commands and filling in the blanks.\n. I gave this a shot again. I have `travis` working properly. The NPM installation, however, fails on my machine. `npm cache clear` \u2014 no dice.\n. @bernil No, I\u2019ve had the problem before and NPM was working fine at the time. I might need to manually purge my cache.\n. I was about to complain, but I think I got confused. You seem to have done what I would have done, in implementing the deprecated valueOf in terms of the new inspect. Will make a closer review.\n. I agree that they should be consistent. I\u2019m torn on which way. I think making a fresh array is less likely to get me lynched, but I do see the \u201cwasteful garbage collector churn mob\u201d out back and I work with some of them.\n. One thing we have going for us is that no-one is likely to notice either way.\n. @rkatic We all agree that consistency is where we must eventually be. This inconsistency came about because @domenic and I wrote these methods separately and each assumed the other had total knowledge of the status quo. You have done us both a favor in pointing out the inconsistency, which all parties here revile.\n. I really like @rkatic\u2019s proposal.\n. Pardon. I am assuming that this whole consistency requirement is a settled issue and resolving ambiguities accordingly. My preference is to apply the insight of one suggestion to both `all` and `allSettled`. Based on this assumption, our collected insights boil down to some options:\n1. Both functions should receive `(inputs, opt_outputs)` and `opt_outputs` should default to a fresh array. If one wants to reuse the same array, it is a matter of passing it as both arguments.\n2. Both functions should receive `(inputs, opt_outputs)` and `opt_outputs` should default to `inputs`. If one wants to produce a fresh array, it is a matter of passing `[]` to the second argument.\n3. Both functions should receive `(inputs)` only. The inputs are reused for the output. If one wants the output to be a fresh array, it is a matter of calling `(inputs.slice())`.\n\nI like the first option.\n. @rkatic, You\u2019re right, problem 2 (`arrayOfArray.map(Q.all)`) makes Options 1 & 2 unavailable as far as I\u2019m concerned. I\u2019m not willing to engage in machinations to detect the meaning of the second argument. That leaves only Option 3 (one argument, use slice if you want a new array), or the unmentioned option (always produce a fresh array, provide no option for reducing memory costs).\n. To be clear, we have not. Decision still pending.\n. > \u201cThere can only be one!\u201d \u2014 McCleod\n\nWe are turning traces off by default in a future release. They will be opt-in thereonout.\n. I actually am wondering whether I might beg a code review from @erights. Is this consistent with the direction of the language? Is this mature?\n. Thanks for this article @andywingo, http://wingolog.org/archives/2013/05/08/generators-in-v8\n. I\u2019m inclined to land this before a thorough review and deal with the consequences as they come. I expect that there will be wonky issues with CSP and the eval to feature test. Not necessarily that it will fail generally, but that it will fail when it should pass. I respect the decision to completely separate and replicate the inner algorithm for Q.async so it\u2019s easier to delete the old path. It will be worth noting that we will not remove the shim _when Firefox upgrades its generators_ but _when no one is using the old generators on Firefox_, presumably a much later date, unless we force forward and leave such users stranded in a backward version of Q (a good option too).\n. I don\u2019t see anything that we can change, unless there\u2019s a way to feature-test for Harmony generators without using `eval`. I will land this as-is.\n. @domenic This is prepped for release. Let me know if you want anything else in v0.9.4.\n. This is a great catch. Thank you so much.\n. Assigning to myself.\n. I presume it throws with a syntax error on compile.\n. Assigning to @domenic, praying he has an idle moment. Of course, this is a _great_ task for a member of the community looking to provide a high impact contribution without too much hassle.\n. It\u2019s true, @domenic\u2019s response was terse and hurried. I\u2019ll apologize on his behalf as his co-maintainer. Let\u2019s try to keep it technical, where we all do best.\n\nI agree that the order of magnitude of difference is suspicious. We\u2019ll have do a profile and see where it went wrong.\n\nThank you for updating with JavaScript. It does help _me_ since I don\u2019t use much CoffeeScript tooling. I know Domenic does and his comments were for my benefit.\n. I think this is moot. The plan is to factor our next \"tick\" implementation into an `asap` package-module-function and use it by that name.\n. \u2026pending the factor into CommonJS modules with browserify standalone. Issues pending there.\n. We would do this in a backward incompatible release. Users of next tick would be advised to use the ASAP package directly.\n. ASAP is live, https://github.com/kriskowal/asap\n. Will be fixed with #394 \n. @ravi, I\u2019m pretty sure that won\u2019t work. This variation on `Q.all` might do the trick for this _specific_ case, because it checks whether the aggregate promise is still pending and only calls `deferred.reject` in that case.\n\n``` javascript\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var countDown = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            if (isFulfilled(promise)) {\n                promises[index] = valueOf(promise);\n            } else {\n                ++countDown;\n                when(promise, function (value) {\n                    promises[index] = value;\n                    if (--countDown === 0) {\n                        deferred.resolve(promises);\n                    }\n                }, function (error) {\n                    if (deferred.promise.isPending()) {\n                        deferred.reject(error);\n                    } // otherwise ignore the error; it\u2019s been handled\n                });\n            }\n        }, void 0);\n        if (countDown === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n```\n. Duly poked. What else is blocking a patch release? Perhaps we should tackle this too.\n. @ravi, No, you\u2019d `Q.stopUnhandledRejectionTracking()` globally.\n. I\u2019m going to favor a patch now rather than wait for these. Both problems fall firmly in the realm of Hard\u2122.\n. @ravi That\u2019s right. If you want to process the failures of all the inputs, you would need to do something like:\n\n``` javascript\nreturn Q.all(promises.map(function (promise) {\n    return promise.catch(function (error) {\n        // process every individual failure\n        throw error; // then invalidate the whole\n    });\n}))\n.then(function (values) {\n    // all promises succeeded\n}, function (error) {\n    // first failure of any, invalidating the whole\n})\n```\n. We are removing the unhandled rejection tracking code for the time being. Further work will be needed to create state snapshots for promise inspectors, but I am hoping this issue does not surface in the new incarnation.\n. Let\u2019s keep it in the repo. It\u2019s just simpler.\n. @domenic No, we can axe the min.js.gz.\n. Are you sure we should have an implicit `done()` on the end of `spawn()`? Do we imagine that this would only be used at the top level of some promise work, and we would only use `async` to do work that might return a promise?\n. As @domenic, I am reluctant to mix values and errors contingent on success or failure of input promises.\n\nWe do plan to release `allSettled`.\n. `allSettled` landed. I\u2019m closing this since the desired behavior is simple enough to compose in terms thereof. Thank you for posting, @adjohnson916!\n. In the interest of preventing bloat and keeping a focused scope, I\u2019m not inclined to virtualize `if` blocks.\n. @domenic, yes please!\n. This looks good. Would you like me to merge this and cut the release?\n. Yes, and once we\u2019ve got something that generates good numbers, we should regress it over our commit log and see how we\u2019ve been doing.\n. Sounds good to me.\n. @mpj I believe that @stefanpenner also has a benchmark he uses to tune RSVP. By that benchmark, last I checked, when.js was really good, but most of the libraries designed for speed did well. Q is designed at a higher level of abstraction and does more to protect private state than the rest of the pack, which comes at a significant performance cost. I have been re-evaluating that trade-off in the experimental v2 branch, but if speed is your primary concern, you\u2019re willing to opt-out of the Q ecosystem, and you have no desire to use promises as proxies for remote objects, you should for sure go with one of the others.\n\nI have used @stefanpenner\u2019s benchmark to evaluate Q.\n\nhttps://github.com/stefanpenner/promise_benchmarks\n. My intent is to generate the \u201cUMD\u201d rendition of Q with either Browserify or Closure Compiler, as I believe you earlier recommended, as a first step toward modularizing.\n. Superseded by #317\n. I am not sure this belongs in Q. Can you enumerate (some or all of) what interfaces this can be used with, where they are implemented, and whether they are likely to become standard? It seems likely to me that these will eventually migrate to W3C Promise.\n. Awesome. The recent failures are my fault, in trying to fix a problem with interop with earlier versions of Q, which requires further investigation on my part.\n. @rkatic good observation.\n\n@forbeslindesay, we need to be able to thread an alternate template through this process. The `bootstrap` line will not work with Montage (Montage\u2019s bootstrapping expects a generic \"promise\" module, not \"q\", which is of course debatable but matter-of-fact), the SES stuff is Q-specific and experimental. As far as I can tell, this means threading an alternate template through Grunt, Grunt-Browserify, Browserify, and UMD. Alternately, we\u2019ll have to roll our own solution.\n. @jrburke @briancavalier This commit moves the UMD version of Q into `release/q.umd.js` and `release/q.min.js`. I presume that this will be a backward-incompatible change for the AMD ecosystem. Will a minor version ramp be sufficient to avoid fallout within your community? What do we need to communicate this change to UMD users.\n\nThis is part of a move to introduce modularity to Q, and shuck dependencies out to other packages. I\u2019m not sure what the ramifications of this will be for the AMD world.\n. @rkatic, good points!\n\n@ForbesLindesay UMD does not need to support Montage\u2019s module system. It is CommonJS. The only reason that there is an additional case for Montage in Q is because Q is a dependency of Montage\u2019s CommonJS module loader (Mr), so it is one of four modules that have to be loaded with script-injection in the bootstrapping process. This is not a number that needs to scale or an effect any other UMD package needs to accommodate.\n\nAs for linking to an auto-generated build, @domenic has been arguing for it, but I really want to keep it easy to replicate this project\u2019s infrastructure.\n. @domenic @jrburke I am hoping to avoid a support nightmare, where thousands of users file an issue that they updated with Bower or Yajspm and Q no longer works with their configuration. I\u2019m wondering whether we can avoid that with Semver + CHANGES.md so that users can opt deliberately in.\n. We do not provide support for JamJS in this venue. Perhaps take it up with your package manager. v0.9.6 is in NPM and tagged on Github.\n. I\u2019ve verified the issue in cdnjs. Looks like the minified version lagged behind. We need to get a fresh release on there.\n\nI\u2019m gathering that this is one of those cases that will simply not happen unless we do it ourselves. If that\u2019s the case, we need automation.\n\nI am reminded of the Duke Atreides in Dune \u2014 \u201cWe have inherited the greatest wealth in the universe and the never-ending struggle to defend it.\u201d\n. Seems like cdnjs is pulling automatically these days. I don\u2019t intend to revisit this.\n. It seems likely that this would cause there to be a race to add work to the array before all the contained work completes. This probably would not end well.\n\nApart from that, it would be necessary to observe array content changes, which is something that @aadsm and I facilitated in https://github.com/montagejs/collections.\n\nI do not think we will do this and I hope my answer is not too dissatisfying.\n. Thank you.\n. It\u2019s not a bad idea, but I\u2019m in favor of keeping the current API.\n. It is _very_ interesting. However, I don\u2019t think it\u2019s practicable in Q. For one, we provide `n*` functions for browsers as well, where domains are not available. It becomes complicated, although not impossible, to have a conditional require that works both with or without Node.\n\nIt breaks my heart, because this is very clever and useful, but it would be wise to decline.\n. Your `delay` has the intended semantics of `delay`. I can\u2019t contrive in my imagination a use for `throttle`. Even if I needed it, I would:\n\n``` javascript\n.thenResolve(Q(value).delay(ms))\n```\n. I\u2019m also thinking that we should not delay rejection.\n. Thank you, @wmertens \n. I know it\u2019s not what you want to hear, but this would be too much magic for my taste. I\u2019ll let others pipe in before closing.\n. Please take a look at what\u2019s going on in #334. I\u2019m closing this particular pull for a variety of reasons, some of which I will outline in the source, but the big picture is I\u2019m making some large factoring changes for v0.10 that will align things better for making this work. Particularly, `all` will become suitable for generically waiting either for an \"iterable\" of promises to all be fulfilled, or pass non-iterables through. That\u2019ll cover arrays, generators, iterators, and promise queues, and pass everything else through.\n. @jlongster My notion is to use `all` instead of `Q` to coerce yielded values in `async`.\n. I\u2019m going to leave this open. There is a chance that an overload like this will fall into our lap with `all` being overloaded for \"iterables\".\n. I added @rkatic\u2019s `props` to the specs in my working copy. It does in fact work, though `result` is oddly an `Array` with named properties. In any case, I think that is as fixed as this issue is going to get.\n. The name `hash` really needs to be preserved for generating probably-unique consistent hashes on \"hashable\" objects. I\u2019m eliding a rant on the history of the practice of using \"hash\" as a synecdoche for \"hash table\" and will just say it causes confusion about the concepts.\n\nI am open to the idea of implementing such a method with a different name.\n. Q captures all errors, so that anything that is depending on their result asynchronously has an opportunity to be informed and handle the problem gracefully.\n\nIf you get to the end of a chain of promises, use `.done()` and it will explicitly surface any errors that were not handled.\n. For the record, supersedes\u2026\n\nFixes #326\n. Going with @wmertens PR.\n. This behavior is easy enough to compose from \"reduce\" and \"when\", with a more idiomatic (as @domenic mentions) effect with less API surface for folks to learn (as @killdream mentions). I\u2019m inclined to close and recommend applying this to a utility or just using primitives. I invoke \u201cThe Virtue of Unix\u201d, that is, the composition of small tools design well for a single purpose.\n\n``` javascript\n[f1, f2, f3].reduce(Q.when, Q())\n```\n. I think what might need to be clarified is that this is not a matter of flattening the pyramid with your existing functions. To be adapted to the promise-style, you no longer pass callbacks, but simply return values or promises in _any_ function. You would adapt your `step` or `nstep` functions to be `pstep` functions. You would only need to use `defer`, `resolve`, or `nf*` functions at the boundary between your promise-oriented functions and your non-promise functions. Does that make sense? What this should look like is:\n\n``` javascript\nfunction step1() {\n    // returns a promise\n}\n\nfunction step2(step1Value) {\n    // returns a promise\n}\n\nfunction report(step2Value) {\n    console.log(step2Value);\n    // implicitly returns undefined, albeit a promise for undefined\n}\n\nQ.fcall(step1)\n.then(step2)\n.then(report)\n.done();\n```\n. @domenic, I find your idea satisfying.\n. I actually kind of like the idea of making the progress/notification arguments free-form depending on the domain. Emitting (index, progress) updates sounds like a neat idea to me, that would make it easier to adapt those events to domain-specific progress.\n. Fixes #234, introducing Q.map.\n. Introduces `map`, `reduce`, `forEach`, `Queue` and handling of \"iterables\" in general.\n. I\u2019m running into much broader problems with this effort in general. It is proving difficult, once again (because I have tried this pretty much once a year since this project began :/) to make these operators compose well while chaining with back-pressure. I\u2019ll let you all know, but this might be a throw-away PR.\n. Bear in mind that I\u2019m still exploring this, but the general idea is that it should be possible to chain `map` calls, then aggregate with either `all`, `reduce`, or `forEach`. There should eventually be support for `flatten` (`flatMap` being composed of `map` and `flatten`), which could be interspersed among the `map` pipeline.\n\nI\u2019m synthesizing promises, streams, iterators, and FRP. FRP doesn\u2019t inherently do buffering or throttling or back pressure, but promises provide a good back-pressure signal, and each of these operations could take a buffer size argument. An infinite promise queue serves as a semaphore or throttle. In fact, infinite promise queues for iterations can serve as asynchronous iterators (as included at the end). So I can use infinite promise queues for streams internally.\n\nThe other dimension of the problem is remote objects. For that reason, I\u2019m moving `iterate` into the promise protocol so you can pipeline a number of parallel operations from a remote iterable.\n\nHere is the example I\u2019m mulling:\n\n``` javascript\nQ.map([1, 2, 3], function (n) {\n    return n * 2;\n})\n.map(function (n) {\n    return Q(n * 2).delay(1000);\n})\n.all()\n.then(function (a) {\n    console.log(a);\n})\n.done()\n```\n\nNote that there are two maps. The second map should not wait for the completion of the first. The second map should be complete in exactly 1 second, not 3, since all three delays should be in parallel.\n\nThen there\u2019s the issue of throttling. It should be possible for the input of these chained map operations to be an infinite promise queue of indefinite length.  It should be able to pass values through both steps as they arrive, and it should be possible to throttle to only have a certain number of outstanding promises.\n\nThe `all` operator should wait for the input stream to close.\n. Continuing at #337\n. This replaces #334, see that request for the conversation up to this point. The reason for the PR change was that I poorly judged the name of the branch and it seems like I can't re-root the PR.\n. I think I\u2019ve solved most of the composition problems. However, forEach is still the only method that limits parallelism, and none of the methods yet support back-pressure. I did experimentally find a way to reduce parallelism in `reduce` but there isn\u2019t much point until `map` supports back-pressure. This will involve creating a control system between the output queue and the consumption of input, so that only a certain amount of work can be scheduled between them.\n. Alright, rate control now works. All of the operations support a `parallelism` argument which limits the number of concurrent activities within the step and allows the consumer to limit the rate of production.\n\nStill need to go over the docs and JSHint, and clean up the code. I added Semaphore and Control types that need docs and probably some iteration.\n. Alright, I\u2019m done polishing. Ready for a review.\n. @domenic Breaking it into a module is even more problematic since a promise is a promise for an object of _any_ type. I do have some ideas for making the Q API inheritable and being able to cast promises to promises for more specific types, but that\u2019s a different issue to explore down the road.\n\nAs for the iterator API, it is only `next`. The generator API adds `throw`.  I\u2019m re-appropriating `throw` (though the meaning differs), and adding `return` and `yield` (n\u00e9e `send`), so that the producer side of the queue can marionnette the queue to behave as if it were a generator.  I need to swing back and rewrite the docs to that effect.\n. @domenic, the thing is that usually an object only has methods appropriate for its type. With a promise, since it\u2019s a proxy for what might be an object-as-a-map, it has `get`, `set`, `delete`, `has`, and `keys`. Since it\u2019s a proxy for what might eventually be an object-as-instance, it has `invoke` and `post`.  Since it might eventually be a function, it has `fcall` and `fapply`. Since it might be an iterable, it\u2019ll have `forEach`, `map`, `reduce`, and `buffer`.  It would make sense to give each \"face\" of a promise to have a different promise type, eventually someday even have specialized methods to reflect the eventual resolution. Might even be possible to generate these types based on sufficiently descriptive prototypes.\n\nI have explored this possibility in the past. One thing that becomes obvious is that the system has to become _very_ type-aware. Another trouble is that `then` must return a promise for the very most generic type of promise, since it is a promise for whatever the _callback_ returns and is not dependent at all on the type of the input promise. As such, it becomes necessary to introduce a method like `as(Type)` so that a promise can be cast to a more specific promise type. As you can see, it is a rabbit hole better suited to a structurally typed language.\n\nThe advantage is that the promises themselves can be broken up into smaller opt-in modules.\n\nMaybe we\u2019ll go down that road some day, but for now, I\u2019m just lumping all of these interfaces on a single promise prototype.\n. Rebased.\n. Already done, I think. Did I miss one?\n. @domenic. Thanks. I missed that one. I\u2019ll follow it up. Going to look into this Browserify thing. That\u2019s blocking most of the next release\u2019s plans.\n. We could, but this PR commits us to a backward-incompat release so I think I want to race to the finish.\n. @domenic New evidence suggests that fresh output arrays are a win. The input of `all` is not necessarily an array any more, and `allSettled`, as @rkatic points out, should never have been reusing the input.\n. This has been made obsolete. The changes were rolled into the `unroll` branch PR.\n. I had to rebase the promise streams work back out to a branch, so this issue remains. More info on the mailing list: https://groups.google.com/forum/#!topic/q-continuum/JE6zSshyC5s\n. @rkatic On closer inspection, these changes are in master, except for the docstring which I just hand-copied into my working copy and will land soon. Because of the rebase, you may need a fresh checkout of master. You may have attempted to pull from the rebased head, which would have failed.\n. @rkatic On even closer inspection, the problem _does_ still remain and I had lost track of my branches. I\u2019ll fix this.\n. Rebased on #339\n. @domenic, I would love to see the numbers.\n. Before then after.\n\n```\n              A single simple async operation\n  56,769 op/s \u2a20 with an immediately-fulfilled promise\n  70,630 op/s \u2a20 with an immediately-fulfilled promise\n\n 231,258 op/s \u2a20 with direct setImmediate usage\n 292,525 op/s \u2a20 with direct setImmediate usage\n\n     835 op/s \u2a20 with direct setTimeout(\u2026, 0)\n     809 op/s \u2a20 with direct setTimeout(\u2026, 0)\n\n              A fs.readFile\n\n   8,232 op/s \u2a20 directly, with callbacks\n   9,587 op/s \u2a20 directly, with callbacks\n\n   4,703 op/s \u2a20 with Q.nfcall\n   5,774 op/s \u2a20 with Q.nfcall\n\n   4,656 op/s \u2a20 with a Q.denodeify'ed version\n   5,923 op/s \u2a20 with a Q.denodeify'ed version\n\n   5,922 op/s \u2a20 with manual usage of deferred.makeNodeResolver\n   7,588 op/s \u2a20 with manual usage of deferred.makeNodeResolver\n\n              1000 operations in parallel\n\n      43 op/s \u2a20 with immediately-fulfilled promises\n      47 op/s \u2a20 with immediately-fulfilled promises\n\n     540 op/s \u2a20 with direct setImmediate usage\n     466 op/s \u2a20 with direct setImmediate usage\n\n              Chaining\n\n      47 op/s \u2a20 Chaining many already-fulfilled promises together\n      48 op/s \u2a20 Chaining many already-fulfilled promises together\n\n      65 op/s \u2a20 Chaining and then fulfilling the end of the chain\n      63 op/s \u2a20 Chaining and then fulfilling the end of the chain\n```\n. I screwed up the history on this one by pushing master before force pushing unroll. Sorry. See:\n\nhttps://github.com/kriskowal/q/compare/d144e138e29565aaf8dbc054be2f7f13dda274d5...f5a310cfc3310242a30507e8944d3277f6dc2520\n. This change could not land until v2. As it happens, notify and progress have been removed outright in v2, and if they are reintroduced, will not compose. Closing.\n. @tomdaub cancellation is an unrelated concern to progress/notify. Q promises have multiple consumer semantics, so cancellation is tricky. I am contemplating building a library with a \"task\" primitive that is similar to a promise but with explicit fork() and cancel(), and @domenic is actively working out whether promises can become cancelable promises with reference counting on observers.\n\nSee: https://github.com/kriskowal/gtor\n. @domenic, yes to explicitly saying we\u2019ll get around to it.\n. This will land in a separate library. Closing.\n. @domenic Agreed.\n. Good enough for me. If you care to follow up, please give it a run in JSHint. We put a space after `if` and curly braces around blocks, statements on new lines.\n. Thanks, @aaylward \n. This will be separated into a library.\n. This is right, but we can leave off q.montage.js and q.ses.js off for this pass.  For Montage and Mr, I think we\u2019ll abandon the current script-injection bootstrapping in favor of using Browserify to create our bootstrappers.  There\u2019s a chance my colleagues will not like that, in which case, we\u2019ll bring it back in, but, in general, I would favor pushing it out.\n\nTell us more about S3. Do we get a free account for being pro-social? How do we manage the API key? What steps do we need to take to keep it simple to fork the project infrastructure?\n. I\u2019m proposing:\n- q.js (source, CommonJS)\n- release/q.js (`<script>`, global Q, bundled with transitive dependencies using Browserify)\n- release/q.min.js (\u2026and minified)\n- release/q.amd.js (AMD (not UMD), not bundled)\n- release/q.amd.min.js (\u2026and minified)\n\nI approve of support for Volo, with a big thank you for playing along with `package.json`.\n\nI am entertaining the possibility of bringing in support for Bower and Component provided that their metadata are build products.\n- release/component.json\n- release/bower.json\n\n@domenic, you have my blessing to give S3 a chance.\n. Yeah, that\u2019s what I thought. For whatever reason, Gem is b\u00f8rked on my machine so that\u2019s a bit of a dead-end for me. I have tried installing the `travis` command in the past.\n. Alright, I got my Ruby/Gem situation figured out and `travis encrypt` works locally.\n. @jrburke,\n\nThe elimination of the tyranny of choice very concisely describes why Q subsumes its dependencies and pioneered the UMD approach. Which is to say, there is a part of me that agrees that Q should maintain its own _status quo_.\n\nHowever, when we spoke at JSConf, you mentioned also that Q is not palatable to the Dojo community, for among other reasons, Q subsumes its dependencies and those dependencies overlap with products Dojo already provides as independent modules. So we are confronted between a trade-off between the paradox of choice and modularity. In Q\u2019s nascence, I elected to chose the simple road. But Q has grown and the best way to make its size reflect its inner simplicity today would be to reduce it to its core and use packages and modules: ES5-Shim, ASAP, WeakMap, &c.\n\nThankfully the tool system and the _modus operandi_ of the community has evolved and modularity is practical today on all fronts.\n\nMy reasoning for having separate AMD and Script versions is that the AMD version need not bundle its dependencies, provided that all of the dependencies provide an AMD version as well. That probably will mean that the build will also need to include the info that popular AMD package managers need.\n. @domenic I like it.\n. @jrburke, Your observation that (1) in this branch is presently not bringing in dependencies is accurate, but this is, as you say, just step 1. In subsequent steps, we\u2019ll be using `require` to bring in `asap`, `es5-shim`, and eventually `weak-map`, all of which will be rigged the same way: source in CommonJS format, a built AMD version with the simple `define(cjs)` boilerplate (and itinerant metadata), and a built `<script>` version that subsumes all of the dependencies using Browserify.\n. @domenic, I\u2019m okay with the `amd/` prefix. I do not think that the `amd/` dir would ever need to slurp up the AMD versions from package dependencies though.\n. @domenic Ah, got it.\n. @domenic How far do you think `from-commonjs` is from being ready for a PR. It looks really good so far. Are we going to wait for S3 support and then hook Volo up with the published versions? Let\u2019s leave support for building bower.json and component.json to a later PR so we can get this in master sooner.\n. And there was much rejoicing!\n. Oh, dear. We have no story for allowing Volo users to lock to a specific version.\n. Perhaps instead of adding a Volo link to the package.json, we need to put a modified package.json in the release products and accumulate releases by version in S3.\n. Got it. `{version}` solves the problem.\n. Confirmed, however, if we move the `var call` line out of the function, we can have our cake and eat it.\n\nBearing in mind that if safety is your paramount, you should look at https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/makeQ.js?r=4779\n\nThese projects, Q and SES makeQ are moving in the direction of API compatibility, though I enjoy the liberty of getting user feedback on experiments here which does cause ephemeral divergence. I have had to make some tough calls favoring speed in some cases and flexibility (as in a settable `onerror`) over safety and security and am admittedly a student of security, not qualified to bring this library all the way as Mark Miller has with makeQ. Once Mark and I have more SES foundations set up to work in Node, I may revisit all of these decisions and point us back, but for now, we are not on track for security.\n. It is not for minification\u2014you\u2019ll note that we use a shim if `map` is not implemented on `Array.prototype`. It is a relatively recent addition to the language.\n. I should refrain from thank kind of speculation in my comments.\n. @alFReD-NSH Your framework should either be promise-aware or provide callbacks for signaling asynchronous completion.  If it is promise aware, you would just need to return a completion promise and your error would asynchronously propagate to that promise for the framework. The framework may even chose to use `.done()` as @kitcambridge points out, to surface the exception and halt the test runner. If your framework provides a callback, e.g., `done(error_opt)`, you would need to take your completion promise and call `.then(done, done)`.\n. @alFReD-NSH Agreed, that is why we have the \"Unhandled errors\" message; it ensures that if you do forget to handle an error, it will not be silent. Ideally we would have a debugger that shows the causal graph of all promises with stack traces. This tool could even show promises that cross process boundaries. It happens that Terry Stanley made a prototype for this called Causeway some time ago, but we have yet to bring it to browser debuggers. It is on the roadmap.\n\nI do sympathize with your sentiment. Unfortunately, quite a bit of the benefit of promises\u2014implicitly propagating errors asynchronously\u2014comes with this cost. We have tried where we could to minimize the risk. In my own use, avoiding unhandled errors has become as natural as avoiding infinite loops.\n. The crux of the problem is that in an asynchronous program, an unhandled error may be handled at a later turn, or by multiple subscribers. That is, an unhandled error is not necessarily an error that will never be handled. Not handling an error is not even necessarily a sign that there was a problem, if the promise was not necessary for the progress of the program.  We use `done` to explicitly distinguish the case where an unhandled error should terminate the program with an error or drop an non-redactable error to the console.\n\nThe errors in the `unhandledErrors` array do have stack traces. It is a shame they are not easy to expand at the console. It might be worth bringing @paulirish into the conversation.\n\nWe also intend to eventually provide hooks for debuggers, e.g., `console.ondefer`, `console.onresolve`. These hooks would drive a promise debugger extension or possibly even the browser\u2019s debugger itself. This would be very similar to your proposal.\n. This may be interference we should give further consideration.\n. Good enough for me. We\u2019ll leave it alone.\n. This is a very early draft. I will likely change the protocol before finalizing.\n. Supercedes #65\n. @magalhas The node/web inspector would need to implement a promises panel that communicates with this library service. As yet, this is not a reality.\n. I share the sentiment that too many features have creeped into Q, in general. @domenic has also expressed that he would like to punt more into modules. Mark Miller has (sagely) discouraged me to add streaming promises to Q proper. A moratorium is in effect. We are taking measures to make the transition from a one-script-pony to making use of CommonJS modules and NPM, which unlocks some possibilities. We culled a lot of creep in the leap to 0.9 and I plan to do the same in 0.10. Here\u2019s the roadmap.\n\nhttps://groups.google.com/forum/#!topic/q-continuum/JE6zSshyC5s\n\nThere are some obstacles, but the trajectory in general is: make q.js more focused.\n\nHowever, some things will not be leaving Q core:\n- object proxy methods `get`, `post`, `invoke`. However, `set` and `delete` would not be missed.\n- the second argument of `then`. `catch` is implemented in terms of `then`.\n- method aliases for pre-ES5. alas.\n\nThe Node and Generator methods are good candidates for punting into modules.\n\nI will entertain debate on `timeout` and `delay`. My feeling is that they provide a lot more convenience than cost.\n. Some resources for you:\n- https://github.com/promises-aplus/promises-spec\n- https://github.com/promises-aplus/promises-tests\n\nSome related efforts:\n- https://github.com/tildeio/rsvp.js\n- https://github.com/cujojs/when\n- https://npmjs.org/browse/keyword/promise\n\nI am going to close this issue. The process of modularizing is tracked on other tickets.\n. @fresheneesz Unfortunately, I have too many projects in dire need of my attention to be that generous with my time. It occurs to me that you could also get a lot of what I _would_ say upon review from this article:\n\nhttps://github.com/kriskowal/q/blob/master/design/README.js\n\nI can say that some of your reasoning for wanting a trimmed version of Q is that you may very well have only a subset of the problem that I am solving. I am generally happy to point folks in the direction of API compatible, specification-test-passing variants of Q if they don\u2019t need all the things Q does.\n. Thanks. This is a regression due to rebasing. I\u2019ll take care of it.\n. Was unable to reproduce on master. What version are you using, @surr-name?\n. Closing provisionally.\n. @surr-name Sounds to me like we need to roll out a patch release.\n. @surr-name Thank you for verifying. Glad to hear the problem is resolved.\n. @SET001 Q.all([]) should settle to [] immediately. There should be no need for the special case.\n. @SET001 I mean resolved, settled, and fulfilled. A promise can be resolved with any other promise, including pending or \"settled\" promises. \"settled\" includes \"fulfilled\" or \"rejected\".\n. Yeah, so it can cleanly fall in the 0.9 back-port branch.\n. This is a backward-incompatible change and should wait for a major (or 0.minor).\n. Perhaps I should rethink this so that it is still possible to programmatically retrieve the whole reason, but still only show the traces in the console.\n. Thanks, @domenic. Sounds good to me.\n. That\u2019s a lucky break. Maybe the `.git` internals vary from version to version. This makes me nervous.\n. @domenic Not merely nicer. That is great!\n. @domenic \n- let\u2019s leave the AMD raw. We are already assuming that AMD folks will be using AMD tooling to manage dependencies\u2014it is safe to assume they are using tooling for their build products.\n- It is up to you on how far you want to go to discourage hot-linking. You could even go so far as to provide `Content-type: application/octet-stream` and `Content-disposition: attachment`.\n- Based on what I see from the listing you generate, I think we should go with `{version}`, `commits/{hash}`. I presume that \u201clatest\u201d links to hash by branch name. Whatever makes sense to you for that one.\n. @domenic, I slept on it. I\u2019m pretty sure it\u2019s just a matter of moving some stuff in `become` into `defer`\u2019s `promiseDispatch`, and throwing a flag in there so that we only coerce once.\n. This seems to conflate `Q.async` and `Q.fbind`. I would prefer to keep them separate. Let me know if this is not what you intended.\n. This could be errant behavior on the part of Node\u2019s `inspect`.\n. @ExxKA `promise.toString` returns '[object Promsie]'. `inspect` returns an object describing the internal state of the promise, e.g., `{state: 'fulfilled', value: 10}`, but Node.js\u2019s `inspect` function, used by `console`, delegates to `inspect` methods expecting a string, or an object that can be inspected to produce a string. Node.js developers have been fiddling with `inspect` and the bug likely lies there.\n. I believe @erights may want to review these changes and contemplate the implications.\n. @erights Debugging, testing, and optimizing are the uses today. It is also the polymorphic basis for implementing methods like `nearer`, `mostResolved`, and the deprecated `valueOf`.\n. I should clarify. `nearer` is our implementation of `shorten` described on the Concurrency Strawman and receives very little use. `mostResolved` does not exist, but I have contemplated reimplementing `nearer` in terms of `mostResolved`. `mostResolved` would be responsible for following the promise chain to the last promise, and `nearer` or `shorten` would be responsible for unpacking the fulfillment value from the most resolved promise.\n. I would be content to dump `shorten`, `nearer`, `mostResolved`.\n\n`inspect` is used to optimize `all` and `allSettled`, as well as backing `isFulfilled`, `isRejected`, and `isPending`. We could stretch the `pending` state to cover `accepted` and keep things mostly working.\n. These are the affected tests if we stretch `accepted` over `pending`.\n\n```\nFailures:\n\n  1) inspect for a promise resolved to a rejected promise\n   Message:\n     Expected { state : 'pending' } to equal { state : 'rejected', reason : {  } }.\n   Stacktrace:\n     Error: Expected { state : 'pending' } to equal { state : 'rejected', reason : {  } }.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:817:44)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  2) inspect for a promise resolved to a fulfilled promise\n   Message:\n     Expected { state : 'pending' } to equal { state : 'fulfilled', value : 10 }.\n   Stacktrace:\n     Error: Expected { state : 'pending' } to equal { state : 'fulfilled', value : 10 }.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:828:44)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  3) promise states of deferred rejection\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:891:38)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  4) promise states of deferred rejection\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:892:37)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  5) promise states of deferred fulfillment\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:899:39)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  6) promise states of deferred fulfillment\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:901:37)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  7) promise states of isFulfilled side effects\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:937:46)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  8) promise states of isFulfilled side effects\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:939:48)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  9) promise states of isFulfilled side effects\n   Message:\n     Expected undefined to be 2.\n   Stacktrace:\n     Error: Expected undefined to be 2.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:940:50)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  10) all rejects after any constituent promise is rejected\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at /Users/kris/q/spec/q-spec.js:1102:42\n    at _fulfilled (/Users/kris/q/q.js:794:54)\n    at self.promiseDispatch.done (/Users/kris/q/q.js:823:30)\n    at Promise.promise.promiseDispatch (/Users/kris/q/q.js:756:13)\n    at /Users/kris/q/q.js:580:53\n    at flush (/Users/kris/q/q.js:108:17)\n    at process._tickDomainCallback (node.js:459:13)\n\n  11) delay should not delay rejection\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at /Users/kris/q/spec/q-spec.js:1659:41\n    at _fulfilled (/Users/kris/q/q.js:794:54)\n    at self.promiseDispatch.done (/Users/kris/q/q.js:823:30)\n    at Promise.promise.promiseDispatch (/Users/kris/q/q.js:756:13)\n    at /Users/kris/q/q.js:580:53\n    at flush (/Users/kris/q/q.js:108:17)\n    at process._tickDomainCallback (node.js:459:13)\n\n  12) unhandled rejection reporting doesn't report a resolve, then reject (gh-252)\n   Message:\n     Expected 1 to equal 0.\n   Stacktrace:\n     Error: Expected 1 to equal 0.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:2443:48)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\nFinished in 2.119 seconds\n180 tests, 287 assertions, 12 failures, 0 skipped\n```\n. If we promote acceptance to adoption at time of resolution if the accepted value is a branded promise, the fallout drops somewhat.\n\nAt the end of the day, I would not mind dumping `isFulfilled`, `isRejected`, and `isPending`, and all of the optimizations that use `inspect`. `inspect` could disappear entirely. I expect the only people who would be saddened would be the users\u2014I say only somewhat facetiously.\n\n```\nFailures:\n\n  1) promise states of deferred fulfillment\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:899:39)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  2) promise states of deferred fulfillment\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:901:37)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\n  3) promise states of isFulfilled side effects\n   Message:\n     Expected true to be false.\n   Stacktrace:\n     Error: Expected true to be false.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:937:46)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  4) promise states of isFulfilled side effects\n   Message:\n     Expected false to be true.\n   Stacktrace:\n     Error: Expected false to be true.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:939:48)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  5) promise states of isFulfilled side effects\n   Message:\n     Expected undefined to be 2.\n   Stacktrace:\n     Error: Expected undefined to be 2.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:940:50)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  6) unhandled rejection reporting doesn't report a resolve, then reject (gh-252)\n   Message:\n     Expected 1 to equal 0.\n   Stacktrace:\n     Error: Expected 1 to equal 0.\n    at null.<anonymous> (/Users/kris/q/spec/q-spec.js:2443:48)\n    at jasmine.Block.execute (/Users/kris/q/spec/lib/jasmine-promise.js:21:32)\n\nFinished in 2.126 seconds\n180 tests, 287 assertions, 6 failures, 0 skipped\n```\n. I\u2019ll leave it to our resident Caltech physicist to put to record whether the uncertainty metaphor applies as well as it sounds!\n. > Users can never have too much information to make it easy to use your work. A responsible developer makes good code, documentation, and videos. Anything less is lazy.\n\nTrue enough. Still, this is a free service we provide in our spare time. You should look at @domenic\u2019s public contributions graph on his Github home page, or even mine. We appreciate your understanding.\n\nI\u2019ll be doing a presentation at Fluent next week. I did a presentation in Berlin in 2010. Domenic and Forebes Lindesay have done numerous good videos. We will take your advice and create an index of some of this ancillary documentation.\n. Ah, there it is. I remembered it but could not find it.\n. Try `Q(http).ninvoke(\"get\", \u2026)`. `nfcall` does not invoke with `this == http`, which may be contractually required.\n. To be clear, `.then(console.log)` only works in Node. In Browsers, `log` has to be bound to `console`, and in fact, will crash Safari 2 if it is not.\n. Thank you @dtudury. I got a smile and a laugh out of that and had to tell my wife. We do have a bit of a moratorium in place to stave off our feature creep. We\u2019re also in the process of dissolving Q into smaller modules to ease some of the tension on Q\u2019s surface, tending in the direction of fewer conveniences in the core and considering a feature to make the core extensible externally.\n. Shooting in the dark: Does Q.async work in Q 0.9.6 on Node 0.11.2?\n. Also, does Q.async work if you merge https://github.com/kriskowal/q/pull/366 locally? Support for SpiderMonkey generators makes `async` much more complicated than it will need to be going forward and that might be interfering.\n. @popasquat89 Thanks. Since 11 is in the unstable track, we are not likely to bend Q in any subtle way to support a generators that have already been fixed. Unless you find a compelling and succinct solution, I\u2019m inclined to close as \u201cwon\u2019t fix\u201d.\n. Feature has been killed.\n. Sorry, no. These methods will return undefined to signal completion. We\u2019ve vacillated, I know, but when using these to interact with remote objects, we don\u2019t want to send data back and forth unless we need to.\n. @dtudury Thanks for the pull request in any case. We appreciate that you care!\n. That\u2019s a shame. Let\u2019s add a note with references about why we\u2019re doing this.\n. That\u2019s about right. Thanks.\n. Merged, but rebased. I retained your authorship, but refined the comment a bit.\n\nhttps://github.com/kriskowal/q/compare/e33f9e1b2ec6e2b228f4aac1facd94ca7fe8ff34...dc92d37b55405841482aeddc6b9e6b5a95dffa88\n. You can, but it is not obvious or trivial and there is no clear default and automatic way to combine promise progress.  You have to do it manually based on how you expect the inputs to contribute to the output progress.\n\nFor example, if getAlice is expected to be relatively quick, and getBob is expected to take 3 time getAlice in perfect proportion, you can do this:\n\n``` javascript\nvar output = Q.defer();\noutput.resolve(getAlice().then(function (alice) {\n    return getBob(alice).progress(function (bobProgress) {\n        output.notify(.25 + bobProgress * .75);\n    });\n}, null, function (aliceProgress) {\n    output.notify(.25 * aliceProgress);\n});\nreturn output.promise;\n```\n\nNote that this is one of many ways to compose progress. There could be constant time overhead.  Alice and Bob could perform work in parallel, with one dominating the other. Alice and Bob might emit a different kind of information that could provide better insight, like actual time to completion estimates instead of percentages of total period.  `Q.all` provides input for parallel composite progress notifications like `{value, index}`, so you can update the aggregate progress based on the progress `value` for each `index`.\n\nSky is the limit.\n\nWe\u2019ll keep this ticket open to track the task of documenting these strategies.\n. Progress is deprecated. Removing in version 2. Not sure whether to get rid of the docs for progress entirely or explain the current, unsound behavior.\n. Merged at bcc50d69c37d149a0085f06242b7659fecae26cc\n. I\u2019m going to follow-up on these changes and remove the dependency on ES5-Shim. I think we will just raise the requirements on the engine to ES5 (that is, environments in which WeakMap is shimmable), and maintain the previous release train (alas).\n. I\u2019m getting:\n\n```\n},{\"asap\":1}],3:[function(require,module,exports){\nself[\"Q\"] = require(\"../../../../../Users/kris/q/q.js\");\n\n},{\"../../../../../Users/kris/q/q.js\":2}]},{},[3])\n;\n```\n\nIn my `release/q.js`, which probably means a path is a bit too explicit in the Browserify/Grunt build step.\n. Thanks, @rkatic. We\u2019ll block on that for sure.\n. Yeah, WeakMap is ES5 only. I forgot to consider that. We might be stranding folks in earlier versions of Q. That also implies that ES5-Shim would be completely wasted, since we would be raising our minimum operable version. I think we should consider the shift anyway.\n. Speaking of which, perhaps that needs to be called \u201caccepted thenable weakmap\u201d. I was going to say \u201ccasted\u201d instead of \u201ccoerced\u201d, but it occurs to me that we should make the mapping the moment a thenable is accepted, if we\u2019re doing the deferred coercion of thenables that appears to be in for ES6.\n. @domenic As for the private variables approach, I believe that\u2019s what @erights and his merry band of cypherpunks call \u201cbrands\u201d. They are tricky to get right, whereas it\u2019s pretty hard to mess up with WeakMap.\n. @domenic can I ask you to look at the failing specs locally and assess the situation regarding progress notifications?\n. I\u2019m rolling this into the modularity omnibus branch.\n. Thank you for the very thorough investigation. We will definitely embed a reference with the fix. Once we figure out what that\u2019s going to be. Holy expletive, what a mess!\n. @domenic Word.\n. This issue will be tracked here https://github.com/kriskowal/asap/issues/21\n\nWhen that issue is closed, we may elect to back-port the fix to the v0.9 branch of Q. v1.0 will benefit from the fix to ASAP through dependency.\n. Yeah, handling sequences is a pattern, and there are other ways to do them to boot. I think they\u2019re mentioned in the right place, but I could buy a PR that provides cross-linkage from the API to the tutorial to speed up discovery of this kind of thing. I know you wouldn\u2019t be asking if it wouldn\u2019t have helped to read relevant section of the tutorial sooner.\n. Ah, I see. We could help that misstep by providing a link to MDN in the tutorial.\n. ``` js\nreturn Q.try(function()\n{\n    if (!uri || typeof (uri) !== \"string\")\n        throw new TypeError(\"Invalid uri: \" + uri);\n    return Q(jQuery.ajax({\n        url: \"foobar.html\",\n        type: \"GET\"\n    }))\n    .then(function (xhr) {\n        if (xhr.status !== 200)\n            throw new Error(\"Unexpected response code\");\n        var data = xhr.responseJSON;\n        return data.uri;\n    })\n});\n```\n. Should probably be something we mention on https://github.com/kriskowal/q/wiki/Coming-from-jQuery, maybe even first thing. @domenic just rewrote that, and I just reread it, and I don\u2019t recall seeing it called out. @cowwoc, you might try your hand on the wiki.\n. Everything looks fine. I made some edits in an attempt to simplify. `Q.try` isn\u2019t necessary unless you\u2019re weary of `jQuery.ajax` throwing an error (maybe you are). `Q.defer` is nice, but `Q.promise` is the direction libraries are going, and it takes the place of the `Q.try` you had before.\n. @cowwoc Oh, my. Your best option is to create a record with all the properties of the xhr that are salient downstream, like `{responseText: xhr.responseText, status: xhr.status}`.\n\nWhat follows is mostly for @domenic to overhear, where I mumble about how we might make this case easier for you in the future.\n\nWe do not presently have a way to bless an object such that its `then` method will be ignored. We had `Q.fulfill` for a while, which could conceivably have served that purpose, and still might if we abuse our thenable coercion weakmap coming in 1.0.\n\nYou may know that promises are being brought into the JavaScript spec as we speak, and in that effort, there is an answer, but it is a little weird. With upcoming promises in the language, the promise system would not coerce a value to a promise unless you use `then`. These promises also have a `flatMap` which is like `then`, but would do what you need if you played nicely with it.\n. Seems related to how asynchronous traces are working in Chrome now. Each event\u2019s trace starts with an explanation of what underlying operation enqueued the event.\n. @STRd6, we have `Q.promise(function (resolve, reject) {}` today. This will probably become `new Promise(function (resolve, reject) {})` in the future, which is the direction the libraries are all converging upon for the pattern you\u2019re looking for. However, we also have a Promise constructor that we use to generate fulfilled, rejected, and remote promises, which does need to be a public API as well, which stands in the way. We\u2019ll have to work that out as well. It might be an okay situation to overload. In any case, the game is afoot.\n. Thanks for taking the time to PR, in any case.\n\nQ has a bit of a broader charter than jQuery\u2019s since it comes from a security background. It is not in-fact secure, but our intention is to remain API compatible with versions that do have a security mandate.  Part of that requires that promises and resolvers be separate authorities. As @domenic points out in the jQuery migration guide, it is easier to give than to take away, when it comes to authority.\n\nWe also have a mandate to support promises as proxies for remote objects. As a consequence, it would be difficult for Q whittle down to a single function interface, though we pack a lot of punch with just `Q` and `Q.promise`. Much of what remains is just for convenience, like `Q.all([])` instead of `Q([]).all()` or `Q.try(f)` instead of `Q(f).fcall()`, though it can be (and has been) argued that `all` (or anything except `then`, `get`, `post`, and `fapply`) has no business being on the promise prototype since it is outside the sufficient interface for proxying arbitrary eventual or remote values.\n. There is a relatively new API, `Q.race([promise1, promise2, promise3])`, but it may not have been documented yet. We\u2019ll track that with this ticket.\n. For what it\u2019s worth, I like you intuition on the name and will run the idea by @erights, steward of the API.\n. Case closed. Thanks @erights, @domenic.\n. Yeah, that\u2019s on my mind as well.\n. This is good. Let\u2019s do it.\n. #404 may address this issue.\n. Truth.\n. Let\u2019s keep this open to track the update to README\n. Ah, no branch to track. Will open an issue.\n. Uh oh, the `window.Touch` thing is a new problem. I\u2019m not willing to keep this feature off by default though.\n. See #413 v0.9 #412 for v1.0\n\nI don\u2019t plan to do anything for the PhantomJS case unless we can find a reliable differentiator.\n. @francoisfrisch do you recall why we added this exception and whether it is still relevant? If so, we need a new differentiator.\n. Addressed @domenic\u2019s review.\n. @ForbesLindesay As it were, it is not necessary for Q-IO. Q-IO takes the \"b\" argument to specify that you want bytewise data, and its omission implies \"utf-8\" by default.\n. See #416 for benchmark\n. Needs a note that this also addresses #369 \n. And also, since it addresses #369, obviates #372 \n. Thanks, and thanks for the tip on usage of V8 internal methods.\n. With the little benchmark we have in Q, here\u2019s a comparison.\n\nhttps://docs.google.com/spreadsheet/ccc?key=0An5phhxDkYDPdDg3V0prbVZkMzdDZ2NYZVRpTWxQWVE#gid=0\n\nThe top is the branch name, except for `rearch` with `--harmony`, which just enables the native `WeakMap` instead of the shim.\n. Closing. See: https://github.com/drses/weak-map/issues/1\n. Take a look at `allSettled`. `all` will stop at the first rejection.\n. Is it possible that you\u2019re adding values to the array _after_ calling `all` or `allSettled`? Neither of these methods react to changes to the array after they have been called.\n. If you could produce an isolated use case that we can run that does not work the way you expect it, we might be able to make this work for you. `Q.all` does not behave as you describe under normal conditions, so there must be something special about your situation that we do not know yet.\n. @cjmagee Can we have a gist and instructions to run it or a jsfiddle that reproduces the problem? Otherwise, we\u2019ll stitch the case together by typing out your screenshots and ask you to verify, but it won\u2019t be fast.\n. Having given this a fresh glance (a glance mind, I have not spent a lot of time on this) it occurs to me that this might be an issue with cancelation. Ideally, if any promise is rejected in `Q.all`, the others would be canceled. Q does not at this time support cancellation, and if it does, promises will no longer be inherently safe to give to multiple consumers, since they would be able to interfere by canceling. We could tack on an interface that would allow a promise to be explicitly forked for multiple consumers, or defended, preventing upstream cancelation and deep freezing the promise.\n\nLeaving this open for a rainy day.\n. I don\u2019t foresee having time to give this question justice. My apologies, but closing.\n. Oops.\n. I\u2019ve removed the warnings from the v0.9 branch, to be released in the next patch.\n. You may consider using `promise.thenResolve` and `promise.thenReject`, and `Q()` instead of `Q.resolve()`.\n\n``` js\nQ('a').thenResolve('b').then(function (res) {\n    console.log('test 1', res); // test 1 b\n});\n```\n. I don\u2019t intend to support unravelling yielded arrays of promises. This behavior strikes me as too much magic. Apart from that, I think we\u2019re already compliant. Please correct me if I\u2019m wrong.\n. Yes. Sorry for the interruption. We\u2019ve landed some changes very recently that alter the infrastructure. It used to be that q.js and q.min.js as checked in were sufficient to get started in a browser, but now q.js is CommonJS-only and we are building q.js and q.min.js for `<script>` tags and uploading them to S3 automatically. We will address this problem shortly.\n. For the interim, please see v0.9\u2019s branch https://github.com/kriskowal/q/tree/v0.9\n\nMaster is targeting the release of v0.10 and v1.0 and is unstable.\n. It would be possible to augment the `Deferred.prototype` on master, if Q were to export it.\n\nhttps://github.com/kriskowal/q/blob/master/q.js#L933\n\nIf Q were to use `Q.Deferred` with lazy binding in `Q.defer`, it would also be possible to subvert it.\n\nBearing in mind that this implementation of Q has relaxed quite from its security centric design. None of these cut-points will be extensible in a secured version of Q and it has been my policy in the past to discourage it.\n. I concur with @domenic. This would be a handy utility in a third-party package. I am trying to keep Q\u2019s weight down.\n. This is an interesting illustration of an idea that has been going around\u2014the use of a promise\u2019s progress channel as a source of a stream.\n\nI am going to leave this open for discussion and contemplation.\n. An implementation of the behavior of `any` already exists as `race` and we intend to keep it by that name.\n. In master, I\u2019ve removed support for SpiderMonkey/Pythonesque generators. Content Security Policies would also cause this code to misreport that ES6 generators were unavailable. The fix will come in a backward-incompatible release `v0.10.0`, and soon-after `v1.0.0`, hopefully soon.\n. `then` receives a function that will start the next stage. In this case, you can just use bind to partially apply `waitp`. `then` will call the resulting function when the previous completes.\n\n``` js\nwaitp(1000)\n  .then(waitp.bind(null, 500))\n  .then(waitp.bind(null, 1000))\n  .then(waitp.bind(null, 200))\n  .done(function () {\n    console.log('ok')\n  })\n```\n\nIn general, however, you would use a callback as the argument to `then`.\n. Please reopen if this did not answer your question.\n. I presume your changes are forthcoming. So far, we only have four of my commits that distinguish v0.9 from master, which are probably not what you intend. You might need to edit this PR to encompass the changes between your branch and either our master or v0.9.\n. The other commits are expected. I have forked the `master` branch from the `v0.9` branch. If you revise your target branch to `kriskowal/v0.9`, it will merge cleanly without my extra commits.\n. As @petkaantonov would say, `tasks.reduce(Q.when, Q())` would probably do what you want, but I would like to clarify the purpose of `Q.chain`. Is each task independent, or does it need to see the result of the previous task? Does it need to see the results of all previous tasks? Do you need a promise for the results of all tasks, or just a promise for the result of the last task? The `reduce(Q.when, Q()` idiom will pass the result of the previous task to the next task.\n\nThis idiom would pass the results of all previous tasks as arguments to each task, and ultimately return a promise for an array of all the results:\n\n``` js\nreturn tasks.reduce(function (results, task) {\n    return results.then(function (results) {\n        return Q.fapply(task, results).then(function (result) {\n            results.push(result);\n            return results;\n        });\n    });\n}, Q([]));\n```\n\nIn both cases, I\u2019m assuming that a task is a function that must be called in serial and returns a promise for the completion of the task.\n\nI\u2019m sure that there is a variation of this pattern that would suit the purposes of `Q.chain`.\n. Thank you for proposing this change. It is great to see what patterns of usage are common. However, there are so many small variations of this pattern, and it is so easy to create small utilities for each case, that it would be impractical to promote one above all the others. About three years ago, I was maintaining a library, QQ, where I fiddled with the idea of a `Q.step` method with the behavior of `tasks.reduce(Q.when, Q())`, inspired by @creationix\u2019s library by that name. I dropped it because it did not turn out to be useful in practice. At the end of the day, `then` is a powerful building block that can be composed a lot of different ways.\n\nI am tentatively closing this issue, but I would be very happy to continue this conversation to whittle your utility method down to its essence.\n. The `tasks.reduce(Q.when, Q())` pattern would execute the tasks sequentially, waiting for the promise returned by each task to be fulfilled before executing the next task. They would be executed in the order that they exist in the tasks array. If a task promise is rejected, it would stop the execution of the chain, but that can be prevented by catching the error in the task.\n\n``` js\nreturn function task() {\n    return makePromise().catch(function (error) {\n        // ignores the error, fulfills the resulting promise with `undefined`\n    })\n}\n```\n\nThis pattern will not work if the task chain is actually a queue or tree that grows in response to the results of previous tasks. If that\u2019s what you need, describe that further. There are elegant solutions for those cases as well.\n. You will be interested to know that `$.ajax()` returns a sort of promise that Q can use, so you do not need to pass a resolver. You just wrap the result in `Q`, and you can omit the success and error handlers. Also, `Q` has its own timeout mechanism, so you can use it or the jQuery one, whichever you prefer.\n\n``` js\nfunction ajaxTask(url) {\n    $.support.cors = true;\n    return Q($.ajax({\n        url: url,\n        type: \"GET\",\n        dataType: \"json\",\n        cache: false\n    })).timeout(5000);\n}\n```\n\nIf I understand this correctly, this is a simple matter of waiting for all of the ajax tasks to be resolved in parallel, and then proceed to look at the results in serial order. However, you do not want to stop on the first error. In that case, you have options. You can either catch and handle the error from each task and use `Q.all`, or you can use `Q.allSettled`, which waits for all promises to resolve and then gives you back the array of promises (instead of results). You can then unpack the values from the fulfilled promises.\n\n``` js\nreturn Q.allSettled(urls.map(ajaxTask))\n.then(function (resultPs) {\n    for (var i = 0; i < resultPs.length; i++) {\n        var resultP = resultsPs[i];\n        if (resultP.isFulfilled()) {\n            var result = resultP.inspect().value;\n            // \u2026\n        }\n    }\n})\n```\n. @jouni-kantola No, your information was accurate, but I missed the detail about calling display immediately. @petkaantonov seems to have got all the knobs right, and if you refresh his comment, it looks like he handles the error case as well now, using `$.noop`. You are in good hands.\n. My hard requirement is that by `v0.10`, we pick one function name for each behavior. I may grant special dispensation for the one-argument usage of `Q.try`, as it is equivalent to the one-argument usage of `Q.fcall`, but only for the one-argument case.\n\nAlso, I want feedback from @domenic and @erights. I will not release `v0.10` or `v1.0` without their blessing.\n\nI am open to reconsidering which names are deprecated and which are retained.\n\nThe method names should be consistent with analogies in the ES6 world. I favor the Proxy analogy. A promise is, after all, a proxy for a value displaced in space or time.\n\nI am sympathetic to abandoning the HTTP analogies established by `ref_send`: that means `post`. I have already changed `put` to `set`, to align with the proxy handler interface.\n\nWe will still need to retain _provisional_ spread variants, by whatever name. `apply` as the spread variant for `call` is uncontroversial, but `post` for `invoke` or `send` lacks a precedent.\n\nThe usage of `fapply` and `fcall` is an unfortunate aberration, and I will ditch it if there is a viable solution. It might be worthwhile to use `call` and `apply` on `Promise` and on `Promise.prototype`, where there is no problem with these names, and just retain `fcall` and `fapply` on Q. That is to say, the single-letter `apply` and `call` variants should not be considered strong precedent. They are not likely to exist in ES6+ because there is no overlap with `Function.prototype` on `Promise` or `Promise.prototype` like we have on `Q`.\n\nI am sympathetic to the argument that `mapply` for `mcall`, where `mcall` replaces `invoke` or `send`, because it is consistent with the `apply` for `call` and consistent with `fapply` and `fcall` variations, but if proxies support (or even _might_ eventually support) `invoke`, I want `invoke`, and that leaves no precedent for the spread variant. It is important to note that whatever name we chose for the spread variant will be _provisional_, because it will be _vestigial_ on ES6.\n. Also, to give you an idea of the time-table, I\u2019m not going to release `v0.10` unless it is faster than `Q`. At present, this is not the case. Performance improvements on the `WeakMap` shim may fix this. Flipping the architecture of `then` and `done` might help too. That is to say, this is not the only issue blocking the next release.\n. In the version 2 experimental branch, we have removed all aliases and only support ES5. The methods that remain are `call(thisp, ...args)`, `apply(thisp, args)`, and `invoke(name, ...args)`. These exist only on the promise prototype to avoid collision with `Function.prototype` on `Q`. `Q.fcall` has been replaced by `Q.try`. `Q.fbind` has been replaced with `Q.function`, but does not perform partial application. All of the f_, m_, and n\\* methods except `ninvoke` have been deprecated.\n\nThanks for the recommendations @Redsandro. We will continue enjoying the `m*` methods for the duration of the version 1 release train.\n. @domenic Even the first two cases you illustrate are not equivalent if the latter promises reject before the first resolves.\n. @ndkrempel `Q.all` was variadic by spec, but I elected to use an array because we don\u2019t have the spread operator yet. It is much more convenient to add the brackets than to add the `Q.all.apply(Q, \u2026)` idiom.\n. @ndkrempel Returning non-promise values from then-handlers, and passing non-promise values to `deferred.resolve` are analogous cases to yielding a non-promise. We always use `Q(valueOrPromise)` to promote values to promises.\n\n@jlongster asked for this feature some time ago. Although I wanted to make him happy then, and to make @ndkrempel happy now, I think that I will stand by the status quo. Explicit is better than implicit, at least in this case, and consistency is better than a dweomer, in the Perl sense, especially when it folds semantics in ways that are difficult to unfold.\n. Thank you.\n. Close enough. Thanks.\n. Thanks @tschaub. I was asleep at the wheel. I have sorted this out, I think. https://github.com/kriskowal/q/commit/db9220d714b16b96a05e9a037fa44ce581715e41\n. Thanks.\n. We have delegated this responsibility to @microjs. We do not have the inclination to maintain multiple package management solutions.\n. Progress notifications are on life-support in the version 1 release train. They will not be removed until version 2, but they are architecturally unsound and I do not plan to put further work into them.\n. Oh, in version 2, progress has been replaced with an \u201cestimated time to completion observer\u201d system. I do not think that long stack traces apply to observers.\n. This is indeed an area that requires further contemplation. It would be reasonable to guarantee that the progressed handler be guaranteed to receive at least one notification if `notify` is ever called, with the last-known progress. Would also be also be reasonable to guarantee that the `progressed` handler gets called before the `fulfilled` or `rejected` handlers, since these imply a 100% progress notification.\n. `v0.9` and `master` are the relevant branches. I\u2019ll do some house keeping to emphasize that fact.\n\n`master` is a hypothetical for all intents and purposes. A lot in there is unstable particularly regarding progress and notifications. I intend to revisit the topic.\n. Having contemplated the design further, I deem that the progress/notify system is architecturally unsound. I am replacing it in version 2 with estimated time to completion observers, which actually compose and do not suffer the problems observed here.\n. What is and isn\u2019t deprecated is still up in the air. @domenic has expressed that the constructor/prototype reflection is one of Q\u2019s endearing qualities. @erights and I agree that the API has gotten bloated, and I erred on the side of aggression in my latest refactor. This is still a topic of discourse.\n. Dust has settled. `Q.when` is here to stay in the `v2` branch.\n. Just a point of style, we use 4 spaces here. I\u2019ll let @domenic assess this otherwise.\n. Assigning to @domenic, in hopes that he finds time for it before I do :)\n. We have considered `thenCall`, `thenApply`, and `thenInvoke`, but haven\u2019t found substantial need. More often than not, when using `then`, you do want to see the result of the previous promise and using a promise purely to wait is relatively uncommon. I\u2019ve also been contemplating something like `thenDelegate` that would call methods of an object, like `resolve`, `reject`, `notify` as a means for closure avoidance and object reusability, but that has not come to fruition yet. Substantial changes to Q core would be necessary for that path to make sense (though, substantial refactoring is in progress).\n. I am considering this, not for the syntactic sugar, but because it would solve a problem with message pipelining.\n. Subsuming in #453 \n. I might take this. Going to think on it.\n. Thank you.\n. `thenCall`, `thenApply`, and `thenInvoke` might not just be useful sugar, but fill a gap in promise pipelining performance.\n. Oh, crossed wire. Previous comment does not apply to Node.js shorthands. It would be conceivable to have `thenNinvoke`.\n. I have implemented trial versions of then{Invoke,Call,Get} in v2.\n. @Redsandro v2 is a rewrite with a minimum environment of ES5, slimmed down, and not completely backward compatible with v1, though I have only changed things that I regret. It is no where near a stable state, so it would be premature to advertise, and going forward for some time, the API reference will not be stable. I am building additional infrastructure, starting with ASAP, to improve coverage on multiple fronts.\n. However, @Redsandro, I do continuously maintain CHANGES.md.\n. I still hope to address speed concerns in `v2`. The Bluebird author, @petkaantonov, does in fact know what he\u2019s doing when it comes to speed in ways I do not, but I\u2019m also not willing to go to the incredible lengths he has, e.g., doubling the size of the code, nor to specifically target V8 if it comes as an expense to slower engines (which is just a matter of measuring. there is a good chance Bluebird has serendipitous benefits in Firefox at least), and I can\u2019t sacrifice the message passing kernel since Q is designed for far references. Summarily, more research needed to bridge the performance gap, and if your use-cases are a good fit for Bluebird, and you can leave the Q ecosystem behind, you should consider using it.\n. It would make sense to have a grab bag of functions that would allow a promise chain to explicitly permit interleaving.\n\n``` js\nvar render;\nfunction yieldForRender(x) {\n    if (!render) {\n        render = Q.promise(function (resolve) {\n            setImmediate(function () {\n                render = undefined;\n                resolve();\n            });\n        });\n    }\n    return render.promise.thenResolve(x);\n}\n```\n\nUsage:\n\n``` js\ngetUser()\n.then(function (user) {\n    // \u2026\n})\n.then(waitForRender)\n.then(function (\u2026) {\n    // \u2026\n})\n```\n\nWait for reflow, wait for draw, wait for etc.\n\nThere is also the possibility that we will eventually expose a `makeQ(schedule)` method at some point in the future.\n. Uh oh. This implies that either the spec has changed, or the implementation has drifted away from the spec.\n. @ljharb There is probably a miscommunication here. The `new Promise(f(resolve, reject))` constructor does facilitate fulfilling a promise after its created.\n\n``` javascript\nvar deferred = Q.defer();\ndeferred.resolve(10);\nreturn deferred.promise;\n```\n\n``` js\nreturn new Promise(function (resolve) {\n    resolve(10);\n});\n```\n\nBut the `Promise` constructor does discourage passing or returning \u201cdeferred\u201d objects that house both the power to resolve and observe. These powers should be passed separately.\n. (previous comment was prematurely submitted, so please check back if you don\u2019t see the second code example in email)\n. Pending feedback from vert.x. See #460.\n. I keep trying to give @osteele his well-deserv\u00e8d Google-juice, and he just keeps moving his blog around :P\n. This is a duplicate of #150. It doesn\u2019t look like Vert.x has made any progress on this issue.\n. @kennethjor It still messes up static analysis. The `require` statement implies a dependency on a module that doesn\u2019t exist in most environments. This is not important for Node.js, but tools like Browserify, Mr, and Mop use static analysis to discover the working set of a module before execution, or before bundling. These tools can usually be tricked with expressions like `(require)(\"id\")`. You could do this. However\u2026\n\nI would prefer to put pressure back on Vert.x to expose `setImmediate` or `setTimeout` globally. This issue is ultimately a symptom of a Vert.x architecture bug, though they may disagree. I am leery of maintaining this nuance for a fringe engine since it doesn\u2019t get much exercise and penalizes other engines.\n\nThat said, I am not immune to the pressures to increase adoption and cross compatibility. Can we make an attempt to fix this in Vert.x before we commit to supporting this wart in Q (provided that require becomes parenthesized)?\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. @vishy1618 No, they\u2019ll get collected.\n\nClosing. Do follow up if you have further questions. This is just closed because there is nothing we are going to change in Q.\n. I tend to agree with @petkaantonov. I may end up redacting progress from Q entirely. We haven\u2019t figured it out yet.\n. @dts I concur that there is a concept of progress on promises, and it is compelling to expose it with our `notify` API if possible. The question is one of composition. Our present system assumes that each promise may communicate progress notifications directly consumable by something like a determinate or indeterminate progress widget, using values like 0 to 1. However, start time and estimated time to completion is probably more useful for composition purposes. This is further complicated by the \u201cprogress algebra\u201d necessary each time you call `then`.\n\nSo here\u2019s my analysis of the problem we need to solve:\n\nConsider a simple example of a `Q.delay` promise. Such a promise could theoretically provide progress \u201cnotifications\u201d of any level of granularity, but it would be sufficient for it to advertise that it should resolve in some number of milliseconds known at time of construction and _never_ updated. The user interface can animate at whatever rate and infer the percentage from the current time and the last known estimated time to completion.\n\nAn XHR is similar. Until a notification becomes available, we can assume that the estimated time to completion is indeterminate. At some point the response headers become available, and if those response headers contain a content length, we have a piece of a puzzle but no ground for an update on our estimated time of completion. However, thereafter we can measure the time between chunk arrivals, measure the size of each chunk, and produce an estimate for the throughput, then do some simple math from the time the promise was created, the time the headers were received, the content length, and the throughput estimate, to arrive at a new estimated time to complete. We might even do some weighted averaging.\n\nThen you use `then`. Assumptions are scarce, so we must do algebra case-by-case. The percentage so useful for a widget is useless for composition since the weights differ. \n\nAssuming that two promises are sequential: We have to take into account the estimated time to fulfill the input promise, an estimate for the time to compute in the handler, and the estimated time to fulfill the promise returned by the handler if any. Before the input promise is fulfilled, we must assume the time to complete the output, and after the input is fulfilled, we must account for the known time it took to complete. Anything that involves computation varies by system and would have to be measured and ideally trained over multiple runs, and may vary depending on the parameters, may vary by processor scheduling weather, or we can assume that it is negligible. Anything over a network depends on the bandwidth at the bottleneck and if that isn\u2019t the link from the ISP, it is dominated by weather.\n\nAssuming that the two promises are parallel, we have a predicament. The `then` method itself is not privy to the ongoing progress of the promise that will be returned by the handler. When either the input or handler promise produces a notification, we would ideally update the aggregate promise\u2019s ETA to the max of either. `Q.all` needs to do something similar.\n\nAs such, our API will need to be adjusted to thread the necessary parameters through and compose them appropriately. For one, promises will need a way to synchronously expose the last known or initial estimated time to completion, in addition to a way to subscribe to notifications when the estimate changes. Sounds like an FRP problem. We\u2019ll also have to retain and expose the start time for each promise in order to surface a percentage.\n\nWith due apologies, this is all the exposition I have time for at the moment. Please feel free to finish the thought. I sense that this is not far from an idea.\n. ``` js\n\n// Parallel delay between two promises\n\nvar p1 = Q.delay(1000);\nvar p2 = Q.delay(2000);\nreturn p1.thenResolve(p2)\n.progress([p1, p2], max);\n\n// Assuming that indeterminate progress is a \"viral contaigon\".\nfunction max(progresses) {\n    return progresses.reduce(function (prev, next) {\n        if (prev == null || next == null) {\n            return null;\n        } else {\n            return Math.max(prev, next);\n        }\n    }, void 0);\n}\n\n// Defining the progress method as\nfunction progress(promises, compose) {\n    var deferred = Q.defer();\n    var progresses = new Array(promises.length);\n    var observers = promises.map(function (promise, index) {\n        return promise.observeEtf(function (progress) {\n            progresses[index] = progress;\n            deferred.setEtf(compose(progresses));\n        });\n    });\n    return deferred.promise;\n}\n\n// ETF meaning estimated time to fulfillment. We're optimists.\n// Assuming existence of setEtf, getEtf, and observeEtf.\n// Where getEtf returns the last set ETF, or undefined.\n// Where setEtf sets the ETF and arranges for each observer be notified in a\n// subsequent event unless such a notifier has already been scheduled but\n// not yet dispatched.\n// Where observeEtf adds an observer to the promise, which will\n// be called in a future turn with the current ETF, albeit undefined, and after\n// each subsequent change. The ETF becomes the actual time of fulfillment\n// and dispatches a change as well.\n// Observers might become cancelable and might compose well with cancelable\n// promises if such a thing were to happen.\n\nvar p1 = Q.delay(1000);\nvar p2 = p1.then(function () {\n    return Q.delay(1000);\n});\nreturn p2.progress([p1, p2], function (p1, p2) {\n    if (p2 == null) {\n        return p1 + 1000;\n    } else {\n        return p2;\n    }\n});\n\n// Generalizing composition of parallel promises\n\nreturn Q.all([\n    Q.delay(1000),\n    Q.delay(2000),\n    Q.delay(3000)\n]);\n\n// Depends only on a pretty straightforward augmentation of existing all\nfunction all(questions) {\n    var countDown = 0;\n    var deferred = defer();\n    var answers = Array(questions.length);\n    Array.prototype.forEach.call(questions, function (promise, index) {\n        ++countDown;\n        promise = Q(promise);\n        promise.then(\n            function (value) {\n                answers[index] = value;\n                if (--countDown === 0) {\n                    deferred.resolve(answers);\n                }\n            },\n            deferred.reject\n        );\n    });\n    if (countDown === 0) {\n        deferred.resolve(answers);\n    }\n    return deferred.promise.progress(questions, max);\n}\n```\n. I am fixing progress with this change, which is now in the `v2` branch.\n\nhttps://github.com/kriskowal/q/pull/475/files\n. I do plan to expose a `Promise` object that meets the ES spec. That much is not hard. I am not planning on making it a polyfill \u2013 that is, to fall back to using the global Promise as the implementation if it exists. However, @erights and I might consider such a project and put it under https://github.com/drses.\n. As mentioned, we now expose `Q.Promise`. In the `v2` branch, it has the right interface, but a bit more work will be needed to bring it up to spec, with help from @domenic if he has time. Polyfilling is otherwise out of scope for Q, but is a good idea for a future project.\n. Thank you.\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. Textbook case of the tension between design principles and adoption / user happiness. Thanks for the feedback.\n. True enough.\n. I believe this has the opposite of the intended effect. The idea is for the array logged to the console to react to changes to its content, so that it contains only the rejections that are unhandled at a given time.\n. The issue is that errors can be handled asynchronously, but might not be handled at all. We cannot distinguish the two programmatically, so we show a \u201cbest guess\u201d, such that if an error is thrown, it is shown, and when it is handled, hidden. At any moment, you will only see the errors that have not yet been handled.\n. I can see the value of promoting primitives to full-fledged errors at the earliest convenience, to enable us to at least trace a bad error to its event of origin. I\u2019ve left this open and will entertain pull requests if someone beats me to it.\n. I am tempted to remove the feature entirely, which I intended to do once there was a viable promise debugger. All of these problems amount to misunderstanding the log entry or consoles failing to update. As for the viable promise debugger, work is ongoing both in the Ember inspector and the Montage inspector.\n. @cowwoc My hope is that you will not have to buy into Ember or Montage to take advantage of their promise debuggers. This will require some coordination about what protocol Q will use communicate with them (over the window message port).\n\nRegarding consoles that don\u2019t update https://github.com/kriskowal/q/issues/151\n\nThe console message is sent once and immediately when a rejection is created, regardless of whether it is subsequently handled. If it is subsequently handled, the relevant error should be removed from the array and the console should update the live list. It very well might not, but if the browser fails to update, there is nothing we can do from within Q to improve the situation.\n. @cowwoc handlers can be added in future events. That an error is not handled before the event queue flushes is not a perfect indication that the event will never be handled. Though it is a decent heuristic in practice, if the console does not update, there will be false negatives.\n. @cowwoc Astute observations all around. We _are_ indeed looking forward to post-mortem garbage collection hooks, perhaps in the ES7 timeline, though these have been discussed by TC39 for at least five years http://wiki.ecmascript.org/doku.php?id=strawman:weak_references.\n\nI agree that the console _should_ capture a snapshot.\n\nThis is my throw-away prototype for a Chrome Extension that adds a Promise panel https://github.com/montagejs/continuum\n\nThis is the issue pertaining to the development of the Promise tab in the Ember inspector https://github.com/tildeio/ember-extension/pull/76\n. @cowwoc Thanks for the tip on the WebKit behavior. If it snapshots when opened, it\u2019s useless for this purpose. We need to remove the feature outright and hope for postmortem GC or a promise inspector. At this point, the log is completely misleading.\n. @domenic I am tempted to remove all unhandled rejection tracking entirely. Do you want to keep the interface in the `v1` train and remove it entirely in `v2`?\n. @domenic I\u2019m proposing that we remove the log in `v1`, retain the current interface, and perhaps add the interface you\u2019re proposing as a temporary substitute. In the end, we need to implement an inspector protocol that provides those hooks.\n. @petkaantonov That is a better but not a perfect heuristic.\n\n``` js\nvar Queue = require(\"q/queue\");\nvar queue = new Queue();\nqueue.put(Q.reject());\n// \u2026 later\nqueue.get().catch(function () {\n});\n```\n. The producer and consumer are running in separate events. Ergo, `// \u2026 later`.\n. Note that until and unless the `respect` lands, the relevant differences are here:\n\nhttps://github.com/kriskowal/q/compare/respect...eta\n. Automatically closed when I renamed `master` to `v2`.\n. Merging into `v2`.\n. Here\u2019s my argument, and my apologies if there\u2019s heat coming off it.\n- Specs need to work in Mr and Node.js without much futzing. Jasmine and Mocha both require scripts outside the module system. Mocha and Chai are not loadable with Mr because they depend on `index.js` modules. Not a problem for Browserify, but on Mr, I debug without a build step.\n- To facilitate debugging, reporters need to display results inline with all output produced during a test. Both the Node.js and Browser reporters proposed here just note when a test begins on the console to make it obvious where to look when something is broken. I use coloring in Node.js to make these delimiters conspicuous without being distracting. I used console.group and console.groupEnd for the browser specs because they were there. I also used coloring to draw attention to certain lines of the summary depending on the big picture, like highlighting passes in green only if all tests pass, highlighting errors or skipped specs only if there are any.\n- Also, browser specs should use the page as a stage and the console for reporting. Fancy dynamic test result reporters in browsers make it difficult to identify which tests produced which console output, which makes tracing errors more difficult.\n- Jasmine tries too hard and in the wrong ways to emulate a domain for each spec. I do not want domains. I want exception containment to flow through promises. I do not mind if a spurious error causes the tests to fail prematurely since this will be relatively straightforward to isolate.\n- I do very much want the interface to be `describe`, `ddescribe` for focus, `xdescribe` for skip, `it`, `iit` for focus, `xit` for skip. Jasmine does not have this feature, Mocha has `.skip` and `.only` modifiers, which are awkward to causually insert and remove.\n- I also don\u2019t care for the natural language machinations. The only good reason to use the `expect` DSL is that it separates the expected from actual values, which makes it easier to explain failed assertions. This scaffold re-uses Object.is, Object.equals, Object.compare, and Object.has operators from MontageJS/Collections which have sensible meanings and modern implementations for handling reference cycles gracefully. I would rather re-use these primitives than re-implement them, or have slightly different implementations of them between the test scaffold and elsewhere I use them.\n- Specs need to work in Istanbul without much futzing. Mocha and Jasmine both support this, but with this scaffold, it is trivial.\n. This was automatically closed when I renamed the `master` branch.\n. I am going to merge this into `v2` although it is not final.\n. Thanks.\n. I can\u2019t account for the Github UI, but the changes did apply.\n. I gather that this wasn\u2019t even thrown as an exception. I was counting on that.\n. Not very nice of them. I can\u2019t withdraw support for SpiderMonkey in the `v1` timeline, but there are perhaps better ways to check, e.g., existence of a `StopIteration` global that is _hopefully_ not a shim.\n. We\u2019re trying to create a promise inspector protocol to address this problem. This would enable a variety of agents to surface the list of as-yet-unhandled rejections and still-pending deferred promises.\n\nhttps://gist.github.com/kriskowal/8948969\n. This is a good observation, and the result of my vacillating over the course of the last month. I\u2019ll add clarifications to the v1 and v2 readmes. \n. Addressed. Please take a look at the readmes in the v1 and v2 branches and let me know if the preamble statements are clear enough.\n. I have a pretty strong DRY policy. Mostly because I will reliably forget to update redundant information. I realize you are probably picking `q.js` out of the repository and using it as a script, but it\u2019s better to keep the `package.json`, `LICENSE`, and relevant modules together. Package managers generally do this.\n\nHowever, in the 2.0 timeline, we have _generated_ products for script tag and AMD usage, so we could introduce a system to inject version and license information.\n. See #434 \n. IRC, Freenode, `#promises`. Can coordinate a hangout from there if that\u2019s what you mean.\n. My intention is for the v2 release train to be experimental end-to-end, with v3 being the next stable. That would get us out of the must-be-perfect dead-lock so we can iron some of these things out. That I think fulfills the intention of a \"prerelease\", but lets us tinker a bit. It will be good to have these out in `npm` so we can fiddle with downstream implications, particularly for Q-Connection.\n\nWe are on the same page about progress and notify. I have removed them outright and might introduce something to replace its status notification behavior downstream using the same async reactive observer technique as the estimated time to completion feature.\n\nWe are on the same page about `invoke` and `try`. I would be fine with separating the internals for function calling and method invocation again. I did consolidate both behaviors into `post` per @erights and Tyler Close\u2019s implementation but would not mind separating them again.\n\nI am definitely going to introduce `Promise.prototype.call(thisp, ...args)`, `Promise.prototype.apply(thisp, args)`, and `Promise.prototype.bind(thisp, ...args)`, so that a promise for a function is \u201cisomorphic\u201d to a function. My intent is to ignore the troublesome `thisp`. I don\u2019t want to entrain Javascriptiness in the wire protocol, but perhaps such is inevitable. Perhaps we\u2019ll need to convert function calls with a non-global, defined `thisp` into invocations internally.\n\nSo in summary, I am fine with the variadic forms of method invocation and function calling being `invoke` and `call`, with perhaps `fcall` to omit the `thisp`, perhaps. With `try` playing, I could be convinced to eliminate `fcall` and `fapply` entirely from the public interface.\n\nHowever, we still need names for the non-variadic forms of `invoke` and `call`, currently `post` and `apply`. We don\u2019t have a spread operator yet. Perhaps we can eliminate them in the public interface since they're seldom used, but I don\u2019t want variadics in Q-Connection or the lowest levels of the Q implementation. I\u2019ll have to think and fiddle on your feedback for this.\n\nI agree that `post` no longer smells right. I don\u2019t know how firmly @erights and Tyler Close hold to that name. Between you (@domenic) and me, I felt strongly enough about `invoke` to get rid of `send`. I don\u2019t have an alternative name to replace `post`, apart from eliminating the non-variadic form entirely and using the `invoke` as the name on the wire even though the argument pattern doesn\u2019t match.\n\nI could buy `Q.method` with passing `thisp`.\n\nI am inclined to keep `is{Fullfilled,Rejected,Pending}` because they can be implemented to avoid creating a snapshot object.\n\nI\u2019m making `q/node` an implementation detail and exposing the entire Node.js interface regardless of whether you\u2019re using Q in Node.js or not. I believe you sold me on this. However, this is one Q feature I do not intend to push to standardization.\n\nI will either kill or keep passByCopy before v3. Much depends on what works out for Q-Connection v2 experimental.\n\n`then` in terms of `done` is still on the table. My preliminary essays did not work out.\n. Preliminary checklist for a v2.0.0 experimental release:\n- [x] clarify in CHANGES.md that there are no plans to support `progress` and `notify` hereafter. The interface and behavior are broken. Something else may be invented to fill the need for ad-hoc status change notifications.\n- [x] consider refactoring `post` into `invoke` and `call`.\n- [x] consider eliminating `fcall`, `fapply`, and `fbind` in favor of `call`, `apply`, and `bind` with `thisp`\n- [x] consider factoring `call`, `apply`, and `bind` such that they wrap `invoke` instead of `call` if they are given a meaningful `thisp`.\n- [x] consider replacing refactoring the `\"post\"` dispatch operator into `\"invoke\"` and `\"call\"` instead of using the null thisp to distinguish the cases. Note that `\"invoke\"` would replace `\"post\"` for method invocation messages despite that its first operand would be an array of arguments, not spread arguments like the `invoke` method.\n- [x] introduce `Q.method` to replace `Q.fbind`.\n- [x] make sure `nodeify` is in the right place (imlpemented in `node.js`, exposed in `q.js`)\n- leave passByCopy alone for now. MarkM needs it for DrSES, though we might go a different way for Q-Connection with push/pull.\n- implement then in terms of done at some point, but doesn't have to land immediately, assuming it works at all. It is also necessary that it be faster in the end than the current factoring.\n. Merged changes.\n. I rebased. It seems our entire conversation is lost to posterity.\n. As mentioned by @erights, that makes the Q object itself indistinguishable from a thenable. This is somewhat moot since Q is unlikely to be used as the resolution of a promise.\n\nHowever, I do like that the position of when and then mirrors their usage in natural English.\n- Go to the market _then_ buy some eggs.\n- _When_ you go to the market, please buy some eggs.\n. I don\u2019t intend to implement this. Like Bluebird\u2019s `bind(thisp)`, this interface would inevitably leak information and capabilities into parent stack frames or chained promises.\n. ``` js\nQ(null)\n.then(something)\n.then(something)\n.then(function (value) {\n    return doSomeQuery(value)\n    .timeout(2000, \"Query took too long\")\n})\n.done();\n```\n. In this case it is different only because the timer starts when `timeout` is called. Nesting it changes the time.\n. As a thought experiment, consider when the timer would start and when it would stop. These must be different times and a promise must be constructed and fulfilled between them.\n. How is the end of the chain to be communicated back up the chain? Also, promise chains can branch. Which end? If the chain is continued by a third party, does the timeout necessarily apply to all future work that begins with the returned promise?\n\nI hope that I am coming off more as the Plato than the adversary. My belief is that the idea will not work and that nesting nicely delineates where the intended work both begins and ends.\n. Understood. Thanks.\n. @domenic Promise.constructor can wait for `v2`, where promises are actually using constructors. Will need your review to be sure it does what you mean.\n. 1.0.1 published.\n. Seems npm publish hiccoughed. Upgraded npm and published anew. Should be up now.\n. @nillis Thanks for isolating that. We\u2019ll switch to using a dom observer in a future release.\n. `then` creates a new promise _for whatever result is produced by either the fulfillment handler or the rejection handler_. If you want to see an error pass through a `then`, you need to \u201ccatch and release\u201d.\n\n``` js\nreturn service.get()\n.then(function (data) {\n    console.log(\"GOT\", data);\n    return data;\n}, function (error) {\n    console.log(\"ERROR\", error);\n    throw error; // <- do this for the error to continue propagating\n});\n```\n\nThis is directly analogous to `try`, `catch`, and `throw`.\n\n``` js\ntry {\n    var data = service.get();\n} catch (error) {\n    console.log(\"ERROR\", error);\n    throw error;\n}\nconsole.log(\"GOT\", data);\nreturn data;\n```\n. You would get a resolution of `undefined` if you omit the `throw`, since an error handler can recover from a failure by returning the desired result, and if you omit `return` in a JavaScript function, it falls back to implicitly return, specifically return undefined.\n. Thank you for spotting that. We\u2019ll have to use `fcall` or some such.\n. @pornel This could use your review. #499 \n. Thanks @stubbornella \n. I have no idea. It should not in principle since v2 is entirely experimental, ES5 only, and somewhat broken; but if it does and someone can tell me how to prevent that, let me know.\n. @xogeny Thank you for finding this solution. I will leave this open. I\u2019m open to documenting these directions for Bower users, perhaps a link to the Wiki from the README.\n. I\u2019ve noted that you have to use `q#1.0.1` as the version of Q for Bower in the README.\n. Summarily, no. Such a feature would necessitate fibers, which come with plan interference hazards and break JavaScript\u2019s run-to-completion event semantics. Specifically, closures that capture variables in your scope may execute during _any_ function call, no matter how irrelevant that function call\u2019s work is, if it in turn needs to block.\n\nWe of course feel the pressure to make asynchronous code look like synchronous code to give it the appearance of simplicity. But beneath these solutions is merely a leaky half-hidden complexity. For this reason, we are moving toward the use of `Q.async` and generators, which allows us to _explicitly_ yield to the event loop in code that has the same form as synchronous analogues.\n. Not sure how I could have been right since I\u2019m pretty sure I misapprehended the question, but I like your idea for the solution. Alas that event handlers are synchronous. If you need to delay to decide whether to prevent propagation, you would probably need to synchronously stop the propagation and then manually re-dispatch later.\n. This might require more explanation. Usually the first step in a series of functions receives \u201cundefined\u201d as the argument of the first step, for which this example is sufficient. If I were to add this, I would add a new subsequent example and clarify that the \u201cfirstValue\u201d would be the sole argument to the first function.\n. @jimCresswell On reviewing the context, you are definitely not missing something. Merging.\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. Good question. Thank you for asking. We may have to address this question in the README.\n. @aexmachina Can you check which version you have? It should be 1.0.1, not 2.0.x. If it is 2.0.x, can you tell me how you obtained it? There may be a problem.\n\nOtherwise, I do hope / plan to deprecate nfcall in the v2 timeline, which will be an opt-in transition. When that time comes, the preferred usage will be `Q(object).ninvoke(\"method\", \u2026args)` or `var qfunction = Q.denodeify(nodefunction)` followed by `qfunction(\u2026args)` to call.\n. @aexmachina Please run `npm install q@1.0.1 --save` in your project root. You probably installed Q on the one day that 2.0.0 had the \"latest\" tag in npm. This has since been rectified. Q 2.0.0 is not stable, the interface has not been finalized, only works in engines that support ECMAScript 5, and might even be slower that Q 1.\n. Assigning to @domenic, for a boring weekend. I might rediscover and fix the issue when I port Saucelabs infrastructure to Q from Jasminum and ASAP.\n. It would certainly be possible for `done()` to return a singleton rejected \u201cdone\u201d promise. That might help in this particular case, which can be caused by refactoring.\n. Can another reviewer confirm for me that the existing narrative is correct?\n. @granteagon Thank you for taking the time to contribute and sorry that it ends with disappointment. Perhaps next time.\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. Please post questions on Stack Overflow. There is a vibrant community that will be happy to answer this question, typically in less than a day. Use the keywords \"q\", \"promise\", and \"javascript\".\n. I like these ideas.\n. This appears to correspond to APN version 1.4.4, which depends on Q 0.9.x. I am not able to reproduce this problem with Q in isolation. Something in your application or environment must be defining \"delay\" as a read only property of Function.prototype. Please consider attempting to inspect your function prototype to ascertain where the existing \"delay\" property comes from.\n\nIt is not likely that this is an issue with Q itself.\n. No, the current behavior is consistent with the design and `fulfill` does not produce a promise for a promise. Throughout Q, returning a promise or a value from a function causes an eventual resolution for the wrapped value. Async methods must always return a promise, and returning a promise from within an async generator should defer resolution of the async function.\n. You are not the only one passionate about this design difference! Dart\u2019s Futures have this type signature and there was quite a bit of argument about how Promises should behave in ES6. However, recursive unwrapping of promises, and always returning promises, is the only behavior consistent with the design of Q, and we do not have static types like C# and Dart.\n\nThank you for correcting me on the behavior of `fulfill`. This was an experimental undocumented function and will be removed in the next major version.\n\nThe design you wish to achieve would be more similar to Dart\u2019s Futures, could conceivably be thenable, and could have strictly monadic type signatures. There are some wrinkles with this approach, particularly that you have to handle return values from handlers as well as generators differently. You could coerce non-future values and adopt existing futures, or you could mandate that handlers must return futures.\n\nThe merit of the Q promise design is that it is forward-thinking about working with remote objects. I believe the approach of having a \"then\" that only unboxes one level of promise does not play well in this scenario for performance reasons. With recursive unboxing, we can shorten promise chains, and we actually support this enhancement in the v2 branch.\n\nI am sympathetic to your concerns here, but Q is not flexible on this point. I am eager to see alternate implementations that explore the space you describe, as well as implementations that consider cancelable tasks with reference counting. I might take on one of these experiments myself, but outside the purview of Q. Please consider the issue rather thoroughly thought-out.\n. Thank you!\n. This is true, and I had hoped nobody would notice until version 2. Version 2 uses an internal WeakMap, which cannot be tricked, even if you use `Object.create(Q.Promise.prototype)`. It would be sensible to use instanceof in the v1.0 release train.\n. I\u2019ve landed this. This will be published in version 1.0.2.\n. My intent is to back-port recent changes to https://github.com/kriskowal/asap. Thank you for your pull request. We will be adopting its strategy.\n. See #396. In summary, not yet.\n. Thanks.\n. Thanks!\n. I have already make this change in the v2 branch. Will need to back-port.\n. There is a nascent effort to provide an equivalent feature in a library. Perhaps you can give @tatumizer a hand.\n\nhttps://github.com/tatumizer/circuit-js\n. You might have more luck if you frame the problem using an array of functions that return promises instead of an array of promises.\n\n``` js\nfunctions.reduce(Q.when, Q())\n.then(function () {\n    console.log(\"All stages completed\");\n})\n.done();\n```\n. The next interesting pattern is executing each sequential step contingent on the result of the previous. In that case, you would compose your functions wrapping the last with the previous until you wrap the first.\n\n``` js\nvar response = phases.reduceRight(function (nextApp, app) {\n    return function (request) {\n        var response = app(request);\n        if (response.status >= 400 && response.status < 500) {\n            return nextApp(request);\n        } else {\n            return response;\n        }\n    });\n}, function notFound(request) {\n    return {status: 400};\n})(request);\n```\n. As far as I can tell, you either want to wait for all the file checks to be completed, or you want the file checks to be executed in serial.\n\nTo run the file checks in parallel, obtaining a promise for the completion of all checks:\n\n``` js\nQ.all(files.map(function (file) {\n    var filePath = path.join(directoryPath, file);\n    return fileChecker.check(filePath, whatIf);\n}))\n.then(function () {\n    console.log('All done');\n})\n.done();\n```\n\nTo run the checks in serial, with a promise for all of them to complete, one common pattern is:\n\n``` js\nfiles.reduce(function (ready, file) {\n    return ready.then(function () {\n        var filePath = path.join(directoryPath, file);\n        return fileChecker.check(filePath, whatIf);\n    });\n}, Q())\n.then(function () {\n    console.log(\"All done\");\n})\n.done();\n```\n\nPlease consider following up on http://stackoverflow.com/. You\u2019ll get a lot more answers much more quickly than here. This channel should be reserved for problems that might necessitate changes to the library.\n. The sole distinction and in-fact purpose for `done` is that if an error is thrown from a handler, the promise library will not catch it. With `then`, such errors would be caught and be transformed into rejections on the promise that `then` returns. `done` does not return such a promise. My original intent for creating `end()`, which @domenic convinced me to rename `done(fulfilled_opt, rejected_opt)` presumably to cater to the jQuery crowd, was to make it possible for an exception to escape the `try/catch` in `then` and be surfaced as a synchronous error. If you only have `then`, you end up frequently inventing your own often error-prone `.catch(function (error) {console.log(error.stack)}` where you need to surface an unexpected exception.\n\n`Q.reject(new Error(\"foo\"))` creates an asynchronously rejected promise. The error can percolate to a handler. `onerror` is intended for rejections that were not handled as expected, because they made it all the way to the `.done()` at the end of a promise chain. Try `Q.reject(new Error(\"foo\")).done()`.\n. @AZielinski give it a shot. Throw a console.log in Q.reject. In many programs, this will cause much more noise than signal. Alternately, add a hook for when the nextTick queue is completely flushed and log all the rejections that have not been handled (which is pretty straightforward to track in Q.reject and Rejection#then. You\u2019ll still get false positives in some programs, e.g., any time you use a promise queue where the producer side is making rejections faster than the consumer is taking them up.\n\nFirefox just added a feature where, if a rejected promise is garbage collected, it surfaces the error. This is a great heuristic and a hint at the long term solution. There are a couple efforts to add insight about unhandled rejections and pending promises in inspectors.\n. Oh, you\u2019re begging some semantic distinction between errors and rejections. This implies that you would explicitly catch all errors that you would like to be handled as rejections and then manually call `Q.reject(error)` in all those cases, e.g.,\n\n``` js\nFS.read(fileName).then(function (text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return Q.reject(error);\n    }\n})\n```\n\nThis is the style that you have to use with jQuery promises, and in my opinion, largely defeats the benefit to using Q.\n. @AZielinski rejected promises propagate through chains of `then` until they hit `done`, just as exceptions pass through parent stack frames until they hit the bottom. Until we have better debugger support, you just need to remember to either return or `done()` every chain of promises.\n. Please see `denodeify` and `ninvoke`. There are also `nfcall` and `nfapply`, but they have a less certain future.\n. Data on queue support for browsers.\n\nhttps://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\nWe can drop MessageChannel leaving a very small segment of browsers falling back to setTimeout.\n\nExcept, as @stefanpenner points out, WebWorkers.\n. Need to back-port https://github.com/kriskowal/asap/pull/41\n. Replied.\n. The version 2 branch is CommonJS only. We do not have anything set up yet to give you a single JavaScript file with version 2 bundled with its dependencies.\n. I have colleagues who have been using progress and notify to propagate status messages.\n\nQ does need the specific utility of ETC. I don\u2019t think that utility can be tacked on in a library because the composition needs to occur in then, all, &c.\n\nI believe status messages will also require integration with the core.\n\nApproximations of the eventual value are an interesting case. A generic system for signaling may be in order. However, this crosses from the realm of promises to the realm of functional reactive programming.\n\nI will continue thinking about this. For now, if it dispels a sense of urgency, the v2 branch is flagged \"experimental\", subject to radical change, subject to discussion, and not advised as a foundation for any project at this time. The v1 branch will continue to support progress/notify indefinitely.\n. This is because `deferred.makeNodeResolver` has too much magic and not enough knobs. This has been rectified in the v2 release train, where we'll have an opportunity to make a backward incompatible change to makeNodeResolver. It may be possible to introduce the new behavior under a different name, but then there will be a migration to the side, and a migration back, which would be byzantine. I have decided to close this as wontfix, in the context of v1, fixed in v2, since in the v1 timeline, the problem can be worked around by not using denodeify and writing a custom wrapper at small expense.\n. Assigning to @domenic, to investigate at his leisure, if he will.\n. Thanks a bunch!\n. Thanks.\n. Sounds like you\u2019re calling `then` as a free function instead of as a method of the promise.\nThe following code would have the effect you describe:\n\n``` js\nvar then = promise.then;\nthen(fulfilled, reject);\n```\n. @pedroteixeira I will take it under consideration, but there is a limit to the amount of defensiveness that is practical for a JavaScript library to undertake, short of using Caja.\n. Thanks.\n. Hey, @dantman. Please to hear from you again.\n\nThe Q version 1.0 train will continue to be maintained indefinitely, supporting legacy browsers. If anything, I aim to increase compatibility with browsers deeper into the mists of time.\n\nThanks for pointing that out in CHANGES.md. That is not in sync with the current policy and is a relic from before 1.0 was released. That description applies accurately to the v2 branch and \"future\" release train, which I do not recommend anyone use at this time.\n. Fixed verbiage in CHANGES.md in v2 branch.\n. Good point. I have also been hoping to make a dedicated website for Q and related packages with searchable documentation. Stay tuned.\n. I\u2019ve always considered the audience beginners, but have equally always struggled to reach out to them. Perhaps more specifically, the audience of the Q readme has been shifting over the years, from reaching out to like minded people I needed to help support and promote, to skeptics who might already know the alternatives well enough to judge, and that is perhaps as far as we have gotten. The audience is moving and we may be overdue for a another iteration of the introduction.\n. Have you tried Q 1.0.1? Thank you for revealing the issue, but v2 is experimental so you might try the stable version.\n\nThat being said, this is a curious bug indeed!\n. I considered moving the Node specific adapters into a separate module in v2, but this significantly reduces the convenience of using them. Also, Node.js style callbacks do exist client side especially in conjunction with Browserify. And the penalty for having them is not very large. In v2, I\u2019ve scaled back to just supporting `ninvoke`, `nodeify`, `denodeify`, and an improved `makeNodeResolver`.\n\nWhile I would love to see dead code elimination, I\u2019m not sure we can facilitate it in Q, short of a global.Q_NONODE.\n. Duplicate of #328 \n. @Alexsey can you describe how this interferes with your application? The Collections package does shim some methods on Array.\n. I\u2019m bringing in the iterator shim from collections@future for remote streaming. I will need to find a middle road before q@future is prime time.\n\n@alexsey Please note that this is not a problem for the official release of Q, and Q version 2 is not recommended for anything but experimental use.\n. The most viable solution is to remove shimming in Collections and instead expose operator modules. cc @stuk\n. @stuk, In Python at least, the strategy for adding operators to lower level objects and allowing higher level objects to override is to expose an operator like `len(object)` that implements the behavior for lower level objects (checking the length of a builtin like list and set) and then if the type is unknown, delegate to a method if it exists, like `object.__len__()`.\n\nCollections provides `equals`, `compare`, and `iterate` operators.\nThese could conceivably be exposed the Python way instead of as `Object.equals`, `Object.compare`, and `Array.prototype.iterate()`.\nThe usage would become:\n\n``` js\nvar iterate = require(\"collections/iterate\");\niterate(collection);\n```\n\nFor now, the `iterate` operator would still have to delegate to `collection.iterate()` as a named method, but ES-next introduces `Symbol.iterate`. In keeping with that style, operator modules would probably export a `symbol` property on the operator, to allow higher level objects to safely add overrides for any operator module.\n\n``` js\nvar iterate = require(\"collections/iterate\");\nMySet.prototype[iterate.symbol] = function () {\n};\n```\n. Thanks, @Alexsey. I worry about breaking people\u2019s stuff with my moon shot branch.\n. You can use .done() at the end of promise chains to ensure they get surfaced. In the browser, this will log the error and continue. In Node.js, it will log and halt. You can override its behavior by assigning to Q.onerror which will have global effects.\n. Thanks.\n. Spread does implicitly call `all` internally. This is an interesting use case that challenges that decision.\n. Thanks.\n. Yes. Q can be loaded as a script tag, it can be loaded with RequireJS, and it can be loaded with any CommonJS client side module loader, e.g., Browserify, Mr, or Mop. Please stick to using version 1. Version 2 is not fully baked and not fully compatible.\n. Please consider this idiom:\n\n``` js\nQ.delay(minTime).thenResolve(promise)\n```\n. We will need to add it to the qooqbooq when such a thing exists.\n. For version 1, we would need to take into consideration that the require call would be discovered by static analyzers in other environments, which would in turn fail to find the module. I know that Mr can be tricked but not sure about Browserify et al.\n\nFor version 2, does the addon-sdk still support overlays?\n. This is by design. I apologize for being short on time to explain this. In short, `then` returns a new promise for the result of the handler, which may be undefined if you do not return anything explicitly. It does not return the same promise that it received.\n. I will defer to the ES6 Promise spec and fix either the behavior or the comment. Thank you for noticing the subtle difference. I believe that the behavior is correct and this comment is incorrect. Tobie Langel proposed a distinct `any` method that would behave as this comment describes.\n. I am likely to merge this.\n. I will have to come back and answer this question properly. I am sorry that I only have a moment for a terse reply since my wife and I are preparing to move.\n\nA chain of promises does not necessarily have a single, canonical, terminal promise. These chains can branch.\n\n``` js\nvar branchA = promise.then(A);\nvar branchB = promise.then(B);\n```\n\nThere also remains the problem that `last` would only be able to get to the end of a chain as currently written. The last promise in the chain might be pushed back by attaching a promise to the end of an existing chain.\n\nYou might alternately wish to cap _all_ the branches, and while you might mean well by it, this feature would break the Principle of Least Authority and opens the door for distant effect hazards.\n\nIn short, promises might not be the primitive you need to solve the problem you\u2019re considering. This sounds like a situation where an observable would be better suited, since you could throttle render messages.\n. Override Q.onerror. Otherwise, promises by design consume thrown exceptions so that they can be received by their dependencies. This introduces a class of programming errors that are unique to promises, but not avoidable at time of writing. Developer tools will be able to mitigate the disappearance of errors never to be handled and forever pending promises.\n. Thank you. We will not be including this feature.\n. Thanks. I\u2019ll change this to `typeof module === \"object\" && module && typeof module.exports === \"object\")`. We use strict equals for value checks. To be especially paranoid, also checking whether module is truthy since null is a typeof object.\n. Indeed. Thanks for noticing that. Checking for its existence seems good enough to me for now. Let me know if it fails to distinguish some environment where it turns out to be null.\n. @jfrumar As @kahnjw points out, the problem probably lies after the code you have elided. \"promise\" in this case is the result of the last method of the chain. If Q.ninvoke returned undefined, the expected error would be \"could not call method 'then' of undefined\". We have substantial evidence that \"then\" on a promise returns a promise. It is very likely that you need to remove `.done()` from the end of your chain since it is the only promise method that intentionally returns `undefined`. Please let us know.\n. Thanks. Pushed the tag. Sorry that I missed that step.\n. No, there are working implementations of these in Q-IO\u2019s v2 branch. That work in turn inspired the sketches in the https://github.com/kriskowal/gtor repo.\n. In Java (as in JavaScript) you catch and fail to log or rethrow, the error is consumed. That is not a fundamental difference.\n\nHowever, there is a fundamental difference between synchronous exceptions and asynchronous exceptions. The promise _must_ catch the exception so that it can be observed by _zero or more_ consumers in the future. It is possible that nobody will care about the failure, possible for multiple branches of logic to depend upon a promise and observe the failure, and possible for the failure to be cached until someone comes around and depends on the promise eventually.\n\nBecause of all of these scenarios, logging every error at the throw site generates substantial noise. If you have a sufficiently advanced promise graph browser, as you would with a technology like Causeway or Zipkin but which is not yet in devtools for the web, it would be possible to inspect the state of every promise and their causal chains. Barring that, it would be useful to see a snapshot of all of the \"pending\" and \"rejected but not yet handled\" promises at any point in time. Logging every failure at the call site would make it possible to see every error, but manually poring over the logs to determine whether that error has been handled, how many times it has been handled, and whether it will ever be handled, is not a viable debugging technique.\n. This breaks because of a change of order. I presume something is missing from this commit.\n. I have reverted this pull request from master. Please submit another with the complete set of changes if `npm test` passes all tests and the performance increase is verifiable.\n. I don\u2019t think that extensions like makeNodeResolver are viable with the \u201crevealing constructor\u201d strategy, or perhaps if there is agreement that the argument position should be foreverafter slated for a Node.js specific extension (unlikely). I recommend continuing to use `Q.defer()` for this case.\n. This seems reasonable to me.\n. Pull requests with tests welcome.\n. @pwmckenna Lazy binding everything might slow the library down. I would like visibility into that. Lazy binding Q itself would not be necessary if Q went back to delegating to Q.resolve, but again, that might slow the library down. In alternative approach would be to look into the tickets regarding instrumentation for a debugger. There\u2019s a PR that introduces a way to trap creation of pending promises, settling of pending promises, creation of rejected promises, and handling of rejected promises.\n. Publishing now.\n. Existing code depends on the ability to pass a function with optional or variadic arguments to promise.finally, e.g., promise.finally(stream.close) and promise.finally(server.close). Passing an argument would interfere with these cases, in the same way that array.forEach(console.log) displays the index and array on the same line. Early versions of finally experimented with passing the error or value but I found this to be less useful that the ability to pass variadic functions. It is possible to check the state of a promise within the finally block, e.g., promise.finally(() => promise.inspect()).\n. Having `always` and `finally` side by side would do more to confuse than illuminate. I\u2019m of the opinion that Q gives you all the tools you need as-is and that this sugar would not improve enough people\u2019s lives to pay for itself.\n. This is good. Thanks. I will try to find some time to review, land, publish this weekend or maybe an evening this week.\n. I am curious what about this workflow prevents using Q. Is is there a step that injects a 'use strict' directive? I would entertain this change if it were altered such that it did not preclude using Q as a script in other environments that do not provide 'window'.\n. I am going to land this because, even though there are conceivably environments that this change breaks, this case is likely more important for now. I will follow up by adding 'use strict'; to this block.\n. Good catch!\n. Q will not support this feature. This feature is not possible to implement in browsers. It is possible to implement in Node.js with a binary add-on but is antithetical to the concept of run-to-completion no-shared-memory event loop programming.\n\nBlocking on asynchronous work, regardless of whether you are using promises, will eventually cause the same problems as threads, that is, unexpected interleaving or \"plan interference\". With fibers in particular, it is possible for an asynchronous callback to fire asynchronously any time you call a function that eventually yields, and any function call is a candidate.\n\nThis is the Pandora\u2019s box that must remain closed.\n. `Q.when(promise1, promise2)` is not a feature of Q. You may be confusing it with jQuery\u2019s Bizarro World promises. `Q.when(x, f)` is in fact exactly and only equivalent to `Q(x).then(f)`, which is to say the value is auto-wrapped in a promise if it is not already a promise, and then we wait for it to be fulfilled. `Q.when` is useful in conjunction with `reduce` to do things that are similar but not the same as `Q.all`. The latter is able to abort faster if any promise rejects.\n. I am amenable to adding this feature. Feel free to send a pull request to v1 or v2 or both.\n. Thank you. This is good. I made some time to garden my open source projects this weekend but did not get to this. This is in the queue.\n. @hankduan There is no global list of promises. When you resolve a deferred, the corresponding promise will notify all of its subscribers as soon as possible by adding tasks to the micro event queue. Until a promise is resolved, it has no presence or relationship to the event queue. As such, a process may exit even if a promise remains pending. You can attempt to trap this event with `process.on('exit', function (code) {deferred.reject(new Error(blah))});` but at the end of the day, whatever entity is responsible for resolving the promise needs to keep the process alive (e.g., by holding a timer open, holding an open connection, holding a listening server).\n. Wrong base.\n. Q docs are overdue for a review. I\u2019ll provide a short answer here, and perhaps someone can give me a hand with the documentation itself.\n\nQ already exports Q.Promise, which supports the Promise constructor interface (see the change log for a version). I do not have plans as yet to monkey patch the global Promise constructor with Q in any future version, though optional subclassing might be feasible. Q will always support Q-Connection, by whatever means possible, which may imply using a special kind of promise for remote message passing, and the normal promise for local synchronization.\n\nAnd we do need to draw out the migration paths for each of these methods. Q version 2 has a somewhat streamlined interface.\n\nAnd, for my ambitions for promises in general that go beyond the scope of Q, see https://github.com/kriskowal/gtor\n. I think `promisehelpers` is a better home for this utility.\n. (But this is one of the better pull requests I\u2019ve seen. I recommend filing an issue to gauge interest in the future. Feels bad to say no when someone goes this far)\n. @timjacobi Propose the syntax you would like to see. In the Q version 2 ecosystem, Q-IO provides a stream reader that has concurrency limiting.\n\n``` js\nreturn Reader(asyncIterable)\n.map(function (value, index) {\n    // ...\n}, null, 1) // 1 limits concurrent jobs to 1\n.all()\n.then(function (array) {\n})\n```\n. @timjacobi I do not intend to incorporate this feature in Q. Q-IO provides this facility and if that is not satisfying, I recommend creating a library and adding it to our list https://github.com/kriskowal/q/wiki/Libraries\n. For long indefinite sequences of values, arrays and Q.all are the wrong\ntool. You have to upgrade to streams. Q-IO (v2) provides a readable stream\nthat implements asynchronous forEach(), reduce(), all(), etc, with optional\nconcurrency limits, which beyond 1 concurrent operation, relax the ordering\nconstraint of the stream.\n\nStreams are asynchronous iterators. I talk about this in an essay I wrote a\nyear ago, GToR github.com/kriskowal/gtor\n\nRough implementations exist for stream in the GToR repository and Q-IO v2\nhttps://github.com/kriskowal/q-io/tree/v2\n\nThese are somewhat on the frontier, so bring a willingness to fix bugs and\ncontribute upstream or fork. This is an area where there\u2019s opportunity to\nleave a mark.\n\nOn Thu, Jan 14, 2016 at 2:34 PM, Doug Molineux notifications@github.com\nwrote:\n\n> Jamming a large array of promises into Q.all() isn't scalable (especially\n> when you can't really tell how large it could grow). As a consequence we've\n> been forced to not use it anywhere where we are unsure of the size of the\n> array. In my opinion, A Q.sequenceAll would be an ideal and cleaner way\n> to fix this, rather than using a custom reduce method.\n> \n> It is reasonable to assume that many small implementations of this method\n> will probably not run into this issue, but as soon as we deployed our code\n> to a production environment we ran into this issue in many places.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/606#issuecomment-171803484.\n. Verified.\n. This has been fixed in v1.1.1. Please verify and close.\n. queue.js is included intentionally. I am amenable to shifting over to the \"files\" approach.\n. Thank you.\n. How do you propose we resolve this issue?\n. The part that doesn\u2019t fly for ES6 migration is iterable[Symbol.iterator], unless we can get symbols to implement the map interface before and after such that `Symbol.iterator.get(iterable)` would work before and after, with a Symbol shim.\n. @domenic That would be acceptable.\n. If you\u2019re on the Q/Q-IO version 2 _experimental_ branch, you can do the following for the same effect. 1 is the concurrency limit. `data` may be an array, an object that implements `iterate`, an iterator that implements `next`, a promise for any of the above, or even a remote promise for any of the above via Q-Connection. For higher concurrency values, order is not necessarily preserved.\n\n``` js\nvar Reader = require(\"q-io/reader\");\nvar runOnAll = new Reader(data).map(func, null, 1).all();\n```\n. @slawo Thanks for isolating the issue. Please take up this case at https://github.com/kriskowal/q-io/issues. We have a different set of maintainers at that repository. If you can drum up a failing test case and send me a PR on Q-IO, I would be especially appreciative.\n. @domenic. I agree. It seems that it is time to drop support for old Firefox. Unfortunately, this is a major version change since there are people using Q in Firefox extensions and probably depending on this feature. Yet those things might be upgraded, it's still a major change. Support for old FF has already been removed in the published versions of the v2 branch, so problem solved there.\n. It is very likely that I will need to do weird feature detection per iterator instance to make the heterogenous case work (where both styles are available and either might be used, or possibly even mixed). There are differences in the prototypes, but I will have to do some serious research to capture exactly and only old Firefox iterators without interfering with any other kind of iterator, including duck-iterators (which I will assume to be new-style to avoid going mad).\n. Use the latest, version 1 supports AMD still. Version 2 will eventually.\n. By latest, I mean what npm installs by default. Version 2 is published to npm but is still experimental so not default. There is remaining work to be done in the publishing process to generate the AMD and script tag build products.\n. It\u2019s very likely that you\u2019re not receiving the notification because the observer is not yet attached.\r\n\r\nThis is among the reasons that I replaced notifications with composable progress observers in v2. You get a notification immediately upon observation, with the last known value. Notifications don\u2019t have a specific domain or merge semantics.. This problem should be solved in libraries. In Q-IO, I\u2019m introducing an asynchronous iterator or stream reader. Such readers implement map, filter, forEach, all, &c and accept a concurrency limit argument beyond the standard Array method arguments, e.g., `new Reader([async?][iterable?]source).map(fn, thisp, concurrency)`.\n. @ramakrishnan That is available in Q-IO, but not in Q proper, but only in the experimental v2 releases. I\u2019ve run up against the ceiling of how much time I have to maintain further packages, so anyone willing to pare that out and own it, or backport it to Q-IO v1 and join the contributors/publishers for that package, would be welcome. Anyone willing to provide assistance in bringing v2 out of experimental phase should follow me on twitter and try to join me for open source office hours, which I usually hold every other Sunday at 14:00 PST.\n. @piglovesyou The thin wrapper for node/reader just pumps data into a buffer. The stream uses two promise queues internally, one of which provides promises for the write side, and the other provides promises for the read side. The buffer's size is the number of pre-solved promises in the queue to the writer. The `map`, `forEach`, `reduce` etc methods all accept a third argument which is the concurrency limit. This gets passed into the buffer constructor. I wish I had more time to help. I wrote about the general idea [here](https://github.com/kriskowal/gtor), which may help. The code is a bit of a mess and has at least one known bug. Please follow-up in the Q-IO issue tracker to keep Q notifications relevant for its contributors.\n. You are not alone in these thoughts. Much of the conversation about promises involves these issues.\n\nAs for `.done()`, Q is a dialog with the Promise spec, not an adherent. Q influenced the evolution of the spec and the evolution of the spec influences Q. `.done()` may or may not become vestigial as developer tools improve.\n\nAcross the board, developer tools are exposing a promise inspector which shows unhandled rejections. The thing about an unhandled rejection that makes them unsuitable for plain old logging is that they can be eventually handled. Also, since a promise can be observed by anyone at any time, a handler can be introduced asynchronously. This is anticipated by the design.\n\nDistinguishing operational errors from programmer errors is also a common topic. One could theoretically allow programmer errors to pass through and halt a program. This may or may not be desirable in production, mostly depending on whether a service is stateless, whether you manage your side-effects carefully, whether you can restart quickly, whether your availability matters more than your consistency, &c. So there is no one-size-fits-all for that. Using Q.reject to distinguish asynchronous operational errors from synchronous programmer errors is smart. Similarly, one could require Q.resolve for asynchronous resolution. At that point you have taken on all the burdens necessary to get rid of the recursive unwrapping feature of promises, then becomes equivalent to flatMap in the Monad world. But that\u2019s a different library with a backward incompatible change to its semantics. I won\u2019t even contemplate that for v2. That is not to say it is a bad idea.\n\nThe other issue is that promise chains branch and merge, as above. Ideally your whole program can be modeled as a single asynchronous function call with one way in and one way out, in which you would only ever call .done() once. That is admittedly difficult. Also, handling one branch of a promise chain does not necessarily mean that the root cause of an exception has also been handled by another branch of the promise chain. So, `a.then(b).done()` does not mean that `a.then(c).done()` should omit its `done()` clause, even though a rejected A promise would get reported twice.\n\nIn any case, I thank you for your thoughts. I am closing this issue for the purpose of triaging actionable issues. Continued discussion is welcome.\n. Please review #690\n. Please review #690. The intent is to retain support for windowless JavaScript contexts.\n. We have no interest in maintaining duplicate information for multiple package managers. If you can get what you need by adding information to package.json instead of replicating package.json, we would be amenable.\n. It\u2019s been an age since you submitted this and I\u2019m sorry for losing track of it. I have not triaged Q as often as I ought.\n\nI don\u2019t have a compelling reason to evade adding these checks. If you don\u2019t have time to work on this, I\u2019ll eventually address my feedback and land it myself.\n. Correct. v1 is master. v2 is unstable master.\n. Version 2 of Q has experimental support for passing a thisp as an argument to then. I do not intend to implement bind() because it leaks information downstream. This introduces a security hazard to the interface which, while perhaps unimportant to many users, it is important to discourage its use so that code written for promises remains portable to environments where safety is a concern.\n. My apologies for not responding. My notifications have been going to spam for a while and I\u2019ve just noticed.\n. Replied on link\u00e8d PR.\n. Thank you.\n. Keeping q.min.js in sync was more pain than it\u2019s worth. I recognize that this would be convenient, but it encourages an anti-pattern. You should be bundling and minifying the bundles. If you don\u2019t need to bundle, you almost certainly don\u2019t need to minify.\n. And thank you. I appreciate the feedback and if it turns out you\u2019re one of many, I always take a ticket as a sign.\n. @jcalfee There is a Q.onerror that you can use as a catch-all for unhandled errors once they hit a terminal .done(). I am amenable to @benjamingr\u2019s idea, especially in so far as it would be the beginning of debugger hooks.\n. I have completed a review locally and am good to merge this. Would be great to get :+1: from @domenic. Would be even better if you would follow up with a regression test to ensure that future work does not break this new feature.\n. Sorry for the delay. I have merged and published this as in v1.3.0. If you decide to follow-up with browser support for this feature with window events, or if you follow up with pending and settled events, take a moment to examine the prevailing style for white space in control flow blocks.\n. There are releases of v2 published to npm. Use npm install q@2 to get the latest release of the v2 branch. Also, expect breaking changes on patch releases. v2 is far from final. The same applies to many v2 branches of various projects I contribute to.\n. Thank you for the ideas. I will think about it.\n\nHowever, perhaps you should wait for the smoke to clear. I intend to announce a v2 release from which semver will be reinstated when it would be appropriate to start migrating dependees. The state of Q at present is so very experimental that you are likely to thrash needlessly on interface changes.\n. Do these environments also provide a bad process.nextTick?\n. Come back and re-open this if process.nextTick is bad on these fake Node environments. The isNode test just means that Q will use process.nextTick and check whether process.domain exists when necessary. It should not have any harmful side effects.\n. This has been addressed by @kahnjw in v1.2.1. Thanks for the tips.\n. For what it\u2019s worth, this shows most of the of effort necessary to add a feature to Q in terms of code, documentation, and tests. However, this is very similar to the existing Q.race, and combined with Q.allSettled, provides the same capabilities. I\u2019m inclined not to add this method to the interface. In the next major version, I am rather looking to reduce rather than grow Q.\n. The following pattern seems fitting.\n\n``` js\nreturn Q.race(promises)\n.then(function onFulfilled(first) {\n    // ...\n}, function onRejected(firstError) {\n    return Q.allSettled(promises)\n    .then(function (resolutions) {\n        // ...\n    });\n});\n```\n. Is this what you are describing? https://esdiscuss.org/topic/promise-any\n. I would accept a PR for the `any` as described by @tobie. It is the sensible dual to `all` and distinct from `race`. This is not quite ready and I will note where.\n. See #374 #328 #159\n. Per prior discussion, I do not intend to bring this feature to Q. Please consider using q-deep or publish a small module.\n. This looks good. Thank you for your time! If you do not have any further, I will carry this over the finish line next weekend.\n. @vergara Note the countDown variable in Q.all (which should be used to mirror style), that it gets incremented for each promise that array_reduce visits, then decremented for each promise that settles.\n. Note to self: update README and, when it lands, API reference.\n. Thanks. Coming soon to a minor release near you.\n. I am pretty sure I have seen a package that provides this feature. I don\u2019t intend to bring this feature into Q proper.\n. Sch\u00f6n dank.\n. Any assistance would be helpful.\n. I\u2019d accept a pull to throw if arguments.length !== 1. I would not create an ambiguous overload.\n. @dtheodor I believe what you are looking for is a Signal. I wrote up a long essay about finding the right tool for the job which might be insightful. https://github.com/kriskowal/gtor\n\n@havvy Thanks for your feedback. I find that people feel more welcome if you open by explaining how you understand their motivation.\n. Thanks for the discussion.\n. I am pushing way back on adding new features since feature creep has already gone too far. However, this is not a bad idea. Not because it is convenient, but because it conveys more information for the purpose of estimating time to completion. With the desugared version you illustrate, the resulting promise would not have a good way to infer time to fulfillment, but with `a.after(b)`, the ETF is clearly `max([a.etf, b.etf])`, just like `Q.all([a, b])`. As such, it might be good to implement `after` in terms of `all` in v2.\n\nI\u2019m on the fence, but these are my thoughts.\n. I try to keep concerns separate. I\u2019m sympathetic to the case for convenience, but this comes at a high cost in clarity. There is `Q.promised(f)` (among other things) for the one case, and `Q.async(g)` for the other.\n. Callback hell can be mitigated with or without promises. The first step you should consider is to flatten out our chain with small named functions that forward the state that needs to be captured by future / inner callbacks explicitly, and discarding things in scope that do not need to be carried forward. It may be helpful to create a state object that can capture these values and pass them forward. An affordance of promises is that these small functions can simply be chained with `then`.\n\n``` js\nvar fs = require(\"q-io/fs\");\nreturn fs.makeDirectory(filebox)\n.then(function () {\n    return fs.writeFile(file1, content1);\n}).then(function () {\n    return fs.writeFile(file2, content2);\n}).then(function () {\n    return fs.writeFile(file3, content3);\n}).done();\n```\n. With generators, this is only slightly different.\n\n``` js\nvar fs = require(\"q-io/fs\");\nQ.async(function *() {\n    yield fs.makeDirectory(filebox);\n    yield fs.writeFile(file1, content1);\n    yield fs.writeFile(file2, content2);\n    yield fs.writeFile(file3, content3);\n})().done();\n```\n\nAnd note that writing those files is probably parallelizable.\n\n``` js\nreturn fs.makeDirectory(filebox)\n.then(function () {\n    return Q.all([\n        fs.write(file1, content1),\n        fs.write(file2, content2),\n        fs.write(file3, content3)\n    ]);\n}).done();\n```\n\nAnd note that while parallelism is great, it can explode if you overwork a program, so if you've got enough files and you want to limit active parallelism, you might want to use a job queue of some sort. This is a feature of q-io@2, experimental.\n\n``` js\nnew Reader(files)\n.forEach(function (file) {\n    return fs.makeTree(fs.directory(file.path))\n    .then(function () {\n        return fs.write(file.path, file.content);\n    })\n}, this, 50).done();\n```\n. You are likely to receive a more timely response on stack overflow. You are welcome to keep this open as long as needful in the chance that someone drops by and has a moment, but please close this when you find an answer.\n. There\u2019s a bunch of writing on this topic, but in summary, a promise represents the return value or thrown error from a function call, either from the past or future. Since functions only return one value, you have to box and unbox multi-values as demonstrated above. Other designs run into strange complications.\n\nI hope that the work-around above settles well with you.\n. I hope that @bpq\u2019s summary is satisfying. From our README, always either .done() or return a promise.\n. This has been addressed in the v2 branch. This is a backward-incompatible change, so it can arrive no sooner than version 2, which is and will always be an opt-in upgrade. Version 2 also remains unstable until we have settled on what set of breaking changes we would like to make final.\n\nMy time lingering over the v2 trigger may have to come to an end soon.\n. True. Technically the \"last registered before the resolution\".\n. I would very much like to find some time, or assistance, to automate the process of building compatibility tables. I did this in ASAP https://github.com/kriskowal/asap\n. We have no intention of maintaining two separate but nearly identical package description formats by hand. I would accept a pull request that introduces functionality that replaces, augments, or subverts `npm version` and `npm publish` and correctly produce build artifacts for both Bower and npm from the existing source files without cluttering the working copy.\n. Thanks. I\u2019ll make sure the changes are pushed tonight.\n. pushed\n\nOn Tue, Apr 7, 2015 at 4:22 PM, TJ Rothwell notifications@github.com\nwrote:\n\n> Issue\n> - Changes has 1.2.0: CHANGES.md\n>   https://github.com/kriskowal/q/blob/v1/CHANGES.md\n> \n> Expected\n> - Releases should have a listing for v1.2.0 /releases\n>   https://github.com/kriskowal/q/releases\n> \n> Actual\n> - Releases _doesn't_ show v1.2.0 /releases\n>   https://github.com/kriskowal/q/releases\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/674.\n. This is expected behavior. Each call to .then creates a new promise for the return value or thrown exception of the rejected or fulfilled callback. Since you return undefined in both cases for the handlers of the first promise, the second promise is fulfilled with undefined.\n. Addendum: If you wish the exception to propagate to the second handler, rethrow.\n\n``` javascript\nvar q = require('q');\nvar fs = require('fs');\n\nfunction ReadMyFiles() {\n    return q.all([\n        q.nfcall(fs.readFile,'file1.txt','utf8'),\n        q.nfcall(fs.readFile,'fileee2.txt', 'utf8')  // fileee2.txt doesn't exist\n    ])\n}\n\nReadMyFiles()\n.then(\n    function(data) {\n        console.log('All files read!');\n    },\n    function(reason) {\n        console.log('Some file could not be read. Reason: ');\n        console.log(reason);\n                throw reason; // XXXXXXX\n    }\n)\n.then(\n    function(data) {\n        console.log('Fulfilled!');\n    },\n    function(reason){\n        console.log('Rejected');\n    }\n)\n```\n. 2.2.6 refers to parallel, not series, usage of `then`. Consider:\n\n``` js\nvar files = ReadMyFiles()\n\nfiles.then(\n    function(data) {\n        console.log('All files read!');\n    },\n    function(reason) {\n        console.log('Some file could not be read. Reason: ');\n        console.log(reason);\n    }\n)\n\nfiles.then(\n    function(data) {\n        console.log('Fulfilled!');\n    },\n    function(reason){\n        console.log('Rejected');\n    }\n)\n```\n. Unhelpful docs are a bug. Please let us know what we can do to make the Q README clearer. This is the relevant section:\n\nhttps://github.com/kriskowal/q#propagation\n. I would entertain a PR for this feature in the v1 branch, but feel this feature is highly antiquated in a world with module systems.\n. yes\n. This looks good to me. I will land and release this by end of weekend and hopefully sooner.\n. This is released in v1.2.1. Thanks for looking into this.\n. ``` js\nprocess.nextTick(function (error) {\n    throw error;\n})\n```\n\nHowever, that is what `done()` effectively does.\n\nSome folks have wondered whether it would be possible to automatically distinguish operational errors from programmer errors, throwing the latter and rejecting the former. Distinguishing errors is beyond the scope of Q, but it certainly is possible to:\n\n``` js\n.catch(function (error) {\n    if (!isOperational(error) {\n        process.nextTick(function () {\n            throw error;\n        });\n    }\n    throw error;\n})\n```\n. This seems reasonable and I would land this unless @domenic has strong opinions to the contrary. Bother me if I take no action between now and mid May. I do my open source gardening on weekends.\n. This is a great library. I am perfectly content for it to remain external to core. Please feel free to advertise it here https://github.com/kriskowal/q/wiki/Libraries\n. Deliberate, yes. Correct, no. Revised.\n. I\u2019m not sure how you ended up with `q@2`. `q@1.4.0` is latest in npm and you have to explicitly opt-in for version 2. There is some chance that version 2 got trapped in your package.json or shirnkwrap. Otherwise, I am unable to reproduce the problem locally.\n. Thanks!\n. Landed for v1 and I\u2019ve got a fix for v2 in my working copy. Closing this to get it out of the inbox.\n. `Q.all` does not have the ability to limit concurrency. It receives an array of input promises for work that has already started. Q-IO v2 provides a `Reader` that implements `map` with a concurrency limit that you adjust parametrically.\n\n``` js\nnew Reader(iterable)\n.map(function (value) {\n    // return promise\n}, null, config.development ? 1 : 100)\n.all()\n```\n. Reproduced locally. Investigating.\n. Missing `var`. The second call overwrites the global `defer` so the first timeout never resolves.\n. \"use strict\";\n. Thanks, but this is fine as written in my opinion.\n. Yes. then() returns a promise for the value returned, excpetion thrown, or promise resolved by onFulfilled or onRejected. Chaining is different than branching.\n. Deep in the annals of Q, you will find that this backward-incompatible change reverts a backward incompatible change that was made between 0.8 and 0.9. I decided that it would be suboptimal for Q-Connection to be hauling the serialized return value of these methods across the wire. @domenic also expressed distaste for chaining style methods, and I concur.\n\nWith the respect due for a proposal to make Q work the way I originally wrote it, this will not land in the v1 branch (because it is backward-incompatible) and probably won\u2019t land in the v2 branch (because it would lead to waste on the wire).\n. @benjamingr That would not work. The .set() method sends a message, which will arrive before the \"ignore\" message.\n. You will get a much faster response on stack overflow.\n. I have not had a moment to spare.\n\nPlease clarify what engine (Node.js?) you are using so we can dismiss the possibility that you are using actual threads. I presume you\u2019re using \"thread\" figuratively. If you are using \"thread\" literally, all bets are off.\n\nNote that you can do `deferred.resolve(this.doSomethingElse())` instead of hooking up the resolve/reject through then.\n\nThis might be something simple to isolate with a test case. I\u2019m ready to believe that progress listener code is undertested. It has been eliminated in v2.\n. Yes, we should fix this.\n. A PR is welcome.\n. Worth looking into. v2 has weak maps to assist with this kind of problem, but I\u2019ve been using them less and less because of the performance overhead.\n. Thanks. Sorry for the instability. I recently published a version of Collections that does not support shims. Q needs an update.\n. Oh, problem is that you\u2019ve pinned to the 2.0.0 exact version. This problem does not exist in version 2.0.3 since the collections dependency has been removed.\n. It\u2019s fair to say at this point that Q@^1 is Q forever. A version 2 has turned out to not be practical.. check your version of Q. latest patch of 2 does not depend on collections.\n. I advocate direct use of the reduce/Q.when/Q idiom. It\u2019s in the README https://github.com/kriskowal/q#sequences\n. In the future, please address this kind of question to Stack Overflow. There is a very active community that can help diagnose these issues quickly.\n\nThe problem in this case is because each iteration of the for loop is overwriting the deferred variable, so deferred.resolve in a future turn of the event loop is only being called on the last iteration. The other promises remain pending forever. The problem can be solved by capturing the deferred in a closure for each iteration, or simply capturing the result of `rp` and adding it to the array, since the deferred is superfluous in this case.\n. Change last line to have `.done()` on the end, which will cause exceptions to surface. There is a reference error in your console.log(e) expression. There is also a missing return in your test.\n. The name Q came from a proposal to TC39 by Mark Miller (@erights) which in turn came from a library by Tyler Close in Waterken with similar shape and purpose. I have the impression that it is short for \u201cevent queue\u201d since promises manage events, and the brevity is deliberate, to encourage folks to wrap promises they receive from others with `Q(promise).then...` instead of trusting `promise.then...` directly. Not all promises are made alike, but most can be tamed by virtue of thenability.\n. @erights That has not aged well. The main points about the limitations of using closures as objects to placate ADSafe became unnecessary in the world of ES5 and SES, so I altered the interface accordingly. The rest has varied in the details. Q no longer does valueOf. The treatment on variadic arguments varies by version as well. Version 2 eschews variadic arguments entirely for the internal handlers, grasping for performance.\n. I have a big request, if you can pull it off. A snapshot of a sample of stacks would be very useful to us, and a very powerful tool for you to use to debug similar issues going forward. What operating system are you using? If you are running on Linux, you could try SystemTap with [node-stap](https://github.com/uber/node-stap) to capture a flame graph. There are similar tools for other operating systems.\n. @nknapp We did intentionally omit synchronous state queries from Q for a long while and left them only for perf optimizations and debugging reasons. We do intentionally call handlers asynchronously, regardless of the state of the promise. If you need an order guarantee, `then` is there to ensure it.\n\nWe don\u2019t intentionally return false for this specific case, but it is an emergent behavior. Creating a special case would probably not be worthwhile, but I would certainly consider a change if it is simple.\n. That is certainly an option. You could also use [ASAP](https://github.com/kriskowal/asap) instead of setTimeout. You could also monkey patch that into `Promise.prototype.done`. Alternately, you could put your faith in the Chrome developer tools, which may even be automatically surfacing unhandled errors when promises get garbage collected.\n. The Q project does not directly support Bower. Anyone who is providing support for Q in Bower, please let these folks know where they can go to get this issue addressed.\n. This is more or less expected since Q v1 was designed to prove the API for promises, makes extensive use of closures internally for a semblance of clarity, and provides a layer of abstraction for remote objects that no other promise library to my knowledge yet does.\n\nI have taken some steps in the Q v2 release train to address some of these performance issues. I would love to see figures for that release train.\n. The v2 branch or npm i q@2 will get it for you.\n. Thanks for bringing up the issue. Much depends on whether this benchmark is indicative of real usage, but regardless I would love to see these metrics improve.\n\n\u201cpseudo recursion\u201d (event queuing) is handled by the ASAP library in v2. It may need some attention. There is a possibility that other implementations trade caution for speed and may be right to do so. There may also be \u201ctail queue\u201d optimization opportunities. There certainly are opportunities to simplify and improve developer experience on ASAP.\n. ASAP was factored out of Q in v2. Had hoped all those promise implementations would rally around our common ground and contribute. We might have to go and back port their observations.\n. Thanks, would gladly accept further changes of this kind. Consider using !callback for brevity and catching other invalid values, or typeof callback !== 'function' to catching an even broader set of invalid values.\n. Oh, please run the tests. Build broke due to a lint error I didn\u2019t notice.\n. Also, feel free to forward-port this kind of change to the v2 branch.\n. TravisCI also does npm run lint. I should probably just add that to npm test\u2019s suite.\n. Fixed lint errors on v1 and added lint to tests (and npm ls check).\n. Pull request for overridable Q.emit welcome.\n. Compatibility with domains is begrudgingly in-scope for Q. PR\u2019s to address issues with domains (with tests!) are welcome.\n. 2.x is pre-release. We do not maintain Bower\u2019s packages. Not sure who does.\n\nOn Thu, Nov 5, 2015 at 1:01 AM, ThomasCrvsr notifications@github.com\nwrote:\n\n> The last published version of Q on NPM is 1.4.1. When you install it with\n> Bower, the version is 2.x. I just wonder if v2 is stable or is this a\n> pre-release ? In the case of a pre-release, it might be relevant to tag it\n> as pre-release no ?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/742.\n. I should have used pre-release semver tags for the 2.0.0 train. Unfortunately, tags are not a mistake that can be unmade. Also, when the 2.x train is officially released, I don\u2019t intend for it to replace the 1.x train as \"latest\" for a long time, possibly never, because there is a general expectation that `npm install q` will give you the version everyone is using, whereas `npm install q@2` opts in for the 2.x version ecosystem.\n. PR welcome on v1 branch. I went a different way in the v2 branch. I am also not picky about Jasmine. I\u2019ve been using TAP for my recent work.\n. terminate your promise chain with `.done()`.\n. Yes, this was a regrettable decision, trying to avoid a usually-unnecessary array allocation. Unfortunately, to fix this requires a backward-incompatible release. As such, the behavior has been altered in the v2 branch. Of course, this is far from the only backward-compatibility break in the experimental version.\n\nhttps://github.com/kriskowal/q/blob/v2/q.js#L304\n. Good catch!\n. Thank you for your suggestion, @ykosbie. In the v2 branch, in an effort to simplify and minimize the common payload for Q, I have been deprecating and removing features, in favor of having these in supplementary libraries when possible. These are neat utilities which I recommend you publish in another package. You\u2019re welcome to add a reference to it in related libraries on the Wiki.\n. The commit hook might be amiss. I forced a recompile with the manual hook http://documentup.com/kriskowal/q/__recompile and it looks fine to me.\n. First glance, this looks like a legitimate improvement to me. cc @domenic for sanity check.\n\nPlease consider making some concessions for the prevailing style. Spaces around operators, fully-spelled variable names (array over arry, length over len).\n. I\u2019m compelled to leave the library as it stands. Undesirable as the behavior is in some cases, it is less surprising in the majority. Explicitly filling missing arguments at the call site seems safer than implicitly filling them in the library.\n\nRegardless, thank you for contributing.\n. Which version of Q and which version of which browser?\n. Thanks. Please consider using the stable version of Q (1.4.1).\n. Pull request welcome. Please isolate what makes the environment dissimilar from the ones Q already recognizes.\n. I propose that the feature should be enabled by the act of setting up an unhandled rejection handler, and otherwise disabled. PRs are welcome.\n. Window is not an available free variable in all environments.\n\nI am hoping that perhaps instead of a change like this, we could expose Q.ondefer, Q.onresolve, Q.onfulfill, Q.onreject, etc hooks for arbitrary promise inspector plugins. Maybe also simplify the existing code for tracing in Node.js, perhaps replacing the onUnhandledRejection error, or at least providing a better underlying mechanism for hooking it up.\n. Thank you!\n. Might be useful to share versions of Node.js and perhaps any modules that might be monkey-patching nextTick. Maybe do a search for occurrences of runAfter. There are no direct references to nextTick.runAfter in Q.\n. Pardon, I was on the wrong branch. Q does in fact have a nextTick.runAfter now.\n. Would anyone be able to Q.nextTick.toString() and manually verify that nextTick.runAfter is missing? Sounds like something is monkey-patching Q.\n. Thanks @mdressman. Let\u2019s keep this issue open to track how Q can be more resilient against this kind of monkey-patching. nextTick should close over its runAfter dependency instead of exposing it as public API.\n. Perhaps we can move it to a top level hook.\nOn Tue, Feb 23, 2016 at 12:56 AM Benjamin Gruenbaum <\nnotifications@github.com> wrote:\n\n> The rationale was to let people change the scheduler kind of like\n> bluebird's setScheduler. I don't think we should explicitly hide it.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/764#issuecomment-187606563.\n. :ok:\n. I recommend publishing this tool as a separate package. I am striving to make Q smaller.\n. This change will need to be cast in a way that does not break backward-compatibility, by preserving existing properties.. For context, I thought hard about this API and removed it entirely in the v2 branch in favor of an \"estimated time to completion\" observer, which has much more sensible composition semantics through \"any\" (min) and \"all\" (max). So what I want in the v1 branch isn\u2019t particularly relevant, but the semver contract with our users is that no minor or patch release will break existing usage.\r\n\r\nSo, whatever you change here has to be additive, not subtractive.. \u2026and the best way to guarantee it is additive is to add tests, no updates or removals.. result.reason should be an Error instance. as with throw, the language permits you to throw other things, but in practice, they should always be Error instances. This problem must be solved in the provider of somePromise or someOtherPromise.\n. This is behaving as designed. The timeout method (as with any other Q method) does not alter the state of the wrapped promise, which would constitute a plan interference hazard. Only the resolver has the power to reject the promise and the timeout method has no access to that capability. If you wish to be informed of the timeout, you must capture the timeout promise instead of the wrapped promise. This can be done by bringing the timeout into the loop around the work per iteration that must be accomplished in a timely fashion for the loop to continue.\n. Yeah, published v1.5.0 a couple hours ago.. So it is done. `master` is the primary branch.. A PR would be welcome.. The correct behavior in principle would be to propagate an \"all rejected\" exception if all of the inputs are rejected. I\u2019ll leave some space for my fellow maintainers to weigh in.. Released in v1.5.1. @timmfin Indeed. There was an unrelated change to the same feature.. Response codes are outside the scope of Q. The promise library only distinguishes fulfilled from rejected. This bug may apply to another library. Are you using Q-IO?. Use the \"latest\" version in npm, which is the most recent release in the version 1 train. Version 1 does not depend on the presence of a CommonJS module system.. You may have an exception trapped in an un-observed promise. Since you\u2019re using `then` with only a fulfillment handler, and not returning the promise returned by `then`, that can happen. Avoiding unnecessary use of `defer()` will help with this:\r\n\r\n```js\r\nfunction someFunction(value) {\r\n    return Q.all(array.map(otherFunction));\r\n}\r\n```. Released in v1.5.1. ",
    "qorrect": "kriskowal, looks gorgeous!\n\nSo the variable 'collection' that reduce is called is from mongodb driver or Q ?\n. kriskowal, looks gorgeous!\n\nSo the variable 'collection' that reduce is called is from mongodb driver or Q ?\n. ",
    "erikvold": "Yah I just noticed after making this pull req that the following two lines have a similar issue. Was this intended? or should they be corrected as well?\n. Yah I just noticed after making this pull req that the following two lines have a similar issue. Was this intended? or should they be corrected as well?\n. ",
    "warpech": "Thanks for clarification. I wasn't aware that qq is a separate repo. I would suggest to write about it in the readme for the newbies like me :) All best\n. Thanks for clarification. I wasn't aware that qq is a separate repo. I would suggest to write about it in the readme for the newbies like me :) All best\n. ",
    "jrburke": "OK, thank you! I also confirmed it works with the Dojo loader.\n. This came up in volo too, and recently saw a link to [domains in node](http://nodejs.org/docs/v0.7.9/api/domain.html) which sounds similar to the pool approach that @kriskowal mentioned. I do not have anything helpful to add, just mentioning data points.\n. @kriskowal sure. for me as a newbie, the pyramid of doom was enough to get me into q, but I'm really fine with whatever you think might work. I am just suggesting giving a bit more context before talking about promises. In any case though, thanks for the README update!\n. It looks like q.js has enough license info in it that LICENSE can be added to the npmignore. Similar with the README -- seems like a user could figure out how to get more info on q.js by looking at the q.js file.\n\n.gitignore are automatically ignored.\n\nI'm not sure how travis works -- if it consumes npm-installed packages, then I would not put it in the npmignore. Otherwise, I would add it.\n. Thanks for the heads up!\n\nOne option could be using \"index.js\" for the node/commonjs entry point and keeping q and q.min as the built things as they are now. That could avoid any potential issues, and keep with at least node conventions.\n\nIf going the release folder route, I would vote for `release/q.js` and `release/q.min.js`, but completely understand if you prefer otherwise.\n\nIn any case, I think it would work out for AMD consumers, for any of the paths mentioned.\n\nRegardless of the path chosen, it would make it easier for [volo](https://volojs.org) to use the new approach if you specify the following in the package.json (adjusted for whatever file name you choose for the non-minified version):\n\n``` javascript\n    \"volo\": {\n        \"url\": \"https://raw.github.com/kriskowal/q/{version}/release/q.js\"\n    }\n```\n\nvolo works with q today by using the \"main\" value in the package.json, but as the format of that \"main\" module will change with this ticket, and what is really desired for volo is the release bundle, and the package.json property helps point it to the correct location.\n\nIf you have an aversion to supporting non-npm package systems, and do not want to do it, I will understand, and I will try to figure something out that does not impact this repo. Thanks for providing a very useful library!\n. I have found it useful to commit built artifacts for latest branch commits so that other could test them as I fix issues for them. That may not be a goal for this project, and that is fine too, just sharing data points. It does not work for all types of projects, but for single file output of text-based JS it can.\n\nAlong those lines, you may be able to skip providing a .min.js file. It seems like more front end devs are used to doing their own project's minification and concatenation, which gives them some flexibility on the minfier of their choice.\n. If it helps simplify some things, I encourage just doing a release/q.js that is in UMD format. \n\nThe .min files in particular should go out of fashion. I expect that most projects now have their own project bundling steps, which should minify the full bundles, so providing the .min.js version is not really needed. If people are asking for it, I would suggest that it is not actually buying them much if they are not also minifying the project-specific code.\n\nTo generate the q.js file in UMD format, the following approach could be an option, although I would not be surprised if you could work out a workflow similar to this with browserify:\n- Use the [requirejs optimizer](http://requirejs.org/docs/optimization.html) to build the file using [cjsTranslate: true](https://github.com/jrburke/r.js/blob/d563dc51438d564438e2c78ccf36e828ea42772f/build/example.build.js#L549). I am assuming this built q would not need any node native module shims (like for 'fs' or 'path'). cjsTranslate just translates, does not provide adapter modules for node native modules. If needed, you can just place the browserify version of the adapters in the build area.\n- [wrap](https://github.com/jrburke/r.js/blob/d563dc51438d564438e2c78ccf36e828ea42772f/build/example.build.js#L443) can be used to wrap the code in a UMD block.\n- [onBuildWrite](http://www.ericfeminella.com/blog/2012/03/24/preprocessing-modules-with-requirejs-optimizer/) can be used to convert internal define() calls to just be function calls, so you could avoid a require/define adapter inside the UMD inner factory function. [Modernizer uses it](https://github.com/Modernizr/Modernizr/blob/a8d20c503ef4973ded147a7f61070013ce40d36b/Gruntfile.js#L166) for combining feature tests without needing the define calls after the build.\n\nIf you were interested in that pathway, I could do a pass at it if you have a branch or something I could use that already has q organized how you want in source form. No worries though if you already have it sorted.\n. On multiple vs one release file: for me it is about removing the tyranny of choice, and I expect the differences between the files are just a few lines at the top of it. Compared to the overall size of q.js I would expect it to be a single digit percent difference. With just the one release file, it makes it easier to consume: \"just get this one file and it works everywhere else outside of node\". The UMD version could just be \"browser global and AMD\", and if SES or montage was added later, add those lines to the UMD version.\n. @kriskowal I was a bit ignorant of the scope of q modularization. So reading your message, it sounds like q will npm install dependencies like ES5-Shim, ASAP, WeakMap, and then q.js itself just require()s those things and is fairly small on its own?\n\nIn that case, if you want 'q' to be consumable via its parts, it would probably be simpler all around if it just had a UMD-like wrapper in source form (maybe just for AMD and CJS though), and then include the package manager dependency declarations for npm and volo.\n\nFor people that just want one lib, and do not want to worry about tracking individual dependencies as it may not support runtime dependency use via a module system (so browser globals and people who use the bower package manager), do the one release/q.js in UMD format (could just be AMD and browser globals though), and then perhaps have a separate repo for the bower.json and its associated release/q.js.\n\nFor the q.js source file, if you found UMD boilerplate unpalatable, you could npm-rely on amdefine, so that the q.js could look like:\n\n``` javascript\nif (typeof define !== 'function') { var define = require('amdefine')(module) }\n\ndefine(function(require) {\n  require('ES5-Shim');\n  var asap = require('asap');\n  ...\n\n  //returning the value will set node's module.exports\n  return {};\n});\n```\n\nThose require('amdefine') calls will be ignored in AMD systems, and the requirejs optimizer will remove them from concatenated files.\n\nJust giving some options, but I completely understand if that amdefine approach is still not the desired aesthetic. In that case, I suppose a release/q.amd.js could work, and it is just a define() wrapped q.js source file. Then, release/q.js could be the bundle that has all dependencies in it and wrap itself in a UMD style for people that just want one thing to download.\n\nSide note: I cannot wait for ES modules, so some of the base module format friction goes away and we can just focus on package manager format friction.\n\nI do not think breaking it up would make it too much more palatable to dojo folks as they have their own promise thingy, and it has been hard for them in the past to just rely on another lib for that kind of functionality. Some of them may also have a hard time accepting the \"always notify of resolution on next turn\" (not me though, but then I am also not a consumer of dojo any more). Their choice of package manager may provide other challenges, not sure yet. Their dojo 2.0 story is a bit murky though, some proposals for it do try to leverage more third party code.\n. Maybe this is just a preliminary step down the full road to modularization, but since there are no require() calls in the source q.js, the optimizer is not needed for a single file conversion. It would be enough to do a concat so that the ending file looks like:\n\n``` javascript\ndefine(function(require, exports, module){\n//q.js goes here\n});\n```\n\nGoing further, you could probably just take the UMD boilerplate removed in the source q.js and use that as the pre-file and post-file to add around q.js. It would need to be adjusted for the module.exports usage, but should be straightforward.\n\nThat way, the build step is just a simpler concat file, and there would be just one release/q.js that could be used by any non-node env.\n\nIf the hope is to lay the groundwork for a simpler source q.js that does require() calls for other node packages, then the above mentioned simple define() wrapper for the single q.js module is enough for the AMD case (with package manager metadata for specifying module dependencies).\n\nThe r.js optimizer could still be used to generate a release/q.js that has everything included with a UMD wrapper, but then you probably could figure that out with a browserify step too.\n. @domenic I feel like there is a disconnect: there is only one file, no interior requires in source q.js, so the optimizer seems like overkill (even the browserify use). The grunt task writes out a create-global-entry thing, it seems like a writeout of 'define(function (require, exports, module) {' + fs.readFileSync('q.js', 'utf8') + '}' would be similar effort for a q.amd.js. Or just inserting the removed UMD block in a slightly modified form for what is put in the q-global.js file.\n\nBut I am probably missing something. I should be online tomorrow if talking in IRC works better, maybe there a requirements that are not coming though in the pull request discussion. I'm in requirejs on freenode and in some mozilla IRC rooms (like jslang). Happy to meet you in a channel that works for you.\n\nMy big disconnects are:\n\n1) Will the source q.js be doing require() calls to build up its full functionality (instead of being all inline into the source q.js now)?\n\n2) Will the files in release/ be considered standalone builds of q.js -- as in, nothing else needs to be included in a project to use q, just get a file from that release folder?\n\nMy understanding was **yes** to question 1, and for 2, the answer could be **yes, but if AMD, then just AMDify the q.js file as an AMD project can pull down the other dependencies as separate AMD modules**. Or just **yes**.\n\nRight now that branch seems be answering **no** to 1 and **yes** to 2, so that is informing how I am giving feedback.\n. Thanks for taking the time to bring me up to speed. A release/amd directory with the amd modules that are internal to this package would work well for AMD consumption. \n\nFor just converting a directory of CJS modules to AMD (not optimizing them together), there is a [command line switch to r.js that can be used](https://github.com/jrburke/r.js#convert-commonjs-modules).\n\nThat command line does a recursive directory copy and converts any .js files in CJS format to AMD. Which may not be what you want. If you prefer to do a very selected file conversion, you can use this code in a grunt task:\n\n``` javascript\nvar requirejs = require('requirejs');\n\nrequirejs.tools.useLib(function (require) {\n    require(['commonJs'], function(commonJs) {\n        //Save convertedContents to your file of choice.\n        //fileName is used for error notifications, fileContents is the text string\n        //of the file.\n        var convertedContents = commonJs.convert(fileName, fileContents);\n    });\n});\n```\n\nThe commonJs module is here:\nhttps://github.com/jrburke/r.js/blob/master/build/jslib/commonJs.js\n. It does look nicer!\n. OK, thank you! I also confirmed it works with the Dojo loader.\n. This came up in volo too, and recently saw a link to [domains in node](http://nodejs.org/docs/v0.7.9/api/domain.html) which sounds similar to the pool approach that @kriskowal mentioned. I do not have anything helpful to add, just mentioning data points.\n. @kriskowal sure. for me as a newbie, the pyramid of doom was enough to get me into q, but I'm really fine with whatever you think might work. I am just suggesting giving a bit more context before talking about promises. In any case though, thanks for the README update!\n. It looks like q.js has enough license info in it that LICENSE can be added to the npmignore. Similar with the README -- seems like a user could figure out how to get more info on q.js by looking at the q.js file.\n\n.gitignore are automatically ignored.\n\nI'm not sure how travis works -- if it consumes npm-installed packages, then I would not put it in the npmignore. Otherwise, I would add it.\n. Thanks for the heads up!\n\nOne option could be using \"index.js\" for the node/commonjs entry point and keeping q and q.min as the built things as they are now. That could avoid any potential issues, and keep with at least node conventions.\n\nIf going the release folder route, I would vote for `release/q.js` and `release/q.min.js`, but completely understand if you prefer otherwise.\n\nIn any case, I think it would work out for AMD consumers, for any of the paths mentioned.\n\nRegardless of the path chosen, it would make it easier for [volo](https://volojs.org) to use the new approach if you specify the following in the package.json (adjusted for whatever file name you choose for the non-minified version):\n\n``` javascript\n    \"volo\": {\n        \"url\": \"https://raw.github.com/kriskowal/q/{version}/release/q.js\"\n    }\n```\n\nvolo works with q today by using the \"main\" value in the package.json, but as the format of that \"main\" module will change with this ticket, and what is really desired for volo is the release bundle, and the package.json property helps point it to the correct location.\n\nIf you have an aversion to supporting non-npm package systems, and do not want to do it, I will understand, and I will try to figure something out that does not impact this repo. Thanks for providing a very useful library!\n. I have found it useful to commit built artifacts for latest branch commits so that other could test them as I fix issues for them. That may not be a goal for this project, and that is fine too, just sharing data points. It does not work for all types of projects, but for single file output of text-based JS it can.\n\nAlong those lines, you may be able to skip providing a .min.js file. It seems like more front end devs are used to doing their own project's minification and concatenation, which gives them some flexibility on the minfier of their choice.\n. If it helps simplify some things, I encourage just doing a release/q.js that is in UMD format. \n\nThe .min files in particular should go out of fashion. I expect that most projects now have their own project bundling steps, which should minify the full bundles, so providing the .min.js version is not really needed. If people are asking for it, I would suggest that it is not actually buying them much if they are not also minifying the project-specific code.\n\nTo generate the q.js file in UMD format, the following approach could be an option, although I would not be surprised if you could work out a workflow similar to this with browserify:\n- Use the [requirejs optimizer](http://requirejs.org/docs/optimization.html) to build the file using [cjsTranslate: true](https://github.com/jrburke/r.js/blob/d563dc51438d564438e2c78ccf36e828ea42772f/build/example.build.js#L549). I am assuming this built q would not need any node native module shims (like for 'fs' or 'path'). cjsTranslate just translates, does not provide adapter modules for node native modules. If needed, you can just place the browserify version of the adapters in the build area.\n- [wrap](https://github.com/jrburke/r.js/blob/d563dc51438d564438e2c78ccf36e828ea42772f/build/example.build.js#L443) can be used to wrap the code in a UMD block.\n- [onBuildWrite](http://www.ericfeminella.com/blog/2012/03/24/preprocessing-modules-with-requirejs-optimizer/) can be used to convert internal define() calls to just be function calls, so you could avoid a require/define adapter inside the UMD inner factory function. [Modernizer uses it](https://github.com/Modernizr/Modernizr/blob/a8d20c503ef4973ded147a7f61070013ce40d36b/Gruntfile.js#L166) for combining feature tests without needing the define calls after the build.\n\nIf you were interested in that pathway, I could do a pass at it if you have a branch or something I could use that already has q organized how you want in source form. No worries though if you already have it sorted.\n. On multiple vs one release file: for me it is about removing the tyranny of choice, and I expect the differences between the files are just a few lines at the top of it. Compared to the overall size of q.js I would expect it to be a single digit percent difference. With just the one release file, it makes it easier to consume: \"just get this one file and it works everywhere else outside of node\". The UMD version could just be \"browser global and AMD\", and if SES or montage was added later, add those lines to the UMD version.\n. @kriskowal I was a bit ignorant of the scope of q modularization. So reading your message, it sounds like q will npm install dependencies like ES5-Shim, ASAP, WeakMap, and then q.js itself just require()s those things and is fairly small on its own?\n\nIn that case, if you want 'q' to be consumable via its parts, it would probably be simpler all around if it just had a UMD-like wrapper in source form (maybe just for AMD and CJS though), and then include the package manager dependency declarations for npm and volo.\n\nFor people that just want one lib, and do not want to worry about tracking individual dependencies as it may not support runtime dependency use via a module system (so browser globals and people who use the bower package manager), do the one release/q.js in UMD format (could just be AMD and browser globals though), and then perhaps have a separate repo for the bower.json and its associated release/q.js.\n\nFor the q.js source file, if you found UMD boilerplate unpalatable, you could npm-rely on amdefine, so that the q.js could look like:\n\n``` javascript\nif (typeof define !== 'function') { var define = require('amdefine')(module) }\n\ndefine(function(require) {\n  require('ES5-Shim');\n  var asap = require('asap');\n  ...\n\n  //returning the value will set node's module.exports\n  return {};\n});\n```\n\nThose require('amdefine') calls will be ignored in AMD systems, and the requirejs optimizer will remove them from concatenated files.\n\nJust giving some options, but I completely understand if that amdefine approach is still not the desired aesthetic. In that case, I suppose a release/q.amd.js could work, and it is just a define() wrapped q.js source file. Then, release/q.js could be the bundle that has all dependencies in it and wrap itself in a UMD style for people that just want one thing to download.\n\nSide note: I cannot wait for ES modules, so some of the base module format friction goes away and we can just focus on package manager format friction.\n\nI do not think breaking it up would make it too much more palatable to dojo folks as they have their own promise thingy, and it has been hard for them in the past to just rely on another lib for that kind of functionality. Some of them may also have a hard time accepting the \"always notify of resolution on next turn\" (not me though, but then I am also not a consumer of dojo any more). Their choice of package manager may provide other challenges, not sure yet. Their dojo 2.0 story is a bit murky though, some proposals for it do try to leverage more third party code.\n. Maybe this is just a preliminary step down the full road to modularization, but since there are no require() calls in the source q.js, the optimizer is not needed for a single file conversion. It would be enough to do a concat so that the ending file looks like:\n\n``` javascript\ndefine(function(require, exports, module){\n//q.js goes here\n});\n```\n\nGoing further, you could probably just take the UMD boilerplate removed in the source q.js and use that as the pre-file and post-file to add around q.js. It would need to be adjusted for the module.exports usage, but should be straightforward.\n\nThat way, the build step is just a simpler concat file, and there would be just one release/q.js that could be used by any non-node env.\n\nIf the hope is to lay the groundwork for a simpler source q.js that does require() calls for other node packages, then the above mentioned simple define() wrapper for the single q.js module is enough for the AMD case (with package manager metadata for specifying module dependencies).\n\nThe r.js optimizer could still be used to generate a release/q.js that has everything included with a UMD wrapper, but then you probably could figure that out with a browserify step too.\n. @domenic I feel like there is a disconnect: there is only one file, no interior requires in source q.js, so the optimizer seems like overkill (even the browserify use). The grunt task writes out a create-global-entry thing, it seems like a writeout of 'define(function (require, exports, module) {' + fs.readFileSync('q.js', 'utf8') + '}' would be similar effort for a q.amd.js. Or just inserting the removed UMD block in a slightly modified form for what is put in the q-global.js file.\n\nBut I am probably missing something. I should be online tomorrow if talking in IRC works better, maybe there a requirements that are not coming though in the pull request discussion. I'm in requirejs on freenode and in some mozilla IRC rooms (like jslang). Happy to meet you in a channel that works for you.\n\nMy big disconnects are:\n\n1) Will the source q.js be doing require() calls to build up its full functionality (instead of being all inline into the source q.js now)?\n\n2) Will the files in release/ be considered standalone builds of q.js -- as in, nothing else needs to be included in a project to use q, just get a file from that release folder?\n\nMy understanding was **yes** to question 1, and for 2, the answer could be **yes, but if AMD, then just AMDify the q.js file as an AMD project can pull down the other dependencies as separate AMD modules**. Or just **yes**.\n\nRight now that branch seems be answering **no** to 1 and **yes** to 2, so that is informing how I am giving feedback.\n. Thanks for taking the time to bring me up to speed. A release/amd directory with the amd modules that are internal to this package would work well for AMD consumption. \n\nFor just converting a directory of CJS modules to AMD (not optimizing them together), there is a [command line switch to r.js that can be used](https://github.com/jrburke/r.js#convert-commonjs-modules).\n\nThat command line does a recursive directory copy and converts any .js files in CJS format to AMD. Which may not be what you want. If you prefer to do a very selected file conversion, you can use this code in a grunt task:\n\n``` javascript\nvar requirejs = require('requirejs');\n\nrequirejs.tools.useLib(function (require) {\n    require(['commonJs'], function(commonJs) {\n        //Save convertedContents to your file of choice.\n        //fileName is used for error notifications, fileContents is the text string\n        //of the file.\n        var convertedContents = commonJs.convert(fileName, fileContents);\n    });\n});\n```\n\nThe commonJs module is here:\nhttps://github.com/jrburke/r.js/blob/master/build/jslib/commonJs.js\n. It does look nicer!\n. ",
    "cadorn": "Never mind. `Q.isResolved(Q.defer().promise)`. Would be nice to have a warning somehow.\n. `setTimeout()` is not available as a global in the mozilla addon environment.\n\n`serverSideRequire(\"event-queue\")` will return a module I am providing **BUT** the addon sdk loader will not allow me to load the module without finding it declared in a static analysis pass (looking for `require('<id>')`).\n\nIf I can set `exports.nextTick` externally I can bypass all the current detection logic.\n. Unfortunately there is no clean way to detect the addon sdk environment. Since `setTimeout()` nor checking for `serverSideRequire(\"timers\").setTimeout` (due to not finding `require('timers')`) will work I think the only solution is setting `nextTick` externally.\n\nThe function could be cached on first use to avoid security implications if that helps.\n. @kriskowal `typeof MessageChannel: undefined`\n\n_injection_ is indeed the way to go and that will be available in future as we have more intelligent loaders but `Q` is such a low-level module that it may be used without an _injecting_ loader quite frequently (or even to implement the loader as in my case). I don't think the addon-sdk is alone when it comes to striving to provide a clean (minimal globals) module environment.\n\nYou can say; just patch `Q` when you import it into your project; but that is not consistent with the current attempts to subsume the _event-queue_ and provide an _out-of-the-box_ experience.\n\nThe addon-sdk exposes `require(\"timers\").setTimeout()` but if used as `serverSideRequire(\"timers\").setTimeout` it will not allow access to the _timers_ module as the static analysis fails. (I currently implement an `event-queue` module and am adding `require('event-queue');` to the top of `q.js`).\n\nTo prevent _replacing_ the `nextTick` implementation it should be cached on first use. I think this is a fair workaround for the lack of _injectability_.\n\nThere are also cases when you want more control over `nextTick` than `Q` currently offers. In the addon-sdk the `timers` implementation respects the lifecycle of the program and test runner. See: https://github.com/mozilla/addon-sdk/blob/master/packages/api-utils/lib/timer.js\n\nI suppose if we decide against a one-time settable `nextTick` I can look into teaching the addon-sdk loader the ability to allow loading of the `event-queue` module (since it cannot find it by static analysis) by configuration from `package.json`. This is a use-case not unique to this scenario but was hoping to hold off on for now.\n. @kriskowal No. They may if it becomes a commonjs spec though at which point it could be used instead of `serverSideRequire`.\n\nThe problem is they want _lean_ builds to generate addons that only contain what is needed. If using `require.async(id, cb, eb)` we still have no way to determine what module is being referenced and would need a declaration in `package.json`. This is a problem area I am working on in general (constraining `require.async` for a module so we can gather possible IDs at build time in order to generate the dynamic load bundles). I have a working solution but am not happy with it. I think it will end up needing a pureJS load handler / dynamic linker that can be invoked at runtime or build time.\n\nIf we don't want to make changes to `Q` to support the addon-sdk the consequence for addon-sdk developers is:\n- Must use a non-enforcing loader instead of the stock one (I am about to test that by subclassing the stock loader) and\n- Built add-on cannot be a _lean_ build and must include all files.\n\nThis is _fine for now_ but will not fly longer term.\n. > For version 1, we would need to take into consideration that the require call would be discovered by static analyzers in other environments, which would in turn fail to find the module. I know that Mr can be tricked but not sure about Browserify et al.\n\nYeah. Its unspecified ground. This is a common issue and requires a transformation/override step at some level.\n\n> For version 2, does the addon-sdk still support overlays?\n\nNo.\n\nOne solution that would make sense from my POV is to specify some annotation that can be put at the top of module files that specifies the expected globals and points to a spec for their implementation. Each environment can then map these common spec uris to their respective implementations and provide the requested globals to the module.\n\nI think mozilla would accept such a solution into their loader as it can be secured.\n\nI guess I am trying to arrive at a solution that is portable to other libraries. I can always put the one line into the top of `q.js` using an automated patch; but that does not help the JS component ecosystem because its a common problem.\n. Ah of course. Too many abstractions in my head tonight ;)\n. Never mind. `Q.isResolved(Q.defer().promise)`. Would be nice to have a warning somehow.\n. `setTimeout()` is not available as a global in the mozilla addon environment.\n\n`serverSideRequire(\"event-queue\")` will return a module I am providing **BUT** the addon sdk loader will not allow me to load the module without finding it declared in a static analysis pass (looking for `require('<id>')`).\n\nIf I can set `exports.nextTick` externally I can bypass all the current detection logic.\n. Unfortunately there is no clean way to detect the addon sdk environment. Since `setTimeout()` nor checking for `serverSideRequire(\"timers\").setTimeout` (due to not finding `require('timers')`) will work I think the only solution is setting `nextTick` externally.\n\nThe function could be cached on first use to avoid security implications if that helps.\n. @kriskowal `typeof MessageChannel: undefined`\n\n_injection_ is indeed the way to go and that will be available in future as we have more intelligent loaders but `Q` is such a low-level module that it may be used without an _injecting_ loader quite frequently (or even to implement the loader as in my case). I don't think the addon-sdk is alone when it comes to striving to provide a clean (minimal globals) module environment.\n\nYou can say; just patch `Q` when you import it into your project; but that is not consistent with the current attempts to subsume the _event-queue_ and provide an _out-of-the-box_ experience.\n\nThe addon-sdk exposes `require(\"timers\").setTimeout()` but if used as `serverSideRequire(\"timers\").setTimeout` it will not allow access to the _timers_ module as the static analysis fails. (I currently implement an `event-queue` module and am adding `require('event-queue');` to the top of `q.js`).\n\nTo prevent _replacing_ the `nextTick` implementation it should be cached on first use. I think this is a fair workaround for the lack of _injectability_.\n\nThere are also cases when you want more control over `nextTick` than `Q` currently offers. In the addon-sdk the `timers` implementation respects the lifecycle of the program and test runner. See: https://github.com/mozilla/addon-sdk/blob/master/packages/api-utils/lib/timer.js\n\nI suppose if we decide against a one-time settable `nextTick` I can look into teaching the addon-sdk loader the ability to allow loading of the `event-queue` module (since it cannot find it by static analysis) by configuration from `package.json`. This is a use-case not unique to this scenario but was hoping to hold off on for now.\n. @kriskowal No. They may if it becomes a commonjs spec though at which point it could be used instead of `serverSideRequire`.\n\nThe problem is they want _lean_ builds to generate addons that only contain what is needed. If using `require.async(id, cb, eb)` we still have no way to determine what module is being referenced and would need a declaration in `package.json`. This is a problem area I am working on in general (constraining `require.async` for a module so we can gather possible IDs at build time in order to generate the dynamic load bundles). I have a working solution but am not happy with it. I think it will end up needing a pureJS load handler / dynamic linker that can be invoked at runtime or build time.\n\nIf we don't want to make changes to `Q` to support the addon-sdk the consequence for addon-sdk developers is:\n- Must use a non-enforcing loader instead of the stock one (I am about to test that by subclassing the stock loader) and\n- Built add-on cannot be a _lean_ build and must include all files.\n\nThis is _fine for now_ but will not fly longer term.\n. > For version 1, we would need to take into consideration that the require call would be discovered by static analyzers in other environments, which would in turn fail to find the module. I know that Mr can be tricked but not sure about Browserify et al.\n\nYeah. Its unspecified ground. This is a common issue and requires a transformation/override step at some level.\n\n> For version 2, does the addon-sdk still support overlays?\n\nNo.\n\nOne solution that would make sense from my POV is to specify some annotation that can be put at the top of module files that specifies the expected globals and points to a spec for their implementation. Each environment can then map these common spec uris to their respective implementations and provide the requested globals to the module.\n\nI think mozilla would accept such a solution into their loader as it can be secured.\n\nI guess I am trying to arrive at a solution that is portable to other libraries. I can always put the one line into the top of `q.js` using an automated patch; but that does not help the JS component ecosystem because its a common problem.\n. Ah of course. Too many abstractions in my head tonight ;)\n. ",
    "marshalys": "ok, thank you, I'll check my code,\nbut when I use the old version, this problem is not occur.\n. My code use qq.js lib. I think this issue maybe caused by the function \"step\" .\n\"step\"  invoke -> deep -> consolidate.\nin the function consolidate,has this code:\n\n for (var i in object) {\n                (function (i, value) {\n                    synchronize = Q.when(synchronize, function () {\n                        return Q.when(deep(value), function (value) {\n                            object[i] = value;\n                        });\n                    });\n                })(i, object[i]);\n            }\n\nI think this maybe the place the \"reduce\" property add to the array.\n. Congratulations!\n. ok, thank you, I'll check my code,\nbut when I use the old version, this problem is not occur.\n. My code use qq.js lib. I think this issue maybe caused by the function \"step\" .\n\"step\"  invoke -> deep -> consolidate.\nin the function consolidate,has this code:\n\n for (var i in object) {\n                (function (i, value) {\n                    synchronize = Q.when(synchronize, function () {\n                        return Q.when(deep(value), function (value) {\n                            object[i] = value;\n                        });\n                    });\n                })(i, object[i]);\n            }\n\nI think this maybe the place the \"reduce\" property add to the array.\n. Congratulations!\n. ",
    "csosborn": "I just ran into this as well. Wouldn't it be possible to add reduce to Array.prototype using Object.defineProperty rather than straight assignment? You could then specify that it should be non-enumerable.\n. Ah, I see. In my case, q became a very effective detector for unguarded for..in loops elsewhere in my code, two of which immediately broke. I've upgraded them with calls to hasOwnProperty and all is well again.\n. This is still a problem in the latest q and qq on NPM. I know you said that Object.defineProperty would not work properly with ec5-shim, but isn't it still better than direct modification of Array.prototype? It would work beautifully on Node, at least.\n. Congratulations! What are you doing on Github if your wedding is tomorrow? Don't you have vows to memorize or something? :)\n\nAnyway, I'll put together a patch. Thanks!\n. Thanks!\n. Thanks. Those look good. I'll give them a try when they're released. \n\nI think the main advantage of a deferred.node() approach is that there is no confusion about the context in which doSomething() runs. Q.ncall() and Q.node() are good for the free-floating function case, but if I want to call foo.doSomething() then I'm left creating a new closure and the convenience is lost.\n. That looks great! Thank you!\n. I just ran into this as well. Wouldn't it be possible to add reduce to Array.prototype using Object.defineProperty rather than straight assignment? You could then specify that it should be non-enumerable.\n. Ah, I see. In my case, q became a very effective detector for unguarded for..in loops elsewhere in my code, two of which immediately broke. I've upgraded them with calls to hasOwnProperty and all is well again.\n. This is still a problem in the latest q and qq on NPM. I know you said that Object.defineProperty would not work properly with ec5-shim, but isn't it still better than direct modification of Array.prototype? It would work beautifully on Node, at least.\n. Congratulations! What are you doing on Github if your wedding is tomorrow? Don't you have vows to memorize or something? :)\n\nAnyway, I'll put together a patch. Thanks!\n. Thanks!\n. Thanks. Those look good. I'll give them a try when they're released. \n\nI think the main advantage of a deferred.node() approach is that there is no confusion about the context in which doSomething() runs. Q.ncall() and Q.node() are good for the free-floating function case, but if I want to call foo.doSomething() then I'm left creating a new closure and the convenience is lost.\n. That looks great! Thank you!\n. ",
    "asutherland": "Sandboxes and support for annotations would be excellent, although I should be clear that my biggest concern in this issue is that use of Q can lead to quietly eaten exceptions.  The Mozilla platform (at least when dealing with the non-browser XPCOM stuff) loves to eat exceptions, and I don't want to go back to that, so it would be great to make sure that rejections (that are exceptions, at least) are always re-thrown if not explicitly handled by the user.\n\nIn any event, Q is working fantastically for me, especially with a minor hack patch to re-throw errors.  Thanks again for all the great work on Q, have a good week away/off, and let me know if there's a mailing list you would like to use to discuss such issues.\n\n(The XPCOM issue in a nutshell, if you are interested, is a 1) fundamental impedance mismatch between C++ and (transparently-exposed) JS and 2) the use of integer success/error codes in the C++ code.  The XPConnect code allows JS code to obey the C++-style IDL interfaces, but has a hard call to make when an exception propagates upward, because it is able to translate the exception to an integer failure code, which may or may not be desired... it can't tell and can only either report every exception it sees or just translate them to integers.  Unfortunately, that sucks quite extensively for developers.  Q is in the much more advantageous position of being able to tell that there is no one explicitly handling/translating an error, and thus that it can/should be reported.)\n. Another useful causeway link (that I don't believe the above links reference) is a more recent JS version with live-ish examples:\nhttp://code.google.com/p/causeway/\n. Sandboxes and support for annotations would be excellent, although I should be clear that my biggest concern in this issue is that use of Q can lead to quietly eaten exceptions.  The Mozilla platform (at least when dealing with the non-browser XPCOM stuff) loves to eat exceptions, and I don't want to go back to that, so it would be great to make sure that rejections (that are exceptions, at least) are always re-thrown if not explicitly handled by the user.\n\nIn any event, Q is working fantastically for me, especially with a minor hack patch to re-throw errors.  Thanks again for all the great work on Q, have a good week away/off, and let me know if there's a mailing list you would like to use to discuss such issues.\n\n(The XPCOM issue in a nutshell, if you are interested, is a 1) fundamental impedance mismatch between C++ and (transparently-exposed) JS and 2) the use of integer success/error codes in the C++ code.  The XPConnect code allows JS code to obey the C++-style IDL interfaces, but has a hard call to make when an exception propagates upward, because it is able to translate the exception to an integer failure code, which may or may not be desired... it can't tell and can only either report every exception it sees or just translate them to integers.  Unfortunately, that sucks quite extensively for developers.  Q is in the much more advantageous position of being able to tell that there is no one explicitly handling/translating an error, and thus that it can/should be reported.)\n. Another useful causeway link (that I don't believe the above links reference) is a more recent JS version with live-ish examples:\nhttp://code.google.com/p/causeway/\n. ",
    "johnjbarton": "I believe issue 30, https://github.com/kriskowal/q/issues/30, is a example of the problem being discussed here.\n. Arggh. I guess github issues are not plain text.\nhttps://github.com/johnjbarton/Purple/blob/master/tests/promises/throwInFulfilled.html\n. How about a Q.debug = true mode? The problem with .end() is of course you fail to call it just in the cases you need it.\n\nI suppose to be realistic the ergonomics of Q are pretty horrible in that the call stack goes from \"oh, my code\" to \"OMG what is this code?\" A big step could be showing the dev the chain you describe. What is Causeway? (This is one of the areas I want to work on, tho not in Firebug.  Same issues face all other async libs like require.js.)\n. Thanks! Since we are in the same process I think we can do something non-post morteum\n. Maybe this will help, \nhttps://github.com/johnjbarton/LongMueller\n. Sorry, I was really just offering the source as inspiration. You can see an example of Cause.js on my fork of Q\nhttps://github.com/johnjbarton/q/blob/master/q.js\nHowever, to be clear, this was done just at the end of my experiment with Q so I'm unsure how well the stacks work in routine practice.\n. I believe issue 30, https://github.com/kriskowal/q/issues/30, is a example of the problem being discussed here.\n. Arggh. I guess github issues are not plain text.\nhttps://github.com/johnjbarton/Purple/blob/master/tests/promises/throwInFulfilled.html\n. How about a Q.debug = true mode? The problem with .end() is of course you fail to call it just in the cases you need it.\n\nI suppose to be realistic the ergonomics of Q are pretty horrible in that the call stack goes from \"oh, my code\" to \"OMG what is this code?\" A big step could be showing the dev the chain you describe. What is Causeway? (This is one of the areas I want to work on, tho not in Firebug.  Same issues face all other async libs like require.js.)\n. Thanks! Since we are in the same process I think we can do something non-post morteum\n. Maybe this will help, \nhttps://github.com/johnjbarton/LongMueller\n. Sorry, I was really just offering the source as inspiration. You can see an example of Cause.js on my fork of Q\nhttps://github.com/johnjbarton/q/blob/master/q.js\nHowever, to be clear, this was done just at the end of my experiment with Q so I'm unsure how well the stacks work in routine practice.\n. ",
    "domenic": "WinJS has a similar solution to Q, where `.done(f, r)` is equivalent to Q's `.then(f, r).end()`:\n- http://msdn.microsoft.com/en-us/library/windows/apps/hh700337.aspx\n- http://msdn.microsoft.com/en-us/library/windows/apps/hh700334.aspx\n- http://blogs.msdn.com/b/microsoft_press/archive/2012/06/04/free-ebook-programming-windows-8-apps-with-html-css-and-javascript-first-preview.aspx page 78\n\nThe latter has a particularly poignant quote:\n\n> In practical terms, this means that if you end a chain of promises with a then and not done, all exceptions in that chain will get swallowed and you\u2019ll never know there was a problem! This can place an app in an indeterminate state and cause much larger problems later on. So, unless you\u2019re going to pass the last promise in a chain to another piece of code that will itself call done, always use done at the end of a chain even for a single async operation.\n\nIn practice, we've adapted to the status quo, and adopt the simple rule to always either (a) return the promise; or (b) cap with `.end()`. We enforce this even for promises that have error handlers, just in case the error handler itself throws, and also to make the rule simple and easy to follow without thinking.\n. See also promises-aplus/unhandled-rejections-spec#4\n. You are coming from jQuery, I see. In Q, such a method is not necessary; there is a much more elegant approach:\n\n```\n// Will return a promise for the value that anotherPromiseReturner's promise\n// is fulfilled with, plus 5.\nfunction returnsAPromise() {\n    return anotherPromiseReturner().then(function (result) {\n        return result + 5;\n    });\n}\n```\n\nAll of the other things you describe have similar elegant solutions with Q. You can see some examples of them in [my slides](http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript), starting around slide 48.\n\njQuery breaks this CommonJS promise semantic, i.e. breaks the promise fulfillment <-> method return value correspondence. (In short, this occurs because promises in jQuery can be fulfilled with multiple values.) That is why it needs a custom, nonstandard `pipe` method and the ugly code it generates.\n. @ThomasBurleson, I'll try again. Q natively supports all three of your requirements, in a more elegant syntax than the hacked-on `pipe` extension.\n\n1) As in my previous post.\n2)\n\n``` javascript\ndoSomethingAsync().then(function (result) {\n  if (result.statusCode !== 200) {\n    throw new Error(\"Bad status code\");\n  }\n});\n```\n\n3)\n\n``` javascript\nQ.defer().promise.then(func1).then(func2).then(func3).then(...);\n```\n. @ThomasBurleson\n\nHappy to help. As @kriskowal explains, `then` does exactly what you want. Your last example is written in Q as\n\n``` javascript\n.then(function (event) {\n   return event.result;\n}).then(function (result) {\n  // ...\n});\n```\n\nSimilarly, my intercept-and-throw example from above can be expanded as\n\n``` javascript\ndoSomethingAsync().then(function (response) {\n  if (response.statusCode !== 200) {\n    throw new Error(\"Bad status code\");\n  }\n  return response.text;\n}).then(\n  function (responseText) {\n    // ...\n  },\n  function (error) {\n    // error here is either the original error from `doSomethingAsync`,\n    // or the one we threw above for non-200 status codes.\n    // This behavior is in direct correspondence with how exceptions bubble in sync code.\n  }\n);\n```\n. The problem really comes from dealing with callback APIs, but thankfully we have a lot of helpers for that. For example you could do:\n\n``` js\nfunction getFiles() {\n  return Q.invoke(fs, \"readdir\").then(function (files) {\n    return Q.all(files.map(processFile));\n  });\n}\n```\n\nNote that this version also handles if there's an error reading the directory, which the `getFiles` in your post does not (it ignores such errors).\n. Yes, that would work wonderfully. Unfortunately weak maps are not weak references.\n. How would you maintain that list? (Answer: using a strong reference.)\n. How would you then find out if the promise is in the weak map?\n. I humbly submit <a href=\"http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\">my presentation</a> as either a link to include, or as a source from which examples can be plagiarized at will.\n. @kriskowal Agreed. I think slides 42--68 are the most relevant.\n. This makes sense. Just to make sure, neither the `MessageChannel` nor `setTimeout` implementations are sufficient for your purposes? I would imagine the former is both available and sufficiently fast.\n\nIn any case, there is actually already a `Q.nextTick`, but we'd need to change all the internal usages to reference `exports.nextTick` instead of just `nextTick` if we wanted to make setting it useful.\n. A settable `nextTick` makes sense to me. I'm just wishing there was a way to make it work out of the box. Let me know if you think of anything.\n\nI'll wait for @kriskowal to weigh in before committing anything though, since I don't understand all the security guarantees Q provides enough to know whether a settable `nextTick` would break them.\n. @Yaffle Yes it does, although of course IE10 has native `msSetImmediate`. See also NobleJS/setImmediate@9be325240d3cc37ddeb782a109410bb9c4413b67.\n. Right, good point. It seems convenient; the only reason I can think for including `call` and `apply` but not `bind` is that you can probably get `bind` via `promiseForFunction.get(\"bind\").invoke(thisp, 1, 2, 3)`.\n. Wait but I guess that's true for `call` and `apply` as well, so nevermind. I'll try to add it later today.\n. Yeah, the fact `setImmediate` has all the unnecessary stuff is unfortunate.\n\nSo your proposal is to change to\n\n``` javascript\nvar nextTick = global.nextTick || global.setImmediate ||\n               (typeof process !== \"undefined\" && process.nextTick) ||\n               nextTickShim;\n```\n\n and then, perhaps in the future, publish a browser-based `global.nextTick` library?\n. Well now I feel silly for sending this to q-continuum as well, heh. Good to hear I was on the right track. It was confusing because the old example didn't seem to need the `Q.resolve()`:\n\n``` javascript\nreturn array.reduce(function (done, value) {\n    return Q.wait(done, doWork(value));\n});\n```\n\nAs for shipping the reference off to the wiki, <a href=\"https://github.com/kriskowal/q/commit/6b41d3160891000f001b5c089f50eefb25b5c141\">already done</a> :)\n. On first thought the best route is to use something like <a href=\"https://github.com/rauschma/lobrow/blob/master/lobrow.js\">lobrow</a> to get dirt-simple Node-modules-in-the-browser up and running. I also think @substack had a recent one but I can't find it in his monster list of public repositories.\n\n@Gozala/test-commonjs seems like it would work pretty well in such an environment, since it doesn't depend on much environment, and is already browser-compatible in at least some fashion (AMD might be involved?).\n\n---\n\nAnother option would be to have a compile step for the tests that wraps them in and AMD wrapper to be used alongside @Gozala/test-commonjs. I believe @jrburke/r.js can do this.\n. @Gozala That sounds excellent, since I think our goal is just to check that we didn't break anything.\n. I think the best stack right now would be <a href=\"http://busterjs.org/docs/\">BusterJS</a> for native \"`return` a `then`-able\" support + <a href=\"http://chaijs.com/\">Chai</a> + <a href=\"https://github.com/domenic/chai-as-promised/\">Chai as Promised</a>. I haven't used BusterJS yet but the latter two are working great in our project at work.\n. To get the bikeshedding out of the way: `createNodeCallback` or `asNodeCallback` are most to my liking.\n\nI think generating it on each call (and thus being a function instead of a property) makes the most sense, as it seems very rare to want to get the callback more than once.\n\nI suppose for browsers that support getters we could add a `nodeCallback` lazily-computed property, but I don't know if I liking having a variable API surface depending on environment.\n. I... kind of like it. <a href=\"https://www.google.com/#q=%2Bnodeback\">Why isn't anyone using that term already?</a>\n. In my experience, the majority of Node functions end up needing the `this` parameter, so this wouldn't work too well. You'd end up having to say\n\n``` js\ndynodeClient.putItem.bind(dynodeClient).qcall(...)\n```\n\nwhich is hardly a win :-/\n. Right, sorry, my mistake. Hmm. I'd say it would be nice indeed. It would need an opt-in line, e.g.\n\n``` js\nQ.extendFunctionPrototype();\n```\n\nwhich increases friction a bit. But still, could be useful.\n. @kriskowal thoughts?\n. `Q` itself can't be a function call, because that conflicts with `Q.call` and `Q.apply`.\n\nAlso, option #1 is very \"nodeback\"-centric; remember most users of Q will not be using it in conjunction with nodebacks, except at certain, hopefully very hidden, seams.\n. Yeah, I don't think that makes much sense, compared to `Q.call`.\n. I think I have a vague idea what you mean, but could you give an example of a stack trace that still shows asynchronous boundaries?\n\n---\n\nBy instrumenting `when` with the following lines:\n\n``` js\nvar error = {};\nError.captureStackTrace(error, when);\nconsole.log(\"stack trace\", error.stack);\n```\n\nI manage to get the following two stack traces:\n\n```\nstack trace [object Object]\n    at makePromise.then (c:\\Users\\Domenic\\Programming\\test\\node_modules\\q\\q.js:270:12)\n    at doYAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:10:23)\n    at doZAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:16:12)\n    at Object.<anonymous> (c:\\Users\\Domenic\\Programming\\test\\test.js:19:1)\n    at Module._compile (module.js:441:26)\n    at Object..js (module.js:459:10)\n    at Module.load (module.js:348:31)\n    at Function._load (module.js:308:12)\n    at Array.0 (module.js:479:10)\n    at EventEmitter._tickCallback (node.js:192:40)\nstack trace [object Object]\n    at Object.end (c:\\Users\\Domenic\\Programming\\test\\node_modules\\q\\q.js:885:5)\n    at makePromise.end (c:\\Users\\Domenic\\Programming\\test\\node_modules\\q\\q.js:289:34)\n    at Object.<anonymous> (c:\\Users\\Domenic\\Programming\\test\\test.js:19:12)\n    at Module._compile (module.js:441:26)\n    at Object..js (module.js:459:10)\n    at Module.load (module.js:348:31)\n    at Function._load (module.js:308:12)\n    at Array.0 (module.js:479:10)\n    at EventEmitter._tickCallback (node.js:192:40)\n```\n\nSo the information is at least there and accessible (and we can use `Error.prepareStackTrace` to restructure it as necessary). The trick will be associating it with promises as they propagate through the system, and then putting it all together at an appropriate time.\n\n---\n\nAs far as I can tell we'd want this information in two places:\n- In a scenario using `.end()` as above.\n- As a replacement for `rejectionReason.stack` inside rejection handlers, e.g. for live debugging.\n\nFor the latter case I mean that if we replaced the above `doZAsync` with\n\n``` js\nfunction doZAsync() {\n    return doYAsync().fail(function (err) {\n        console.log(err.stack);\n    });\n}\n```\n\nIt would output something like\n\n```\nError: boo!\n    at c:\\Users\\Domenic\\Programming\\test\\test.js:11:15\n    at doYAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:10:xx)\n```\n. Really like the async boundaries idea now that I get it :).\n\n> My thought was that we could get away with just instrumenting deferreds since that\u2019s where everything ultimately comes from. Even `when` calls `defer` before yielding.\n\nOoh, thanks for the tip. Yeah, I was just getting to the point of trying to figure out which seams I need to insert myself into.\n\n> It strikes me that exceptions should inherently support chaining, so you can both have a friendly face and the ability to dig deeper into the issue by expanding the next error in the chain.\n\nAgreed. Cf. <a href=\"http://msdn.microsoft.com/en-us/library/system.exception.innerexception%28v=vs.100%29.aspx\">Exception.InnerException</a> in .NET.\n. What should the following output?\n\n``` js\nvar Q = require(\"q\");\n\nfunction doXAsync() {\n    return Q.resolve(5);\n}\n\nfunction doYAsync() {\n    return doXAsync().then(function doXAsyncCallback() {\n        return Q.delay(10).then(function delayCallback() {\n            return { foo: \"bar\" };\n        }).get(\"bar\").then(function getBarCallback() {\n            throw new Error(\"boo!\");\n        });\n    });\n}\n\nfunction doZAsync() {\n    return doYAsync();\n}\n\ndoZAsync()\n    .end();\n```\n\nI've got\n\n```\nError: boo!\n    at getBarCallback (C:\\Users\\ddenicola\\SkyDrive\\Programming\\Work in Progress\\q with stack traces playground\\test.js:14:19)\nFrom previous event:\n    at doYAsync (C:\\Users\\ddenicola\\SkyDrive\\Programming\\Work in Progress\\q with stack traces playground\\test.js:10:23)\n    at doZAsync (C:\\Users\\ddenicola\\SkyDrive\\Programming\\Work in Progress\\q with stack traces playground\\test.js:20:12)\n    at Object.<anonymous> (C:\\Users\\ddenicola\\SkyDrive\\Programming\\Work in Progress\\q with stack traces playground\\test.js:27:1)\n```\n\nright now but feel like `doXAsyncCallback` and maybe `delayCallback` should appear in the trace.\n. I am going to go out on a limb and say we don't need the [[Construct]] behavior that we <a href=\"https://github.com/kriskowal/q/blob/40511a3176444aad13d54cedca98cc4b5027fedb/q.js#L764-776\">currently support in `Q.bind` proper</a>. Let me know if you think otherwise.\n. Done.\n. If there's anything to tweak in the above commits, let me know. (Changelog wording perhaps?) Otherwise I'll squash all of them into two (\"Remove Narwhal support\" and \"Use `setImmediate` if available\") and push.\n. @Yaffle, @kriskowal what do you think of 3175d1c.\n. Closed in favor of squashed commits.\n. I've been thinking we should publish a new minor version now. There are actually <a href=\"https://github.com/kriskowal/q/blob/master/CHANGES.md\">a number of nice fixes</a>. Probably the biggest hold-up is #54, since we cannot be sure releasing will not break the browser.\n\nIf you want to use master directly, you can as always do something like\n\n``` json\ndependencies: {\n    \"q\": \"git://github.com/kriskowal/q.git\"\n}\n```\n\nor to be a bit less bleeding-edge,\n\n``` json\ndependencies: {\n    \"q\": \"git://github.com/kriskowal/q.git#027c1bb51cf0f6e478704ab8a45c00830b03cc87\"\n}\n```\n\nWill leave open in case @kriskowal wants to use this to track the next release.\n. I believe domenic/q@a9a3e40 will do the trick. Anyone want to look it over?\n. >  I take it the intention is not to standardise at all on what args to use (or even how many args) in a progress notification?\n\nIndeed, although I was inclined to maybe standardize on a single arg. Dunno.\n\n> There's an interesting related case of transferring meta information. For example if you use the request library to make a web-request, you get a response, but you also get an object containing headers etc. I'm not sure whether meta handling makes sense to be handled in a special way within Q.\n\nI don't really see it. I'd return a promise for `{ headers, response }`, which is still a single object.\n. > I'm inclined to agree with standardising on a single arg, that makes it a closer match to the other callbacks.\n\nOK cool. I'll take it to q-continuum and see what everyone thinks.\n\n> I guess that makes sense, and that's what I'm looking at doing at the moment for my APIs...\n\nI guess my real question is: how would you handle this for synchronous methods? Since there is an exact parallel between async fulfillment values and sync return values, what would your sync method counterpart look like?\n. We need to assimilate cancellable WinJS promises at work so I'll probably be working on this over the next week or two.\n. To make sure I understand, the idea is that we test for the presence of `console.fulfilled`, and if it exists, call it whenever a promise is fulfilled?\n. See also promises-aplus/unhandled-rejections-spec#2\n. Works in Chrome now although that code is kind of horrible. Notably Chrome shows the short stack trace when you click the little arrow in the console, even though if you break on error and do `error.stack` in the REPL, it will give the long stack trace. Investigating.\n. Answered on StackOverflow. Do you think there's anything we could do to make it more clear, in the README or in the Wiki?\n\n@kriskowal What about a Wiki page with an \"examples gallery\"? I feel like I've put together a lot of gists, StackOverflow answers, etc. that might be interesting to peruse.\n. @kriskowal Great; I'll start a page. EDIT: https://github.com/kriskowal/q/wiki/Examples-Gallery\n. Spec runner fixed in 02241ea8326861d846d6df4e3a84fe46b1de2d29\n. Done. Specs now passing in IE7, IE8, IE9, and IE10.\n. @kriskowal, does this look merge-worthy?\n. Knowing very little about .npmignore best practices, what about LICENSE, README.md, .travis.yml, .gitignore?\n. I believe Travis just checks out the code.\n\nUpdated list:\n\n```\ndesign\nexamples\nspec\ntest\n.coverignore\n.travis.yml\nCHANGES.md\nLICENSE\nREADME.md\nVERSIONS.md\nq.min.js\nq.min.js.gz\nref_send.md\n```\n\nBTW @kriskowal is `ref_send.md` subsumed by [this wiki page](https://github.com/kriskowal/q/wiki/Coming-from-Waterken%E2%80%99s-Ref-Send)?\n. Thanks for finding this! Fixed slightly differently in 73ee9d30cec517b772fd01e03c56ea2ad560565b.\n. @sp an npm release is somewhat imminent, but in the meantime you can use git URLs in your package.json\n. It's like the code-coverage gods are smiting us for not achieving perfection -_-.\n. Any chance of getting a test with this? Not sure if it should go in `spec/q-spec.js` or `test/` or both though... @kriskowal?\n. @kriskowal Want to take another look at this area?\n. @danfuzz After taking some time to dig in to this, I think you are right that `makePromise.promiseSend` should not be calling `resolve` unconditionally. Have you had time to hack on the source long enough to make that work?\n. OK so I basically merged this fix. But I still think there is some crazy stuff going on inside the `when` and `promiseSend` implementations.\n\nI tried to remove a nesting level as per [Kris's earlier comment](https://github.com/kriskowal/q/pull/76#discussion_r870221) but that broke all the tests. I wonder if fc2ba180fe5b1f86865c6e83b3ddacb6ac0dd29a was the reason they were succeeding for Kris.\n\nAnyway, @kriskowal, @ForbesLindesay, and @danfuzz, would love to hear your thoughts on the deeper issues and possible fixes. For now though a bugfix seemed prudent.\n. I don't think this makes much sense, simply because we have no idea which of the arguments should be resolved in parallel versus not. I.e. should that be\n\n``` js\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    let [A, B, C] = [yield a, yield b, yield c];\n    // ...\n});\n```\n\nor\n\n``` js\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    let [A, B, C] = yield Q.all([a, b, c]);\n    // ...\n});\n```\n\nor\n\n``` js\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    let [A, B] = yield Q.all([a, b]);\n    let C = yield c;\n    // ...\n});\n```\n\nor even\n\n``` js\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    let [A, B, C] = yield Q.allResolved([a, b, c]);\n    // error recovery code for rejected A, B, or C\n    // ...\n});\n```\n. > For a well behaved promise, does it actually make a difference whether they're resolved in serial or parallel?\n\nYou are right, sorry. I was confusing this with the case of calling multiple promise-returning functions.\n\nIt still seems likely that there are significant differences, since each `yield` is a suspension of the execution state of the function and then a reentry later. Perhaps it would simply be a matter of <var>n</var> `nextTick`s for <var>n</var> `yield`s. I'd have to think harder about how generators and `Q.async` work to be sure.\n\nIn that case it sounds like the convenience method you're asking for could be implemented as\n\n``` js\nQ.deepAsync = function (generator) {\n    return Q.async(function *() {\n        var args = Array.prototype.slice.call(arguments);\n        var argsResolved = yield Q.all(args);\n        return generator.apply(this, argsResolved);\n    });\n};\n```\n\n(off the top of my head, untested, might be buggy, etc. disclaimer)\n. @kriskowal re: remote objects and `get`/`post`/etc., I've always thought something like <a href=\"https://gist.github.com/1372013\">this gist</a> was the way to go. Not sure if anyone ever actually turned that into a library, although it looks like @Gozala's meta-promise is a (SpiderMonkey-specific?) realization of it.\n\nThis doesn't really address your concern, but perhaps indicates that `Q.async` + `Q.promised` + meta-promise--like proxy promises could be mashed up into an awesome remote-promises--friendly wrapper.\n. @Gozala Without new syntax, what about something like `files.eventually.filter(...)`. I'm doing something similar in <a href=\"https://github.com/domenic/chai-as-promised/#shouldexpect-interface\">Chai as Promised</a>.\n. @Gozala Haha yes `yield` is how how this whole thread got started :). But I was thinking of the remote promises case where you don't want to actually wait for resolution until the last minute.\n. Closing in favor of #87\n. Should be able to change `\"test\": \"node test/all.js\"` in `package.json` to `\"test\": \"jasmine-node spec\"`. But, I don't know anything about Travis, so I'll leave it up to you.\n. This seems to have been fixed by switching to the `test` line in package.json. Woo!\n\nhttp://travis-ci.org/#!/kriskowal/q/jobs/1443944/L140\n. Let's not forget to remove `test-cover` and rename `spec-cover` to just `cover` in the `package.json` scripts.\n. Makes sense. Could you update the style to conform to the rest of the code (spacing after commas, `if`, and `function`;  double quotes), and be sure to fix all of the \"depreciate\" misspellings?\n. Merged as 8341cd150368052967474e13927b4653bc106a60\n. Oooh, this looks like a cool library. I very well might use it in my projects.\n\nI'm a bit concerned on starting to explode that section of the README. I should, for example, probably add [Dynamo as Promised](https://github.com/domenic/dynamo-as-promised/) and maybe [Chai as Promised](https://github.com/domenic/chai-as-promised/). [Capsela](https://github.com/capsela/capsela) is also cool. Maybe we should move it to a wiki? As a bonus, then people could add their projects at will.\n. I like the ideas, and the enthusiasm, but I think one major outstanding factor is that Q isn't complete. The three pieces I want to finish, and I know Kris is on board with, are:\n- Long stack traces\n- Cancellation\n- Progress\n\nProgress I am almost done with; just need a solid few hours to get on. Long stack traces I started, and so should probably continue, although I don't have anything in progress at the moment. Cancellation is more unsure: we don't even know the best approach, especially in light of the security implications.\n\nRegardless, tidying up outstanding issues is definitely a priority. I'll try to close out this one now.\n. Have you done heap snapshots of this? I'd expect that after the timer fires, it would be automatically cleared by the browser. (And even if the deferred is resolved before the timeout, the timer will still fire.) I suppose this would free the memory sooner, so it's worth pulling in regardless, but I'm curious as to whether we actually have a leak or just are holding on memory longer than we have to.\n. Huh, interesting. Well, thanks!\n. Merged with some small style fixes as d920b30b27e49a75232a072891e200165d8619f9\n. Thanks @MattiSG, merged with some formatting fixes as 6d0c67f17ea337691f7aee41e4f87537822e1c34\n. I'm curious what @kriskowal has to say, but my impression was that `put` is supposed to be analogous to the ECMAScript [[Put]] operation, which has a CompletionValue equal to the value that was put. See e.g. [the concurrency strawman](http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#syntactic_sugar) on the ECMAScript wiki.\n. I'm not sure I understand the distinction?\n. No use of `put` in any of my many promise-using projects, including some very large closed-source codebases at work.\n\nI think the real use case is for remote objects (cf. q-comm) where it can avoid round-trips. I also like it (as-is) just from a theoretical perspective because of the parallel semantics thing, but as @kriskowal mentioned, that's been deemphasized over time.\n\nIs Mark Miller on GitHub? I feel like his input would be valuable since this area of Q is rather motivated by his work.\n\nMy default position at this point is to accept the patch though, since as Kris says, this is strictly more useful.\n. We found a use for `put`:\n\nhttps://github.com/NobleJS/WinningJS/blob/4cfb415109cb371e25ae184ea252adf4b92de7cc/lib/ui/components.js#L43\n\n:D\n. I am +0. Maybe take it to the q-continuum mailing list for more opinions?\n. I agree this is an issue; `Q.fcall` is not a very intuitive function, even though once you really \"grok\" Q, it's quite a useful one. So I am not quite sure the best approach. Let me give a bit of background and perhaps we can work together toward a better explanation.\n\nAll promises can come from either deferreds or `Q.fcall`, essentially. (The other static helper methods, like `fapply`, `fbind`, `napply`, `invoke`, etc. etc. all delegate to `fcall`.) And `Q.fcall(f)` produces a promise, based on `f`, in one of three ways:\n1. If `f` returns a non-promise, it gives a promise resolved with that value as its fulfillment value.\n2. If `f` throws an error, it gives a promise resolved with that error as its rejection value.\n3. If `f` returns a promise, it gives a promise deferred to that returned promise.\n\nSo your example doesn't quite work, because `setTimeout` doesn't return a promise. `Q.fcall` doesn't have any capabilities for adapting callback-based code. Now, if you did\n\n``` js\nQ.fcall(function() {\n  return Q.delay(50).then(function() {\n    return 5;\n  });\n});\n```\n\nthen _that_ would work, because of 3 above. But it's kind of funny because the promise returned by `Q.delay` is created via a deferred. So it is really just illustrating the deferred case all over again.\n\n---\n\nMaybe a better approach would be to avoid explaining `fcall`, since it's a more advanced feature. The section \"Using `Q.fcall`\" really could be replaced with one explaining `Q.resolve` and `Q.reject`.\n\nAlternately, we could do that replacement, but then add a new, separate \"Using `Q.fcall`\" section that explains what it's really for: taking a synchronous function, or a function that is sometimes-synchronous and sometimes-async, and turning it into a async (promise-returning) function. The example there would be something like\n\n``` js\nvar url = getUrl();\n\nvar promise = Q.fcall(function () {\n    if (!url) {\n        throw new Error(\"Must supply a URL\");\n    }\n    return Q.when($.ajax(url));\n});\n```\n. Yes, wrapping around callback APIs is best done with deferreds. We have some nice helpers for Node-style callbacks (`Q.nbind` etc.), but your XHR example is a good one.\n\nIf you'd like to put it in a gist and add it to the [examples gallery](https://github.com/kriskowal/q/wiki/Examples-Gallery), that would be awesome! And we'll use this issue as a reminder to include the examples gallery somewhere prominent in the readme.\n\nEDIT: oh wait, it looks like we [already have such an example](https://gist.github.com/593076)! Wow, we really need to link to the example gallery.\n. > That way if cb is undefined, we return a promise for someone to use, but if it is defined, we call it in the normal node style.\n\nThat is really cool.\n. > Oh, not necessarily Node\u2019s CPS style. `.end(callback, errback)` is what I have in mind\n\nThis is the same as WinJS's `.done` and pretty similar to jQuery's `done` (which just doesn't have an `errback`). Should we consider renaming it?\n. I'd say `.done(callback, errback)`, `.nodeCallback(nodeCallback)`, and maybe keep `.end()` for compat? So far we've been good about keeping node idioms prefixed.\n\nMaybe `.nend(nodeCallback)`, but it's not really the same as `.end()`, whose purpose is to guarantee errors are never silenced---if you did `.nend(function () { })`, you'd silence the error.\n\n@kriskowal, thoughts? Agreed on `.done()`?\n. After sleeping on it for a few days, I like `.done(callback, errback)` and `.ndone(nodeCallback)`. We'd deprecate `.end` (and remove in the next major).\n. Some initial work here. https://github.com/domenic/q/compare/done\n. Yup, that makes sense. I need a test \"when the promise is fulfilled / and the callback throws / it should rethrow the error in the next turn\", and then I need to implement all three of the \"it should rethrow the error in the next turn\" tests.\n. My original plan was for `ndone` to replace `nend`. But as @medikoo points out, `nend` returns a promise. This, I believe, is designed to enable APIs like that of [node-flurry](https://github.com/tlrobinson/node-flurry), [like so](https://github.com/tlrobinson/node-flurry/blob/master/flurry.js#L45-59).\n. To summarize and bring in some thoughts:\n\n### `.done(f, r, p)`\n\nActs like `then` except that it does not return anything, and causes a next-tick-throw upon rejection. Equivalent to today's `.then(f, r, p).end()`. Replaces `.end()` since `.done()` is equivalent.\n\nMatches WinJS. Similar to jQuery's `.done(f[, f, f, ...])`, which notably returns the original promise.\n\n### `.ndone(cb)`\n\nWas envisioned as `.then(function (x) { cb(null, x); }, cb).end()`, or as `.end()` alone if no `cb` is passed.\n\n### `.nend(cb)`\n\n[Check out the implementation](https://github.com/kriskowal/q/blob/a7596e045cb0ba722ac376e46856698fd55fe41a/q.js#L1579-1593)\n\nThings to note:\n- If `cb` is falsy, it will return the original promise. This is useful as we'll see below.\n- The use of `nextTick` escapes the handler-catchers, so that errors thrown in the callback jump to the top of the stack (Node-style).\n- It's not very `end`-ey: without a callback, it acts nothing like `end`.\n\n### On `nend` or `ndone` enabling dual APIs\n\n`nend` currently enables dual APIs like so:\n\n``` js\nfunction asyncFunc(a, b, c, cb) {\n    return promise.nend(cb);\n}\n```\n\nThis is very nice.\n\nIf we were to move to `ndone` as part of a move to `done` a naive translation no longer works, since\n\n``` js\nfunction asyncFunc(a, b, c, cb) {\n    promise.ndone(cb);\n    return promise;\n}\n```\n\nwill throw-in-next-tick if promise ends up being rejected, denying any promise-using callers a chance to handle rejections. This makes me think `ndone` is pretty useless.\n\n### Recommendation\n\nWhereas,\n- `nend` as it exists is awesome, but it is named confusingly since it doesn't behave like `end` at all;\n- `done` is still a good idea and a good replacement for `end`;\n- `ndone` turns out to be useless;\n\n**I think we should replace `end` with `done` and do nothing else.** Keep `nend` named as it is, since there will no longer be a `end` to confuse matters. And forget about `ndone`.\n. - nodeify\n- maybeNodeify\n. @ForbesLindesay remember we playing the old-browser compat game so no `Function.prototype.bind` allowed. Wouldn't want to leave those Safari users out.\n. @ForbesLindesay want to get this in as a pull request, and claim all the glory? Let's defer `npromised` until someone asks for it.\n. Closes by #87\n. Actually `errors` will always be empty at the point in time that line is run; Q is still initializing. The idea is to output the array which might change later, since Web Inspector at least will auto-update the array's contents if they change over time.\n. Sounds good, although that link 404s @kriskowal.\n. @kriskowal I think enough bugfixes have accumulated that we should do a push. I guess I'll try to update the CHANGES.md, then you can do the npm publish?\n. @kriskowal I'm domenicdenicola on npm. Sounds good!\n. Thanks!\n. Oh eek, nice catch. Want to squash and force-push before I merge?\n. Yeah just these two :)\n. Remember that `then` takes a function, so you presumably meant `.then(function (a, b, c) { /* ... */ })`.\n\nBut even with that, this would be explicitly against Q's goals. Promises are supposed to [provide a direct correspondence with synchronous code](http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript). In particular:\n- There is only one fulfillment value because synchronous functions only have a single return value.\n- There is only one rejection reason because synchronous functions only throw a single exception.\n- You can only either fulfill or reject, not both, because synchronous functions only either return a value or throw an exception.\n\nUnfortunately another popular library did not quite get on board with this aspect of promises in implementing their own version of them, and so we have confusion. But a proper Promises/A compliant library like Q maintains this parallel, and thus will only allow a single fulfillment value.\n\n(Bonus question: `deferred.resolve` can take a promise. What happens if I do `deferred.resolve(rejectedPromise, fulfilledPromise, scalarValue)`? Bad things is what.)\n\nHope that helps! :)\n. [The one which must not be named](https://github.com/kriskowal/q/wiki/Coming-from-jQuery)\n. Wow, nice work! If you could just clean up the style to conform to the rest of the file, I'd be happy to merge.\n\nItems of note:\n- Four-space indent instead of two\n- Use function declarations when possible instead of function expressions (`captureLine`).\n- Space between `)` and `{`\n- Always use curly braces, even for single-line blocks.\n- Leave the declaration of `captureLine` down in the same area as the rest of the long stack trace stuff; using it before it's declared is OK (as long as you switch to a function declaration).\n\nThanks for this! Very cool.\n. I like this, and it certainly [would make testing easier](https://github.com/kriskowal/q/blob/5701e1975134d3bd46929365ee2a0cd47e918bc3/spec/q-spec.js#L1056-1081). Let's get some buy-in from @kriskowal before merging, but I'm sure it'll get in in some form.\n\nThe only question I have is whether there should be a single global error handler, which multiple users of Q can overwrite, or whether it should be an event-dispatching system where multiple calls to `Q.onError` result in multiple listeners being registered. I can see arguments either way.\n. @kriskowal, I'd really like something like this. One more consideration: #111 calls for something like `Q.stackJumpLimit = 5`.\n\nIn light of these two, I see two options:\n1. Un-defend `exports`, perhaps selectively making all existing properties non-writable and non-configurable. This allows us to align with existing APIs a bit better, viz. `window.onerror` and `Error.stackTraceLimit` as settable properties.\n2. Introduce a `Q.configureErrors({ uncaughtTrap, stackJumpLimit })` call.\n. LGTM. @kriskowal, any objections?\n. All tests pass, merged.\n. Yeah this is definitely wrong. Maybe a better version would be\n\n``` js\nreturn foo()\n.then(function (info) {\n    return [info.name, FS.read(info.location, \"utf-8\")];\n    // FS.read returns a promise, so this array\n    // mixes values and promises\n})\n.spread(function (name, text) {\n})\n```\n\n@kriskowal?\n. Is this on master or on 0.8.5? There have been so many fixes to problems like this on master... It should hopefully not happen there.\n\nOn Jul 30, 2012, at 10:04, \"Forbes Lindesay\" reply@reply.github.com wrote:\n\n> ``` javascript\n> var Q = require('q');\n> \n> function CustomError() {\n> }\n> \n> Q.when(null, function () {\n>    throw new CustomError();\n> }).end();\n> ```\n> \n> produces the output:\n> \n> ```\n> C:\\src\\>node experiment\n> \n> C:\\src\\node_modules\\q\\q.js:1299\n>                var combinedStackFrames = errorStackFrames.concat(\n>                                                           ^\n> TypeError: Cannot call method 'concat' of undefined\n>    at exports.timeout (C:\\src\\node_modules\\q\\q.js:1299:60)\n>    at process.startup.processNextTick.process._tickCallback (node.js:244:9)\n> ```\n> \n> Any ideas?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/kriskowal/q/issues/98\n. Yeah, there's a whole protocol for inheriting from `Error`, especially in V8. See http://www.devthought.com/2011/12/22/a-string-is-not-an-error/\n\nI am 95% sure it's impossible to attach a stack trace after the fact---that's the point of `Error.captureStackTrace`, after all.\n\nI believe Q is just as well-behaved as regular code here; if you have a custom error that doesn't call `Error.captureStackTrace` and throw it in synchronous code, you won't get a stack trace either.\n. Meh, I'm over it.\n. Squash and force-push for great justice? :)\n. I don't quite understand what this would do or what the use case is?\n. Would #94 work?\n\nOr perhaps this is really about how errors passed to rejection handlers need a long-stack-traced `.stack` property.\n. I see what you mean. To clarify, part of the intention there is that you should usually be able to just use the convenience methods, like `Q.ncall` or `Q.ninvoke`. But yes, it's not quite a last resort.\n. No real ideas off the top of my head, but FWIW this is definitely on my weekend to-do list.\n. Does this mean Promises/A implementations cannot interop without valueOf/nearer implementations?\n\nOn Aug 23, 2012, at 19:37, \"Kris Kowal\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\n@briancavalierhttps://github.com/briancavalier I\u2019ve reproduced and came to the same conclusion. There is a cycle where Q and When are taking turns coercing eachother\u2019s promises with their resolve methods. As part of this process, they both call .then on the other.\n\nwhen can break the cycle by attempting to normalize the promise to a fulfilled value with promise.valueOf(). I\u2019ll send a patch. I imagine Q could do something similar, but I don\u2019t see an implementation of valueOf or nearer.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/106#issuecomment-7987962.\n. Are you asking for something like this?\n\n``` js\nQ.ninvoke(mysql.connection, \"query\", \"SELECT * FROM table\").then(function (rows, fields) { ... });\n```\n\nThe problem is, promises are always either fulfilled with a single value, or rejected with a single reason. Just like normal functions only return a single value, or throw a single error. So the above code would be impossible, since it would involve a promise being fulfilled with more than one value---which would be like a function returning more than one value!\n\nThe solution, as seen in Q, is to transform such situations into arrays (just like you might do for a sync function that needs to return more than one value). We even have a shortcut to make things easier:\n\n``` js\nQ.ninvoke(mysql.connection, \"query\", \"SELECT * FROM table\").then(function (results) {\n    var rows = results[0];\n    var fields = results[1];\n    // ...\n});\n```\n\nis equivalent to\n\n``` js\nQ.ninvoke(mysql.connection, \"query\", \"SELECT * FROM table\").spread(function (rows, fields) {\n    // ...\n});\n```\n\nSee [the README](https://github.com/kriskowal/q#combination) for more details.\n\nDoes this help?\n. I believe we already do, actually:\n\nhttps://github.com/kriskowal/q/blob/939b7ca64f6c4714b82865e941f8d9eda6af536d/q.js#L522-526\n. The cases in which we would have used this are all pretty much\n\n```\nreturn Q.all([...]).thenResolve();\n```\n\nwherein we just want to wait for a bunch of operations to complete, and give a promise that succeeds if they do, but don't want to expose their fulfillment values (if any), or (more likely) an array of `undefined`s.\n. Do we like this? I'm +0 (as opposed to -0). Let's make a decision.\n\n---\n\n>  I agree that we need to exercise caution with bloating the library. I wonder if we could split it into two files (Core and Extensions)?\n\nIn general I wish we could split Q up into multiple files. I'd envision something like:\n- core.js --- core promise object, deferred, when/then\n- sugar.js --- catch, finally, done\n- objects.js --- get, put, del, keys\n- arrays.js --- all, allResolved, spread\n- functions.js --- post, invoke, fapply, fcall\n- node.js --- nbind, nfcall, nfapply, ninvoke, npost, ndone, deferred.makeNodeResolver\n- utility.js --- timeout, delay, promised\n- stackTraces.js --- long stack traces\n. @kriskowal You could still do it, you'd just have something like\n\n``` js\n// core.js\nexports.Promise = function () { };\n\n// sugar.js\nvar Promise = require(\"./Promise\");\nPromise.prototype.catch = function () { };\n\n// q.js\nexports.Promise = require(\"./core\").Promise;\nrequire(\"./sugar\");\n```\n\nor similar.\n. Dupe of #88\n. Yup, dupe of #88 essentially. Thanks for the input though---it's good to hear that this is a pain point for others.\n. Nice detective work. As for the fix, we should probably either respect `Error.stackTraceLimit` or implement a counterpart to it for Q stack traces (e.g. `longStackJumpLimit`).\n. Well, but the point of `Error.stackTraceLimit` is somewhat different.\n\nIf you write non-Q code, even with long callstacks, you wouldn't run into this. With, say, `Error.stackTraceLimit === 10`, it would cap at 10 levels of stack traces, and memory usage would stay constant. That is, memory usage is `O(Error.stackTraceLimit) = O(1)`.\n\nBut we capture multiple stack traces, one for each \"jump\" between short stack traces, so memory grows linearly. That is, memory is `O(n * Error.stackTraceLimit) = O(n)`.\n\nWe could use `Error.stackTraceLimit` as an indication that you don't want memory to grow any further than that. I'm not sure we could do that accurately without triggering the getter---that is, to determine the actual length of each component stack trace, I think we'd need to look at the stack trace. But we could limit the number of stack jumps to `Error.stackTraceLimit`, giving a total possible memory consumption proportional to `Error.stackTraceLimit * Error.stackTraceLimit`. Or we could introduce `longStackJumpLimit` or similar, giving memory consumption proportional to `longStackJumpLimit * Error.stackTraceLimit`.\n. OK, this is harder than I initially thought. I think it will require a redo of the long stack trace logic. Jotting down some notes here, both for myself and for anyone to comment on.\n\n---\n\n**The current approach** is to attach a `stack` property to every promise, essentially recording the stack at the time of its creation. (This is done in `defer`, where all pending promises come from. NB why don't we capture fulfilled and rejected stacks??)\n\nWe actually _do not_ support more than one level deep of long stack traces. That is,\n\n``` js\nQ.resolve(5)\n.then(function () { return 10; })\n.then(function () { return 20; })\n.then(function () { throw new Error(\"boo!\"); })\n.done();\n```\n\nonly generates\n\n```\nC:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\\q.js:1436\n                throw error;\n                      ^\nError: boo!\n    at C:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\\test.js:8:27\nFrom previous event:\n    at Object.<anonymous> (C:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\\test.js:8:2)\n```\n\nThis can clearly be seen by looking at the implementation of `done`: it just concatenates the error's stack trace with the promise's stack trace. It has no way of looking back in the history to find previous promises in the chain.\n\n**I'd like to fix this.**\n\n---\n\nBut, **why is the current approach \"leaking\"?**\n\nIt doesn't really make sense, if we only use the last stack trace, for us to keep around memory for every stack trace. Why is this happening? If @ef4 is right and commenting out `Error.captureStackTrace` keeps the memory constant, why is that? I'd expect it to still grow linearly, just with the increment being the size of a promise, not size of a promise + stack trace.\n\nThe key question: is the `test` function preventing the GC of 1000 promises inherently, or is it due to the stack traces?\n\nIs it possible that by using these not-yet-serialized stack traces we're keeping references to closures and scope that keep the promise alive, even though we've since chained off it and moved on? **Test this** by serializing the stack trace.\n\n---\n\nRegardless, this needs a rewrite. The current architecture leaks _and_ doesn't give you anything useful for your leaks; i.e. it only gives you one jump.\n\n**New strategy:** each promise gets a chain of _serialized_ stack traces, probably pre-concatenated. This can be capped using `Q.stackJumpLimit`.\n\nGetting access to the existing chain is the tricky part. Currently we hook into `defer`, but that won't really suffice, since a deferred has no knowledge that it's being created in order to react to a previous promise in a chain. We'll probably need to hook in to a few places, with `when` being the primary candidate. That is, `var promise2 = when(promise1)` can transfer `promise1`'s stack chain to `promise2` for `promise2` to build upon, and chop off the beginning if we're starting to exceed `stackJumpLimit`.\n. WOW. It is indeed preventing GC because of the unserialized stack traces. That is, if I change\n\n``` js\nError.captureStackTrace(promise, defer);\n```\n\nto\n\n``` js\nError.captureStackTrace(promise, defer);\npromise.stack;\n```\n\nthe memory usage stays low. That means by doing #117 this bug should be fixed. We remain with the fact that there's only one stack jump level, but that's actually pretty orthogonal.\n. Just got a chance to look at your hack\u2014it's very impressive. I don't think it would work as a by-default feature due to memory concerns, but I'm inspired to think about adding it to a debug mode (maybe a separate Q-debug package that includes your hack and others?). I'll have to let this roll around in my head for a few days\u2026\n. Oh interesting, I hadn't considered that case. Yeah we don't (and shouldn't) to any forwarding for `Q.all`, but even more basic cases like yours introduce some difficulties. Will test and report back.\n. Here's a demo of that:\n\nhttp://jsfiddle.net/cLtNS/1/\n\nIt looks like it emits progress from `fast`, then any progress from `slow` that hasn't already happened while `fast` was unresolved.\n. Next step is to see what the other progress-using promise libraries (jQuery, When, WinJS) do.\n- jQuery emits progress from `fast` then all-at-once emits progress from `slow` that happened while `fast` was unresolved, then emits the rest of the progress from `slow` at its own pace: http://jsfiddle.net/8GkkE/1/\n- When emits progress from `slow`, but only those after `fast` resolves: http://jsfiddle.net/qe9F3/1/\n. > I'm planning to add progress propagation to Dojo 1.8.1. If the progback returns a non-undefined value, that value is emitted as a progress update on the returned promise.\n\nThe problem with this approach, I would think, is that it doesn't address my first example in #113. Namely, the following works:\n\n``` js\npromiseWithProgress\n.progress(console.log)\n.finally(function () { })\n.end();\n```\n\nwhereas the following does not:\n\n``` js\npromiseWithProgress\n.finally(function () { })\n.progress(console.log)\n.end();\n```\n\nThis seems counterintuitive to me and makes using the shortcut functions (`finally`/`fin` or `catch`/`fail`) very error-prone since doing so throws away progress information.\n. > IIRC deferreds only have single resolution, rejection or progress values.\n\nIf you recall _what_ correctly? Promises/A gives no guidance. On the other hand all libraries but jQuery do have single progress values (and jQuery doesn't count, they don't even have single fulfillment values or rejection reasons). [More discussion on Q Continuum](https://groups.google.com/d/topic/q-continuum/kjQM__NM2PA/discussion).\n\n> In Dojo the progress is pass-through if there is no progback registered.\n\nThis makes sense, but I'm not sure I gather the exact semantics of the transformation. How does this behave?\n\n``` js\npromise.then(null, null, function (x) {\n    return Q.delay(1000).then(function () { return x + 10; });\n})\n.then(f, r, p);\n```\n\nDoes `p` receive a promise, or the eventual value? In particular can `p` be called after `f`/`r`?\n. > I'm not familiar with the promise.progress() syntax you use, so allow me to give an example:\n\nSorry, `promise.progress(p)` in Q is just sugar for `promise.then(null, null, p)`. I'll edit for clarity. The example I gave was trying to figure out how returning a promise from a progressback behaves. Any feedback on that?\n\nI agree that notifying a deferred of progress (`deferred.notify()` in Q) after it's already been resolved should be a noop.\n. Superceded by #125.\n. See also promises-aplus/unhandled-rejections-spec#6\n. #121 is probably worth merging as a stopgap before I do more extensive stack trace-related work, but I need to get `Q.onerror` working first as a revision of #94. Will work on it tonight.\n. What is the role of `Q.when` in this new world?\n\nEDIT: nevermind, silly question, `resolve` doesn't take any other arguments whereas `when` does.\n. This already works without us doing anything, I think because `process.nextTick` is used. @mikeal or @isaacs feel free to confirm/deny.\n\nThis test passes:\n\n``` js\ndescribe(\"node domain support\", function () {\n    it(\"should work or something\", function (done) {\n        var error = new Error(\"should be caught by the domain's handler\");\n        var domain = require(\"domain\").create();\n\n        domain.run(function () {\n            Q.resolve().done(function () {\n                setTimeout(function () {\n                    throw error;\n                }, 10);\n            });\n        });\n\n        var errorTimeout = setTimeout(function () {\n            done(new Error(\"Wasn't caught\"));\n        }, 100);\n\n        domain.on(\"error\", function (theError) {\n            expect(theError).toBe(error);\n            clearTimeout(errorTimeout);\n            done();\n        });\n    });\n});\n```\n. @ForbesLindesay I don't quite see what you're getting at? E.g. what would be a potential test case.\n\nAlso I just realized I totally forgot bullet point 1 in my OP. It probably works though. Lemme add another test.\n. @mikeal is there a simple async function we can call (or setup we can create) to exhibit this behavior, without dragging in a redis library? E.g. some way I could modify [the test case above](https://github.com/kriskowal/q/issues/120#issuecomment-10685555) to use something other than `setTimeout` and somehow escape the domain.\n. Would love some sample code there when you get the time; I still can't quite imagine how that works.\n\nSince `nextTick` is already trapped and all Q callbacks get called in `nextTick`, it seems likely we're already OK. But better safe than sorry.\n. @isaacs would this also be a fix?\n\n``` js\nfunction beep(cb) {\n  e.once('beep', function () {\n    var args = arguments;\n    process.nextTick(function () {\n      cb.apply(null, args)\n    })\n  })\n}\n```\n\nIf so I imagine Q is already fine as we do something similar.\n\nIn either case thanks so much for taking the time to give a nice example and talk us through the problem. I think it'll be worthwhile adding to Q (if we don't have it working already); it'd be far from the first unnecessary cost we've taken on ^_^\n. OK I fixed @ForbesLindesay's test (had to modify it slightly to get it to fail):\n\n``` js\nit(\"should take care of re-used event emitters with `done`\",\n   function (done) {\n    var error = new Error(\"should be caught by the domain\");\n\n    var e = new EventEmitter();\n    setTimeout(function () {\n        e.emit(\"beep\");\n    }, 100);\n\n    d.run(function () {\n        callAsync().done();\n    });\n\n    var errorTimeout = setTimeout(function () {\n        done(new Error(\"Wasn't caught\"));\n    }, 500);\n\n    d.on(\"error\", function (theError) {\n        expect(theError).toBe(error);\n        clearTimeout(errorTimeout);\n        done();\n    });\n\n    function callAsync() {\n        var def = Q.defer();\n        e.once(\"beep\", function () {\n            def.reject(error);\n        });\n        return def.promise;\n    }\n});\n```\n\nBut I am trying to think if there is a case involving just `then`, analogous to [this passing test](https://github.com/kriskowal/q/blob/9cadca7060e6b8240ad7c72a777e67d21c836c8e/spec/q-spec.js#L1751-L1773), that we should be handling. @ForbesLindesay ideas?\n. Do you think it's possible to get this to pass? I couldn't, on first try:\n\n``` js\nit(\"should take care of re-used event emitters with handlers\",\n   function (done) {\n    var error = new Error(\"should be caught by the domain\");\n\n    var e = new EventEmitter();\n    setTimeout(function () {\n        e.emit(\"beep\");\n    }, 100);\n\n    d.run(function () {\n        callAsync().done();\n        Q.resolve().then(function () {\n            e.once(\"beep\", function () {\n                throw error;\n            });\n        });\n    });\n\n    var errorTimeout = setTimeout(function () {\n        done(new Error(\"Wasn't caught\"));\n    }, 500);\n\n    d.on(\"error\", function (theError) {\n        expect(theError).toBe(error);\n        clearTimeout(errorTimeout);\n        done();\n    });\n});\n```\n. Meh. If someone is really using domains and Q together and runs into an edge case where we didn't manage to make it work, they can bring it to our attention. I think we knocked out most of this.\n. Related: #117\n. OK, now that we've got a global error trap on the way, this can go through. Feel free to touch it up as per my comments in preparation for that, and I'll merge it as soon as @kriskowal code-reviews #124.\n. A promise one primary axis of state:\n\n**Resolved** vs. **deferred**\n\nIf the promise is resolved, then it has another axis:\n\n**Fulfilled** vs. **rejected**\n\nYou are probably looking for `Q.isFulfilled()` instead of `Q.isResolved()`.\n. > Sorry, but this makes no sense. There are two distinct ways to complete a defer, either reject, or resolve.\n\nYou can resolve a deferred with a promise. In this case, two things happen:\n- If the passed promise is already resolved, the underlying-promise adopts its state, becoming itself resolved.\n- If the passed promise is still pending, the underlying-promise stays in the pending state, waiting on the passed promise to resolve before adopting its state.\n\nNotably, you can call `deferred.resolve(Q.reject(new Error()))` to achieve the same effect as `deferred.reject(new Error())`. In this sense `deferred.reject` is just sugar; the only thing you can do with deferreds is resolve them. The effect on the underlying promise---whether it will be resolved, or stay pending---is determined by what you resolve the deferred _with_.\n\n> \"A promise one primary axis of state:\", that statement makes me think you agree with me, it should either be resolved, or rejected NOT both?\n\nYou seem to have missed the subsequent line, where I explained that this axis is not resolved vs. rejected, but resolved vs. deferred. A promise can either be resolved or deferred, but not both. Similarly, it can be either fulfilled or rejected, but not both. Resolved can mean either rejected or fulfilled, however.\n. > OK, so I should think of reject as resolveWithRejection :), thanks for taking the time to go through it\n\nYeah that's pretty much it :). Thanks for sticking with me!\n. Well, the confusing thing is that \"resolve\" as a verb only applies to deferreds, whereas \"resolved\" as a state only applies to promises. :-/\n\nI agree that a `promise.isPending()` might clarify things, but that would just be the same as `!promise.isResolved()`, so it's not that helpful.\n\n@kriskowal may have more to say, but glad I could get you moving in the right direction :)\n. Yeah, jQuery has made a decision to ignore the Promises/A standard, so we can't really do much besides tell people to assimilate them with `var qPromise = Q.when(jQueryPromise)` and then move into comfortable territory where things like error propagation actually work.\n. LGTM, definitely an improvement once I realized `nend`'s return value is a useless always-fulfilled promise.\n. @kriskowal updated to propagate `undefined`s (and rebased on master).\n\nTwo remaining questions:\n1. Should returning `undefined` (or not returning) stop propagation? I.e. no progress handler should propagate the old value, but maybe a handler that doesn't propagate should stop propagation instead of continuing to trigger progress handlers, just with the `undefined` value for the argument.\n2. How should we handle throwing an exception in the progress handler?\n. Merged but opened #136 to address the still-rather-pressing exception question.\n. Do we want to just remove `nend` in 0.8.10, assuming it hasn't gotten too much adoption, or should we deprecate until 0.9?\n. What's left:\n\n``` js\n// in `makeNodeResolver`:\n              self.resolve(array_slice(arguments, 1));\n```\n\nAll of `Q.promise`.\n\n`makePromise.prototype.toSource` (do we care?)\n\nAll of `Q.master`.\n\nThe second `if (done) { return; }` in `Q.when`.\n\nAll of `Q.async` and `Q.return`.\n\nThree lines of `Q.timeout`, covering both error cases (the timeout and the original-promise rejection).\n\nAnd a bunch of shims and alternative <del>lifestyles</del> module loaders we don't care about.\n. I'm happy with how things are now. Curious why I couldn't write a test that covered the second `if (done) { return; }` in `Q.when`, but whatevs.\n\nI'll leave it up to you to decide whether the things I left are worth keeping this bug open as a reminder for or not. It's pretty much:\n- the second `if (done) { return; }` in `Q.when`\n- `Q.master`\n- `Q.async` and `Q.return`\n- `makePromise.prototype.toSource`\n. No tests? :(\n. I think we generally update the readme when doing a new release, but yes, this is a good idea.\n\n(The wiki, actually, gets updated rather infrequently :(.)\n. This seems like a horrible bug to me; nice catch. @kriskowal?\n. Can't we just only call `valueOf` on promises?\n. Related: promises-aplus/promises-spec#18\n. Working on fixing this test...\n\n``` js\n    it(\"should not convert `Date` instances to milliseconds\", function () {\n        var promise = Q.resolve(new Date(2012, 10, 4));\n        expect(promise.valueOf()).toEqual(new Date(2012, 10, 4));\n    });\n```\n. OK, fixed, but in the course of fixing this I think I came around to believing that yeah, `valueOf` is no longer a good name for this function. `nearer` seems reasonable.\n. Wow, I didn't know we returned promises from `deferred.(resolve|reject)`. And I think it's clearly a bug that we return differently each time. I'm definitely in favor of always returning `undefined`; @kriskowal?\n. If I understand correctly, the problem comes because we're doing:\n\n``` js\nforeignPromise.then(myDeferred.resolve, myDeferred.reject, myDeferred.notify)\n```\n\ninstead of\n\n``` js\nforeignPromise.then(\n  function (v) { myDeferred.resolve(v); },\n  function (r) { myDeferred.reject(r); },\n  function (p) { myDeferred.notify(p); }\n);\n```\n\nShouldn't we just change our libraries to do this instead? Then we're agnostic to what each others' deferred methods do.\n. Some options:\n- Ignore them, or log them, but don't let them have substantial impact. (Maybe pass to `Q.onerror` if it exists.)\n- Throw in `nextTick`. Not great since an error in the progress handler doesn't seem fatal, conceptually, but this will bring down your app in Node.js or Windows 8.\n- Transform the returned promise into a rejection. This is what I favor, simply because the other options kind of suck. @briancavalier thinks that progress handlers should not be allowed to effect the state of the returned promise though (i.e. they're not as important as fulfillment or rejection handlers); I can see that logic.\n\n[Previous discussion in the when.js group](https://groups.google.com/d/topic/cujojs/QurUiAeTa5E/discussion)\n. > That leads to the obvious next question of what happens when the head does start to unwind? IOW, what should happen when p1 fulfills or rejects? Promises/A+ says that handleFulfilled1 or handleRejected1, respectively, must be called. But what do we do with the result (be it a return value or a thrown exception), since p2 has already been rejected?\n> \n> This seems like a huge problem: No one can observe the result of handleFulfilled1 or handleRejected1\n\nThis convinces me: the progress handler cannot control the state of the promise.\n\nThrow in `nextTick` is possibly the best option now. Or remove progress entirely, but, I dunno, it's so convenient...\n. WinJS swallows them, for the record.\n\nWhen.js propagates thrown exceptions as progress values.\n\nDojo, from what I can tell [by inspection](https://github.com/dojo/dojo/blob/master/Deferred.js), rejects `p2`.\n. I mean, it's a shame to have less features than any other promise library, even if those features are problematic. Q is, after all, the grandaddy of promise-libraries when it comes to features.\n\nPut another way, the reason I originally got off my butt and added promise support was because WinJS had it, and I needed to assimilate some WinJS promises with progress. I can imagine someone coming from jQuery and having similar sadness.\n\n@kriskowal any thoughts?\n. BTW this is the last item on the 0.8.11 release list :). Once we figure it out we can move on to 0.9, i.e. the \"kill all the deprecated methods!\" release.\n. I'll try running it by the continuum then but my natural instinct is to throw in `nextTick`, as dangerous as that can be.\n. Q doesn't have a build process; the error in the logs is:\n\n```\n8879 error EEXIST, mkdir '/Users/dmarr/Documents/Minion/node_modules/q/node_modules/jshint/node_modules/cli/node_modules/glob/node_modules/mkdirp/node_modules/tap/node_modules/deep-equal/node_modules/tap/node_modules/tap-runner'\nFile exists: /Users/dmarr/Documents/Minion/node_modules/q/node_modules/jshint/node_modules/cli/node_modules/glob/node_modules/mkdirp/node_modules/tap/node_modules/deep-equal/node_modules/tap/node_modules/tap-runner\nMove it away, and try again.\n```\n\nIt sounds like a transient error in the installation. Did you retry a few times, after deleting your existing installation and doing an `npm cache clean`?\n\nYou can also try\n\n```\nnpm install q --production\n```\n\nto avoid getting the devDependencies, which are what's causing this problem.\n. I've noticed similar issues. Is `deprecate` broken?\n. I'm not sure the second stack trace is _our_ error; it sounds like they have an `undefined` that they're trying to call `.end()` on. Calling `done` wouldn't work either.\n\nMaybe that one is caused by removing the return values of `deferred.(resolve|reject)`?\n. Ah yes. As predicted, it's caused by us removing the return value of `deferred.resolve`. Details in karthikv/nodefront#28.\n. Well, now that [we know how to solve the infinite-loop-assimilation issue](https://github.com/kriskowal/q/issues/135#issuecomment-10055952), we can go back to returning the promise. We should avoid the behavior @briancavalier pointed out where we are inconsistent about returning it or not, however.\n. In that case I'd say just use try to jump on cases like this as they occur and leave it as-is. After all, we're pre-1.0, so semver says we can do anything we want at any time :P. People who aren't pegging to a specific version deserve what's coming to them!!\n\n&lt;/cowboy&gt;\n. Wow, nice catch. Let's do `typeof value.valueOf !== \"function\"`.\n\nFeel free to submit a pull request with tests; otherwise we'll try to get this done soon.\n. @ForbesLindesay Yes, because Q's `isPromise` is a bit misnamed; it really means `isPromiseProducedByQ` or perhaps more accurately, `hasAPromiseSendMethod`.\n. @kriskowal except for `Date`s...\n. Nah I'm happy leaving `promise#valueOf` as a Q extension, just like `nodeify` or `catch` or the like.\n. Thanks, committed as 46a0366f0997d29b12fd00cbc57afa1e86e7e258.\n. Can you produce a test case we can work on that doesn't depend on an external library like mongoMqDb?\n. This is a historical artifact. Thanks for pointing it out; we'll see what we can do to address the inconsistency.\n\nWe used to have `Q.call(func, thisP, ...args)` (and still do, behind a deprecation warning). Thus its counterpart was `Q.ncall(func, thisP, ...args)`.\n\nHowever, we've since deprecated `Q.call` in favor of `Q.fcall`, which removes the `thisP`: `Q.fcall(func, ...args)`. But we never updated/deprecated `Q.ncall` or introduced a `Q.nfcall`.\n\n@kriskowal, thoughts?\n. > IMHO, `Q.ncall`'s `thisP` argument seems counter-intuitive. Doing `myFunction.bind(this)` is pretty vanilla, and one could argue that the API could err on the side of \"least surprises\". \n\nAgreed, that's why we got rid of `Q.call` in favor of `Q.fcall`. The original idea was an attempt to parallel `call`/`apply`/`bind`, which have `thisP`s, but then we moved away from that---but only partially, leading to the current inconsistent and confusing state.\n. > `ncall`, `napply`, and `nbind` are different beasts. They cannot function without a proper thisp, so it makes sense to retain them in that interface.\n\nNot really true. `ninvoke` and `npost` suffice to replace the former two, and `nfbind(func.bind(thisP))` suffices to replace `nbind`.\n. Well, I think we need the `f` prefix to stay in sync with `fcall`/`fapply`/`fbind`. And the conciseness has worked well for me so far. I'd say `nsend`, `npost`, `nfcall`, `nfapply`, and `nfbind` are a good set to land on.\n\n> Another consideration is that I intend to rename `invoke` to `send` in v0.9.\n\nOh, good to know; was wondering about that mismatch with the concurrency strawman. A bit less communicative of a name, IMO, but ah well.\n. Done! Feel free to fix up.\n. @kriskowal nope. I assume it's due to retaining unhandled rejections indefinitely...\n. Thanks @nponeccop. I'll try to take a stab at it this weekend; as you can see, we have it as blocking 0.9.\n. Sounds like vertX still needs to figure itself out here. Hope we can make it work, eventually, but this solution isn't tenable.\n. Which browser (version is important) or server environment?\n. Pretty sure this shouldn't be happening :(. If you could put together a small self-contained test case that's a whole HTML file (from `<!DOCTYPE>` to `</html>`, I mean), that would be super-helpful. Then we can test it in various browsers etc. Otherwise we can try to reproduce on our own.\n. Much appreciated! I know it sucks to just start using a project and then get sucked into the bug tracker. If it's any consolation, I'm pretty sure this won't impact your use of the library, and will likely just be annoying in the console.\n. @kriskowal, there's been some impressive detective work here. But as @kaerus says, we're starting to get into the complicated internals of Q, and your expertise would probably help a lot here :).\n. I think `deepResolve` is pretty valuable and is a good solution to the original problem.\n. Or in [QQ](https://github.com/kriskowal/qq)? :P\n\nUp to @kriskowal though.\n. Yeah, but QQ is \"out of service.\" Qx may be a good successor/replacement...\n. @kriskowal, @SLaks Are we happy with the solutions proposed here? Namely, slight-hackery with `spread`, or a utility library implementing `deepResolve`? If so we should close this up.\n. Hi @arikon,\n\nI think this is more appropriate for the Q mailing list instead of the issue tracker, given that it is not a bug in Q.\n. Is this deep or not? If it's deep, I'd prefer `deepAll` as a name; if it's not, I'd prefer just making `all` do this. The only difference from current `all` would be the weird edge-case wherein we resolve `length` in `{ length: Q.resolve(5) }`.\n. Hmm.\n\nSo `Q.all` would use the `Array.prototype.forEach` algorithm (i.e. 0-based properties from `0` up to `length` with `in`-testing for sparse arrays).\n\nAnd `Q.allProperties` would use... `Object.getOwnPropertyNames`? `Object.keys`? `for ... in`? Or the annoying-to-program fourth quadrant, all own and inherited properties regardless of enumerability?\n. RSVP v2 is going to have this as `RSVP.hash`.\n. This would deprecate the promised wrapper because then `nfbind` would become equivalent to `promised`.\n. Right yes, that's definitely what I meant.\n. This has back-compat implications not only for how it changes the meaning of code that currently passes promises around but also because, as we noted above, we'd remove `Q.promised`.\n. I think package managers that can't deal with a vanilla package.json should die in a fire and we should never support their craziness ever.\n. I love this idea. @ForbesLindesay, I don't quite see your objection; could you restate it?\n. Yeah, I'm not really seeing the use case?\n. No, I understand, I think we're both confused where this notion of \"traditional CPS\" comes from. What libraries use `cb` and `eb` pairs? When would you want to expose such an interface to the world?\n. Is this causing all the Travis failures? :-/\n. It might be that `console.warn` output causes the tests to fail somehow? We'll have to investigate... hopefully `npm test` locally gives the same failures.\n. Did you mean to put this in 0.8?\n. I am fairly opposed to the `valueOf` name these days, after we found out that its not what we want for dates etc.\n. Yeah, good idea.\n. > It would be helpful if you could prevent q from gathering stack trace info for a specific jump (e.g. Within a library like QEJ)\n\nThis should work, no?\n\n``` js\n\nvar limit = Q.stackJumpLimit;\nQ.stackJumpLimit = 0;\nvar d = Q.defer();\nQ.stackJumpLimit = limit;\n\n// `d.promise` does not have a `stack` property\n```\n. @Redsandro you may be interested in our many [error tracking bugs](https://github.com/kriskowal/q/issues?labels=error-tracking&page=1&state=open)\n. You need to bind methods before passing them as arguments to functions:\n\n``` js\nq.nfcall(mysql.client.query.bind(mysql.client), query, [lang_code, autocomplete]);\n```\n\n(This is a general feature of JavaScript, and not specific to Q.)\n. I don't know why the above are failing, but yet again, this is incorrect:\n\n``` js\nvar doQuery = q.nfbind(mysql.client.query);\n```\n\nyou are still passing methods without binding them. You must do\n\n``` js\nvar doQuery = q.nfbind(mysql.client.query.bind(mysql.client));\n```\n. I don't have the time to look at your longer example right now, but in regard to bind: you use bind when you have methods, not functions. Methods need to be bound to the object that contains them so that they get the correct `this` value. Functions do not, since they do not use `this`.\n\nThe Node.js \"fs\" module contains a bunch of functions; assuming someone had done `var FS = require(\"fs\");`, then `FS.readFile` would refer to the `readFile` function inside the \"fs\" module.\n\nSo no, it doesn't have anything to do with the \"number of levels up\". It's just whether you're calling a method or a function. That is,\n\n``` js\nvar client = mysql.client;\nvar query = client.query(client);\n```\n\nis the same as\n\n``` js\nvar query = mysql.client.query.bind(mysql.client);\n```\n. Indeed. The problem can be illustrated by the following:\n\n``` js\nvar obj = {\n  method: function () {\n    console.log(this.foo);\n  },\n  foo: \"foo!\"\n};\n\nobj.method(); // logs \"foo!\"\n\nvar unboundMethod = obj.method;\nunboundMethod(); // logs undefined in sloppy mode, or errors in strict mode.\n\nvar boundMethod = obj.method.bind(obj);\nboundMethod(); // logs \"foo!\"\n```\n. @Redsandro `nfapply` takes a function; `npost` takes an object and a string naming the method you want to post to. There are examples and explanation in the API documentation.\n. \"post\" is our invention. There is no standard name for the operation taking an object plus a string plus an array of arguments and calling the method on that object denoted by that string with those arguments. \"mapply\" isn't bad, though, I admit :).\n. Something must be wrong with your npm installation...\n\nhttps://npmjs.org/package/q\n. Can you show how you're determining whether the result is fulfilled or rejected? `Q.allResolved` should always return a fulfilled promise.\n. @kuno I meant the promise, not the callback result. E.g. is it\n\n``` js\nrunAlotOfCommands(...).then(function (promises) {\n  console.log('fulfilled');\n}, function (err) {\n  console.log('rejected');\n});\n```\n\nor something else?\n. @kuno I can't help you solve your problem if you don't tell me what the problem exactly is. You say that \"sometime it will be resolved, sometime it was rejected\" (I assume you mean fulfilled, not resolved), but you don't tell me how you are determining this?\n. It would be cool to play around with this and find a nice API that is universally useful... and then put it in another package :). Closing for now, but indeed, thanks for sharing, and I'll keep an eye out for needing something like this in my projects so maybe I can contribute to this chain of thought.\n. It's a wiki, you can edit it too :)\n. @rkatic I think @kriskowal is referring to this signature:\n\n```\ndeferred.then( doneCallbacks, failCallbacks )\n```\n. Like, what is the result of:\n\n``` js\n$.when(5)\n  .then([function (x) { return x + 1; }, function (x) { return x + 2; }])\n  .then(function (y) { console.log(y); });\n```\n\nDoes `6` or `7` get logged?\n. In the link you gave\n. Oh, nice, thanks for guiding me to that :)\n. @cowwoc The wiki page is not about how to mix them (in which case you would probably use `Q`, not `Q.defer`); it's about teaching people who have used jQuery promises what the differences are between them and Q promises.\n. Somehow, I got inspired: https://github.com/kriskowal/q/wiki/Coming-from-jQuery\n\nFixes welcome!\n. OK, so at least now it's my unhandled rejection in the very first test:\n\nhttps://travis-ci.org/kriskowal/q/jobs/4407466/#L198\n\nThe question is, why is the throw-on-exit code not working in Node 0.8?\n. It must be something weird with jasmine, ugh. The exit listener isn't even being called.\n. I put a `console.log` inside the `process.on(\"exit\", function () { });` and it was never called :-/\n. Why isn't this getting logged?\n\n``` js\n        var r = Q.reject(new Error(\"aaargh\"));\n```\n\nit's in the second test in `q-spec.js`, and nobody is handling it, but I don't see it on the console, either locally or in Travis.\n. Mmm OK, yeah. Maybe we'll switch test runners one day; I've never been that happy with Jasmine. If we do we'd want to get multi-browser CI support (like Testling CI) as part of the deal.\n. Let's fold this into #197?\n. Maybe they're just moving the pointer to `array[0]` up by one offset.\n. Idly speculating from the sidelines again: you may gain even more by making your classes \"non hidden,\" i.e. by creating an explicit Node class.\n. @rkatic: I'm aware. I've heard from the V8 people that they can optimize more effectively if the hidden classes are explicit (i.e. use constructors whose only lines are `this.x = y`). Whether that would help in this particular case is, of course, a question that can only be measured by benchmarks.\n. Please use JavaScript when commenting on this repo.\n. Thanks.\n\nThe problem here is that you're already sending all the notifications by the time you attach the progress listener. Notifications that are sent when no progress listener is attached are not stored or re-emitted later.\n\nIn fact, since you are fulfilling the promise immediately, I don't think it would ever be possible to listen for those progress events.\n\nYou can see a working example here: http://jsbin.com/epoped/1/edit\n. You can use `progress()` sugar after `then()`. See my example above. You just can't emit progress before listening to it.\n. It's the magic of progress propagation :). In more detail:\n\n``` js\nvar promise = getPromiseThatEmitsProgress();\nvar promise2 = promise.then(onFulfilled, onRejected);\nvar promise3 = promise2.progress(onProgress);\n\npromise3.done();\n```\n\n`promise` is the one who emits progress, but `promise2` will also emit progress since events from `promise` are propagated to it without change. Thus `promise2.progress(onProgress)` will work.\n\n`promise3` will also emit progress, but the emitted progress values will be transformed by the `onProgress` handler. If it doesn't return anything from the progress handler, it'll emit `undefined` progress data.\n. @iamwilhelm yeah, sure. You just need to delay fulfilling or rejecting the promise until people have a chance to attach progress handlers. `Q.nextTick(deferred.resolve)` should do it, although it's possible since you're going through two levels of promises instead of one, you might need `Q.nextTick(function () { Q.nextTick(deferred.resolve); });`\n. Merged as 74e0a2159afbce53658acf97c96b0b2825757cf1, thanks!\n. I don't think our APIs should be in the business of `thisp`-ing. Telling people to use standard `bind` seems fine to me; that's the usual way you turn methods into functions, and adding extra sugar on top of `bind` seems unnecessary. (Thus I'm satisfied with `nf*` in general.)\n\nAlso, I think `napply` and `ncall` would not be useful, given the existence of `ninvoke` and `nsend`.\n. Sounds like there's not much support for this?\n. Oooh. I mean, I'd be all for `promiseify` (`promisify`? probably. or both.) except that it lacks the Node-specificness.\n. @ForbesLindesay you can, `fs`'s exports are functions, not methods.\n. What tests does this break in IE<9?\n\nIn other words, we're not trying for a true `Object.keys` shim, just one that is good enough for Q's internal code.\n. Oh I see, nevermind, it affects our publicly exposed `keys` method :(. Sorry for being dense.\n. Thanks, merged.\n. Is this valid, or did you close it because you discovered it was invalid?\n. The problem with this approach is that it breaks subsequent handlers if one throws.\n. Maybe test them against [this version](https://github.com/montagejs/montage/blob/601f849e86150f427ebe49bef8317b3fcf4488f2/core/next-tick.js#L61-L113) as well? I believe we were planning on replacing the current one with that, but your idea is intriguing also.\n. _sigh_. In that case, @kriskowal, thoughts?\n. @rkatic a very nice benchmark has been put together over in #206 by @francoisfrisch. But, you've clearly added a lot of thought about the \"reticking\" process. Care to give us an explanation of where it currently stands, how much it optimizes for pessimism vs. optimism, etc.? Could it be made faster by being more optimistic, for example?\n. There might still be value in this; it gives the better debugging experience, as you mention, and lets us kill the `Object.create` mini-shim. @kriskowal, any thoughts?\n. Yeah. We need encapsulation, so we can't use prototypes very much. And already-bound methods is super convenient for deferreds in particular (e.g. `setTimeout(deferred.resolve, 100)`).\n. @tebriel the broken tests have to do with Node.js domain support:\n\nhttps://travis-ci.org/kriskowal/q/jobs/4562257/#L188\nhttps://github.com/kriskowal/q/blob/334d55d87dcb64fe5120cfb1d4b450a4b71b3959/spec/q-spec.js#L1854-L1948\n\ndomains were working in 1.0.28 but something in 1.1.0 is interfering with them.\n. @tebriel thanks, we're now using jasmine-node 1.2.2 without any issues :)\n. We may want to investigate [using Istanbul](http://ariya.ofilabs.com/2012/12/javascript-code-coverage-with-istanbul.html) for code coverage, as it seems rather well-maintained and popular these days. nodecover is pretty good too though, if not actively developed, so a fair comparison will be needed.\n. @kriskowal has gone rogue and written his own runner!! Might as well close this :). Kris, you should publish it as its own package, IMO. I'd be happy to help co-maintain.\n. See also [promises-aplus/synchronous-inspection-spec](https://github.com/promises-aplus/synchronous-inspection-spec) which I'm hoping to push through soon.\n. Thanks, merged as 50cde79aeeb1a39841178919fb49f9d94c5dcfcd\n. This is why the \"fin\" alias exists.\n. Closing in favor of #201.\n. I gave this a shot:\n\nhttps://github.com/kriskowal/q/wiki/_compare/cc2bbdf5ea92ce8370ae44c98194fe07a6eefc84%5E...cc2bbdf5ea92ce8370ae44c98194fe07a6eefc84\n\nBut I still took the ES5-first approach, so let me know if you think we really should take the ES3-first approach and I'll fix it toward that direction.\n. Also: the WinJS source has some good examples of this, from what I recall trawling through it. It's not open-source though...\n. Also: our current strategy for handling non-thenable return values and any thrown exceptions is suboptimal, as we create a promise out of them and then resolve the returned promise with it.\n. Code sample where it helps please, for historical purposes if nothing else?\n. Huh, for some reason I thought that wouldn't work, but somehow it does. I think this means I need to revise https://github.com/promises-aplus/promises-spec/pull/76 to take into account such \"marked-as-non-thenable thenables.\"\n. I like that. In which case, I'd say that `deferred.fulfill(x)` should die, replaced by `deferred.resolve(Q.notAPromise(x))`.\n. My reasoning would be that things you do very uncommonly should have slightly awkard APIs that express exactly what you're trying to do. `deferred.resolve(Q.notAPromise(x))` is more explicit than `deferred.fulfill(x)` and emphasizes that what you want to do is almost always `deferred.resolve(x)`, except maybe sometimes you're dealing with non-promisey thenables and in that case you need to use the explicit `Q.notAPromise` to mark them as such.\n. As much as I love this idea, it apparently doesn't work in IE6 and 7: https://github.com/kriskowal/q/pull/195#issuecomment-13061556\n. > We need to put `nbind` back.\n\nRelunctantly agree.\n. Although,\n\n``` js\nvar bound = Q.nbind(obj.method, obj);\n```\n\nisn't necessarily as pretty as\n\n``` js\nvar bound = Q.nmethod(obj, 'method');\n```\n\nwhich is more along the lines of what the OP suggests.\n. @jokeyrhyme more like JavaScript's `Function.prototype.bind`, actually.\n. @kriskowal, should we put `nbind` back, or create a newer `nmethod`? I'm leaning toward the latter, actually...\n. Our strategy [in the past](https://github.com/kriskowal/q/pull/162) has been to allow people who desire to use hipster package managers to maintain their own repositories with such support. But, since Jam at least uses package.json instead of its own file, this might be an acceptable exception. Up to @kriskowal.\n. Oh, another idea. Given how this essentially just duplicates two fields from `package.json` into a `\"jam\"` subsection, it might be a better approach to open a pull request on Jam itself to look for the regular `package.json` fields as fallbacks.\n. Sounds like this is unnecessary.\n. When you pass methods to other functions in JavaScript, you must `bind` them first. Thus, it should be\n\n``` js\nQ.nfcall(db.collection.bind(db), 'users')\n```\n\nor better,\n\n``` js\nQ.ninvoke(db, 'collection', 'users')\n```\n\n---\n\nYou can see this same problem outside of the Q context if you tried assigning the method to a variable and using that without binding it:\n\n``` js\nvar collection = db.collection;\ncollection('users', function (err, collection) { /* won't work */ });\n\n// or parameter passing:\n\nfunction call(func, arg1, arg2) {\n  func(arg1, arg2);\n}\n\ncall(db.collection, 'users', function (err, collection) { /* won't work */ });\n```\n. Yeah, maybe we should pick better examples in the docs for these things, and add a warning about using methods without binding them. Reopening until we do that.\n. Docs updated!\n. The top of the documentation explains the correspondence: `Q(x).method(...args)` <--> `Q.method(x, ...args)`. In this case it's `Q(array).all()` <--> `Q.all(array)`.\n\nFurthermore, `all` is in the \"promises for arrays\" section, which I would think would help.\n. Not sure. Will think about it more. Perf certainly could be an issue.\n. For reference implicit `promised` is tracked as #160.\n. Small back-compat hazard; tagging as such.\n. Note that `Future.when` seems to have gone away, replaced by `Future.every`, so that reason is no longer there.\n. Ooh, exciting. https://github.com/kriskowal/q/wiki/API-Reference may help.\n\nIs there a good place to discuss that document? A few thoughts come to mind.\n. I think at the very least we should create `Q.then` as a synonym for our current `Q.when`. I'd then personally kill `Q.when`, but if we wanted to come up with a new meaning for it we could do that too.\n. Looks nice, except for the test ugliness. Will merge tonight. Thanks a bunch!\n. Merged as e45d9a9d8d3928f4f63ff240268dfdc0a3f246d9, sorry for the delay.\n. Is it really _O(t log n)_? Because as _n_ -> 0, that's amazing ;).\n. I am +1 on this. `thenResolve` is quite useful so far, and adding `thenReject` for symmetry alone would make me happy. The compelling use case provided clinches it, in my mind, overcoming any concerns about API surface area bloat.\n. @kriskowal is that a +1?\n. Now I know! :)\n\nAlthough, to be fair: https://www.google.com/search?q=%E3%80%83\n. Uh so I think I'm running into this with Mongoose + Q as well. @mgcrea did you figure it out?\n. For me it occurred when trying to serialize a structure that contained a Mongoose object. That is, I got a Mongoose model `x`, took the property `x.foo`, then tried to update another Mongoose model `y` with `{ fooFromX: x.foo }`.\n\nThis seems confined to Mongoose, but then again, I tried doing this without Q and didn't seem to get the infinite recursion. Hrm.\n. This is in fact not correct; thenables should be recursively resolved. I'll let @kriskowal confirm, but generally the consensus has been that `return thenableFor5` should act the same as `return 5`.\n\nSee also https://github.com/promises-aplus/promises-spec/pull/76\n. No, a _fulfilled_ value is a fulfilled value; a _resolved_ value is propagated.\n\nQ is not \"broken\" if a resolved value is a thenable. Q is simply incompatible with thenables where `then` means something too different from what it does in promises. You should wrap them (e.g. `deferred.resolve({ thenable: badThenable })`) if you need to pass them through the promise chain.\n. Right, I believe that our view is that it's impossible for a thenable to have a legitimate fulfillment value that is a thenable; it is our responsibility to squash chains of \"x represents something that represents y\" into \"x represents y\".\n. @rkatic I believe it does go against Promises/A+ 1.1, though, as per the earlier-linked issue.\n. \"Drastic,\" lol. This is an edge case by any definition.\n\nI think I explained it rather well above. Promises represent values. Conceptually, promises for promises are nonsensical: they are chains of \"x represents something that represents y,\" which really just should be collapsed to \"x represents y.\" Furthermore, promises for promises are hazardous, but I won't bother trying to link you somewhere demonstrating this, since you are too busy to read any reasoning longer than a few sentences it seems.\n\nAs for the difference between \"promise for promise for x\" and \"promise for thenable for x,\" @kriskowal explained this well above: we simply don't have the ability to tell the difference, so we assume in good faith that thenables are promises. Anyone who really needs to use non-promise thenables while also wanting to use a promise system will take the effort to wrap it in e.g. `[nonPromiseThenable]` or `{ thenable: nonPromiseThenable }`.\n. > When the `onFulfilled(value)` is called, `value` should be considered fulfilled, even if thenable.\n\nI agree. But only promise implementations call `onFulfilled`, and what we are arguing over in this thread---I thought---was what `value` should be. And my argument is that `value` should never be a thenable.\n. Sadly I don't think I can repeat myself any longer. You should never have a promise for a promise, as I tried to explain above, and we can't distinguish between promises and thenables, thus `value` should never be a thenable.\n. Just in case, let me try to rephrase my most recent comment in a way that seems a bit less circular:\n1. Promises for promises are nonsensical.\n2. Therefore, promises should never have as their fulfillment value another promise. (We guarantee this by collapsing chains when assimilating, when dealing with return values from `onFulfilled` and `onRejected`, and by eliminating `Q.fulfill` as per #205.)\n3. We cannot distinguish between promises and thenables, therefore, promises should never have as their fulfillment value another thenable.\n4. Promise implementations call `onFulfilled` with the fulfillment value of a promise.\n5. If the fulfillment value can never be a thenable, `onFulfilled` will never be called with a thenable.\n\nTa-da! :)\n. Let's take a different approach.\n\nCan you show us why this would be beneficial by including a test that (a) does not currently pass; and (b) is not about a cyclic promise chain (i.e. a promise resolving to itself)?\n\n\"should propagate fulfilled value as it is\" currently passes, without your code modifications.\n\n\"should coerce thenables which resoved value is also thenable\" is actually about promise cycles, which is covered by #223.\n. Oh, sorry for the wrong assumption then. The fact that \"should propagate fulfilled value as it is\" doesn't pass seems worrying and is a convincing argument. I'll try to look into it.\n\nThanks for your persistence.\n. I think we're going to wait until the Promises/A+ test suite 1.1 is done, which contains tests to ensure that returned thenable-for-thenable chains are flattened. Q already passes those, but having them in place will prevent regressions from pull requests like this. Then we can investigate how to make the tests you included pass.\n\nI should be done with the test suite by this weekend, most likely.\n. FWIW Promises/A+ 1.1 is wrapping up soon, so my strategy of waiting until we have those tests in place, then trying to merge this because it contains some tests-that-fail-but-probably-shouldn't, still seems like the way to go.\n. _A very unpolitical and now-removed version of @kriskowal's below statements were previously found here. Let's pretend I never said them, as I do not wish to represent Q in such ways :)._\n. We probably do want a reference to that link in the readme though, along with all the other ways of acquiring Q.\n. This is a small backward-compat hazard; tagging it as such. Also I'd like to point out that the upcoming Promises/A+ 1.1 revision requires self-resolution detection. (It encourages, but does not mandate, vicious cycle detection.) Search for \"if x and promise\" at https://github.com/promises-aplus/promises-spec.\n. I guess `Q.nonPromise` is named for its argument, not for its return value, which is unfortunate.\n\nNot to start off another round of \"name that API,\" but it's more like `Q.promiseForNotAPromise`.\n. 0.9.1 published with this fix.\n. Wow, thanks for finding subtle bugs; those are the worst :).\n\n@kriskowal now that we've got the 0.9 release out the door, I'd love to adopt a \"release often\" strategy to let people get their bugfixes ASAP. So maybe a 0.9.1 tonight?\n. 0.9.1 published with this fix.\n. We could also link to\n\nhttps://rawgithub.com/kriskowal/q/master/spec/q-spec.html\n\nwhich isn't cached I believe.\n. @mbriggs links to documentation for such libraries would be helpful, as I personally can't recall any libraries that don't allow asynchronous failures, only asynchronous success.\n\nAlso, this might be good as a separate package (e.g. `q-browser-adapter`), especially given the variety out there.\n. Re: alternate browser implementation mappings, yeah, as of 2.0 browserify supports [this spec](https://gist.github.com/shtylman/4339901).\n. I can't see any overriding patterns in the DOM that are making this effort feasible. @ELLIOTTCABLE's case is an interesting one, in Node.js: certain Node.js callback-taking functions are actually proxies for `someObject.on('specialEvent', ...)`, like `http.createServer` or `readline.question`, and there's always the `fs.exists` outlier. I'm not sure it'd be worth providing something specifically for those cases though, especially since people would have to remember to use it. (I.e. the workflow would be \"get bitten by `Q.nwhatever` not working, then use `Q.weirdnwhatever`\" which isn't much better than \"get bitten by `Q.nwhatever` not working, then write a small wrapper yourself.\")\n\nAs such, I think it'd be best to leave any experimentation here in user space. If people come up with some really compelling libraries around these ideas, we should link to them. @kriskowal, what do you think---time to close this issue, or is there still some productive work we can do here?\n. Merged as a3f0b85cd9f10332caaf3263c9741b2e865f88e0, with tests in 14bbc8ce3e09f476f3d722b52a4ccdbc7c6b488c. Going to do a pass through the rest of our promise-construction methods for similar problems.\n. `delay` fixed in dd934f1443aa3997f802183c12789dc3abc751a7.\n. Fixed by #233.\n. Nice catch, thank you!\n. I agree this could be quite useful, but then again, we're already fighting API surface area bloat. We'll see what @kriskowal says.\n\nIn the meantime, you may enjoy [Qx](https://github.com/SLaks/Qx), which someone has put together with lots of useful promise + array stuff.\n. Great, I'll update and merge this (with @Redsandro as the author of course) because tonight I am on a streak to close as many Q issues as possible ^_^\n. Merged as f587e75d997556e84bcf5d9a9c85939414056f99; updating API reference now. I kind of like them :)\n. @Redsandro indeed you can!\n. To be fair, there's some agreement that the existing synchronous-inspection mechanisms are confusing, and might be replaced or augmented with something like https://github.com/promises-aplus/synchronous-inspection-spec/issues/6\n. Is this Node 0.10-only?\n\nI don't have much time this week, but maybe next...\n. This seems to be q-io related, since the following does not cause the problem:\n\n``` js\nvar Q = require('q');\n\nQ.reject(\"boo!\")\n.fail(function(err) {\n    console.log('error caught!');\n});\n```\n\ninvestigating...\n. Nope, it's Q's problem. This triggers it:\n\n``` js\nvar Q = require(\"q\");\n\nQ.reject(\"foo\").get(\"bar\").fail(function (err) {\n    console.log(\"error caught!\", err);\n});\n```\n. @kriskowal, I'm at my wits end on how to fix this one. I added a failing test in a branch, as above, but am not sure how to approach it myself.\n. @mikerobe, just as a point of etiquette, it is very rude to post bug reports in CoffeeScript to a JavaScript repo.\n. An API for disabling this is planned; see #265.\n. Remember that .then and .fail create new promises, which are unhandled if the original one is unhandled.\n\nOn May 30, 2014, at 17:45, \"Trevor Burnham\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nI'm wondering why this was closed... surely it's a bug that attaching additional success handlers to a promise causes additional entries to be added to unhandledReasons/unhandledExceptions? Here's a test case:\n\ndeferred = Q.defer();\ndeferred.reject(new Error('foo'));\ndeferred.promise.fail(function() {\n  console.log(Q.getUnhandledReasons().length);  // 0\n});\ndeferred.promise.then(function() {  /\\* ... */ });\ndeferred.promise.fail(function() {\n  console.log(Q.getUnhandledReasons().length);  // 1\n});\n\nIt's perfectly valid to attach more success handlers than failure handlers to a promise, and should not complicate debugging. N'est pas?\n\n## \n\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/238#issuecomment-44703133.\n. Even shorter:\n\n``` js\nQ.allResolved(promises)\n.invoke(\"filter\", Q.isFulfilled)\n.invoke(\"map\", Q.nearer);\n```\n. https://github.com/kriskowal/q/wiki/API-Reference#promisevalueofexception\n. `.fail(onRejected)` returns a new promise (it's shorthand from `.then(undefined, onRejected)`). The relevant section of the spec is thus 3.2.6, governing the behavior of the returned promise.\n\nThat new promise is fulfilled, since you implicitly returned `undefined` from the `onRejected` handler. If you had thrown an exception, the new promise would be rejected, and that step would be skipped, but since you returned, you're signaling that you handled the error.\n\nHere is the analogous synchronous code:\n\n``` js\ntry {\n  console.log('Throwing error');\n  throw new Error('Catch!');\n\n  console.log('You shall skip this step!');\n} catch (e) {\n  console.log('I caught ya! :D');\n}\n\nconsole.log('Shouldn't this step be skipped?');\n```\n. Errors bubble! But if you handle them, then they're handled! :)\n. I'd suggest something like\n\n``` js\n// ...\n.fail(function (err) {\n    console.log('This is not a real error. etc.');\n    return false;\n})\n.then(function (value) {\n    if (value !== false) {\n        // do normal stuff\n    }\n})\n```\n\nAssuming that `...` will fulfill with a non-`false` value in non-error conditions.\n\nAs always, it's good to think how you would handle this in the sync case. If you end up in a `catch` block for something that's not a real error, but this would affect whether or not subsequent steps are executed, you'd probably set a flag and use that to modify the subsequent steps---like we're doing here.\n. I think we'd be best served if you could come up with an example of what you're trying to do, but synchronous. Remembering that promises are just an asynchronous parallel to synchronous function calls, that should help.\n. I look forward to seeing your synchronous counterpart code so I can help you further.\n. You never showed me synchronous code that emulates your desired workflow, which I asked for a few times under the reasoning that once I have a synchronous version, I can show you the optimal promise-based asynchronous counterpart. If you show me synchronous code that does what you want (e.g. with hypothetical synchronous HTTP request functions, like you would have in other runtimes besides Node.js) we can continue.\n. I don't like the idea of `then` ever passing more than one value to its callbacks, or `resolve` accepting more than one value. It breaks the sync/async parallel: a single return value from a sync function <=> a single fulfillment value for an async promise.\n. I think there's been some good discussion here, and maybe the `Q.spreading` idea could be experimented with in the future. But at least for now, I don't think Q will change its semantics in this area, so let's close this issue.\n\n@killdream, if you feel strongly that `Q.spreading` is a good idea, please open a new issue and we can debate its merits there. Personally I feel that it's not better than what we have, and is especially confusing if the `deferred.resolve` call is separated in space or time from the `promise.then` call. But that's just my opinion.\n. Remember that promises parallel synchronous functions, which can only return a single value or throw a single exception. The fact that Node's callbacks don't have any such contract is unfortunate, but there's not much we can do to work around it (besides perhaps throwing away any called-back-with values after the first one, but arrays seem like a better choice).\n\nSo fulfilling with multiple values doesn't work and doesn't make sense.\n. It looks like this is coming from\n\n```\nat /Users/realyze/code/salsita/trunk/src/Project-Evolution/node_modules/q/q.js:665:13\n```\n\nwhich is where Q adds the `process.on(\"exit\", ...)` listener to notify of unhandled rejections before exiting. Interesting.\n\nI'd guess sandboxed-module gets a new copy of Q for each test, and thus the `process.on(\"exit\", ...)` gets run each time. If you end up with 11 or more copies of Q, you get this warning.\n\nI'm not sure there's a great solution here. Since there are indeed 11 copies of Q, there are 11 possible sources of unhandled rejections, so we need all 11 listeners. If anyone has any ideas though, let us know...\n. > Well, strange thing is that this happens even if I use describe.only and run a suite of 6 tests (it still complains about setting 11 listeners).\n\nI am not sure exactly how `describe.only` works, but if I've learned anything about Mocha, it's that its internals are complicated and hard to predict. Maybe it still executes `describe` or `beforeEach` blocks for things outside the `describe.only`, just not `it` blocks... or something. I would try putting a `console.log` next to all instances of `sandboxedModule.require` that reference Q and seeing how many times/where it happens.\n\n> Also, shouldn't the listener be unset when the test ends?\n\nHow would Q know when the test ends? Q only knows when the process exits, but all tests run in the same process, and there are 11 (or so) copies of Q created in the process before it's time to exit.\n\nJust to be clear, in normal code execution, there is only one copy of Q at any time; normal `require` has an internal cache. But by introducing sandboxed-module, the cache is reset every time you do `sandboxedModule.require`, so Q's main code will be executed and a new `process.on(\"exit\", ...)` listener will be added.\n. Is there a page or URL we can link to that wouldn't require us updating the version number in the README every time a new release is published?\n. I mean, if you're just after the latest version, then https://rawgithub.com/kriskowal/q/master/q.js would work well (notice \"rawgithub.com\", instead of \"raw.github.com\"). I assume the benefits of cdnjs are that it's a CDN, and thus presumably distributed worldwide so people get lower ping times.\n. Sadly without a maintenance-free way for us to link to this, we can't really include it in the README like we do other sources of getting Q :(. Let me know if cdnjs grows a new feature like that.\n. Remember that promises represent asynchronous function calls. Since functions can only return a single value, promises can only be fulfilled with a single value. Similarly, since promises can only throw a single exception, promises can only be rejected with a single reason.\n\n[See this presentation of mine](http://www.slideshare.net/domenicdenicola/promises-promises) for more detail on the parallel.\n. Thanks! Merged with some slight wording tweaks as 5a565c0b52ec50aa6e5828727b55e845e42b9428.\n. Superceded by #296.\n. I think `Q.parallel` sounds pretty cool, but I'm not sure it's a common enough use case that we want to add it to the base Q library. @kriskowal, any thoughts in that direction?\n\nEven if we don't add it, it might be a great npm package just by itself!\n. Sounds like a bad bug. Will investigate and fix ASAP. Thanks for reporting it!\n. I am unable to reproduce this, although I did replace the `_.map`s with normal ES5 `map`s (e.g. `out.map(...)` instead of `_.map(out, ...)`.\n\nCan you produce a test case that fails in a JSFiddle, preferably one that does not rely on any third party libraries which might themselves have bugs? We'll reopen if so.\n. I've been starting to think we should turn it off by default, for performance reasons. :/\n. Yes, set `q.stackJumpLimit = 0` or something similar; it should be documented near the bottom of the README.\n. Yes, we used to use the stack trace API, but found it to cause various issues. The idea is that if you use Q, you opt into our `error.stack` handling behavior. If you want to use Q with another library that also manipulates error stacks, you'll want to turn off our stack manipulations (just like, hopefully, other libraries like raven-node also have the ability to turn off their manipulations).\n. I am going to close this, and track any further work in this area (e.g. deciding whether to turn off long stack traces by default) under #264.\n. Optionally, `{ state = \"pending\", resolution = promiseWeAreWaitingOn }`?\n\nAlso, we'd of course keep the rather-convenient `Q.isFulfilled`, `Q.isRejected`, `Q.isPending`, and their promise-prototype counterparts. We could additionally add `Q.isSettled` and `Q.nearest` (`nearer`? both?). If we added the `resolution` idea then `Q.nearest` could be easily implemented in terms of that, which is kind of nice, I think.\n. Ah, and I forgot to mention: Node.js's `util.inspect` treats `inspect` methods specially, by using their output instead of the usual enumerable-keys-and-their-values display. I think this is actually a plus, but, it's something to be aware of.\n. Thanks! Merged as c2da8515431e64cebf6d6a1f03f11409ffc6dbd8.\n. I believe as per comments in #263 this has been obsoleted by #337. Please reopen if I'm mistaken.\n. Sounds good. But,\n\n> Long stack support is useless if it does not get shown by debuggers.\n\nThis is definitely not true in my experience, since in Node.js we don't really use debuggers but we see stack traces get printed all the time :).\n. @kriskowal an update: it turns out infinitely long stacks don't consume any more memory than single-level \"long\" stacks. This is because (a) all promises store their own stack trace already, and (b) when a promise is resolved to another promise, it already stores a closure reference to that promise. Infinite long stack support consists entirely of making that closure reference into a property reference (i.e. `promise.source = resolvedPromise`), then crawling that chain of `promise.source`s when it's time to assemble the infinitely long stack.\n\nWith that in mind, I'm thinking `Q.longStackSupport = true | false`, defaulting to `false`. Hooray, simplicity!\n\n---\n\nNow, for a question: what do you think of switching it on or off depending on environment, like @tgriesser suggests? I found out that [you can find out whether Web Inspector is open](http://stackoverflow.com/questions/7798748/find-out-whether-chrome-console-is-open), and if we combine that with `NODE_ENV`, we'd be in pretty good shape. One potential wrinkle is that the convention for `NODE_ENV` as per Express seems to be to assume it's \"development\" unless it's explicitly set to \"production\".\n. Thanks. I've noticed this in several libraries recently; I wonder if it's a recent change in Mocha. Will fix ASAP.\n. Thanks, merged as 5c10c12c539c22bca079899977cbd8f0111ecb5c!\n. I am becoming increasingly convinced something like this is necessary. Here are some random thoughts:\n- when.js has an implementation that is very simple, [from what I can see](https://github.com/cujojs/when/blob/master/when.js#L699-L752). Tagging in @briancavalier in case he has any comments.\n- RSVP.js makes use of Mutation Observers, which are very fast as they occur in \"micro tasks\" instead of \"macro tasks\". The number of browsers that support [MessageChannel](http://caniuse.com/#feat=channel-messaging) but not [mutation observers](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#Browser_compatibility) is pretty low, and IE10 has `setImmediate` which does allow paints but is pretty fast anyway. We'd basically lose Safari 5.x.\n- Both RSVP and when seem to make the simplifying assumption that enqueued functions cannot throw. This seems reasonable if we carefully control who uses this function.\n- It might be worthwhile to rename per #298?\n. > I do not believe that we catch exceptions before nextTick in all cases. Quick scan shows nodeify in particular.\n\nSure, but we could put the burden on `nodeify` instead of on `asap` (hahahahaha).\n. Thanks, merged as 27e35483977d3638e200dc25f0e2007d16333c31!\n. Thanks; merged!\n. Indeed, @kitcambridge is correct. We point this out at the bottom of our [Adapting Node](https://github.com/kriskowal/q#adapting-node) section in the readme.\n\nAnother solution is to upgrade to Node.js 0.10 or higher, where streams don't start emitting `\"data\"` events until someone is listening to them.\n. Good question. I do this all the time in my code. Here's the idea:\n\n``` js\n// success: return a promise fulfilled with `5`:\nsomeStub.withArgs(\"foo\").returns(Q.resolve(5));\n\n// error: return a promise rejected with an error\nsomeStub.withArgs(\"bar\").returns(Q.reject(new Error(\"bar is bad, foo is good\")));\n\n// advanced: return a promise whose fate you can control later\nvar deferred = Q.defer();\nsomeStub.withArgs(\"bar\").returns(deferred.promise);\n\n// later:\nif (Math.random() > 0.5) {\n    deferred.resolve(5);\n} else {\n    deferred.reject(new Error(\"the winds of fate have carried you to a bad place.\"));\n}\n```\n. I'm afraid at this point I'm not sure how to help, as I've never used Sinon's \"mocks\" (only its stubs and spies). If you have an example using only stubs and spies I can try to be more helpful.\n. I'm sorry to say I'm pretty lost. I don't know what your code is doing anymore because of the mock-related stuff, and thus can't really help.\n. Thanks! Merged, with some minor tweaks, as 5cbbfe8138bf4108a7e543058a3be2b925e8e283.\n. That sounds horrifying! A simple failing test case would be appreciated, if you could.\n. @rkatic, any comments?\n\n@blalor, a small reproducible test case would be extremely valuable.\n. Oh wow, multithreading!? Yeah I imagine that breaks a bunch of assumptions that Q (and every other JS library on the planet) makes :-/.\n\nIf it's an easy fix we'll be happy to take it though. E.g. if you get a small reproducible test case, and then make a small change to the queueing code, and that fixes your test case, we'll very likely accept it.\n. Let's close this for now, but my above words stand: if you have an easy fix and a reproducible test case, we'll take it, even if just for Rhino's sake :).\n. Actually, the way that the unhandled rejection display works is by logging an array to the console, which is live-updated when you push into it. Browser consoles do that automatically these days. So the order shouldn't matter.\n\nIf you have failing JSFiddle though, e.g. one that fails before that change and works after it, I'd be happy to take a second look!\n. What do you mean by \"results in\", \"fails\", and \"works\"? Which browser does it \"result in\" that?\n\nI'm seeing different results. You can test using https://rawgithub.com/domenic/q/master/q.js\n. I can't see how this has anything possible to do with Q, given that Q never touches your filesystem. It sounds like a bug in nodefront.\n. Long stack traces are kind of intimately tied to Q's internals at the moment, but yes, if we could expose appropriate hooks that'd be a good idea.\n\nI'd like to nominate generator-related stuff for being moved to a separate package as well.\n. This code has a syntax error, so it seems unlikely to be actually working code. If you could produce a JSFiddle that shows the problem, that would be helpful.\n. Thank you! Merged as 89a549b6f25b52c46048b81408e59b3e9bc4c145.\n. Hi @necolas, as you can see from #162, we're not interested in maintaining support for other package managers inside this repo. You can file issues against @ForbesLindesay's repo, or maintain your own fork of Q.\n. Indeed, if the package manager cannot draw all it needs from `package.json`, we are not interested in supporting it. As for catering to client-side package managers, we already cater to npm, and [that should be enough for anyone](http://www.slideshare.net/domenicdenicola/client-side-packages) :).\n\n(Opinions in this last sentence not necessarily supported by the Q project as a whole or @kriskowal. Opinions in the first sentence are, however.)\n. `Q.nearer`, which I think used to be called `Q.valueOf`, is I think not compatible with the current release. However, `promise.valueOf` is. That might be source of potential complaint/confusion.\n. > while `all` replaces values of the input array\n\nEeek, that doesn't sound like something we should do! @kriskowal, can we remove that behavior??\n. Yeah, we somehow haven't gotten complaints about `all` so far... still... I'm fingering my lynch-mob-designated pitchfork.\n. So if I'm understanding @rkatic's proposal correctly:\n- The default behavior for `all` would be to create a new fresh array, but optionally one could pass in their own array `results` to be reused\n- The default behavior for `allSettled` would be to reuse the `promises`, but optionally one could pass in a new array `results` to be used?\n\nThis seems inconsistent... Maybe that first line is supposed to be `results = results || promises`?\n. OK, rebased with `allSettled` matching `all` in that both modify their input array.\n. I'm happy to go whichever way @kriskowal prefers.\n. @kriskowal poke\n. Q shouldn't be interfering with `process.on('uncaughtException', ...)`; can you post some sample (JavaScript) code that reproduces the problem?\n. This is one of the most exciting things I've seen :D. Amazing work sir! Will let @kriskowal do the honors of merging, but I can't wait to start using these.\n. @kriskowal if you could look at #238 and maybe #278, a lot of people are getting hurt by those.\n. Yeah, dupe of the unfortunate #238. We want this fixed badly; if you have any ideas let us know!\n. Woah, OK, nice find! I'll try to turn that into a patch tonight or tomorrow. Maybe I'll implement #265 as well in order to be able to test it nicely.\n. Awesome, thanks very much :D. Will merge tonight, and maybe we'll do a 0.9.4 release with it before doing the whole API overhaul as per #265.\n. Thanks so much. Merged as bba609d0f25f9d046c53c58d75d0ee5125424d7d.\n\n@kriskowal, if you want to push the button and do a 0.9.4 release I'm totally ready. I'll try to spend some time this weekend doing #265 but no need to wait up I think.\n. Exceptions thrown inside `onFulfilled` or `onRejected` reject the promise returned by `then`:\n\n``` js\nvar promise2 = def.promise.then(function(val) { assert(false) });\npromise2.then(\n  function () { console.log(\"this will never happen\"); },\n  function (err) { console.log(\"the assertion error:\", err); }\n);\n```\n\nYou can learn more about how this works [in the readme](https://github.com/kriskowal/q#propagation), and get some reasoning behind it [in my blog post](http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/).\n\nWith regard to testing promises, you have a few options. If you use `done` instead of `then`, any rejections (including ones resulting from `throw`s inside `onFulfilled` or `onRejected`) will be thrown in the next tick. For example:\n\n``` js\ndef.promise.done(function(val) { assert(false) });\n```\n\nIf you need more complicated assertions, e.g. with an async testing framework, you can do things like\n\n``` js\nit(\"should be 5\", function (done) {\n  def.promise.then(function (val) {\n    assert(val === 5);\n  })\n  .then(done, done);\n}\n```\n\nThis works because the returned promise either fulfills to `undefined`, resulting in a call to `done()` which async test runners interpret as no error, or the returned promise rejects with an assertion error, resulting in a call to `done(assertionError)` which the test framework then uses.\n\nFinally, if you want something more streamlined, you can try [Mocha as Promised](https://github.com/domenic/mocha-as-promised) and [Chai as Promised](https://github.com/domenic/chai-as-promised/).\n. :)!\n. @Lacrymology while @rkatic's advice is correct, it's a bit more advanced than you might be needing. So the simple answer to your question is just \"yes\" :).\n\n(That said, his first point about exceptions thrown by `handler` is a good one even at the beginner level; [we cover it in the readme](https://github.com/kriskowal/q#handling-errors) for that reason.)\n. The [Q Continuum](https://groups.google.com/forum/#!forum/q-continuum)!\n. Thanks, merged as 1c024d5721f3179e76051ea71ce3851e8feb0a0a.\n. Hmm, I thought I had good arguments against this, but when I start typing them out they seem less strong. Tagging in @briancavalier in case he has any thoughts; I know it's an area he's considered a lot in when.js.\n. Thanks Brian; I knew that rejecting `p` was out of the question, but @eden's suggestion was allowing `p`'s progress handlers to reject children of `p`, and your example from that thread was exactly the counterexample I'd forgotten about.\n\nI agree that that other idea was pretty interesting. Although, the strangeness of it (i.e. the way that `notify` ends up behaving so differently from `resolve` or `reject`) makes me further dislike how we've mixed progress into the `then` signature.\n. OK, it's decided. `notify` will return a promise derived from the various `onProgress` handlers. See #340.\n. Could you write that code in JavaScript, which is the language of this repository?\n. Yes. Asynchronous code is generally slower than synchronous code. If you are using Q for synchronous code (e.g. switching synchronous code to Q-based code), you are making a mistake. If you are using Q for asynchronous code, it won't be that much slower than other asynchronous solutions---which you don't seem to be comparing against.\n. Even ignoring your continued rudeness in posting another language: event emitters are synchronous, not asynchronous.\n. Use `setImmediate` for a real test.\n. You need to call `doit` from inside `doit` to simulate a chain of promises. You can't just run a bunch of `setTimeout`s in parallel.\n. To be clearer: you need nested (recursive) `setTimeout`s to simulate nested promises. Your latest code does not contain any nested `setTimeout` calls.\n. Using the branch that turns off long stack traces by default (see #311) and running [this test suite](https://github.com/kriskowal/q/blob/ebb3769bf7cdb818f46caf7864c819ef8761d1a2/benchmark/compare-with-callbacks.js), I get the results\n\n```\n                      A single simple async operation\n          49,311 op/s \u00bb with an immediately-fulfilled promise\n         436,358 op/s \u00bb with direct setImmediate usage\n              64 op/s \u00bb with direct setTimeout(\u2026, 0)\n\n                      1000 operations in parallel\n              48 op/s \u00bb with immediately-fulfilled promises\n             897 op/s \u00bb with direct setImmediate usage\n```\n\nQ is slower than we would like, but only about 10x slower than callbacks. Running many promises in parallel seems to make Q about 20x slower.\n. @sobotklp you appear to have introduced long stack traces in your upgrade. You can turn them off with `Q.longStackJumpLimit = 0`. In version 0.9.5 they will be off by default.\n. I think it's time to close this. Thanks for prompting us to finally get a performance test suite up and running. If you have any further cases that you think are slower than they should be, we'd appreciate them either over in #312, or even better as pull requests that add to the existing suite.\n. @kriskowal thoughts on this? I guess my preference would be to stop exposing `nextTick` entirely. That way we could eventually move toward a faster implementation that assumes the enqueued functions never throw (by moving any `try`/`catch`ing to the specific cases where we `nextTick` user-supplied functions).\n. There's still the issue of what we expose as an external API, e.g. would we do `exports.nextTick = require(\"asap\")` to maintain backward compatibility?\n. OK, so let's rename this issue to \"remove `Q.nextTick`\"\n. This kinda-sorta argues for an extension to `inspect()` that lets you know what a promise is resolved to, e.g. `{ state: \"pending\", resolution: otherPendingPromise }`. Maybe `{ state: \"fulfilled\", value: 5, resolution: promiseIGot5From }`, but I think that might prevent garbage collection if we need to be able to produce it on-demand.\n\nDunno, haven't though too much about it, but might be useful especially if we were to try to build the unhandled rejection tracking as a kind of external plugin on top of a core Q.\n. Alternately, once @kriskowal reviews and accepts #296, you'll be able to turn off the unhandled rejection tracking :). -poke poke-\n. @kriskowal Yeah I mean we don't want to delay a patch release indefinitely, we've already made great progress on tidying up unhandled rejections, but maybe one of us can try to take on this issue and maybe also #292?\n\n@ravi as Kris says, I don't think `Q.getUnhandledReasons()` would be too useful to you; it would just give you the list of rejection reasons that Q thinks are unhandled (which, as we're discussing in this issue, is not an accurate list).\n. It's not really clear what you even mean by this... What do you want `obj.method1().method2().method3()` to do? Does it have anything to do with promises? You can implement that in normal JavaScript without a promise library, so what are you asking, exactly?\n. Indeed, @wychi and @killdream have this covered. Let us know if you need further clarification.\n. I'm going to give a Grunt build system a shot. Thanks for bringing this to our attention.\n. @kriskowal if I can pull it off, what do you think of some automated way of uploading the minified version to S3 and linking to it instead of storing it in the repo?\n. Second question: it looks like [grunt-contrib-uglify](https://npmjs.org/package/grunt-contrib-uglify) has a way of automatically reporting gzipped size. Given that fact, is there any point in committing the `.min.js.gz` file?\n. +1 to the idea, both on the level of simple sugar for `Q.async(...)()` and also on the level of tracking down unhandled rejections better. I've definitely accidentally created unhandled rejections myself via just simple generator usage, so it could use some work. Approved, if you can add a few tests showing that it does what it says it does (which should be nice and easy with a combination of `Q.onerror` and the new `Q.getUnhandledRejections()` etc.).\n. @kriskowal IMO that's the correct division of responsibilities, although I hadn't seen it put so clearly until you did so :). Ideally, with generators, we should be able to completely avoid unhandled rejections. The only time they should be possible is if you use a promise-returning side-effecting function but forget that it's promise-returning, i.e. you just fire-and-forget it. And async side-effecting functions are the perfect use case for `spawn`, so if `spawn` calls `done` for you... seems good.\n. Hmm I see the idea but am not too happy with parameters that can sometimes be rejection reasons and sometimes fulfillment values. Also, the correct term is actually \"settled\"; `allResolved` uses \"resolved\" incorrectly. (Because if you resolve a promise with another pending promise, the first promise is resolved but still pending; it is not yet settled to either fulfilled or rejected.)\n\n<del>Note that you can accomplish something similar today with the awkward `allResolved`:</del> <ins>This is actually not true, see below</ins>\n\n``` js\nQ.allResolved([\n  promiseThatFulfills,\n  promiseMaybeRejected,\n  promiseThatFulfills]).spread(function (a, b, c) {\n  if (\"exception\" in b.valueOf()) {\n    // .. awkward...\n  }\n});\n```\n\nWith the upcoming #257, which replaces `allResolved` with a more accurately-named and less-awkward `allSettled`, you'd get access to objects of the form `{ state: \"fulfilled\", value: v }` or `{ state: \"rejected\", reason: r }`, which would make the code into\n\n``` js\nQ.allSettled([\n  promiseThatFulfills,\n  promiseMaybeRejected,\n  promiseThatFulfills]).spread(function (a, b, c) {\n  a = a.state === \"fulfilled\" ? a.value : \"default A\";\n  b = b.state === \"fulfilled\" ? b.value : \"default B\";\n  c = c.state === \"fulfilled\" ? c.value : \"default C\";\n});\n```\n\nWhat do you think of that?\n. Oh nice gist; you're right, you can't combine `spread` and `allResolved` in the way I'd thought you would, because of the way `spread` does an `all` internally. Thankfully `allSettled` doesn't have the same problem :).\n. @Redsandro are you using the latest version of Q? The non-extensibility was removed a while ago.\n. `Object.freeze` is a superset of `Object.preventExtensions`, and we used to do that.\n\nAs to which is preferred, technically most methods should be defined with `Object.defineProperty`and `configurable: true`, and probably `writable: true`. `enumerable: false` is the default so you don't need to explicitly state that.\n\nBUT, Q itself doesn't use `Object.defineProperty` since Q maintains IE8-compatibility, so using just assignment is fine and possibly better since it fits with Q's existing practice.\n. Oh, also maybe I should add this to the `prepublish` step? It's not quite what prepublish is made for, since it has no impact on the packaged artifacts, but _if_ you do `npm publish` before you do a `git push`, it's nice, and if you do it after (like I usually do), it'll possibly be a \"whoops, forgot to minify\" reminder.\n. Oh, nope, I lied, we need it for `promiseDispatch` which is pretty fundamental (lol). Not getting away with this after all.\n. @kriskowal after looking into it, Chrome [removed](https://groups.google.com/a/chromium.org/forum/?fromgroups=#!topic/blink-dev/JJ7I6BOX8qA) the ability to detect if the console was open. And it was kind of hacky anyway, either cluttering your console with \"Profile Started ... Profile Ended\" or forcing Q to do a `console.clear()` and lose any console data before Q loads.\n\nCombined with my slight unease about the dominant pattern for `NODE_ENV` defaulting to development, I think it's best to just leave the long stacks off by default. So, this pull request is good as is.\n\nAny comments before I merge?\n. @kriskowal when you have time I think this is the only thing I want to get in before doing a 0.9.5. Then we can move on to more experiments like #313 and the nextTick stuff, mwuahaha.\n. Awesome :). Yeah, will do tomorrow\u2014bedtime now!\n\nOn Jun 10, 2013, at 1:07, \"Kris Kowal\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nThis looks good. Would you like me to merge this and cut the release?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/311#issuecomment-19181017.\n. Merged as 49d920d067619cbd751677302b3d396bb32b0eb5 and 97f4c6b17ce45d0ac5bcd871b5ac37e616c3cff0, w00t (and yay for avoiding merge commits!).\n. I have tests in a branch https://github.com/kriskowal/q/tree/perf but am not sure they're any good. This match thing was _way_ easier to use than BenchmarkJS, but doesn't run in browsers. And I think we'll need to write a custom reporter anyway to get relevant data (e.g., we care about the quotient of Q to setImmediate rather than how many ops/s each takes).\n. My perf tests are rudimentary and should eventually be replaced by something much better, but after breakfast I think I'll merge them in just to give us something.\n. OK, merged in to master. Let's please use this thread for ideas on additional performance tests. It also needs to be rewritten with BenchmarkJS I think; Matcha is super easy to use, but not very maintained or rigorous or browser-compatible.\n. That first blog post has major methodology issues that have been discussed at length. I would not be surprised if the third does as well, given that it's from someone who believes that synchronous resolution is The One True Way.\n. I like this as a good first step but I think two generated files in the repo is getting into bad news territory. If we did this I'd prefer to do some kind of automated upload-to-S3 thing.\n. Thanks for finding this! The inline documentation is in need of some love... I just pushed an update that includes this, except it uses the more correct term \"settled\" (= \"fulfilled or rejected\") instead of \"resolved\" (= \"fate has been sealed, possibly by resolving to another promise that hasn't yet settled\").\n. Here are the results from my nascent perf test suite:\n\n### Before\n\n```\nDomenic@REVAN ~/Dropbox/Programming/GitHub/q (perf)\n$ npm run benchmark\n\n> q@0.9.6 benchmark C:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\n> matcha\n\n\n                      A single simple async operation\n          52,342 op/s \u00bb with an immediately-fulfilled promise\n         388,053 op/s \u00bb with direct setImmediate usage\n              64 op/s \u00bb with direct setTimeout(\u2026, 0)\n\n                      1000 operations in parallel\n              46 op/s \u00bb with immediately-fulfilled promises\n             751 op/s \u00bb with direct setImmediate usage\n\n                      Chaining\n              41 op/s \u00bb Chaining many already-fulfilled promises together\n              45 op/s \u00bb Chaining and then fulfilling the end of the chain\n\n\n  Suites:  3\n  Benches: 7\n  Elapsed: 11,221.02 ms\n```\n\n### After\n\n```\nDomenic@REVAN ~/Dropbox/Programming/GitHub/q (perf)\n$ npm run benchmark\n\n> q@0.9.6 benchmark C:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\n> matcha\n\n\n                      A single simple async operation\n          71,349 op/s \u00bb with an immediately-fulfilled promise\n         317,659 op/s \u00bb with direct setImmediate usage\n              64 op/s \u00bb with direct setTimeout(\u2026, 0)\n\n                      1000 operations in parallel\n              46 op/s \u00bb with immediately-fulfilled promises\n             904 op/s \u00bb with direct setImmediate usage\n\n                      Chaining\n              48 op/s \u00bb Chaining many already-fulfilled promises together\n              57 op/s \u00bb Chaining and then fulfilling the end of the chain\n\n\n  Suites:  3\n  Benches: 7\n  Elapsed: 10,575.42 ms\n```\n. @ForbesLindesay I believe Montage Require uses normal CommonJS modules, with no special syntax (i.e. no AMD `define` analog). But, Q is a special case since a promise library is used for \"bootstrapping\" the module system itself---you can imagine how promises are useful in writing module loaders. So including `bootstrap` code is both (a) not necessary for any modules except Q, and (b) necessary for Q.\n\nSimilarly, I am pretty sure a \"Q implementation\" is a privileged part of SES used for secure communication channels, and SES doesn't generically expose libraries via `ses.makeLibraryName` functions. So, similarly... not necessary except for Q.\n\nSo ideally UMD would remove the `bootstrap` and SES code. Which leaves us wondering how Q can include them. Custom templates, or perhaps template additions, would be one idea... maybe browserify's `browser` field could be extend to include a `umdSupplements` string or something?\n. Another idea: if a module exports a `__umd__` function, then UMD calls that; if it returns `true`, UMD does nothing else, but if it returns `false`, UMD sets up the global or `module.exports` or `define`.\n. @rkatic I have thoughts in making that work via [zuul](https://github.com/shtylman/zuul). It would require switching to Mocha, but I think I can pull that off.\n. @kriskowal re:\n\n> This is part of a move to introduce modularity to Q, and shuck dependencies out to other packages. I\u2019m not sure what the ramifications of this will be for the AMD world.\n\nWe should be able to get away with no real impact, since browserify's standalone option bundles up everything into one big AMD module. So if we end up depending on a CommonJS WeakMap and \"asap\" implementation, those just get stuffed inside the main UMD closure and never exposed; the outside world ends up seeing only the `Q` export. This has a minor downside in potential code duplication if e.g. a user ends up including both Q and asap, as then they will have two copies of asap. But I don't think for our case that will matter much.\n. @kriskowal yeah, I understand that one, was more just addressing your concern about the impact of using other packages as part of Q. In terms of the upgrade headache, I think it will be that those users have to change their mappings config from\n\n```\n\"q\": \"/path/to/externals/q/q\"\n```\n\nto\n\n```\n\"q\": \"/path/to/externals/q/release/q.umd\"\n```\n\nwhich hopefully is OK for users.\n. @ForbesLindesay\n\n> It sounds like it might be best to have a custom script that takes a CommonJS module or a UMD module and adds montageRequire/SES exports?\n\nNot sure exactly what this would look like but maybe you meant something like this appended to Q?\n\n``` js\n(function () {\n  var savedQ = Q;\n  if (typeof ses === \"undefined\") {\n   delete window.Q; // i guess we need to get the global, not always use `window`.\n   ses.makeQ = function () { return savedQ; };\n  }\n  // etc.\n}());\n```\n\nCould work I guess, hmm. Not as nicely integrated into the browserify pipeline, and we'd have to find some concat-files grunt plugin for cross-platformness, but seems possible.\n. Now that GItHub has releases what do we think of having the release-maker upload the `.min.js` and `.umd.js` scripts as part of the release, instead of checking them in to source control? https://github.com/blog/1547-release-your-software\n. @ForbesLindesay what's our plan?\n. Closing in favor of #352.\n. Nope, not sure where you got that impression? We switched from put to set in 0.9.0 I believe.\n. We should probably switch the name from q.js to q while we're at it.\n\nIt looks like they do new versions via GitHub pull requests. I know @ForbesLindesay has some experience with the GitHub API---I bet he could whip something up really quickly, or at least point us in the right direction :)\n. Relevant: https://github.com/cdnjs/cdnjs/pull/1583\n. We don't believe that minified files should be in the source repository. That is, there is no such thing as an official q.min.js. If you would like those on your CDN, you will need to generate them yourself.\n. Indeed, it was introduced in 0.9.5: https://github.com/kriskowal/q/blob/master/CHANGES.md#095\n\n> (aside, it might be better to have a method to enable long stack support so I get an error if I use the wrong name)\n\nThat seems like a pretty good idea actually; @kriskowal thoughts?\n. Promises can only be fulfilled with one value, just like sync functions can only return one value. This kind of consistency guarantee is a very important part of programming with promises.\n\nIf you encounter such an ill-behaved Node method, which calls back with more than one value, Q fulfills the resulting promise with an array composed from those values. Note that if you have a promise for an array, you can use `spread` to get a slightly nicer syntax for extracting values from it. In fact, it would be very close to your second hypothetical piece of code, except it would explicitly call out the fact that your async function call \"returns\" (i.e. returns a promise that fulfills with) an array, by saying \"spread\".\n. This is an interesting idea. @kriskowal, what do you think of these semantics? Would they be desirable? I'm not sure myself... leaning toward \"no, too much magic.\"\n\nNote that the following already works with Q:\n\n``` js\n\"use strict\";\n\nvar Q = require(\"q\");\nvar domain = require(\"domain\");\n\nvar d = domain.create();\nd.on(\"error\", function (err) {\n    console.log(\"error caught\", err);\n});\n\nd.run(function () {\n    Q.nfcall(function() {\n        setTimeout(function() {\n            throw new Error(\"not catched\");\n        }, 100);\n    })\n    .then(function() {\n        console.log(\"ok\");\n    })\n    .fail(function() {\n        console.log(\"fail\");\n    });\n});\n```\n. FWIW I've really started to come around to this idea as a way of plugging a \"hole\" in the promises + Node.js love story. I was talking with @piscisaureus at NodeConf who wants to make some changes to domains to make them more robust and nice to work with, and part of his idea was vaguely promise-like, but a key part of that was this domain safety net.\n\nIt is something we may explore in a separate package or something in the future, creating super-promises augmented by domains that can wrap Node functions to make them ergonomic, `yield`able, and bulletproof against both user-derived errors (e.g. `throw`ing inside the callback) and bug-derived logic errors (e.g. double-callbacking or calling back with both an error and a result). These super-promises would likely be highly micro-optimized as well, e.g. sacrificing encapsulation and integrity in favor of prototype-based approaches or purposefully not-next-ticking when coming from a known-async operation (like https://github.com/promises-aplus/promises-spec/pull/104#issuecomment-19279854).\n\nStay tuned.\n. Yes. That is how `allSettled` works.\n- https://github.com/kriskowal/q#combination\n- https://github.com/kriskowal/q/wiki/API-Reference#promiseallsettled\n. > I\u2019m also thinking that we should not delay rejection.\n\nWatching from the side, I think I agree.\n. Please don't minify when submitting pull requests. I believe that is in the Contributing.md? (If not we should add it.)\n\nOn Jun 29, 2013, at 1:59, \"wmertens\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nI agree as well :)\n\nNew semantics, all tests pass, minified.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/326#issuecomment-20226751.\n. I kind of like it... Not sure we can make it conceptually coherent, however. I want a solid story so that `yield anything` has a straightforward meaning. The easiest meaning is that `yield anything` means `yield Q.resolve(anything)`, i.e. if it's not a promise, we just pass it through. But... so convenient...\n\nI've toyed with this before, in the context of extending `Q.all` so that it works on both objects and arrays. But, once we got that far, it feels a bit strange to special-case `Array.prototype` and `Object.prototype`. To show what I mean...\n\n``` js\nvar x = yield promiseForX;\n// it's a promise, this is our base case, it does what you expect.\n\nyield [doOneThing(), doAnother()];\n// could we make this equivalent to\nyield Q.all([doOneThing(), doAnother()])\n// ?\n\n// what about this??\nvar { one, two } = yield { one: doOneThing(), two: doAnother() };\n// if #328 is adopted and Q.all works with objects, then the translation\nvar { one, two } = yield Q.all({ one: doOneThing(), two: doAnother() });\n// does what you'd want\n\n// but what about:\nvar x = yield regExp;\n// regExp is an object, so what does Q.all do to it? When do we do Q.all vs. Q.resolve?\n```\n. I am hesitantly in favor of this approach, but @kriskowal favors #159. I can see his point, because where do we stop? What about custom class instances that aren't just derived from `Object.prototype` or `Array.prototype`? Arrays are just objects too, so why do we use special logic for them? It's a bit weird.\n\nThat said, your example could be much nicer written as\n\n``` js\nQ.all([getCost(), getTaxes(), getShipping()]).spread(function (cost, taxes, shipping) {\n});\n```\n\nassuming you had no use for the actual `results` object. Which might not be the case; @stefanpenner has mentioned how RSVP's `RSVP.hash` is pretty useful in Ember for building objects out of promises over time.\n\nAnyway, I'll let @kriskowal make the decision on whether to close this one or reconsider, but spoiler warning: I think he probably will close :P.\n. @kriskowal does this work now?\n. Any interest in `Q.hash` to match the original functionality request without overloading `all`?\n. [`Q.allProperties`](https://github.com/kriskowal/q/issues/159)?\n\nI personally am not that excited about this method (I think `spread` covers it pretty nicely) but I know other people are. Some people use it to build up an object's properties asynchronously.\n. > is there a dev switch i can flip and make it halt my app on all unhandled errors ? \n\nFWIW the idea of building a dev console that tracks all unhandled reasons has been in the back of our minds for a long time. There's something hacky in place with outputting a live array to the console, but it doesn't seem to always work (and doesn't help in Node.js). In Node.js we output all unhandled reasons to the console on exit. Finally you can always check `Q.getUnhandledReasons()`. But in the future we'd like a nicer story here.\n. -1, this just introduces a weird way of writing `then` chains which makes your code non-idiomatic.\n. I think we shouldn't gear our opening paragraph toward solving Node users' problems; it's fine to relegate that to the bottom of the readme. Promises are much bigger than Node :). That said, I can see how the juxtaposition of example code might be confusing as is. Perhaps if we changed it to\n\n``` js\nQ.fcall(promisedStep1)\n.then(promisedStep2)\n.then(promisedStep3)\n.then(promisedStep4)\n.then(function (value4) {\n    // Do something with value4\n})\n.catch(function (error) {\n    // Handle any error from all above steps\n})\n.done();\n```\n\nAnd maybe add \"where `promisedStepN` is a version of `stepN` that returns a promise\".\n\n@kriskowal, @danieldkim let me know what you think, if that sounds good I'll update the readme with it.\n. This isn't really a supported scenario. We can't determine what \"progress\" means for a promise composed from `Q.all`. For example, assume you had three promises emitting `\"33%\"`, `\"67%\"`, and `\"100%\"` progress data, but at various speeds. Then you `Q.all`ed them. The resulting promise could end up emitting a stream of progress data that looks something like `\"33%\", \"33%\", \"67%\", \"100%\", \"33%\", \"67%\", \"67%\", \"100%\", \"100%\"`, which is pretty darn WTF.\n\nOnly you know your domain well enough to say what the progress from an aggregated promise is, so we can't have `Q.all` just combine everything.\n. Nope. If you know your domain well enough to recommend aggregation, then explicitly aggregating inside your code is a good way to show it.\n\nYou can also use `Q.promise` for a different syntax, e.g.\n\n``` js\nvar aggregated = Q.promise(function (resolve, reject, notify) {\n    resolve(Q.all([promise1.progress(notify), promise2.progress(notify)]));\n});\n```\n. Hmm, well then! Sounds like a feature. Reopening!\n. @rkatic Hmm I think you're right, that's better especially in light of the promise-streams branch. I'll try to get around to fixing that.\n. I couldn't think of a way for `done` to make sense, but switched to object literals instead of arrays.\n. We should remove `allResolved`.\n. LGTM, thanks for the catch.\n. Fixed by #339. Thanks for being persistent and bugging us until this got fixed :).\n. This is very exciting. It's also more new concepts than I can reasonably judge before seeing them in practice :). So if you're happy with it, let's include it!\n\nThe only concern I have is that this seems pretty different from how I envisioned an ES6-based API, which was just as a naive iterator of promises. For example the existence of `return` and `send` confuses me; ES6 merged `send` and `next`, but doesn't even have a `return`. So I'm a bit confused. But I haven't thought about this whole thing nearly as hard as you have and am willing to trust your judgement.\n\nFinally there's the age-old question of whether this should be in the main file or in a separate module (`require(\"q/queue\")`, etc.), or even package. I'm not sure, to be honest: I like the idea of keeping the core lean, but I don't want to relegate this innovative new stuff into a place where people might not think to use them.\n. > Breaking it into a module is even more problematic since a promise is a promise for an object of _any_ type.\n\nI don't quite understand this part?\n. Probably want to move the primary implementations to the prototype, since that's our main strategy now?\n. Ah yeah, it looks like just `all` is left out. https://github.com/kriskowal/q/blob/master/q.js#L1713-L1725\n. We can probably do a release without browserifying anything, right?\n. What do we think of making `all` consistent with `allSettled`?\n. This seems great in general. Maybe I should merge in my rudimentary perf test suite, even if it's not very great, just so we can get some numbers.\n. Awesome!\n. Ignoring Q's long stack trace rewriting, what happens if you just use CoffeeScript and Browserify and then do `console.log((new Error()).stack)`?\n. Yeah it sounds like browsers just don't support source-mapped `.stack` properties yet :(. I don't think it's a Q-related problem, but rather something to take up with the browser vendors.\n\nIn the meantime people seem to be attempting to work around it in user space: https://github.com/evanw/node-source-map-support https://github.com/janekp/mapstrace etc.\n. > Regarding streams2, the readable callback may still get invoked before the promise callback, right?\n\nThat's correct; more robust code would just call `res.read()`, and only subscribing to `'readable'` if `res.read()` returns `null`.\n\nBut the main point is that the data doesn't go anywhere until you call `read()`. In streams1, since it \"pushed\" data at you in `'data'` events, if you missed that event you would lose data. In streams2, no data is ever lost, since you have to \"pull\" it with `read()`.\n. > It might make sense to include a small section in the tutorial for jQuery users though.\n\nFrom https://github.com/kriskowal/q#the-middle:\n\n> When working with promises provided by other libraries, you should convert it to a Q promise. Not all promise libraries make the same guarantees as Q and certainly don\u2019t provide all of the same methods. Most libraries only provide a partially functional then method. This thankfully is all we need to turn them into vibrant Q promises.\n> \n> ``` js\n> return Q($.ajax(...))\n> .then(function () {\n> });\n> ```\n. > It can be confusing for new programmers looking into promises, what exactly promiseMeSomething() is.\n\nI guess the issue here is that we leave creating promises for later in the tutorial. I think that's still the right approach, but perhaps we could clarify in prose something like \"`promiseMeSomething()` is a function that returns a promise; we'll get to how to create such functions later.\" Or maybe just add an introductory sentence or two at the start of the tutorial saying something like \"we'll first explore how to consume promises given to you, then move on to how to construct your own.\"\n. I added a paragraph saying that we'll explain how to create promises later in the document. Hopefully that helps. I don't think suddenly introducing promise creation, with an unexplained `promiseMeSomething` implementation, is quite the right approach. But thanks so much for pointing this out to us! Let us know if you think it's still unclear or if there's anything else we can do.\n. Gah, nice catch! Why is this such an easy mistake for us to make... Seems like every all/allSettled implementation I've seen for any promise library always has this bugfix in their commit history.\n\nPull request welcome if you want all the fame and glory for yourself. Should be a pretty quick one :). Otherwise we will fix it ASAP.\n\n@kriskowal I'm feeling another 0.9 point release coming on...\n. I can't reproduce this on the latest master; it was probably fixed as part of some architectural changes that have been going on. In any case, I added a test so we can be sure it doesn't happen again.\n. Seems like a really good idea overall. I'm assuming that keeping writing capabilities to yourself, and vending reading capabilities, will be much less common with queues than it is with promises. (Otherwise I imagine we'd move more toward a deferred-style interface, where the reading capabilities are only exposed on the iterator, not on the queue itself.)\n. I wonder about the naming; `get` seems to me to be too much of a false parallel with `Promise.prototype.get`. Alternate pairings, just as a possibility:\n- enqueue and dequeue\n- push and pull\n- unshift and pop\n- push and shift\n- yield and next (so e.g. `queue.yield(x)` would call `queueGenerator.yield({ value: x, index: 0 })`)\n. @kriskowal probably another candidate for backporting to a 0.9 branch, along with #345.\n. Well, if we don't need q.montage.js and q.ses.js, then that makes things easy. We can just do q.umd.js with Browserify's built-in support. (See also https://github.com/ForbesLindesay/umd/pull/5.)\n\nI don't think we get free S3. It's pretty cheap though? Maybe there's something else that does this kind of hosting free? But anyway, Travis has the ability to use encrypted data to perform stuff ([docs](http://about.travis-ci.org/docs/user/encryption-keys/)). The two-second version, from what I understand, is that you run some stuff on your computer that takes confidential stuff like S3, then it spits out some encrypted gibberish you put in the .travis.yml, and then the decrypted stuff will be available as environment variables.\n\nNot sure exactly what you mean by keeping it simple to fork the project infrastructure, but hopefully the above helps answer that?\n. @stefanpenner @fivetanley how do you guys deal with S3 costs for Ember/what do they approximately end up being?\n. Sounds reasonable. A bit more work (will need to browserify an intermediate module that does `global.Q = require(\"./q\");` for the global version, and will need to use the RequireJS optimizer's CJS -> AMD mode for the AMD-only version).\n\nI think it's a bit confusing to call the `<script>` version simply \"q.js\". I'd prefer \"q.global.js\".\n\nYay for S3! I'll give it a try on domenic/q (since presumably Travis won't let me encrypt things as if I were kriskowal). If it works out hopefully you'll just run something to generate some encrypted API keys and we can be good to go.\n. +1 for killing the .min.js's.\n\nI'm agnostic to giving our users both CommonJS and UMD options vs. giving them CommonJS, global, and AMD separately.\n. OK guys, check out https://github.com/kriskowal/q/compare/from-commonjs. S3 is up next if you're happy with this.\n\n@kriskowal, let me know if the output and input look good.\n\n@jrburke, let me know if there's a way to configure the RequireJS optimizer to not make q.amd.js a named module.\n. @jrburke I was hoping to not have to write a custom tool to do cross-platform prefixing of `define(function (require, exports, module) {` and suffixing of `});`. Indeed, I was hoping that the RequireJS optimizer's `cjsTranslate` option was exactly that.\n\nIt sounds like I was not on the right track there, though. Do you know of any such tool?\n. We might also, at some point, want to use multiple modules within the `q` package itself, even if those modules do not deserve to be separate packages. For example I've always envisioned putting the promise-for-object methods in one file, promise-for-array in another, etc.\n\nFor simplicity's sake let's consider the following scenario, with regard to the CommonJS source files:\n\n```\nq.js (contains `require(\"./q-extras\")` and `require(\"asap\")`)\nq-extras.js\nnode_modules/\n  asap/asap.js\n```\n\nI wonder if the AMD deliverables should then be simply `q.amd.js` and `asap.amd.js`, or whether they should be `amd/q.js` and `amd/q-extras.js` for Q, and `amd/asap.js`? (I switched from `.amd.js` to `amd/` prefix because `require(\"./q-extras\")` wouldn't work for `q-extras.amd.js`.)\n. Right, \"and `amd/asap.js`\" should have been \"and `amd/asap.js` for ASAP.\"\n. @jrburke ahah, that was it! I knew I'd done this before successfully, and it was the command line switch that did it. Might not work so well since Q doesn't isolate its .js files under a `lib/` directory, but your next trick should be enough. \n. I made some things and now it is nicer: https://github.com/kriskowal/q/commit/515eea1cf63215acd0785e0a3ee9fdbe7400d149\n. @kriskowal I think it's probably ready to go if we leave S3 for later. Not entirely sure though, it's been a few days. I'll try to do the following tonight or tomorrow night:\n1. Make sure it's good to go besides S3/volo (i.e. I didn't forget anything).\n2. Get the Volo stuff in there\n3. Hook up S3\n\nPresumably 1 and 2 are easy and if I manage to do those but don't find enough time for 3, then we'll still be OK.\n. TADA!\n\nhttp://q-releases.s3-website-us-west-1.amazonaws.com/q.js etc.\n\nvia https://travis-ci.org/kriskowal/q/jobs/10262956#L1068\n. @jrburke how does e69e08b190ac5d9cf1f6f9ddc2bba87b0d479786 look?\n. Yeah, I think I'm going to have to do something smart and upload versioned releases (not sure exactly how; detecting if the current push is tagged or something?).\n\nBut once we do that it's not so bad; volo supports `{version}` in the URL string.\n. volo is also tied to GitHub I believe so we can't host the package.json elsewhere.\n. Implemented!\n. Yeah, unfortunately there's not really anything we can do here. If you want those parameters you'll have to do the wrapping yourself; Q can only absorb one parameter.\n\nExample code would be:\n\n``` js\nfunction withAllParams(jQueryPromise) {\n    var deferred = Q.defer();\n    jQueryPromise.then(\n        function () {\n            deferred.resolve(arguments);\n        },\n        function () {\n            deferred.reject(arguments);\n        }\n    );\n\n    return deferred.promise;\n}\n```\n\nMy preference is to create methods that wrap `$.ajax`'s semantics more correctly, e.g. as in https://github.com/domenic/client-side-packages-demo/blob/e60197d8e331dd5a1716af12d657f42f7c7336ff/lib/github.js#L7-L33\n. I believe (@kriskowal can confirm) that we have transitioned away from safety and toward speed in this instance, in #181.\n. We're still vulnerable to modifications to `Function.prototype.apply`, but, moving that line out was probably a good idea anyway.\n. LGTM\n. Yeah, promises can only be fulfilled with one value, just like functions can only return one value. If you need multiple values, you should use an array.\n. I could swear this worked until recently; I thought util.inspect recursed on itself.\n. Ah, this is fixed in Node 0.11, but the fix was not back-ported to 0.10: https://github.com/joyent/node/commit/66280de133a56964641a08291b06fc0e5ca2b4e1\n. Look closer at your code. The moment you call `qecho(4)`, it generates a random timeout, then uses `setTimeout` to schedule a `console.error` some milliseconds in the future. Since you call `qecho(2)`, `qecho(3)`, `qecho(4)`, and `qecho(5)` all at once, not waiting until the `then` calls you back, all these timeouts will be scheduled at once.\n\nAlso, doing `.then(qecho(4))` will be equivalent to passing `.then` a promise, since that's what `qecho(4)` returns. That doesn't work; only passing functions works.\n. Q 0.9.7 was released a while ago and should work great.\n. +1\n. Do you want to merge this ahead of the from-commonjs stuff?\n. Merged as f7a75056188321cfb7b079ec571164338aa506a5.\n. Seems good. Loses a little bit of information by coercing all reasons to strings, and makes the method name slightly inaccurate, but since the method is for debugging purposes it's definitely a win in terms of functionality.\n. I am ambivalent. That sounds better in theory, but in practice it hopefully never matters, and might bloat the API or make it more complicated to use. I guess it depends how nice the alternate solution would be. We probably _can_ figure out something nice, I suppose :).\n. Wow it looks like you did all the hard stuff. The further work sounds pretty easy to me :D.\n\nOvertaxed with real-life events, finishing off vm2, and some Promises/A+ and JSIDL stuff this week, but I am definitely down for finishing this up on the weekend.\n. Hmm, on my computer `headHash` ends up containing `ref: refs/heads/from-commonjs-release`. I guess it's probable that on Travis they'll check out specific commits and it'll contain a hash. Would be nice to be able to run releases locally though.\n\nWe could make it work by checking to see if it's in the form `ref: ...` and then reading the `...` path. Not sure.\n\nPushing a combined branch with my original stuff + your stuff + some stuff on top of it to this PR. (EDIT: well, that push didn't work, at least from GitHub's perspecive because it still wants to put it on top of from-commonjs.)\n. Verified, it does work on Travis: https://travis-ci.org/kriskowal/q/jobs/10962943#L1086\n. If only Node had `execSync`, this would all be a lot easier. Coming in 0.12, but still.\n. @stefanpenner @fivetanley how do you guys make the pretty page at http://builds.emberjs.com/\n. @kriskowal made this listing page, should be nicer http://q-releases.s3-website-us-west-1.amazonaws.com/\n. @kriskowal a few questions:\n- Do you think we should produce minified versions of all the AMD files? I am thinking probably not, since people will use e.g. the RequireJS optimizer to minify and concat. We can just produce minified q.js.\n- Should we set headers to text/plain to discourage hotlinking, like raw.github.com does?\n- Any thoughts on directory structure, e.g. maybe `commits/{sha}`, `versions/{version}`, `latest/*`, etc.?\n. This has been merged, w00t.\n. See also https://github.com/promises-aplus/promises-spec/issues/128, wherein a few implementers have shared their work on this. It appears to be largely painless.\n. So it sounds like on Node 0.11.x there's a bug in `inspect`? Seems like not our problem.\n. Sounds like this was not a bug in Q. Feel free to open a Node 0.11.x bug, if someone confirms that this is the problem.\n. I dislike exposing accepted as a state. Unfortunately I am not sure I know of a way around it. Perhaps inspect() could trigger the unwrapping process? But no, access to untrusted \"then\" methods must be done in a fresh stack, so that would never be useful. Sigh. It definitely complicates the pedagogical story.\n. lol!\n\nThe memoization plan makes sense to me, as does the analogy :). Sigh, now to spec all this...\n. BTW @kriskowal would love your feedback on https://github.com/domenic/promises-unwrapping, which tries to capture this late-unwrapping shift. It still needs memoization work though.\n. Have you actually tested those two code samples? The first works; the second does not.\n. Right, if there is a badly-behaved node API that sends more than one non-error parameter, we wrap that up in an array. I suppose that should be noted. Most Node APIs do not do this, though.\n. You can make your code slightly shorter with `spread`:\n\n``` js\nreturn Q.nfcall(request.get, opts).spread(function(res) {\n    if (res.statusCode === 200) {\n        // etc ...\n```\n. Nah, let's leave it open to track the desired documentation note about badly-behaved APIs.\n. Turns out we already have that note in the API reference:\n\n> Note that if a Node.js-style API calls back with more than one non-error\n> parameter (e.g. [`child_process.execFile`][cpef]), Q packages these into an\n> array as the promise's fulfillment value when doing the translation.\n. @kriskowal have you seen https://github.com/kriskowal/q/wiki/General-Promise-Resources ? :)\n. This has been considered and rejected in the past. For me the most compelling argument is the slippery-slope one. What about `Error` instances which have properties which are promises? What about arbitrarily-nested prototype chains with promises as properties at each level of the chain? What about arrays with non-numeric properties that are promises? What about if someone adds a promise property to `Number.prototype` and then does `Q.all(5)`? Why are arrays treated specially, since they are just objects too? ETc.\n\nYou can find more discussion in previous issues on the subject: #159, #171, #328.\n. I am surprised this would occur with http.get, but maybe try doing `http.get.bind(http)` before passing it in?\n\nA small piece of code illustrating this failure would be helpful for us to debug.\n. Ah! Yes, of course. `http.get` is one of the unfortunate functions in Node whose callback doesn't follow the standard `(err, value)` form, but instead just passes you `(value)`. Q can't automatically adapt those :(.\n. BTW you may enjoy this version of your code that I put together for testing. It uses [pipe](http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options) to get much better flow control (e.g. the TCP socket will slow down reads if the FS is slow), and ensures all errors are handled (since there is no error parameter you can rely on).\n\nIt's also a good example of a small self-contained file that you can use when reporting bugs on peoples' projects :).\n\n``` js\n'use strict';\n\nvar Q = require('q');\nvar http = require('http');\nvar fs = require('fs');\n\nfunction httpQ(opts) {\n    var deferred = Q.defer();\n    http.get(opts, deferred.resolve);\n    return deferred.promise;\n}\n\nhttpQ('http://www.sachinbhatnagar.com').then(function (response) {\n    var writeStream = fs.createWriteStream('./newoutfile.txt', { encoding: 'utf-8' });\n    response.pipe(writeStream);\n\n    response.on('error', function (err) {\n        console.log('There was an error reading');\n    });\n\n    writeStream.on('error', function (err) {\n        console.log('There was an error writing');\n    });\n\n    writeStream.on('finish', function () {\n        console.log('JOB DONE!');\n    });\n}).done();\n```\n. > Hey thanks Domenic. The code i pasted here was a part of a bigger script, so I posted only what was causing issues. \n\nRight, but when asking for help, it's considered polite to spend the extra time to create a self-contained example that the maintainers can run on their own, instead of forcing them to do so themselves.\n\n> So, for functions which do not follow the standard node style callback, the way out would be to use the Q.defer() method ? Is that correct ?\n\nYeah, that's it! Kind of sad, but when Node is inconsistent with itself, what can we do?\n. That wouldn't really work very well with the nature of promises; for example:\n\n``` js\ndoXHR(url)\n  .then(JSON.parse)\n  .then(function (parsed) { console.log(parsed); }, function (err) { console.error(err); });\n```\n\nLet's say `doXHR(url)` returns a rejected promise. We omitted an error handler from the next step, `.then(JSON.parse)`, so your default error handler kicks in and it does `.then(JSON.parse, defaultErrorHandler)` instead. But now, since your default error handler got in the way, the promise is no longer rejected---you intercepted the error, after all---and the `console.error(err)` never happens!\n\nIn short, chaining is the appropriate way to deal with this. Put your shared code in a function, call it `defaultErrorHandler`, and then at the end of your chain, do `.catch(defaultErrorHandler)`. Note that you only need to do it at the end of the chain!\n. OK cool! Yeah, ideally promise-based programs are chains all the way up. The only reason to start a new chain is if some outside source (usually an event source, like a click or a incoming connection) starts up a new call stack, and you need to do some new async stuff there in that context.\n. Merged as 188f4cdce3a60aa530b4a10f2d32cc8648a30593.\n. Done. Please everyone feel free to add more. https://github.com/kriskowal/q/wiki/General-Promise-Resources\n. Whoops, accidentally merged this while trying to merge #379 :(. Um, @kriskowal, please look it over so I feel less bad.\n. >  'function(...){console.log(...)}' is the same as 'console.log'\n\nThis is actually not true unless `console.log` is bound to `console` which is only the case in Firefox (EDIT: and, as Kris says, in Node).\n. What version of Q? Also maybe upgrade the Node version to 0.11.7.\n. Node 0.11.2 does not support generators correctly. Upgrade to 0.11.7.\n. You are ignoring the promise returned from the function you immediately invoke. You should either call .done() on it, or use Q.spawn, which was made for exactly this use case. Q.spawn(...) <-> Q.async(...)().done()\n. You can't pass a promise to `.then`; you have to pass functions.\n\nYou may be interested in `.thenResolve`.\n. Thank you! Merged as 0b4aa3f1c267e2d75220334375123e47a14530c3 with some minor tweaks.\n. This is strictly more useful than what we have now, I suppose.\n\nI would prefer that we do what ECMAScript does, i.e. `return value[name] = rhs` and `return delete value[name]`, but I admit those return values are not very useful and that returning `value` would be more useful.\n\n@kriskowal, thoughts? I know we've changed this a few times already in various directions.\n. Right, I knew there was a good reason... should have looked back through old issues.\n. We're definitely going to need to split the API reference page into v1 and v2. Probably keep the existing page as one containing links to the two sub-pages so as not to break links.\n. LGTM, maybe get rid of the merge commit. Exciting times!!\n. Are we OK with including Q meaning that you automatically modify the user's environment to have a full ES5 shim? I wonder if we'd prefer a shims.js module inside the Q package.\n. Note that personally, I have no problem doing the modification, as I think everyone's entitled to some good old ES5, and should be using es5-shim anyway. But then again, maybe the correct thing to do would be to just start using the shimmable subset of ES5, and say that having set up es5-shim yourself is a prerequisite for using Q in older browsers. That way it's in the user's hands.\n. That actually isn't a problem, as it just looks things up in the internal map. The reason it happens is that we write the intermediate file to `os.tmpDir()`, instead of to the project directory, so as to avoid breaking watch workflows. (See https://github.com/domenic/global-wrap/commit/b421a2d2ee78280ba4022537018274a58b7d3a8f.) It makes the generated code a bit weird, but does not impact functionality.\n. weak-map is ES5 only, right?\n. This seems very nice. I am excited.\n. > I think we should consider the shift anyway.\n\nI agree. Although I might consider something less sophisticated but with similar properties, e.g. [this approach](http://cwestblog.com/2011/05/04/private-variables-in-javascript/).\n. Weak map also allows us to maintain a [thenable coercions weak map](https://github.com/domenic/promises-unwrapping#the-thenablecoercions-weak-map).\n. Right, I suppose it'd be pretty easy to intercept the \"key\" in that linked example by just shadowing `_` on a given person instance. I see what you mean.\n. I wonder how `postMessage` fares...\n\nI actually have an IE10 mobile device, so I can help test this! After I do the other billion things on my to-do list for the weekend...\n. [Or is there...](https://github.com/NobleJS/setImmediate/blob/master/setImmediate.js#L161-L179)\n. They're not part of the API, so this doesn't really make any sense to me...\n. This will not work, because q.js is CommonJS and not browser-consumable.\n\nThe correct thing to do is to run `npm run test-browser` to run the browser tests; this will put a built q.js in the release directory.\n. Don't use the complete handler; just convert the jQuery promise to a Q promise using the Q function as soon as possible and then you can manipulate it like normal.\n. Right, you will get the first argument (data). If you need `xhr` you should save it in a variable then refer to it inside the handler.\n. I am -1; I find chaining interfaces unintuitive and confusing. ([Command-query separation](http://en.wikipedia.org/wiki/Command-query_separation) and all that.) Up to @kriskowal though.\n. `any` is not a great name, because you would expect it to be the dual of `all` (i.e., the \"there exists\" to `all`'s \"for all\"), and the semantics of `all` are \"if all fulfill.\" Thus `any` would be expected to be \"if any fulfill,\" not \"if any settle.\"\n\nIf anything, `race` could be (re)named `anySettled`, and we could add a new \"any\", giving a total of four operations: all, allSettled, any, anySettled.\n. This looks absolutely lovely. I wonder about adding a `npm run test-browser` script that does something like `opener http://localhost:1234/ && ecstatic spec/ --port 1234`.\n. This is working as intended, sorry to say. I'll try to explain here what the situation is; hopefully you'll see that it cannot be any other way.\n\nWhen you resolve a promise to another promise, it must follow the behavior of that promise exactly; they must be indistinguishable to any other code. For example, once `deferred.promise` is resolved to `p`, `deferred.promise` and `p` must be indistinguishable. Part of this is making `deferred.resolve` and `deferred.reject` into no-ops, but that must also be the case for `deferred.notify`, as otherwise part of `deferred.promise`'s behavior would come from `deferred.notify`, and the rest would be controlled by `p`.\n\nThis perhaps becomes clearer if you set up a situation where `p` has progress notifications as well. Then, when you resolve `deferred.promise` to `p`, you would want `deferred.promise` to give off the same progress notifications as `p` does. After all, they now represent the same asynchronous operation. But that means we can't have `deferred.notify` interfering with `deferred.promise` any more, just like we can't have `deferred.reject` interfering with `deferred.promise`; the responsibility for fulfillment, rejection, or notification now lies with `p` (or perhaps with any promise that `p` gets resolved to).\n\nMake sense? Closing as working-as-intended, but feel free to continue discussion.\n. Q.all only takes one argument; why are you passing it two?\n\nOn 16 Oct 2013, at 06:28, \"Ludwig Magnusson\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nI have two promises, each of an array. I want to use Q.all on these two promises so that I can work on both arrays when both promises are resolved. However, I can't seem to get hold of the second array. Below is a model of my code.\n\nvar Q = require('q'),\n    promise1 = Q([1,2,3]),\n    promise2 = Q([4,5,6]),\n    promise = Q.all(promise1, promise2);\n\npromise.then(function(val) {\n    //val is [1,2,3]\n});\n\npromise.spread(function(first, second){\n  //first is 1\n  //second is 2\n  //arguments contains 1, 2 and 3\n});\n\nIs this a bug?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/410.\n. Yes, Q.fapply.\n\nOn 16 Oct 2013, at 18:34, \"Rafael Kaufmann\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nIn order to be able to use a consistent .then().fail()-based structure in my code, I've found myself having to introduce the following wrapper for promisifying synchronous functions:\n\nfunction applyDeferred(f, params) {\n    var deferred = Q.defer();\n\n```\ntry {\n    var result = f.apply(this, params);\n    deferred.resolve(result);\n} catch (e) {\n    deferred.reject(e);\n}\n\nreturn deferred.promise;\n```\n\n}\n\nIs there a Q built-in helper that already performs this?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/411.\n. Looks great, maybe add that one more sentence and then ship it.\n. Q cannot catch this error, as it is not happening inside Q, but inside MongoDB.\n\nThat line does not throw the error; that line creates an event emitter, and fails to attach an error handler to it, so later, when the error occurs inside MongoDB, the error gets thrown there.\n\nYou can verify this by wrapping that line in a `try`/`catch`; the `catch` clause will never be called.\n. Hah! This is an unintended consequence of us originally overriding valueOf() for our own inspection purposes, and then later deprecating it. We forgot that valueOf() is used when converting an object to a string (or number).\n. Yes, there's not really anything we can do; this is a GitHub bug. https://github.com/isaacs/github/issues/45\n. :shipit: \n. `onFulfilled` and `onRejected` handlers must be handlers, i.e. functions. You cannot pass a promise, or any other object, as a handler; it will be ignored.\n. It's probable that your browser or IDE is not displaying the value of `exception.stack`, but instead some kind of internal, hidden stack value that is not user-modifiable. Unfortunately there's nothing Q can do about modifying that one...\n. A rejection can be anything, just like a thrown exception can be anything.\n\nAnd just like a thrown exception should always be `instanceof Error` unless you hate kittens, a rejection should always be `instanceof Error` as well.\n\nBut, it's not part of the promise library protocol to babysit users and convert their non-`Error`s into `Error`s. So, think of the kittens, and only ever reject with `Error`s.\n. :) The formatting trick is kind of nice. But then, `deferred.reject(formatString, arg1, arg2, ...)` is not that much better than `function f(formatString, args...) { ... }; deferred.reject(f(formatString, arg1, arg2))`. That is, you can make your own `Error`-from-format-string creator function.\n. Yeah, Q is pretty closure-based (at least for now), so it's not possible to change that at the moment. In the future it probably will be. (Maybe even in master, haven't checked...)\n. You are looking for [`nodeify`](https://github.com/kriskowal/q/wiki/API-Reference#wiki-promisenodeifycallback).\n. Oh, I am sorry, I did not read closely enough. You are already aware of nodeify.\n\nThere is no such method in Q already. Your \"wrap\" might be a good package to publish for others with this need. The trick would be coming up with a nice name...\n. IMO it's really best as a third-party module, as Q already provides the relevant tools here and this is just sugar for people who prefer a different style of writing their callback-allowing functions. But @kriskowal might disagree.\n. That information is in the URL though.\n. FWIW @kriskowal I am -1 on this (metadata doesn't belong in source files; people should maintain it externally). But not terribly strongly.\n\nRelatedly I'd prefer keeping the license block in LICENSE, not the source file.\n. To be explicit: `then` takes as its argument a function. You are passing it a promise, which is no good.\n. Well, @kriskowal's strategy should work. Here are a few other ideas.\n\n``` js\nwaitp(1000)\n  .then(function () { return waitp(500); })\n  .then(function () { return waitp(1000); })\n  .then(function () { return waitp(200); })\n  .done(function () {\n    console.log('ok')\n  });\n```\n\nor\n\n``` js\nfunction makeWaiterFunction(time) {\n  return function () {\n    return waitp(time);\n  };\n}\n\nwaitp(1000)\n  .then(makeWaiterFunction(500))\n  .then(makeWaiterFunction(1000))\n  .then(makeWaiterFunction(200))\n  .done(function () {\n    console.log('ok')\n  });\n```\n\nand in all cases you can of course replace `waitp` with `Q.delay`.\n. [You may be interested in `thenResolve`](https://github.com/kriskowal/q/wiki/API-Reference#promisethenresolvevalue). It wouldn't quite do what you want, since the delay would start the moment you call `setTimeout` (which is the same moment you call `waitp(...)`), but maybe for other cases it's what you'd want.\n. We already have this feature! It's called [nodeify](https://github.com/kriskowal/q/wiki/API-Reference#promisenodeifycallback).\n\nWill close the ticket for now, but feel free to ask further questions.\n. In general I find many of the changes and deprecations made in master to be a step backward in usability, but I have not had time to make my case to @kriskowal yet :(\n. To give an idea of my thoughts: I agree with most of what you say, Kris; there are indeed lots of subtleties and you've pretty much laid them all out.\n\nI am sympathetic to `call` + `invoke` as the fundamentals, which in an ES6 world would need nothing else. `apply` and `applyInvoke`/`invokeApply` as the spread variants is one idea I had. This would work especially well if `Q` did not have any of these methods so we could ignore `fcall`/`fapply`.\n\nBut the remaining wrinkle is Node support. I use `ninvoke` extensively. I am sad to see most of the Node support move out of Q proper, and I need to look into the plan there and comment more in depth. This somewhat informs the discussion.\n\nIn the end, the understandability of `call` + `apply`, plus single-letter prefixes of `f`, `m`, and `n`, is pretty nice. It is hard to beat and I am not sure aligning with ES6 abstract operation names is enough of a win to outweigh it. And it allows us to keep the static <-> method parallel, which I have always found to be one of Q's most attractive and useful features.\n. I am sympathetic to how nice this is, but am not a big fan of overloaded behavior in general. Converting whatever is `yield`ed to a promise seems conceptually cleaner to me.\n\nOne thing that seems apparent from how much people want this feature is that it would be worthwhile doing in ES7-timeframe `await` work, e.g. maybe\n\n``` js\nawait all [asyncOp1(), asyncOp2(), asyncOp3()];\n```\n\n/cc @erights @lukehoban\n. > In such cases you can explicitly just .cast.\n\nThis seems pretty reasonable to me, especially given that in Q `.cast` is so short, i.e.\n\n``` js\nyield Q(maybePromise);\n```\n\nIt's still weird IMO to have that much magic packed into the type of the argument. I.e., you can yield two things, promises and arrays, and if it's arrays, we do this parallel thing...\n. It's interesting that\n\n``` js\nyield Q.all([promiseA, promiseB, promiseC]);\n```\n\nis equivalent to\n\n``` js\n[yield promiseA, yield promiseB, yield promiseC];\n```\n\nbut unfortunately\n\n``` js\nyield Q.all([asyncOp1(), asyncOp2(), asyncOp3()]);\n```\n\nis _not_ equivalent to\n\n``` js\n[yield asyncOp1(), yield asyncOp2(), yield asyncOp3()];\n```\n. I think it should be renamed `Q.then` personally :)\n. Q is currently running the Promises/A+ 1.0 tests; it is not up to Promises/A+ 1.1 yet. Thus it's a bit premature to upgrade the adapter to 1.1 format. Also, if this were done, we should upgrade the test version in package.json's devDependencies.\n\nLet's close this and open a new issue to upgrade to 1.1.\n. Q is Promises/A+ 1.0 compliant, but not 1.1.\n. I do not think @kriskowal's `thenCall` is the same as @bluepnume's.\n\n@bluepnume: I think you would be best off using standard JavaScript practices:\n\n``` js\nreturn promise.then(myFunction.bind(args...))\n```\n\n@kriskowal: outside of message passing use cases, I could imagine `thenInvoke` being nice sometimes. I'll keep an eye out for potential uses.\n. No, we have this right. It's next, not send. OP must be using an outdated version of node.\n. Yes,  that page itself says that it's outdated at the top of it.\n\nI am not sure which Node version made the switch.\n. I am -1. I think deferreds are an anti-pattern and Q should move away from them in favor of the Promise constructor. I definitely think they should never be part of a module's public API. People should not be manipulating deferreds; they should be doing async operations and handing out promises. Deferreds are not first-class, and should not have an API that parallels that of promises.\n. Can you write some synchronous try/catch code that illustrates what you're envisioning? Remember that promises parallel synchronous control flow constructs.\n. There are a few issues about this not working correctly. It seems browser consoles no longer do live array updates like they used to. We've since removed the feature from Q and are working toward building a separate unhandled rejection tracker as a browser extension.\n. The entire point of the live-ness of the unhandled reasons array is that once reasons become handled, you should not see them in the console.\n. @kriskowal I feel there is still a decent bit of use to it. Perhaps a minimal interface like:\n\n``` js\nQ.onPossiblyUnhandledRejection(function (reason) { ... })\nQ.onRejectionHandled(function (reason) { ... })\n```\n\nWe could rip it out of v2 for now though and consider adding those back later.\n. Don't do it Kris!!\n\nWhat problems did Mocha give you?\n\nThe split into multiple files, and the switch to Istanbul, seem good and worthwhile.\n\nhttps://npmjs.org/package/lab might be a smaller alternative to Mocha.\n. LGTM :D\n. Oh right, I forgot about the thenable issue :-S. I guess we can close this then. Kind of unappealing but not a big deal.\n. fs.exists does not follow standard node callback conventions, so it won't work with denodeify. Use fs.stat instead, or better yet, just do the operation you're trying to do and handle an ENOENT error.\n. Pretty good interim hack. The lack of accurate .constructor is a bit sad but no big deal. +1\n. If the \"leak\" persists across reloading the page, then this is a bug with Chrome, not with any particular JS script.\n. As I said, it is impossible for a library to cause memory to persist across page reloads, since JavaScript does not have that ability---only C++ does. If this is occurring, then it is a bug in Chrome. I would suggest filing it on http://crbug.com/.\n. Q is not designed for your requirements, and I suggest you write your own version of nodeify.\n. Because otherwise any errors thrown in the callback would be caught and transformed into rejected promises, which would be unexpected.\n. I think TypeScript-specific functionality does not belong in a JS library. A separate q-with-typescript-helpers package would make more sense there.\n. For that you should just use `Q.async`, as Petka pointed out.\n. >  I find the syntax a bit too much prone to error, I'll stick to return the promise itself.\n\nHave you used `try`/`catch` before? If so it should be pretty familiar.\n. Nobody can break your chain in another part of the code. If you have a promise and don't give it to anyone else, nobody else can cause it to fulfill or reject. They can cause the promise _returned_ from _their_ `then` call to fulfill or reject, but that's _their_ code, not yours---and in their code, they need to understand `try`/`catch` to use promises.\n. @kriskowal I think we should explicitly say in the readme that bower is not supported.\n. > The first problem is that Q is already registered with bower (as far as I can tell, by @kriskowal)\n\nNope, that was some independent third-party. You should contact them.\n\n> Also, keep in mind that q was supported in bower previously (prior to version 2) \n\nThis is not true; our policy has not changed.\n. What if your catch code throws an error?\n. The existing code is correct; the change proposed here is incorrect.\n. `then` can only be passed functions that accept arguments, since `promise.then(f)` passes the fulfillment value of `promise` to `f`. Thus `Q().then(f)`, aka `Q(undefined).then(f)`, will pass `undefined` to `f`.\n\nIf you modify your test case to `Q(5).then(Q.nfbind(test))....` you can see the problem more clearly. In that case your proposed solution would throw away the `5` value, which is not acceptable.\n. Dupe of #502. Bower is not directly supported by Q, which targets npm. You're welcome to maintain a fork that is compatible with whatever bower's requirements are; they seem to involve distasteful practices like checking in bundled versions to a source control repository, which we won't be doing. But yes, as in #502, if there are documentation tweaks you would suggest, feel free.\n. Does https://github.com/kriskowal/q/wiki/API-Reference#error-handling-and-tracking meet your needs?\n. I was responding in particular to\n\n> I think this could work by manually calling a function to log all unterminated promises, or calling it every few seconds.\n\nWhich seems like something we already provide.\n. Ah, I see. So this isn't about .then vs. .done. It's about promises who nobody is listening to the results of (for now).\n\nI guess we could add such a thing, but it seems best to just push ahead on the promise-debugger idea. If you've seen Ember's promise debugger, it has this functionality and more.\n. What command did you use to install? What version of npm are you using? `npm install q` with npm 1.4.7 works fine for me.\n. The correct way to think of this is that rejections and throws are exactly the same, and distinguishing between them is not possible.\n\nSo for example, you should solve the problem of distinguishing between \"operation failed to complete\" and \"bad JSON\" the same as you would with sync exceptions. A function could throw either of those (synchronously); if you put a try-catch around that function, what would you do within the catch to distinguish?\n\nWhatever your answer is to that question, about sync exceptions, should be the same as your answer for async exceptions, aka rejections.\n\n---\n\nFrom: Adam Zielinskimailto:notifications@github.com\nSent: \u00fd2014-\u00fd05-\u00fd28 19:43\nTo: kriskowal/qmailto:q@noreply.github.com\nCc: Domenic Denicolamailto:domenic@domenicdenicola.com\nSubject: Re: [q] Why isn't Q.onerror called for promises without explicit error handlers? (#529)\n\nActually I still have one more concern. catch callback is called when any Error is thrown\nLet's assume:\n-   I am either deliberately using throw new Error() or expect an error from a library call like JSON.parse as in your example\n-   I want to do something when promise is rejected so I define a catch callback.\n-   I want to know if there was a runtime Error I didn't expect, perhaps from an invalid function call, or type mismatch, or accessing a property on undefined object - just usual stugg\n\nDo I have to specifically whitelist all expected errors in my catch function and act if rejection reason is not known, or is there some generic way of dealing with that?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/529#issuecomment-44478705.\n. We should switch to only using MutationObserver or setTimeout in browsers, I think.\n. This is good motivation for me to dive back in to Q's code and fix a few outstanding stack-related bugs. I'm at JSConf this week and on vacation in Japan the next one, but I am moving this up to near the top of my queue.\n. Thank you for the really thoughtful critique. We should definitely take it to heart.\n\nQ is a bit of a special case because a large part of its target audience is people who know about promises in some fashion already, or at least have been told that promises are a solution to their callback woes. But I think there is a definite potential for shifting toward beginners.\n. Thanks to everyone in this thread for the kind and encouraging words :). They are awesome.\n\n> and for some reason was intrigued enough by the README to jump over and take a look at the documentation. And I that is what sold me on the idea in about 30 seconds flat. \n\nTo clarify, when you say \"documentation\" are you talking about the README, or the [API reference](https://github.com/kriskowal/q/wiki/API-Reference)? You kind of make it sound like the readme and the documentation are different, which has me a bit confused.\n. You should use `.thenResolve` instead of `.then`. Argument overloading is the root of much evil.\n. > In your words, if a function which returns a promise to someone else, it is OK to call done() to terminate \n\nNo, that is the opposite of what the golden rule states. It states _either_ return it to someone else _or_ call .done() on it, not both.\n. > not one that bring promises.\n\n+1; this will be a dealbreaker for using Q in many shops.\n\nAre we using more of collections than is provided by the WeakMap shim?\n. allSettled is definitely not meant to be a drop-in replacement for all.\n. .then takes functions, not promises\n\n---\n\nFrom: Matthewmailto:notifications@github.com\nSent: \u00fd2014-\u00fd07-\u00fd20 19:49\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] Derived Promises don't propagate reject correctly (#557)\n\nGivent the following snippet\n\nq = require('q');\n\nvar deferredA = q.defer();\nvar promiseA = deferredA.promise;\n\nvar derivedPromiseA = promiseA.then(function() {\n  var equation = 1+1;\n  throw 'fuuuuuuuuuuuuuu';\n});\n\npromiseA\n  .then( derivedPromiseA )\n  .then(function onSuccess() {\n    console.log(\"Unexpected :(\");\n  })\n  .fail(function onFail() {\n    console.log(\"Expected state\");\n  })\n;\n\ndeferredA.resolve('go');\n\nWhat actually happens is it prints \"Unexpected :(\"\n\nConversely, if you run\n\nderivedPromiseA\n  .then(function onSuccess() {\n    console.log(\"Unexpected :(\");\n  })\n  .fail(function onFail() {\n    console.log(\"Expected state\");\n  })\n;\n\nThis prints \"Expected State\"\n\nThe use case for having a longer chain is that you can get explicit dependency declaration despite the redundancy.\n\n---\n\nDetail:\n-   Node v0.10.29\n-   Q v1.0.1\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/557.\n. Q.all takes arrays. Several of your examples do not pass it arrays.\n\n---\n\nFrom: Matthewmailto:notifications@github.com\nSent: \u00fd2014-\u00fd07-\u00fd20 20:25\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] q.all([...]) eats resolved resultants when other q.all([..]) calls are embedded inside it (#558)\n\nWhen you have a couple of branching dependent code paths, you might end up structuring your code such that you need to chain off promises to get at resulted data. This means you don't need to leak information out of your function scopes gives an explicit order in which things should be resolved when the next person comes to read that code.\n\nThis kind of mindset makes the q.all([...]) function very attractive if you have a group of deps that all have data you need to marshal into a function.\n\nHowever, I've run into a bug when composing q.all([...]) on load methods that are themselves also called in the context of q.all([...]). For example, if you:\n1.  Set up a function loadUserConfigs that returns q.all([ loadUsers(), loadGroups() ])\n2.  And set up a function loadDatabaseConnection that returns a promise wrapping a connection handler\n3.  And compose these two calls and chaining them as q.all( loadUserConfigs(), loadDatabaseConnection() ).then(...)\n4.  Then setup a handler that needs to get at resultants from loadUserConfigs() and loadDatabaseConnection()\n\nYou're going to run into a situation where one the handler only has access to the result of the first promise.\n\nHere's a snippet to demonstrate:\n\nvar q = require('q');\n\nvar process = function(i) {\n  var done = q.defer();\n  setTimeout(function() {\n    done.resolve( 'done! ' + i );\n  },0);\n  return done.promise;\n};\n\nvar finishedProcessing = q.all( [1,2,3].map(process) );\n\nvar loadSecondConfig = function() {\n  var done = q.defer();\n\n  setTimeout(function(){\n    done.resolve('finished!!');\n  },0);\n\n  return done.promise;\n};\n\nq.all( finishedProcessing, loadSecondConfig() )\n  .then( function() {\n    console.log(\"\\n\\n\\n\");\n    console.log(\"Test 1: q.all(\\n  q.all( q.all( p1,p2,p3 ), p4 )\\n)\");\n    console.log(\"...gives...\");\n    console.log(arguments);\n  });\n\nq.all( loadSecondConfig(), finishedProcessing )\n  .then( function() {\n    console.log(\"\\n\\n\\n\");\n    console.log(\"Test 2: q.all(\\n  p4, q.all( p1,p2,p3 )\\n)\");\n    console.log(\"...gives...\");\n    console.log(arguments);\n  });\n\nThis prints out\n\nTest 2: q.all(\n  p4, q.all( p1,p2,p3 )\n)\n...gives...\n{ '0': 'finished!!' }\n\nTest 1: q.all(\n  q.all( q.all( p1,p2,p3 ), p4 )\n)\n...gives...\n{ '0': [ 'done! 1', 'done! 2', 'done! 3' ] }\n\nTest 1, we lost the result of p4.\n\nIn Test 2, we lost the combined result of q.all(p1,p2,p3).\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/558.\n. Nitpicking: more correct would be to say that `Promise.race([...])` returns a promise which behaves the same as the first **settled** (fulfilled or rejected) promise in the list. Agreed the comment is incorrect.\n. Hi @franksrevenge,\n\nThanks for your contribution, but I don't think we're interested in duplicating features of the JavaScript language (i.e., local variables). I'd suggest refactoring this code to be\n\n``` js\nvar myVariable;\nQ.all([a, b])\n.then(function() {\n    myVariable = 'Hello world';\n})\n.all([a, b])\n.all([c, d])\n.then(function() {\n    return Q.all([c, d])\n        .then(function() {\n            console.log(myVariable);\n        });\n});\n```\n. $q is unrelated to kriskowal/q\n. `fin` is an alias for `finally`. Just like you use `.catch`/`.fail` when you'd use `catch` in synchronous code, you should use `.finally`/`.fin` when you'd use `finally`.\n\nDoes that help?\n. Yep, that's it exactly!\n. `.finally` is supposed to parallel the keyword `finally`, as in `try`/`catch`/`finally`. Since `finally` does not receive any args, neither will `.finally`.\n\nYour above example seems like you want to notify the message service no matter if there are errors or not. In synchronous code, we already have a pattern for that: `try { ... } catch (e) {}`. So I would suggest\n\n``` js\ndoThing().catch(() => {}).then(() => msgService.notify(data));\n```\n. Yes. I am telling you why the current functionality is designed that way and will not be changing.\n\nThe code I wrote is exactly equivalent to the code you wrote, so it will work in the same way.\n. That's false ... because I have caught the error, the subsequent .then will execute. That is how promises work... Try it in your browser console:\n\n``` js\nPromise.reject(new Error(\"boo!\"))\n  .catch(function () { })\n  .then(function () { console.log(\"this is reached\"); });\n```\n. How would you know ahead of time whether the promise is fulfilled or rejected?\n. Regardless, if the promise is fulfilled, the `.catch` will have no effect. (Just like the `try { doStuff() } catch (e) { }` has no effect if `doStuff()` does not throw an error.)\n. Yes, because the promise returned by `.catch(() => {})` is always fulfilled (the entire purpose of `.catch(() => {})` is to convert rejections into fulfillments, just like `try { } catch (e) { }` converts thrown errors into normal flow).\n\nAll of this applies to $q as well, by the way. I encourage you to just try this in your browser, whether with Q, $q, or window.Promise.\n. What I am saying, is just write your code as if it was synchronous, then convert any `catch`s into `.catch`s, and `finally`s into `.finally`s :). The amount of code you have to write will be parallel in both cases, because promises error flow is parallel to sync control flow in this regard.\n. Well, you can always write a function. Similar to how you might not like to write `try { x(); } catch (e) { } y();` and prefer to write `foo(x, y)`, you could write a promise-based function that does the same thing:\n\n``` js\nfunction foo(x, y) {\n  return x().catch(() => {}).then(y);\n}\n```\n. I disagree that what you are proposing is a feature that encourages clean code. I think clean code for promises is code that makes the structure of error flow clear. Hiding that behind a function is unclean code, whereas making it explicit by only using those structures that have clear analogies in synchronous code is clean.\n. You should be OK creating your own abstractions on top of solid base ones.\n\n`.finally` as an abstraction will not change in promises (I say this as a Q collaborator and the ES6 promises spec editor), because it is important it parallel synchronous `finally`.\n\nIf you want your own abstractions you can try to convince library authors to make them for you, or you can make them yourself. I advise the latter as it helps get work done faster.\n. And I take issue with the description of making your error flow clear as a hack. If you understand promises, or more simply just understand that promise error flow is exactly the same as try/catch/finally error flow, is it entirely natural and non-hacky, and anyone who sees it with that same shared understanding will understand it. I assume you have read http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/ ?\n. > And as a final word: \"finally\" is called anyway - if you are so keen on having the \"try-catch-finally\" blocks, why are you calling the finally when no catch is there?\n\nFinally is used when you _don't_ catch the error, or when you rethrow. E.g.\n\n``` js\ntry {\n  doThing();\n} catch (e) {\n  logToServer(e);\n  throw e;\n} finally {\n  cleanUpResources();\n}\n\n// this code doesn't run since the error is still thrown\n```\n\n<=>\n\n``` js\ndoThing()\n  .catch(e => { logToServer(e); throw e; })\n  .finally(cleanUpResources)\n  .then(() => { /* this code doesn't run since the promise is still rejected */ });\n```\n. Finally is always called in Q as well (try it in your browser). It's just not _useful_ if you don't expect there to be an error.\n. Anyone who understands how promise code parallels synchronous try/catch/finally---which should be everyone using promises---will find such a pattern natural and obvious because that is how you would do it in sync code. So indeed no need to document, not because it's hilarious, but because it's obvious.\n. In your example, `configInitialized` is a promise. `.then(anyPromise)` will do nothing useful, since `.then` takes functions and `anyPromise` is not a function. The same for `Q.fcall`, actually.\n\nBetter would be\n\n``` js\nfirstPromise1.then(function () {\n  return configInitialized;\n}).then(function (data) {\n  // data is now AJAX response data\n});\n```\n\nWe have a shortcut for this:\n\n``` js\nfirstPromise1\n  .thenResolve(configInitialized)\n  .then(function (data) {\n    // data is now AJAX response data\n  });\n```\n. Seems bad for web workers; use `self` instead?\n. Yep, q.denodeify only works on functions that follow the Node callback convention. Many functions do not, including fs.exists.\n. In general you should not use `fs.exists` anyway. You should either (a) just perform the operation you want to perform, and handle ENOENT errors if they occur; or (b) use `fs.stat`.\n\n(a) is better because it prevents race conditions where the file stops existing between your call to `fs.exists` and the operation you're performing. (b) is still subject to race conditions, but `fs.stat` uses the Node callback convention.\n. This is not possible in JavaScript, the language.\n. Would be tricky in ES5... on the other hand, latest IE preview means all major browsers support iterables.\n\n---\n\nFrom: Oliver Joseph Ashmailto:notifications@github.com\nSent: \u00fd2014-\u00fd11-\u00fd18 11:35\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] Q.all(iterable) (#613)\n\nES6 Promise.allhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all allows you to pass an iterable. Could Q provide this functionality today?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/613.\n. We might be able to do it using only ES5 syntax by re-implementing for-of's semantics. There was some es-discuss post from @anba with the full desugaring, but I can't find it anymore...\n. @kriskowal my thought would be that we only support iterables if `Symbol.iterator` (and `Symbol`) are present.\n. This is called \"nodeify\"\n. Sorry I misread; it turns out I meant Q.denodeify.\n. Q.all(data).then(func)\n\n---\n\nFrom: slawomailto:notifications@github.com\nSent: \u00fd2014-\u00fd11-\u00fd23 18:56\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] Q.onAll(func, values_array) (#615)\n\nIs there an equivalent of this:\n\nvar runOnAll = function(func, data) {\n    var results = [];\n    return _(data).reduce(function(res, val) {\n        return res.then(function() {\n            var out = Q(func(val));\n            out.then(function(r) {\n                results.push(r);\n            })\n            return out;\n        });\n    }, Q(0)).then(function() {\n        return Q(results);\n    })\n}\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/615.\n. Use yield, not yield*\n. Ah I see. Yeah readURL should return a promise, not a generator object. Wrap it in Q.async to get that effect. Then you can yield readURL(), i.e. yield the promise.\n. At that point it's seeming like a bug in Firefox...\n. OK, back at a real computer and keyboard now. \n\nWhat you're doing with this code is very strange. In general, the pattern is to create promise-returning functions and, inside functions wrapped in Q.async or Q.spawn, yield promises.\n\nYour original example creates a generator function and inside it, it yields a promise value. That's not too useful; it just creates an iterator that is equivalent to a one-element sequence of a promise. Delegating to that iterator inside Q.spawn seems to confuse the code.\n\nYou seem to be trying to build the readURL function in stages, e.g. first build a promise-returning function that just immediately fulfills onload, and then build something more complicated. For that, try this kind of code:\n\n``` js\nfunction loadXHR(url) {\n    var d = Q.defer();\n    var req = new XMLHttpRequest();\n    req.onload = function () {\n        d.resolve(req);\n    };\n\n    req.open(\"GET\", url);\n    req.send();\n\n    return d.promise;\n}\n\nvar readURL = Q.async(function *(url) {\n    var request = yield loadXHR(url);\n\n    if (request.readyState === request.DONE) {\n        if (request.status == 200) {\n            return request.responseText;\n        } else {\n            throw new Error(\"readURL failed with code \" + request.status + \" at URL: \" + url);  \n        }\n    } else {\n        throw new Error(\"readURL did not complete: \" + url);\n    }\n});\n\nfunction test() {\n    Q.spawn(function* () {\n        console.log(yield readURL(\"http://echo.jsontest.com/\")); // Cross-origin friendly URL for fiddle\n    });\n}\n```\n\nUnfortunately, I am still seeing Firefox get an infinite loop. So I guess I wasn't being very useful after all :(\n. Oh, interesting! Well, Firefox is relatively evergreen; we may wish to just eliminate that workaround and direct people to older Q versions if they want to support old Firefox.\n\nFiled https://bugzilla.mozilla.org/show_bug.cgi?id=1104014 on Firefox.\n. It's under Promise.prototype.then.\n\nOn Nov 24, 2014, at 06:26, Oliver Joseph Ash <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nThe Q website mentions Q.when, but this is not listed in the API Reference on the wiki.\n\nHappy to contribute but I'm not confident that I'll describe it correctly.\n\n## \n\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/617.\n. Example code? Does not occur in any of the code I try.\n\nA method to subscribe only the onFulfilled handler is to pass only a single argument to `.then`.\n. Yeah, exactly. That's why the name `.catch` is preferred to `.fail`, because it makes it clearer that what you're doing is like this synchronous code:\n\n``` js\ntry {\n  functionThatThrewError();\n} catch (e) {\n  console.log('this failed');\n}\n\n// then:\nconsole.log('I thought this would not be called, but is being called');\n```\n. Use Q.spawn for running code; Q.async for creating promise-returning functions.\n\n---\n\nFrom: Adrian Pungamailto:notifications@github.com\nSent: \u00fd2014-\u00fd12-\u00fd08 04:23\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] Q.async eats thrown exceptions (#623)\n\nvar Q = require('q');\n\nQ.async(function*(){\nthrow new Error('Eaten by Q exception...');\n})();\n\ndoes not display anything.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/623.\n. > Run M-x markdown-toc/generate-toc\n\nHow do we do this ourselves, when the readme gets changed?\n. It'd be important for any PR to add a npm script that will update the ToC, so we can do `npm run update-toc`.\n. @arikon I don't think that updates the README though. And http://documentup.com/kriskowal/q/ already has a TOC, so I assume @ardumont is specifically interested in the README.\n. Exactly.\n. Using bower to consume q is not a supported scenario. Please use npm.\n. You are not returning the promise.\n. I think it really should get tests. I'm not sure where the impression that the Q tests are for browsers came from? See e.g. the domain tests: https://github.com/kriskowal/q/blob/v1/spec/q-spec.js#L2319-L2413\n. A promise is like an async return value. I.e., synchronous functions return values, asynchronous functions return promises.\n\nThe caller of a synchronous function can't change the return value of that function. Similarly, the caller of an asynchronous function can't change the return value of that function, i.e., nobody can reset a promise.\n. Dupe of #449 \n. Have you tried io.JS? The V8 version in Node 0.12 is unsupported and full of bugs.\n. You could use browserify, or you could do this:\n\n``` js\nvar Q = window.Q;\ndelete window.Q;\n```\n. Deleting window.$ is exactly what jQuery.no conflict does so I don't really understand what you want.\n. Let's translate that code: substitute the return value of the getter where you put `mail.attachments`. The result is:\n\n``` js\nq.resolve()\n    .then(function() {\n        return 'First then';\n    })\n    .then(q.resolve(['Attachment #1']))\n    .done(function(result) {\n        console.log(result);\n    });\n```\n\nSo you are passing a promise to `.then`, which does not work, since `.then` only accepts functions.\n. That code will indeed pass all relevant information. Can you give a test showing otherwise?\n\nEquivalent code would be `df.resolve(test())`.\n. Well your best scenario is if you are using promise functions instead of adapting callback code like setTimeout. For example if you use Q.delay then you can just do\n\n``` js\nfunction test() {\n  return Q.resolve(123);\n}\n\nfunction test2() {\n  return Q.delay(1000).then(test);\n}\n\ntest2().then(function () {\n  console.log(arguments);\n}).done();\n```\n. Ah I see #693 takes care of this for the 1.x branch.\n. Can you try doing this without Q and seeing if the CPU usage remains high?\n. Can you create a reproduction step without google-api-nodejs-client?\n. Yes, this is the antipattern in action. Instead you should use\n\n``` js\nfunction memcachedGet(key) {\n  return Q.ninvoke(memcached, \"get\", key).then(function (data) {\n    if (!data) {\n      throw new Error(\"no data\");\n    }\n  });\n}\n```\n\nor similar.\n\nAlso, in the future you may find StackOverflow a better outlet for these questions, as this is not a bug with Q.\n. It is because that is not how finally works:\n\n``` js\ntry {\n  // code here\n} finally {  // not finally (something)\n  // cleanup actions\n}\n```\n. This is a pretty major change in semantics and as such should only go into 2.0. I am neutral on the functionality; I can see how it might make sense to test fn.length to find the last argument, but in general I think that's fragile and am not sure relying on it is a good idea.\n. Right, those are intentional semantics currently, because they are the simplest thing that can be done without any magic guessing that might e.g. hide bugs. Magic guessing is OK to add, but it's a major semantic change and deserves 2.0 only.\n\nfn.length is not incompatible between implementations, but it's just not always useful. For example, many core functions in the Node.js standard library have fn.lengths that mismatch their actual call signature, since they switch on `arguments[n]` where `n > fn.length`.\n. WinJS has a similar solution to Q, where `.done(f, r)` is equivalent to Q's `.then(f, r).end()`:\n- http://msdn.microsoft.com/en-us/library/windows/apps/hh700337.aspx\n- http://msdn.microsoft.com/en-us/library/windows/apps/hh700334.aspx\n- http://blogs.msdn.com/b/microsoft_press/archive/2012/06/04/free-ebook-programming-windows-8-apps-with-html-css-and-javascript-first-preview.aspx page 78\n\nThe latter has a particularly poignant quote:\n\n> In practical terms, this means that if you end a chain of promises with a then and not done, all exceptions in that chain will get swallowed and you\u2019ll never know there was a problem! This can place an app in an indeterminate state and cause much larger problems later on. So, unless you\u2019re going to pass the last promise in a chain to another piece of code that will itself call done, always use done at the end of a chain even for a single async operation.\n\nIn practice, we've adapted to the status quo, and adopt the simple rule to always either (a) return the promise; or (b) cap with `.end()`. We enforce this even for promises that have error handlers, just in case the error handler itself throws, and also to make the rule simple and easy to follow without thinking.\n. See also promises-aplus/unhandled-rejections-spec#4\n. You are coming from jQuery, I see. In Q, such a method is not necessary; there is a much more elegant approach:\n\n```\n// Will return a promise for the value that anotherPromiseReturner's promise\n// is fulfilled with, plus 5.\nfunction returnsAPromise() {\n    return anotherPromiseReturner().then(function (result) {\n        return result + 5;\n    });\n}\n```\n\nAll of the other things you describe have similar elegant solutions with Q. You can see some examples of them in [my slides](http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript), starting around slide 48.\n\njQuery breaks this CommonJS promise semantic, i.e. breaks the promise fulfillment <-> method return value correspondence. (In short, this occurs because promises in jQuery can be fulfilled with multiple values.) That is why it needs a custom, nonstandard `pipe` method and the ugly code it generates.\n. @ThomasBurleson, I'll try again. Q natively supports all three of your requirements, in a more elegant syntax than the hacked-on `pipe` extension.\n\n1) As in my previous post.\n2)\n\n``` javascript\ndoSomethingAsync().then(function (result) {\n  if (result.statusCode !== 200) {\n    throw new Error(\"Bad status code\");\n  }\n});\n```\n\n3)\n\n``` javascript\nQ.defer().promise.then(func1).then(func2).then(func3).then(...);\n```\n. @ThomasBurleson\n\nHappy to help. As @kriskowal explains, `then` does exactly what you want. Your last example is written in Q as\n\n``` javascript\n.then(function (event) {\n   return event.result;\n}).then(function (result) {\n  // ...\n});\n```\n\nSimilarly, my intercept-and-throw example from above can be expanded as\n\n``` javascript\ndoSomethingAsync().then(function (response) {\n  if (response.statusCode !== 200) {\n    throw new Error(\"Bad status code\");\n  }\n  return response.text;\n}).then(\n  function (responseText) {\n    // ...\n  },\n  function (error) {\n    // error here is either the original error from `doSomethingAsync`,\n    // or the one we threw above for non-200 status codes.\n    // This behavior is in direct correspondence with how exceptions bubble in sync code.\n  }\n);\n```\n. The problem really comes from dealing with callback APIs, but thankfully we have a lot of helpers for that. For example you could do:\n\n``` js\nfunction getFiles() {\n  return Q.invoke(fs, \"readdir\").then(function (files) {\n    return Q.all(files.map(processFile));\n  });\n}\n```\n\nNote that this version also handles if there's an error reading the directory, which the `getFiles` in your post does not (it ignores such errors).\n. Yes, that would work wonderfully. Unfortunately weak maps are not weak references.\n. How would you maintain that list? (Answer: using a strong reference.)\n. How would you then find out if the promise is in the weak map?\n. I humbly submit <a href=\"http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\">my presentation</a> as either a link to include, or as a source from which examples can be plagiarized at will.\n. @kriskowal Agreed. I think slides 42--68 are the most relevant.\n. This makes sense. Just to make sure, neither the `MessageChannel` nor `setTimeout` implementations are sufficient for your purposes? I would imagine the former is both available and sufficiently fast.\n\nIn any case, there is actually already a `Q.nextTick`, but we'd need to change all the internal usages to reference `exports.nextTick` instead of just `nextTick` if we wanted to make setting it useful.\n. A settable `nextTick` makes sense to me. I'm just wishing there was a way to make it work out of the box. Let me know if you think of anything.\n\nI'll wait for @kriskowal to weigh in before committing anything though, since I don't understand all the security guarantees Q provides enough to know whether a settable `nextTick` would break them.\n. @Yaffle Yes it does, although of course IE10 has native `msSetImmediate`. See also NobleJS/setImmediate@9be325240d3cc37ddeb782a109410bb9c4413b67.\n. Right, good point. It seems convenient; the only reason I can think for including `call` and `apply` but not `bind` is that you can probably get `bind` via `promiseForFunction.get(\"bind\").invoke(thisp, 1, 2, 3)`.\n. Wait but I guess that's true for `call` and `apply` as well, so nevermind. I'll try to add it later today.\n. Yeah, the fact `setImmediate` has all the unnecessary stuff is unfortunate.\n\nSo your proposal is to change to\n\n``` javascript\nvar nextTick = global.nextTick || global.setImmediate ||\n               (typeof process !== \"undefined\" && process.nextTick) ||\n               nextTickShim;\n```\n\n and then, perhaps in the future, publish a browser-based `global.nextTick` library?\n. Well now I feel silly for sending this to q-continuum as well, heh. Good to hear I was on the right track. It was confusing because the old example didn't seem to need the `Q.resolve()`:\n\n``` javascript\nreturn array.reduce(function (done, value) {\n    return Q.wait(done, doWork(value));\n});\n```\n\nAs for shipping the reference off to the wiki, <a href=\"https://github.com/kriskowal/q/commit/6b41d3160891000f001b5c089f50eefb25b5c141\">already done</a> :)\n. On first thought the best route is to use something like <a href=\"https://github.com/rauschma/lobrow/blob/master/lobrow.js\">lobrow</a> to get dirt-simple Node-modules-in-the-browser up and running. I also think @substack had a recent one but I can't find it in his monster list of public repositories.\n\n@Gozala/test-commonjs seems like it would work pretty well in such an environment, since it doesn't depend on much environment, and is already browser-compatible in at least some fashion (AMD might be involved?).\n\n---\n\nAnother option would be to have a compile step for the tests that wraps them in and AMD wrapper to be used alongside @Gozala/test-commonjs. I believe @jrburke/r.js can do this.\n. @Gozala That sounds excellent, since I think our goal is just to check that we didn't break anything.\n. I think the best stack right now would be <a href=\"http://busterjs.org/docs/\">BusterJS</a> for native \"`return` a `then`-able\" support + <a href=\"http://chaijs.com/\">Chai</a> + <a href=\"https://github.com/domenic/chai-as-promised/\">Chai as Promised</a>. I haven't used BusterJS yet but the latter two are working great in our project at work.\n. To get the bikeshedding out of the way: `createNodeCallback` or `asNodeCallback` are most to my liking.\n\nI think generating it on each call (and thus being a function instead of a property) makes the most sense, as it seems very rare to want to get the callback more than once.\n\nI suppose for browsers that support getters we could add a `nodeCallback` lazily-computed property, but I don't know if I liking having a variable API surface depending on environment.\n. I... kind of like it. <a href=\"https://www.google.com/#q=%2Bnodeback\">Why isn't anyone using that term already?</a>\n. In my experience, the majority of Node functions end up needing the `this` parameter, so this wouldn't work too well. You'd end up having to say\n\n``` js\ndynodeClient.putItem.bind(dynodeClient).qcall(...)\n```\n\nwhich is hardly a win :-/\n. Right, sorry, my mistake. Hmm. I'd say it would be nice indeed. It would need an opt-in line, e.g.\n\n``` js\nQ.extendFunctionPrototype();\n```\n\nwhich increases friction a bit. But still, could be useful.\n. @kriskowal thoughts?\n. `Q` itself can't be a function call, because that conflicts with `Q.call` and `Q.apply`.\n\nAlso, option #1 is very \"nodeback\"-centric; remember most users of Q will not be using it in conjunction with nodebacks, except at certain, hopefully very hidden, seams.\n. Yeah, I don't think that makes much sense, compared to `Q.call`.\n. I think I have a vague idea what you mean, but could you give an example of a stack trace that still shows asynchronous boundaries?\n\n---\n\nBy instrumenting `when` with the following lines:\n\n``` js\nvar error = {};\nError.captureStackTrace(error, when);\nconsole.log(\"stack trace\", error.stack);\n```\n\nI manage to get the following two stack traces:\n\n```\nstack trace [object Object]\n    at makePromise.then (c:\\Users\\Domenic\\Programming\\test\\node_modules\\q\\q.js:270:12)\n    at doYAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:10:23)\n    at doZAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:16:12)\n    at Object.<anonymous> (c:\\Users\\Domenic\\Programming\\test\\test.js:19:1)\n    at Module._compile (module.js:441:26)\n    at Object..js (module.js:459:10)\n    at Module.load (module.js:348:31)\n    at Function._load (module.js:308:12)\n    at Array.0 (module.js:479:10)\n    at EventEmitter._tickCallback (node.js:192:40)\nstack trace [object Object]\n    at Object.end (c:\\Users\\Domenic\\Programming\\test\\node_modules\\q\\q.js:885:5)\n    at makePromise.end (c:\\Users\\Domenic\\Programming\\test\\node_modules\\q\\q.js:289:34)\n    at Object.<anonymous> (c:\\Users\\Domenic\\Programming\\test\\test.js:19:12)\n    at Module._compile (module.js:441:26)\n    at Object..js (module.js:459:10)\n    at Module.load (module.js:348:31)\n    at Function._load (module.js:308:12)\n    at Array.0 (module.js:479:10)\n    at EventEmitter._tickCallback (node.js:192:40)\n```\n\nSo the information is at least there and accessible (and we can use `Error.prepareStackTrace` to restructure it as necessary). The trick will be associating it with promises as they propagate through the system, and then putting it all together at an appropriate time.\n\n---\n\nAs far as I can tell we'd want this information in two places:\n- In a scenario using `.end()` as above.\n- As a replacement for `rejectionReason.stack` inside rejection handlers, e.g. for live debugging.\n\nFor the latter case I mean that if we replaced the above `doZAsync` with\n\n``` js\nfunction doZAsync() {\n    return doYAsync().fail(function (err) {\n        console.log(err.stack);\n    });\n}\n```\n\nIt would output something like\n\n```\nError: boo!\n    at c:\\Users\\Domenic\\Programming\\test\\test.js:11:15\n    at doYAsync (c:\\Users\\Domenic\\Programming\\test\\test.js:10:xx)\n```\n. Really like the async boundaries idea now that I get it :).\n\n> My thought was that we could get away with just instrumenting deferreds since that\u2019s where everything ultimately comes from. Even `when` calls `defer` before yielding.\n\nOoh, thanks for the tip. Yeah, I was just getting to the point of trying to figure out which seams I need to insert myself into.\n\n> It strikes me that exceptions should inherently support chaining, so you can both have a friendly face and the ability to dig deeper into the issue by expanding the next error in the chain.\n\nAgreed. Cf. <a href=\"http://msdn.microsoft.com/en-us/library/system.exception.innerexception%28v=vs.100%29.aspx\">Exception.InnerException</a> in .NET.\n. What should the following output?\n\n``` js\nvar Q = require(\"q\");\n\nfunction doXAsync() {\n    return Q.resolve(5);\n}\n\nfunction doYAsync() {\n    return doXAsync().then(function doXAsyncCallback() {\n        return Q.delay(10).then(function delayCallback() {\n            return { foo: \"bar\" };\n        }).get(\"bar\").then(function getBarCallback() {\n            throw new Error(\"boo!\");\n        });\n    });\n}\n\nfunction doZAsync() {\n    return doYAsync();\n}\n\ndoZAsync()\n    .end();\n```\n\nI've got\n\n```\nError: boo!\n    at getBarCallback (C:\\Users\\ddenicola\\SkyDrive\\Programming\\Work in Progress\\q with stack traces playground\\test.js:14:19)\nFrom previous event:\n    at doYAsync (C:\\Users\\ddenicola\\SkyDrive\\Programming\\Work in Progress\\q with stack traces playground\\test.js:10:23)\n    at doZAsync (C:\\Users\\ddenicola\\SkyDrive\\Programming\\Work in Progress\\q with stack traces playground\\test.js:20:12)\n    at Object.<anonymous> (C:\\Users\\ddenicola\\SkyDrive\\Programming\\Work in Progress\\q with stack traces playground\\test.js:27:1)\n```\n\nright now but feel like `doXAsyncCallback` and maybe `delayCallback` should appear in the trace.\n. I am going to go out on a limb and say we don't need the [[Construct]] behavior that we <a href=\"https://github.com/kriskowal/q/blob/40511a3176444aad13d54cedca98cc4b5027fedb/q.js#L764-776\">currently support in `Q.bind` proper</a>. Let me know if you think otherwise.\n. Done.\n. If there's anything to tweak in the above commits, let me know. (Changelog wording perhaps?) Otherwise I'll squash all of them into two (\"Remove Narwhal support\" and \"Use `setImmediate` if available\") and push.\n. @Yaffle, @kriskowal what do you think of 3175d1c.\n. Closed in favor of squashed commits.\n. I've been thinking we should publish a new minor version now. There are actually <a href=\"https://github.com/kriskowal/q/blob/master/CHANGES.md\">a number of nice fixes</a>. Probably the biggest hold-up is #54, since we cannot be sure releasing will not break the browser.\n\nIf you want to use master directly, you can as always do something like\n\n``` json\ndependencies: {\n    \"q\": \"git://github.com/kriskowal/q.git\"\n}\n```\n\nor to be a bit less bleeding-edge,\n\n``` json\ndependencies: {\n    \"q\": \"git://github.com/kriskowal/q.git#027c1bb51cf0f6e478704ab8a45c00830b03cc87\"\n}\n```\n\nWill leave open in case @kriskowal wants to use this to track the next release.\n. I believe domenic/q@a9a3e40 will do the trick. Anyone want to look it over?\n. >  I take it the intention is not to standardise at all on what args to use (or even how many args) in a progress notification?\n\nIndeed, although I was inclined to maybe standardize on a single arg. Dunno.\n\n> There's an interesting related case of transferring meta information. For example if you use the request library to make a web-request, you get a response, but you also get an object containing headers etc. I'm not sure whether meta handling makes sense to be handled in a special way within Q.\n\nI don't really see it. I'd return a promise for `{ headers, response }`, which is still a single object.\n. > I'm inclined to agree with standardising on a single arg, that makes it a closer match to the other callbacks.\n\nOK cool. I'll take it to q-continuum and see what everyone thinks.\n\n> I guess that makes sense, and that's what I'm looking at doing at the moment for my APIs...\n\nI guess my real question is: how would you handle this for synchronous methods? Since there is an exact parallel between async fulfillment values and sync return values, what would your sync method counterpart look like?\n. We need to assimilate cancellable WinJS promises at work so I'll probably be working on this over the next week or two.\n. To make sure I understand, the idea is that we test for the presence of `console.fulfilled`, and if it exists, call it whenever a promise is fulfilled?\n. See also promises-aplus/unhandled-rejections-spec#2\n. Works in Chrome now although that code is kind of horrible. Notably Chrome shows the short stack trace when you click the little arrow in the console, even though if you break on error and do `error.stack` in the REPL, it will give the long stack trace. Investigating.\n. Answered on StackOverflow. Do you think there's anything we could do to make it more clear, in the README or in the Wiki?\n\n@kriskowal What about a Wiki page with an \"examples gallery\"? I feel like I've put together a lot of gists, StackOverflow answers, etc. that might be interesting to peruse.\n. @kriskowal Great; I'll start a page. EDIT: https://github.com/kriskowal/q/wiki/Examples-Gallery\n. Spec runner fixed in 02241ea8326861d846d6df4e3a84fe46b1de2d29\n. Done. Specs now passing in IE7, IE8, IE9, and IE10.\n. @kriskowal, does this look merge-worthy?\n. Knowing very little about .npmignore best practices, what about LICENSE, README.md, .travis.yml, .gitignore?\n. I believe Travis just checks out the code.\n\nUpdated list:\n\n```\ndesign\nexamples\nspec\ntest\n.coverignore\n.travis.yml\nCHANGES.md\nLICENSE\nREADME.md\nVERSIONS.md\nq.min.js\nq.min.js.gz\nref_send.md\n```\n\nBTW @kriskowal is `ref_send.md` subsumed by [this wiki page](https://github.com/kriskowal/q/wiki/Coming-from-Waterken%E2%80%99s-Ref-Send)?\n. Thanks for finding this! Fixed slightly differently in 73ee9d30cec517b772fd01e03c56ea2ad560565b.\n. @sp an npm release is somewhat imminent, but in the meantime you can use git URLs in your package.json\n. It's like the code-coverage gods are smiting us for not achieving perfection -_-.\n. Any chance of getting a test with this? Not sure if it should go in `spec/q-spec.js` or `test/` or both though... @kriskowal?\n. @kriskowal Want to take another look at this area?\n. @danfuzz After taking some time to dig in to this, I think you are right that `makePromise.promiseSend` should not be calling `resolve` unconditionally. Have you had time to hack on the source long enough to make that work?\n. OK so I basically merged this fix. But I still think there is some crazy stuff going on inside the `when` and `promiseSend` implementations.\n\nI tried to remove a nesting level as per [Kris's earlier comment](https://github.com/kriskowal/q/pull/76#discussion_r870221) but that broke all the tests. I wonder if fc2ba180fe5b1f86865c6e83b3ddacb6ac0dd29a was the reason they were succeeding for Kris.\n\nAnyway, @kriskowal, @ForbesLindesay, and @danfuzz, would love to hear your thoughts on the deeper issues and possible fixes. For now though a bugfix seemed prudent.\n. I don't think this makes much sense, simply because we have no idea which of the arguments should be resolved in parallel versus not. I.e. should that be\n\n``` js\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    let [A, B, C] = [yield a, yield b, yield c];\n    // ...\n});\n```\n\nor\n\n``` js\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    let [A, B, C] = yield Q.all([a, b, c]);\n    // ...\n});\n```\n\nor\n\n``` js\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    let [A, B] = yield Q.all([a, b]);\n    let C = yield c;\n    // ...\n});\n```\n\nor even\n\n``` js\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    let [A, B, C] = yield Q.allResolved([a, b, c]);\n    // error recovery code for rejected A, B, or C\n    // ...\n});\n```\n. > For a well behaved promise, does it actually make a difference whether they're resolved in serial or parallel?\n\nYou are right, sorry. I was confusing this with the case of calling multiple promise-returning functions.\n\nIt still seems likely that there are significant differences, since each `yield` is a suspension of the execution state of the function and then a reentry later. Perhaps it would simply be a matter of <var>n</var> `nextTick`s for <var>n</var> `yield`s. I'd have to think harder about how generators and `Q.async` work to be sure.\n\nIn that case it sounds like the convenience method you're asking for could be implemented as\n\n``` js\nQ.deepAsync = function (generator) {\n    return Q.async(function *() {\n        var args = Array.prototype.slice.call(arguments);\n        var argsResolved = yield Q.all(args);\n        return generator.apply(this, argsResolved);\n    });\n};\n```\n\n(off the top of my head, untested, might be buggy, etc. disclaimer)\n. @kriskowal re: remote objects and `get`/`post`/etc., I've always thought something like <a href=\"https://gist.github.com/1372013\">this gist</a> was the way to go. Not sure if anyone ever actually turned that into a library, although it looks like @Gozala's meta-promise is a (SpiderMonkey-specific?) realization of it.\n\nThis doesn't really address your concern, but perhaps indicates that `Q.async` + `Q.promised` + meta-promise--like proxy promises could be mashed up into an awesome remote-promises--friendly wrapper.\n. @Gozala Without new syntax, what about something like `files.eventually.filter(...)`. I'm doing something similar in <a href=\"https://github.com/domenic/chai-as-promised/#shouldexpect-interface\">Chai as Promised</a>.\n. @Gozala Haha yes `yield` is how how this whole thread got started :). But I was thinking of the remote promises case where you don't want to actually wait for resolution until the last minute.\n. Closing in favor of #87\n. Should be able to change `\"test\": \"node test/all.js\"` in `package.json` to `\"test\": \"jasmine-node spec\"`. But, I don't know anything about Travis, so I'll leave it up to you.\n. This seems to have been fixed by switching to the `test` line in package.json. Woo!\n\nhttp://travis-ci.org/#!/kriskowal/q/jobs/1443944/L140\n. Let's not forget to remove `test-cover` and rename `spec-cover` to just `cover` in the `package.json` scripts.\n. Makes sense. Could you update the style to conform to the rest of the code (spacing after commas, `if`, and `function`;  double quotes), and be sure to fix all of the \"depreciate\" misspellings?\n. Merged as 8341cd150368052967474e13927b4653bc106a60\n. Oooh, this looks like a cool library. I very well might use it in my projects.\n\nI'm a bit concerned on starting to explode that section of the README. I should, for example, probably add [Dynamo as Promised](https://github.com/domenic/dynamo-as-promised/) and maybe [Chai as Promised](https://github.com/domenic/chai-as-promised/). [Capsela](https://github.com/capsela/capsela) is also cool. Maybe we should move it to a wiki? As a bonus, then people could add their projects at will.\n. I like the ideas, and the enthusiasm, but I think one major outstanding factor is that Q isn't complete. The three pieces I want to finish, and I know Kris is on board with, are:\n- Long stack traces\n- Cancellation\n- Progress\n\nProgress I am almost done with; just need a solid few hours to get on. Long stack traces I started, and so should probably continue, although I don't have anything in progress at the moment. Cancellation is more unsure: we don't even know the best approach, especially in light of the security implications.\n\nRegardless, tidying up outstanding issues is definitely a priority. I'll try to close out this one now.\n. Have you done heap snapshots of this? I'd expect that after the timer fires, it would be automatically cleared by the browser. (And even if the deferred is resolved before the timeout, the timer will still fire.) I suppose this would free the memory sooner, so it's worth pulling in regardless, but I'm curious as to whether we actually have a leak or just are holding on memory longer than we have to.\n. Huh, interesting. Well, thanks!\n. Merged with some small style fixes as d920b30b27e49a75232a072891e200165d8619f9\n. Thanks @MattiSG, merged with some formatting fixes as 6d0c67f17ea337691f7aee41e4f87537822e1c34\n. I'm curious what @kriskowal has to say, but my impression was that `put` is supposed to be analogous to the ECMAScript [[Put]] operation, which has a CompletionValue equal to the value that was put. See e.g. [the concurrency strawman](http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#syntactic_sugar) on the ECMAScript wiki.\n. I'm not sure I understand the distinction?\n. No use of `put` in any of my many promise-using projects, including some very large closed-source codebases at work.\n\nI think the real use case is for remote objects (cf. q-comm) where it can avoid round-trips. I also like it (as-is) just from a theoretical perspective because of the parallel semantics thing, but as @kriskowal mentioned, that's been deemphasized over time.\n\nIs Mark Miller on GitHub? I feel like his input would be valuable since this area of Q is rather motivated by his work.\n\nMy default position at this point is to accept the patch though, since as Kris says, this is strictly more useful.\n. We found a use for `put`:\n\nhttps://github.com/NobleJS/WinningJS/blob/4cfb415109cb371e25ae184ea252adf4b92de7cc/lib/ui/components.js#L43\n\n:D\n. I am +0. Maybe take it to the q-continuum mailing list for more opinions?\n. I agree this is an issue; `Q.fcall` is not a very intuitive function, even though once you really \"grok\" Q, it's quite a useful one. So I am not quite sure the best approach. Let me give a bit of background and perhaps we can work together toward a better explanation.\n\nAll promises can come from either deferreds or `Q.fcall`, essentially. (The other static helper methods, like `fapply`, `fbind`, `napply`, `invoke`, etc. etc. all delegate to `fcall`.) And `Q.fcall(f)` produces a promise, based on `f`, in one of three ways:\n1. If `f` returns a non-promise, it gives a promise resolved with that value as its fulfillment value.\n2. If `f` throws an error, it gives a promise resolved with that error as its rejection value.\n3. If `f` returns a promise, it gives a promise deferred to that returned promise.\n\nSo your example doesn't quite work, because `setTimeout` doesn't return a promise. `Q.fcall` doesn't have any capabilities for adapting callback-based code. Now, if you did\n\n``` js\nQ.fcall(function() {\n  return Q.delay(50).then(function() {\n    return 5;\n  });\n});\n```\n\nthen _that_ would work, because of 3 above. But it's kind of funny because the promise returned by `Q.delay` is created via a deferred. So it is really just illustrating the deferred case all over again.\n\n---\n\nMaybe a better approach would be to avoid explaining `fcall`, since it's a more advanced feature. The section \"Using `Q.fcall`\" really could be replaced with one explaining `Q.resolve` and `Q.reject`.\n\nAlternately, we could do that replacement, but then add a new, separate \"Using `Q.fcall`\" section that explains what it's really for: taking a synchronous function, or a function that is sometimes-synchronous and sometimes-async, and turning it into a async (promise-returning) function. The example there would be something like\n\n``` js\nvar url = getUrl();\n\nvar promise = Q.fcall(function () {\n    if (!url) {\n        throw new Error(\"Must supply a URL\");\n    }\n    return Q.when($.ajax(url));\n});\n```\n. Yes, wrapping around callback APIs is best done with deferreds. We have some nice helpers for Node-style callbacks (`Q.nbind` etc.), but your XHR example is a good one.\n\nIf you'd like to put it in a gist and add it to the [examples gallery](https://github.com/kriskowal/q/wiki/Examples-Gallery), that would be awesome! And we'll use this issue as a reminder to include the examples gallery somewhere prominent in the readme.\n\nEDIT: oh wait, it looks like we [already have such an example](https://gist.github.com/593076)! Wow, we really need to link to the example gallery.\n. > That way if cb is undefined, we return a promise for someone to use, but if it is defined, we call it in the normal node style.\n\nThat is really cool.\n. > Oh, not necessarily Node\u2019s CPS style. `.end(callback, errback)` is what I have in mind\n\nThis is the same as WinJS's `.done` and pretty similar to jQuery's `done` (which just doesn't have an `errback`). Should we consider renaming it?\n. I'd say `.done(callback, errback)`, `.nodeCallback(nodeCallback)`, and maybe keep `.end()` for compat? So far we've been good about keeping node idioms prefixed.\n\nMaybe `.nend(nodeCallback)`, but it's not really the same as `.end()`, whose purpose is to guarantee errors are never silenced---if you did `.nend(function () { })`, you'd silence the error.\n\n@kriskowal, thoughts? Agreed on `.done()`?\n. After sleeping on it for a few days, I like `.done(callback, errback)` and `.ndone(nodeCallback)`. We'd deprecate `.end` (and remove in the next major).\n. Some initial work here. https://github.com/domenic/q/compare/done\n. Yup, that makes sense. I need a test \"when the promise is fulfilled / and the callback throws / it should rethrow the error in the next turn\", and then I need to implement all three of the \"it should rethrow the error in the next turn\" tests.\n. My original plan was for `ndone` to replace `nend`. But as @medikoo points out, `nend` returns a promise. This, I believe, is designed to enable APIs like that of [node-flurry](https://github.com/tlrobinson/node-flurry), [like so](https://github.com/tlrobinson/node-flurry/blob/master/flurry.js#L45-59).\n. To summarize and bring in some thoughts:\n\n### `.done(f, r, p)`\n\nActs like `then` except that it does not return anything, and causes a next-tick-throw upon rejection. Equivalent to today's `.then(f, r, p).end()`. Replaces `.end()` since `.done()` is equivalent.\n\nMatches WinJS. Similar to jQuery's `.done(f[, f, f, ...])`, which notably returns the original promise.\n\n### `.ndone(cb)`\n\nWas envisioned as `.then(function (x) { cb(null, x); }, cb).end()`, or as `.end()` alone if no `cb` is passed.\n\n### `.nend(cb)`\n\n[Check out the implementation](https://github.com/kriskowal/q/blob/a7596e045cb0ba722ac376e46856698fd55fe41a/q.js#L1579-1593)\n\nThings to note:\n- If `cb` is falsy, it will return the original promise. This is useful as we'll see below.\n- The use of `nextTick` escapes the handler-catchers, so that errors thrown in the callback jump to the top of the stack (Node-style).\n- It's not very `end`-ey: without a callback, it acts nothing like `end`.\n\n### On `nend` or `ndone` enabling dual APIs\n\n`nend` currently enables dual APIs like so:\n\n``` js\nfunction asyncFunc(a, b, c, cb) {\n    return promise.nend(cb);\n}\n```\n\nThis is very nice.\n\nIf we were to move to `ndone` as part of a move to `done` a naive translation no longer works, since\n\n``` js\nfunction asyncFunc(a, b, c, cb) {\n    promise.ndone(cb);\n    return promise;\n}\n```\n\nwill throw-in-next-tick if promise ends up being rejected, denying any promise-using callers a chance to handle rejections. This makes me think `ndone` is pretty useless.\n\n### Recommendation\n\nWhereas,\n- `nend` as it exists is awesome, but it is named confusingly since it doesn't behave like `end` at all;\n- `done` is still a good idea and a good replacement for `end`;\n- `ndone` turns out to be useless;\n\n**I think we should replace `end` with `done` and do nothing else.** Keep `nend` named as it is, since there will no longer be a `end` to confuse matters. And forget about `ndone`.\n. - nodeify\n- maybeNodeify\n. @ForbesLindesay remember we playing the old-browser compat game so no `Function.prototype.bind` allowed. Wouldn't want to leave those Safari users out.\n. @ForbesLindesay want to get this in as a pull request, and claim all the glory? Let's defer `npromised` until someone asks for it.\n. Closes by #87\n. Actually `errors` will always be empty at the point in time that line is run; Q is still initializing. The idea is to output the array which might change later, since Web Inspector at least will auto-update the array's contents if they change over time.\n. Sounds good, although that link 404s @kriskowal.\n. @kriskowal I think enough bugfixes have accumulated that we should do a push. I guess I'll try to update the CHANGES.md, then you can do the npm publish?\n. @kriskowal I'm domenicdenicola on npm. Sounds good!\n. Thanks!\n. Oh eek, nice catch. Want to squash and force-push before I merge?\n. Yeah just these two :)\n. Remember that `then` takes a function, so you presumably meant `.then(function (a, b, c) { /* ... */ })`.\n\nBut even with that, this would be explicitly against Q's goals. Promises are supposed to [provide a direct correspondence with synchronous code](http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript). In particular:\n- There is only one fulfillment value because synchronous functions only have a single return value.\n- There is only one rejection reason because synchronous functions only throw a single exception.\n- You can only either fulfill or reject, not both, because synchronous functions only either return a value or throw an exception.\n\nUnfortunately another popular library did not quite get on board with this aspect of promises in implementing their own version of them, and so we have confusion. But a proper Promises/A compliant library like Q maintains this parallel, and thus will only allow a single fulfillment value.\n\n(Bonus question: `deferred.resolve` can take a promise. What happens if I do `deferred.resolve(rejectedPromise, fulfilledPromise, scalarValue)`? Bad things is what.)\n\nHope that helps! :)\n. [The one which must not be named](https://github.com/kriskowal/q/wiki/Coming-from-jQuery)\n. Wow, nice work! If you could just clean up the style to conform to the rest of the file, I'd be happy to merge.\n\nItems of note:\n- Four-space indent instead of two\n- Use function declarations when possible instead of function expressions (`captureLine`).\n- Space between `)` and `{`\n- Always use curly braces, even for single-line blocks.\n- Leave the declaration of `captureLine` down in the same area as the rest of the long stack trace stuff; using it before it's declared is OK (as long as you switch to a function declaration).\n\nThanks for this! Very cool.\n. I like this, and it certainly [would make testing easier](https://github.com/kriskowal/q/blob/5701e1975134d3bd46929365ee2a0cd47e918bc3/spec/q-spec.js#L1056-1081). Let's get some buy-in from @kriskowal before merging, but I'm sure it'll get in in some form.\n\nThe only question I have is whether there should be a single global error handler, which multiple users of Q can overwrite, or whether it should be an event-dispatching system where multiple calls to `Q.onError` result in multiple listeners being registered. I can see arguments either way.\n. @kriskowal, I'd really like something like this. One more consideration: #111 calls for something like `Q.stackJumpLimit = 5`.\n\nIn light of these two, I see two options:\n1. Un-defend `exports`, perhaps selectively making all existing properties non-writable and non-configurable. This allows us to align with existing APIs a bit better, viz. `window.onerror` and `Error.stackTraceLimit` as settable properties.\n2. Introduce a `Q.configureErrors({ uncaughtTrap, stackJumpLimit })` call.\n. LGTM. @kriskowal, any objections?\n. All tests pass, merged.\n. Yeah this is definitely wrong. Maybe a better version would be\n\n``` js\nreturn foo()\n.then(function (info) {\n    return [info.name, FS.read(info.location, \"utf-8\")];\n    // FS.read returns a promise, so this array\n    // mixes values and promises\n})\n.spread(function (name, text) {\n})\n```\n\n@kriskowal?\n. Is this on master or on 0.8.5? There have been so many fixes to problems like this on master... It should hopefully not happen there.\n\nOn Jul 30, 2012, at 10:04, \"Forbes Lindesay\" reply@reply.github.com wrote:\n\n> ``` javascript\n> var Q = require('q');\n> \n> function CustomError() {\n> }\n> \n> Q.when(null, function () {\n>    throw new CustomError();\n> }).end();\n> ```\n> \n> produces the output:\n> \n> ```\n> C:\\src\\>node experiment\n> \n> C:\\src\\node_modules\\q\\q.js:1299\n>                var combinedStackFrames = errorStackFrames.concat(\n>                                                           ^\n> TypeError: Cannot call method 'concat' of undefined\n>    at exports.timeout (C:\\src\\node_modules\\q\\q.js:1299:60)\n>    at process.startup.processNextTick.process._tickCallback (node.js:244:9)\n> ```\n> \n> Any ideas?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/kriskowal/q/issues/98\n. Yeah, there's a whole protocol for inheriting from `Error`, especially in V8. See http://www.devthought.com/2011/12/22/a-string-is-not-an-error/\n\nI am 95% sure it's impossible to attach a stack trace after the fact---that's the point of `Error.captureStackTrace`, after all.\n\nI believe Q is just as well-behaved as regular code here; if you have a custom error that doesn't call `Error.captureStackTrace` and throw it in synchronous code, you won't get a stack trace either.\n. Meh, I'm over it.\n. Squash and force-push for great justice? :)\n. I don't quite understand what this would do or what the use case is?\n. Would #94 work?\n\nOr perhaps this is really about how errors passed to rejection handlers need a long-stack-traced `.stack` property.\n. I see what you mean. To clarify, part of the intention there is that you should usually be able to just use the convenience methods, like `Q.ncall` or `Q.ninvoke`. But yes, it's not quite a last resort.\n. No real ideas off the top of my head, but FWIW this is definitely on my weekend to-do list.\n. Does this mean Promises/A implementations cannot interop without valueOf/nearer implementations?\n\nOn Aug 23, 2012, at 19:37, \"Kris Kowal\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\n@briancavalierhttps://github.com/briancavalier I\u2019ve reproduced and came to the same conclusion. There is a cycle where Q and When are taking turns coercing eachother\u2019s promises with their resolve methods. As part of this process, they both call .then on the other.\n\nwhen can break the cycle by attempting to normalize the promise to a fulfilled value with promise.valueOf(). I\u2019ll send a patch. I imagine Q could do something similar, but I don\u2019t see an implementation of valueOf or nearer.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/106#issuecomment-7987962.\n. Are you asking for something like this?\n\n``` js\nQ.ninvoke(mysql.connection, \"query\", \"SELECT * FROM table\").then(function (rows, fields) { ... });\n```\n\nThe problem is, promises are always either fulfilled with a single value, or rejected with a single reason. Just like normal functions only return a single value, or throw a single error. So the above code would be impossible, since it would involve a promise being fulfilled with more than one value---which would be like a function returning more than one value!\n\nThe solution, as seen in Q, is to transform such situations into arrays (just like you might do for a sync function that needs to return more than one value). We even have a shortcut to make things easier:\n\n``` js\nQ.ninvoke(mysql.connection, \"query\", \"SELECT * FROM table\").then(function (results) {\n    var rows = results[0];\n    var fields = results[1];\n    // ...\n});\n```\n\nis equivalent to\n\n``` js\nQ.ninvoke(mysql.connection, \"query\", \"SELECT * FROM table\").spread(function (rows, fields) {\n    // ...\n});\n```\n\nSee [the README](https://github.com/kriskowal/q#combination) for more details.\n\nDoes this help?\n. I believe we already do, actually:\n\nhttps://github.com/kriskowal/q/blob/939b7ca64f6c4714b82865e941f8d9eda6af536d/q.js#L522-526\n. The cases in which we would have used this are all pretty much\n\n```\nreturn Q.all([...]).thenResolve();\n```\n\nwherein we just want to wait for a bunch of operations to complete, and give a promise that succeeds if they do, but don't want to expose their fulfillment values (if any), or (more likely) an array of `undefined`s.\n. Do we like this? I'm +0 (as opposed to -0). Let's make a decision.\n\n---\n\n>  I agree that we need to exercise caution with bloating the library. I wonder if we could split it into two files (Core and Extensions)?\n\nIn general I wish we could split Q up into multiple files. I'd envision something like:\n- core.js --- core promise object, deferred, when/then\n- sugar.js --- catch, finally, done\n- objects.js --- get, put, del, keys\n- arrays.js --- all, allResolved, spread\n- functions.js --- post, invoke, fapply, fcall\n- node.js --- nbind, nfcall, nfapply, ninvoke, npost, ndone, deferred.makeNodeResolver\n- utility.js --- timeout, delay, promised\n- stackTraces.js --- long stack traces\n. @kriskowal You could still do it, you'd just have something like\n\n``` js\n// core.js\nexports.Promise = function () { };\n\n// sugar.js\nvar Promise = require(\"./Promise\");\nPromise.prototype.catch = function () { };\n\n// q.js\nexports.Promise = require(\"./core\").Promise;\nrequire(\"./sugar\");\n```\n\nor similar.\n. Dupe of #88\n. Yup, dupe of #88 essentially. Thanks for the input though---it's good to hear that this is a pain point for others.\n. Nice detective work. As for the fix, we should probably either respect `Error.stackTraceLimit` or implement a counterpart to it for Q stack traces (e.g. `longStackJumpLimit`).\n. Well, but the point of `Error.stackTraceLimit` is somewhat different.\n\nIf you write non-Q code, even with long callstacks, you wouldn't run into this. With, say, `Error.stackTraceLimit === 10`, it would cap at 10 levels of stack traces, and memory usage would stay constant. That is, memory usage is `O(Error.stackTraceLimit) = O(1)`.\n\nBut we capture multiple stack traces, one for each \"jump\" between short stack traces, so memory grows linearly. That is, memory is `O(n * Error.stackTraceLimit) = O(n)`.\n\nWe could use `Error.stackTraceLimit` as an indication that you don't want memory to grow any further than that. I'm not sure we could do that accurately without triggering the getter---that is, to determine the actual length of each component stack trace, I think we'd need to look at the stack trace. But we could limit the number of stack jumps to `Error.stackTraceLimit`, giving a total possible memory consumption proportional to `Error.stackTraceLimit * Error.stackTraceLimit`. Or we could introduce `longStackJumpLimit` or similar, giving memory consumption proportional to `longStackJumpLimit * Error.stackTraceLimit`.\n. OK, this is harder than I initially thought. I think it will require a redo of the long stack trace logic. Jotting down some notes here, both for myself and for anyone to comment on.\n\n---\n\n**The current approach** is to attach a `stack` property to every promise, essentially recording the stack at the time of its creation. (This is done in `defer`, where all pending promises come from. NB why don't we capture fulfilled and rejected stacks??)\n\nWe actually _do not_ support more than one level deep of long stack traces. That is,\n\n``` js\nQ.resolve(5)\n.then(function () { return 10; })\n.then(function () { return 20; })\n.then(function () { throw new Error(\"boo!\"); })\n.done();\n```\n\nonly generates\n\n```\nC:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\\q.js:1436\n                throw error;\n                      ^\nError: boo!\n    at C:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\\test.js:8:27\nFrom previous event:\n    at Object.<anonymous> (C:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\\test.js:8:2)\n```\n\nThis can clearly be seen by looking at the implementation of `done`: it just concatenates the error's stack trace with the promise's stack trace. It has no way of looking back in the history to find previous promises in the chain.\n\n**I'd like to fix this.**\n\n---\n\nBut, **why is the current approach \"leaking\"?**\n\nIt doesn't really make sense, if we only use the last stack trace, for us to keep around memory for every stack trace. Why is this happening? If @ef4 is right and commenting out `Error.captureStackTrace` keeps the memory constant, why is that? I'd expect it to still grow linearly, just with the increment being the size of a promise, not size of a promise + stack trace.\n\nThe key question: is the `test` function preventing the GC of 1000 promises inherently, or is it due to the stack traces?\n\nIs it possible that by using these not-yet-serialized stack traces we're keeping references to closures and scope that keep the promise alive, even though we've since chained off it and moved on? **Test this** by serializing the stack trace.\n\n---\n\nRegardless, this needs a rewrite. The current architecture leaks _and_ doesn't give you anything useful for your leaks; i.e. it only gives you one jump.\n\n**New strategy:** each promise gets a chain of _serialized_ stack traces, probably pre-concatenated. This can be capped using `Q.stackJumpLimit`.\n\nGetting access to the existing chain is the tricky part. Currently we hook into `defer`, but that won't really suffice, since a deferred has no knowledge that it's being created in order to react to a previous promise in a chain. We'll probably need to hook in to a few places, with `when` being the primary candidate. That is, `var promise2 = when(promise1)` can transfer `promise1`'s stack chain to `promise2` for `promise2` to build upon, and chop off the beginning if we're starting to exceed `stackJumpLimit`.\n. WOW. It is indeed preventing GC because of the unserialized stack traces. That is, if I change\n\n``` js\nError.captureStackTrace(promise, defer);\n```\n\nto\n\n``` js\nError.captureStackTrace(promise, defer);\npromise.stack;\n```\n\nthe memory usage stays low. That means by doing #117 this bug should be fixed. We remain with the fact that there's only one stack jump level, but that's actually pretty orthogonal.\n. Just got a chance to look at your hack\u2014it's very impressive. I don't think it would work as a by-default feature due to memory concerns, but I'm inspired to think about adding it to a debug mode (maybe a separate Q-debug package that includes your hack and others?). I'll have to let this roll around in my head for a few days\u2026\n. Oh interesting, I hadn't considered that case. Yeah we don't (and shouldn't) to any forwarding for `Q.all`, but even more basic cases like yours introduce some difficulties. Will test and report back.\n. Here's a demo of that:\n\nhttp://jsfiddle.net/cLtNS/1/\n\nIt looks like it emits progress from `fast`, then any progress from `slow` that hasn't already happened while `fast` was unresolved.\n. Next step is to see what the other progress-using promise libraries (jQuery, When, WinJS) do.\n- jQuery emits progress from `fast` then all-at-once emits progress from `slow` that happened while `fast` was unresolved, then emits the rest of the progress from `slow` at its own pace: http://jsfiddle.net/8GkkE/1/\n- When emits progress from `slow`, but only those after `fast` resolves: http://jsfiddle.net/qe9F3/1/\n. > I'm planning to add progress propagation to Dojo 1.8.1. If the progback returns a non-undefined value, that value is emitted as a progress update on the returned promise.\n\nThe problem with this approach, I would think, is that it doesn't address my first example in #113. Namely, the following works:\n\n``` js\npromiseWithProgress\n.progress(console.log)\n.finally(function () { })\n.end();\n```\n\nwhereas the following does not:\n\n``` js\npromiseWithProgress\n.finally(function () { })\n.progress(console.log)\n.end();\n```\n\nThis seems counterintuitive to me and makes using the shortcut functions (`finally`/`fin` or `catch`/`fail`) very error-prone since doing so throws away progress information.\n. > IIRC deferreds only have single resolution, rejection or progress values.\n\nIf you recall _what_ correctly? Promises/A gives no guidance. On the other hand all libraries but jQuery do have single progress values (and jQuery doesn't count, they don't even have single fulfillment values or rejection reasons). [More discussion on Q Continuum](https://groups.google.com/d/topic/q-continuum/kjQM__NM2PA/discussion).\n\n> In Dojo the progress is pass-through if there is no progback registered.\n\nThis makes sense, but I'm not sure I gather the exact semantics of the transformation. How does this behave?\n\n``` js\npromise.then(null, null, function (x) {\n    return Q.delay(1000).then(function () { return x + 10; });\n})\n.then(f, r, p);\n```\n\nDoes `p` receive a promise, or the eventual value? In particular can `p` be called after `f`/`r`?\n. > I'm not familiar with the promise.progress() syntax you use, so allow me to give an example:\n\nSorry, `promise.progress(p)` in Q is just sugar for `promise.then(null, null, p)`. I'll edit for clarity. The example I gave was trying to figure out how returning a promise from a progressback behaves. Any feedback on that?\n\nI agree that notifying a deferred of progress (`deferred.notify()` in Q) after it's already been resolved should be a noop.\n. Superceded by #125.\n. See also promises-aplus/unhandled-rejections-spec#6\n. #121 is probably worth merging as a stopgap before I do more extensive stack trace-related work, but I need to get `Q.onerror` working first as a revision of #94. Will work on it tonight.\n. What is the role of `Q.when` in this new world?\n\nEDIT: nevermind, silly question, `resolve` doesn't take any other arguments whereas `when` does.\n. This already works without us doing anything, I think because `process.nextTick` is used. @mikeal or @isaacs feel free to confirm/deny.\n\nThis test passes:\n\n``` js\ndescribe(\"node domain support\", function () {\n    it(\"should work or something\", function (done) {\n        var error = new Error(\"should be caught by the domain's handler\");\n        var domain = require(\"domain\").create();\n\n        domain.run(function () {\n            Q.resolve().done(function () {\n                setTimeout(function () {\n                    throw error;\n                }, 10);\n            });\n        });\n\n        var errorTimeout = setTimeout(function () {\n            done(new Error(\"Wasn't caught\"));\n        }, 100);\n\n        domain.on(\"error\", function (theError) {\n            expect(theError).toBe(error);\n            clearTimeout(errorTimeout);\n            done();\n        });\n    });\n});\n```\n. @ForbesLindesay I don't quite see what you're getting at? E.g. what would be a potential test case.\n\nAlso I just realized I totally forgot bullet point 1 in my OP. It probably works though. Lemme add another test.\n. @mikeal is there a simple async function we can call (or setup we can create) to exhibit this behavior, without dragging in a redis library? E.g. some way I could modify [the test case above](https://github.com/kriskowal/q/issues/120#issuecomment-10685555) to use something other than `setTimeout` and somehow escape the domain.\n. Would love some sample code there when you get the time; I still can't quite imagine how that works.\n\nSince `nextTick` is already trapped and all Q callbacks get called in `nextTick`, it seems likely we're already OK. But better safe than sorry.\n. @isaacs would this also be a fix?\n\n``` js\nfunction beep(cb) {\n  e.once('beep', function () {\n    var args = arguments;\n    process.nextTick(function () {\n      cb.apply(null, args)\n    })\n  })\n}\n```\n\nIf so I imagine Q is already fine as we do something similar.\n\nIn either case thanks so much for taking the time to give a nice example and talk us through the problem. I think it'll be worthwhile adding to Q (if we don't have it working already); it'd be far from the first unnecessary cost we've taken on ^_^\n. OK I fixed @ForbesLindesay's test (had to modify it slightly to get it to fail):\n\n``` js\nit(\"should take care of re-used event emitters with `done`\",\n   function (done) {\n    var error = new Error(\"should be caught by the domain\");\n\n    var e = new EventEmitter();\n    setTimeout(function () {\n        e.emit(\"beep\");\n    }, 100);\n\n    d.run(function () {\n        callAsync().done();\n    });\n\n    var errorTimeout = setTimeout(function () {\n        done(new Error(\"Wasn't caught\"));\n    }, 500);\n\n    d.on(\"error\", function (theError) {\n        expect(theError).toBe(error);\n        clearTimeout(errorTimeout);\n        done();\n    });\n\n    function callAsync() {\n        var def = Q.defer();\n        e.once(\"beep\", function () {\n            def.reject(error);\n        });\n        return def.promise;\n    }\n});\n```\n\nBut I am trying to think if there is a case involving just `then`, analogous to [this passing test](https://github.com/kriskowal/q/blob/9cadca7060e6b8240ad7c72a777e67d21c836c8e/spec/q-spec.js#L1751-L1773), that we should be handling. @ForbesLindesay ideas?\n. Do you think it's possible to get this to pass? I couldn't, on first try:\n\n``` js\nit(\"should take care of re-used event emitters with handlers\",\n   function (done) {\n    var error = new Error(\"should be caught by the domain\");\n\n    var e = new EventEmitter();\n    setTimeout(function () {\n        e.emit(\"beep\");\n    }, 100);\n\n    d.run(function () {\n        callAsync().done();\n        Q.resolve().then(function () {\n            e.once(\"beep\", function () {\n                throw error;\n            });\n        });\n    });\n\n    var errorTimeout = setTimeout(function () {\n        done(new Error(\"Wasn't caught\"));\n    }, 500);\n\n    d.on(\"error\", function (theError) {\n        expect(theError).toBe(error);\n        clearTimeout(errorTimeout);\n        done();\n    });\n});\n```\n. Meh. If someone is really using domains and Q together and runs into an edge case where we didn't manage to make it work, they can bring it to our attention. I think we knocked out most of this.\n. Related: #117\n. OK, now that we've got a global error trap on the way, this can go through. Feel free to touch it up as per my comments in preparation for that, and I'll merge it as soon as @kriskowal code-reviews #124.\n. A promise one primary axis of state:\n\n**Resolved** vs. **deferred**\n\nIf the promise is resolved, then it has another axis:\n\n**Fulfilled** vs. **rejected**\n\nYou are probably looking for `Q.isFulfilled()` instead of `Q.isResolved()`.\n. > Sorry, but this makes no sense. There are two distinct ways to complete a defer, either reject, or resolve.\n\nYou can resolve a deferred with a promise. In this case, two things happen:\n- If the passed promise is already resolved, the underlying-promise adopts its state, becoming itself resolved.\n- If the passed promise is still pending, the underlying-promise stays in the pending state, waiting on the passed promise to resolve before adopting its state.\n\nNotably, you can call `deferred.resolve(Q.reject(new Error()))` to achieve the same effect as `deferred.reject(new Error())`. In this sense `deferred.reject` is just sugar; the only thing you can do with deferreds is resolve them. The effect on the underlying promise---whether it will be resolved, or stay pending---is determined by what you resolve the deferred _with_.\n\n> \"A promise one primary axis of state:\", that statement makes me think you agree with me, it should either be resolved, or rejected NOT both?\n\nYou seem to have missed the subsequent line, where I explained that this axis is not resolved vs. rejected, but resolved vs. deferred. A promise can either be resolved or deferred, but not both. Similarly, it can be either fulfilled or rejected, but not both. Resolved can mean either rejected or fulfilled, however.\n. > OK, so I should think of reject as resolveWithRejection :), thanks for taking the time to go through it\n\nYeah that's pretty much it :). Thanks for sticking with me!\n. Well, the confusing thing is that \"resolve\" as a verb only applies to deferreds, whereas \"resolved\" as a state only applies to promises. :-/\n\nI agree that a `promise.isPending()` might clarify things, but that would just be the same as `!promise.isResolved()`, so it's not that helpful.\n\n@kriskowal may have more to say, but glad I could get you moving in the right direction :)\n. Yeah, jQuery has made a decision to ignore the Promises/A standard, so we can't really do much besides tell people to assimilate them with `var qPromise = Q.when(jQueryPromise)` and then move into comfortable territory where things like error propagation actually work.\n. LGTM, definitely an improvement once I realized `nend`'s return value is a useless always-fulfilled promise.\n. @kriskowal updated to propagate `undefined`s (and rebased on master).\n\nTwo remaining questions:\n1. Should returning `undefined` (or not returning) stop propagation? I.e. no progress handler should propagate the old value, but maybe a handler that doesn't propagate should stop propagation instead of continuing to trigger progress handlers, just with the `undefined` value for the argument.\n2. How should we handle throwing an exception in the progress handler?\n. Merged but opened #136 to address the still-rather-pressing exception question.\n. Do we want to just remove `nend` in 0.8.10, assuming it hasn't gotten too much adoption, or should we deprecate until 0.9?\n. What's left:\n\n``` js\n// in `makeNodeResolver`:\n              self.resolve(array_slice(arguments, 1));\n```\n\nAll of `Q.promise`.\n\n`makePromise.prototype.toSource` (do we care?)\n\nAll of `Q.master`.\n\nThe second `if (done) { return; }` in `Q.when`.\n\nAll of `Q.async` and `Q.return`.\n\nThree lines of `Q.timeout`, covering both error cases (the timeout and the original-promise rejection).\n\nAnd a bunch of shims and alternative <del>lifestyles</del> module loaders we don't care about.\n. I'm happy with how things are now. Curious why I couldn't write a test that covered the second `if (done) { return; }` in `Q.when`, but whatevs.\n\nI'll leave it up to you to decide whether the things I left are worth keeping this bug open as a reminder for or not. It's pretty much:\n- the second `if (done) { return; }` in `Q.when`\n- `Q.master`\n- `Q.async` and `Q.return`\n- `makePromise.prototype.toSource`\n. No tests? :(\n. I think we generally update the readme when doing a new release, but yes, this is a good idea.\n\n(The wiki, actually, gets updated rather infrequently :(.)\n. This seems like a horrible bug to me; nice catch. @kriskowal?\n. Can't we just only call `valueOf` on promises?\n. Related: promises-aplus/promises-spec#18\n. Working on fixing this test...\n\n``` js\n    it(\"should not convert `Date` instances to milliseconds\", function () {\n        var promise = Q.resolve(new Date(2012, 10, 4));\n        expect(promise.valueOf()).toEqual(new Date(2012, 10, 4));\n    });\n```\n. OK, fixed, but in the course of fixing this I think I came around to believing that yeah, `valueOf` is no longer a good name for this function. `nearer` seems reasonable.\n. Wow, I didn't know we returned promises from `deferred.(resolve|reject)`. And I think it's clearly a bug that we return differently each time. I'm definitely in favor of always returning `undefined`; @kriskowal?\n. If I understand correctly, the problem comes because we're doing:\n\n``` js\nforeignPromise.then(myDeferred.resolve, myDeferred.reject, myDeferred.notify)\n```\n\ninstead of\n\n``` js\nforeignPromise.then(\n  function (v) { myDeferred.resolve(v); },\n  function (r) { myDeferred.reject(r); },\n  function (p) { myDeferred.notify(p); }\n);\n```\n\nShouldn't we just change our libraries to do this instead? Then we're agnostic to what each others' deferred methods do.\n. Some options:\n- Ignore them, or log them, but don't let them have substantial impact. (Maybe pass to `Q.onerror` if it exists.)\n- Throw in `nextTick`. Not great since an error in the progress handler doesn't seem fatal, conceptually, but this will bring down your app in Node.js or Windows 8.\n- Transform the returned promise into a rejection. This is what I favor, simply because the other options kind of suck. @briancavalier thinks that progress handlers should not be allowed to effect the state of the returned promise though (i.e. they're not as important as fulfillment or rejection handlers); I can see that logic.\n\n[Previous discussion in the when.js group](https://groups.google.com/d/topic/cujojs/QurUiAeTa5E/discussion)\n. > That leads to the obvious next question of what happens when the head does start to unwind? IOW, what should happen when p1 fulfills or rejects? Promises/A+ says that handleFulfilled1 or handleRejected1, respectively, must be called. But what do we do with the result (be it a return value or a thrown exception), since p2 has already been rejected?\n> \n> This seems like a huge problem: No one can observe the result of handleFulfilled1 or handleRejected1\n\nThis convinces me: the progress handler cannot control the state of the promise.\n\nThrow in `nextTick` is possibly the best option now. Or remove progress entirely, but, I dunno, it's so convenient...\n. WinJS swallows them, for the record.\n\nWhen.js propagates thrown exceptions as progress values.\n\nDojo, from what I can tell [by inspection](https://github.com/dojo/dojo/blob/master/Deferred.js), rejects `p2`.\n. I mean, it's a shame to have less features than any other promise library, even if those features are problematic. Q is, after all, the grandaddy of promise-libraries when it comes to features.\n\nPut another way, the reason I originally got off my butt and added promise support was because WinJS had it, and I needed to assimilate some WinJS promises with progress. I can imagine someone coming from jQuery and having similar sadness.\n\n@kriskowal any thoughts?\n. BTW this is the last item on the 0.8.11 release list :). Once we figure it out we can move on to 0.9, i.e. the \"kill all the deprecated methods!\" release.\n. I'll try running it by the continuum then but my natural instinct is to throw in `nextTick`, as dangerous as that can be.\n. Q doesn't have a build process; the error in the logs is:\n\n```\n8879 error EEXIST, mkdir '/Users/dmarr/Documents/Minion/node_modules/q/node_modules/jshint/node_modules/cli/node_modules/glob/node_modules/mkdirp/node_modules/tap/node_modules/deep-equal/node_modules/tap/node_modules/tap-runner'\nFile exists: /Users/dmarr/Documents/Minion/node_modules/q/node_modules/jshint/node_modules/cli/node_modules/glob/node_modules/mkdirp/node_modules/tap/node_modules/deep-equal/node_modules/tap/node_modules/tap-runner\nMove it away, and try again.\n```\n\nIt sounds like a transient error in the installation. Did you retry a few times, after deleting your existing installation and doing an `npm cache clean`?\n\nYou can also try\n\n```\nnpm install q --production\n```\n\nto avoid getting the devDependencies, which are what's causing this problem.\n. I've noticed similar issues. Is `deprecate` broken?\n. I'm not sure the second stack trace is _our_ error; it sounds like they have an `undefined` that they're trying to call `.end()` on. Calling `done` wouldn't work either.\n\nMaybe that one is caused by removing the return values of `deferred.(resolve|reject)`?\n. Ah yes. As predicted, it's caused by us removing the return value of `deferred.resolve`. Details in karthikv/nodefront#28.\n. Well, now that [we know how to solve the infinite-loop-assimilation issue](https://github.com/kriskowal/q/issues/135#issuecomment-10055952), we can go back to returning the promise. We should avoid the behavior @briancavalier pointed out where we are inconsistent about returning it or not, however.\n. In that case I'd say just use try to jump on cases like this as they occur and leave it as-is. After all, we're pre-1.0, so semver says we can do anything we want at any time :P. People who aren't pegging to a specific version deserve what's coming to them!!\n\n&lt;/cowboy&gt;\n. Wow, nice catch. Let's do `typeof value.valueOf !== \"function\"`.\n\nFeel free to submit a pull request with tests; otherwise we'll try to get this done soon.\n. @ForbesLindesay Yes, because Q's `isPromise` is a bit misnamed; it really means `isPromiseProducedByQ` or perhaps more accurately, `hasAPromiseSendMethod`.\n. @kriskowal except for `Date`s...\n. Nah I'm happy leaving `promise#valueOf` as a Q extension, just like `nodeify` or `catch` or the like.\n. Thanks, committed as 46a0366f0997d29b12fd00cbc57afa1e86e7e258.\n. Can you produce a test case we can work on that doesn't depend on an external library like mongoMqDb?\n. This is a historical artifact. Thanks for pointing it out; we'll see what we can do to address the inconsistency.\n\nWe used to have `Q.call(func, thisP, ...args)` (and still do, behind a deprecation warning). Thus its counterpart was `Q.ncall(func, thisP, ...args)`.\n\nHowever, we've since deprecated `Q.call` in favor of `Q.fcall`, which removes the `thisP`: `Q.fcall(func, ...args)`. But we never updated/deprecated `Q.ncall` or introduced a `Q.nfcall`.\n\n@kriskowal, thoughts?\n. > IMHO, `Q.ncall`'s `thisP` argument seems counter-intuitive. Doing `myFunction.bind(this)` is pretty vanilla, and one could argue that the API could err on the side of \"least surprises\". \n\nAgreed, that's why we got rid of `Q.call` in favor of `Q.fcall`. The original idea was an attempt to parallel `call`/`apply`/`bind`, which have `thisP`s, but then we moved away from that---but only partially, leading to the current inconsistent and confusing state.\n. > `ncall`, `napply`, and `nbind` are different beasts. They cannot function without a proper thisp, so it makes sense to retain them in that interface.\n\nNot really true. `ninvoke` and `npost` suffice to replace the former two, and `nfbind(func.bind(thisP))` suffices to replace `nbind`.\n. Well, I think we need the `f` prefix to stay in sync with `fcall`/`fapply`/`fbind`. And the conciseness has worked well for me so far. I'd say `nsend`, `npost`, `nfcall`, `nfapply`, and `nfbind` are a good set to land on.\n\n> Another consideration is that I intend to rename `invoke` to `send` in v0.9.\n\nOh, good to know; was wondering about that mismatch with the concurrency strawman. A bit less communicative of a name, IMO, but ah well.\n. Done! Feel free to fix up.\n. @kriskowal nope. I assume it's due to retaining unhandled rejections indefinitely...\n. Thanks @nponeccop. I'll try to take a stab at it this weekend; as you can see, we have it as blocking 0.9.\n. Sounds like vertX still needs to figure itself out here. Hope we can make it work, eventually, but this solution isn't tenable.\n. Which browser (version is important) or server environment?\n. Pretty sure this shouldn't be happening :(. If you could put together a small self-contained test case that's a whole HTML file (from `<!DOCTYPE>` to `</html>`, I mean), that would be super-helpful. Then we can test it in various browsers etc. Otherwise we can try to reproduce on our own.\n. Much appreciated! I know it sucks to just start using a project and then get sucked into the bug tracker. If it's any consolation, I'm pretty sure this won't impact your use of the library, and will likely just be annoying in the console.\n. @kriskowal, there's been some impressive detective work here. But as @kaerus says, we're starting to get into the complicated internals of Q, and your expertise would probably help a lot here :).\n. I think `deepResolve` is pretty valuable and is a good solution to the original problem.\n. Or in [QQ](https://github.com/kriskowal/qq)? :P\n\nUp to @kriskowal though.\n. Yeah, but QQ is \"out of service.\" Qx may be a good successor/replacement...\n. @kriskowal, @SLaks Are we happy with the solutions proposed here? Namely, slight-hackery with `spread`, or a utility library implementing `deepResolve`? If so we should close this up.\n. Hi @arikon,\n\nI think this is more appropriate for the Q mailing list instead of the issue tracker, given that it is not a bug in Q.\n. Is this deep or not? If it's deep, I'd prefer `deepAll` as a name; if it's not, I'd prefer just making `all` do this. The only difference from current `all` would be the weird edge-case wherein we resolve `length` in `{ length: Q.resolve(5) }`.\n. Hmm.\n\nSo `Q.all` would use the `Array.prototype.forEach` algorithm (i.e. 0-based properties from `0` up to `length` with `in`-testing for sparse arrays).\n\nAnd `Q.allProperties` would use... `Object.getOwnPropertyNames`? `Object.keys`? `for ... in`? Or the annoying-to-program fourth quadrant, all own and inherited properties regardless of enumerability?\n. RSVP v2 is going to have this as `RSVP.hash`.\n. This would deprecate the promised wrapper because then `nfbind` would become equivalent to `promised`.\n. Right yes, that's definitely what I meant.\n. This has back-compat implications not only for how it changes the meaning of code that currently passes promises around but also because, as we noted above, we'd remove `Q.promised`.\n. I think package managers that can't deal with a vanilla package.json should die in a fire and we should never support their craziness ever.\n. I love this idea. @ForbesLindesay, I don't quite see your objection; could you restate it?\n. Yeah, I'm not really seeing the use case?\n. No, I understand, I think we're both confused where this notion of \"traditional CPS\" comes from. What libraries use `cb` and `eb` pairs? When would you want to expose such an interface to the world?\n. Is this causing all the Travis failures? :-/\n. It might be that `console.warn` output causes the tests to fail somehow? We'll have to investigate... hopefully `npm test` locally gives the same failures.\n. Did you mean to put this in 0.8?\n. I am fairly opposed to the `valueOf` name these days, after we found out that its not what we want for dates etc.\n. Yeah, good idea.\n. > It would be helpful if you could prevent q from gathering stack trace info for a specific jump (e.g. Within a library like QEJ)\n\nThis should work, no?\n\n``` js\n\nvar limit = Q.stackJumpLimit;\nQ.stackJumpLimit = 0;\nvar d = Q.defer();\nQ.stackJumpLimit = limit;\n\n// `d.promise` does not have a `stack` property\n```\n. @Redsandro you may be interested in our many [error tracking bugs](https://github.com/kriskowal/q/issues?labels=error-tracking&page=1&state=open)\n. You need to bind methods before passing them as arguments to functions:\n\n``` js\nq.nfcall(mysql.client.query.bind(mysql.client), query, [lang_code, autocomplete]);\n```\n\n(This is a general feature of JavaScript, and not specific to Q.)\n. I don't know why the above are failing, but yet again, this is incorrect:\n\n``` js\nvar doQuery = q.nfbind(mysql.client.query);\n```\n\nyou are still passing methods without binding them. You must do\n\n``` js\nvar doQuery = q.nfbind(mysql.client.query.bind(mysql.client));\n```\n. I don't have the time to look at your longer example right now, but in regard to bind: you use bind when you have methods, not functions. Methods need to be bound to the object that contains them so that they get the correct `this` value. Functions do not, since they do not use `this`.\n\nThe Node.js \"fs\" module contains a bunch of functions; assuming someone had done `var FS = require(\"fs\");`, then `FS.readFile` would refer to the `readFile` function inside the \"fs\" module.\n\nSo no, it doesn't have anything to do with the \"number of levels up\". It's just whether you're calling a method or a function. That is,\n\n``` js\nvar client = mysql.client;\nvar query = client.query(client);\n```\n\nis the same as\n\n``` js\nvar query = mysql.client.query.bind(mysql.client);\n```\n. Indeed. The problem can be illustrated by the following:\n\n``` js\nvar obj = {\n  method: function () {\n    console.log(this.foo);\n  },\n  foo: \"foo!\"\n};\n\nobj.method(); // logs \"foo!\"\n\nvar unboundMethod = obj.method;\nunboundMethod(); // logs undefined in sloppy mode, or errors in strict mode.\n\nvar boundMethod = obj.method.bind(obj);\nboundMethod(); // logs \"foo!\"\n```\n. @Redsandro `nfapply` takes a function; `npost` takes an object and a string naming the method you want to post to. There are examples and explanation in the API documentation.\n. \"post\" is our invention. There is no standard name for the operation taking an object plus a string plus an array of arguments and calling the method on that object denoted by that string with those arguments. \"mapply\" isn't bad, though, I admit :).\n. Something must be wrong with your npm installation...\n\nhttps://npmjs.org/package/q\n. Can you show how you're determining whether the result is fulfilled or rejected? `Q.allResolved` should always return a fulfilled promise.\n. @kuno I meant the promise, not the callback result. E.g. is it\n\n``` js\nrunAlotOfCommands(...).then(function (promises) {\n  console.log('fulfilled');\n}, function (err) {\n  console.log('rejected');\n});\n```\n\nor something else?\n. @kuno I can't help you solve your problem if you don't tell me what the problem exactly is. You say that \"sometime it will be resolved, sometime it was rejected\" (I assume you mean fulfilled, not resolved), but you don't tell me how you are determining this?\n. It would be cool to play around with this and find a nice API that is universally useful... and then put it in another package :). Closing for now, but indeed, thanks for sharing, and I'll keep an eye out for needing something like this in my projects so maybe I can contribute to this chain of thought.\n. It's a wiki, you can edit it too :)\n. @rkatic I think @kriskowal is referring to this signature:\n\n```\ndeferred.then( doneCallbacks, failCallbacks )\n```\n. Like, what is the result of:\n\n``` js\n$.when(5)\n  .then([function (x) { return x + 1; }, function (x) { return x + 2; }])\n  .then(function (y) { console.log(y); });\n```\n\nDoes `6` or `7` get logged?\n. In the link you gave\n. Oh, nice, thanks for guiding me to that :)\n. @cowwoc The wiki page is not about how to mix them (in which case you would probably use `Q`, not `Q.defer`); it's about teaching people who have used jQuery promises what the differences are between them and Q promises.\n. Somehow, I got inspired: https://github.com/kriskowal/q/wiki/Coming-from-jQuery\n\nFixes welcome!\n. OK, so at least now it's my unhandled rejection in the very first test:\n\nhttps://travis-ci.org/kriskowal/q/jobs/4407466/#L198\n\nThe question is, why is the throw-on-exit code not working in Node 0.8?\n. It must be something weird with jasmine, ugh. The exit listener isn't even being called.\n. I put a `console.log` inside the `process.on(\"exit\", function () { });` and it was never called :-/\n. Why isn't this getting logged?\n\n``` js\n        var r = Q.reject(new Error(\"aaargh\"));\n```\n\nit's in the second test in `q-spec.js`, and nobody is handling it, but I don't see it on the console, either locally or in Travis.\n. Mmm OK, yeah. Maybe we'll switch test runners one day; I've never been that happy with Jasmine. If we do we'd want to get multi-browser CI support (like Testling CI) as part of the deal.\n. Let's fold this into #197?\n. Maybe they're just moving the pointer to `array[0]` up by one offset.\n. Idly speculating from the sidelines again: you may gain even more by making your classes \"non hidden,\" i.e. by creating an explicit Node class.\n. @rkatic: I'm aware. I've heard from the V8 people that they can optimize more effectively if the hidden classes are explicit (i.e. use constructors whose only lines are `this.x = y`). Whether that would help in this particular case is, of course, a question that can only be measured by benchmarks.\n. Please use JavaScript when commenting on this repo.\n. Thanks.\n\nThe problem here is that you're already sending all the notifications by the time you attach the progress listener. Notifications that are sent when no progress listener is attached are not stored or re-emitted later.\n\nIn fact, since you are fulfilling the promise immediately, I don't think it would ever be possible to listen for those progress events.\n\nYou can see a working example here: http://jsbin.com/epoped/1/edit\n. You can use `progress()` sugar after `then()`. See my example above. You just can't emit progress before listening to it.\n. It's the magic of progress propagation :). In more detail:\n\n``` js\nvar promise = getPromiseThatEmitsProgress();\nvar promise2 = promise.then(onFulfilled, onRejected);\nvar promise3 = promise2.progress(onProgress);\n\npromise3.done();\n```\n\n`promise` is the one who emits progress, but `promise2` will also emit progress since events from `promise` are propagated to it without change. Thus `promise2.progress(onProgress)` will work.\n\n`promise3` will also emit progress, but the emitted progress values will be transformed by the `onProgress` handler. If it doesn't return anything from the progress handler, it'll emit `undefined` progress data.\n. @iamwilhelm yeah, sure. You just need to delay fulfilling or rejecting the promise until people have a chance to attach progress handlers. `Q.nextTick(deferred.resolve)` should do it, although it's possible since you're going through two levels of promises instead of one, you might need `Q.nextTick(function () { Q.nextTick(deferred.resolve); });`\n. Merged as 74e0a2159afbce53658acf97c96b0b2825757cf1, thanks!\n. I don't think our APIs should be in the business of `thisp`-ing. Telling people to use standard `bind` seems fine to me; that's the usual way you turn methods into functions, and adding extra sugar on top of `bind` seems unnecessary. (Thus I'm satisfied with `nf*` in general.)\n\nAlso, I think `napply` and `ncall` would not be useful, given the existence of `ninvoke` and `nsend`.\n. Sounds like there's not much support for this?\n. Oooh. I mean, I'd be all for `promiseify` (`promisify`? probably. or both.) except that it lacks the Node-specificness.\n. @ForbesLindesay you can, `fs`'s exports are functions, not methods.\n. What tests does this break in IE<9?\n\nIn other words, we're not trying for a true `Object.keys` shim, just one that is good enough for Q's internal code.\n. Oh I see, nevermind, it affects our publicly exposed `keys` method :(. Sorry for being dense.\n. Thanks, merged.\n. Is this valid, or did you close it because you discovered it was invalid?\n. The problem with this approach is that it breaks subsequent handlers if one throws.\n. Maybe test them against [this version](https://github.com/montagejs/montage/blob/601f849e86150f427ebe49bef8317b3fcf4488f2/core/next-tick.js#L61-L113) as well? I believe we were planning on replacing the current one with that, but your idea is intriguing also.\n. _sigh_. In that case, @kriskowal, thoughts?\n. @rkatic a very nice benchmark has been put together over in #206 by @francoisfrisch. But, you've clearly added a lot of thought about the \"reticking\" process. Care to give us an explanation of where it currently stands, how much it optimizes for pessimism vs. optimism, etc.? Could it be made faster by being more optimistic, for example?\n. There might still be value in this; it gives the better debugging experience, as you mention, and lets us kill the `Object.create` mini-shim. @kriskowal, any thoughts?\n. Yeah. We need encapsulation, so we can't use prototypes very much. And already-bound methods is super convenient for deferreds in particular (e.g. `setTimeout(deferred.resolve, 100)`).\n. @tebriel the broken tests have to do with Node.js domain support:\n\nhttps://travis-ci.org/kriskowal/q/jobs/4562257/#L188\nhttps://github.com/kriskowal/q/blob/334d55d87dcb64fe5120cfb1d4b450a4b71b3959/spec/q-spec.js#L1854-L1948\n\ndomains were working in 1.0.28 but something in 1.1.0 is interfering with them.\n. @tebriel thanks, we're now using jasmine-node 1.2.2 without any issues :)\n. We may want to investigate [using Istanbul](http://ariya.ofilabs.com/2012/12/javascript-code-coverage-with-istanbul.html) for code coverage, as it seems rather well-maintained and popular these days. nodecover is pretty good too though, if not actively developed, so a fair comparison will be needed.\n. @kriskowal has gone rogue and written his own runner!! Might as well close this :). Kris, you should publish it as its own package, IMO. I'd be happy to help co-maintain.\n. See also [promises-aplus/synchronous-inspection-spec](https://github.com/promises-aplus/synchronous-inspection-spec) which I'm hoping to push through soon.\n. Thanks, merged as 50cde79aeeb1a39841178919fb49f9d94c5dcfcd\n. This is why the \"fin\" alias exists.\n. Closing in favor of #201.\n. I gave this a shot:\n\nhttps://github.com/kriskowal/q/wiki/_compare/cc2bbdf5ea92ce8370ae44c98194fe07a6eefc84%5E...cc2bbdf5ea92ce8370ae44c98194fe07a6eefc84\n\nBut I still took the ES5-first approach, so let me know if you think we really should take the ES3-first approach and I'll fix it toward that direction.\n. Also: the WinJS source has some good examples of this, from what I recall trawling through it. It's not open-source though...\n. Also: our current strategy for handling non-thenable return values and any thrown exceptions is suboptimal, as we create a promise out of them and then resolve the returned promise with it.\n. Code sample where it helps please, for historical purposes if nothing else?\n. Huh, for some reason I thought that wouldn't work, but somehow it does. I think this means I need to revise https://github.com/promises-aplus/promises-spec/pull/76 to take into account such \"marked-as-non-thenable thenables.\"\n. I like that. In which case, I'd say that `deferred.fulfill(x)` should die, replaced by `deferred.resolve(Q.notAPromise(x))`.\n. My reasoning would be that things you do very uncommonly should have slightly awkard APIs that express exactly what you're trying to do. `deferred.resolve(Q.notAPromise(x))` is more explicit than `deferred.fulfill(x)` and emphasizes that what you want to do is almost always `deferred.resolve(x)`, except maybe sometimes you're dealing with non-promisey thenables and in that case you need to use the explicit `Q.notAPromise` to mark them as such.\n. As much as I love this idea, it apparently doesn't work in IE6 and 7: https://github.com/kriskowal/q/pull/195#issuecomment-13061556\n. > We need to put `nbind` back.\n\nRelunctantly agree.\n. Although,\n\n``` js\nvar bound = Q.nbind(obj.method, obj);\n```\n\nisn't necessarily as pretty as\n\n``` js\nvar bound = Q.nmethod(obj, 'method');\n```\n\nwhich is more along the lines of what the OP suggests.\n. @jokeyrhyme more like JavaScript's `Function.prototype.bind`, actually.\n. @kriskowal, should we put `nbind` back, or create a newer `nmethod`? I'm leaning toward the latter, actually...\n. Our strategy [in the past](https://github.com/kriskowal/q/pull/162) has been to allow people who desire to use hipster package managers to maintain their own repositories with such support. But, since Jam at least uses package.json instead of its own file, this might be an acceptable exception. Up to @kriskowal.\n. Oh, another idea. Given how this essentially just duplicates two fields from `package.json` into a `\"jam\"` subsection, it might be a better approach to open a pull request on Jam itself to look for the regular `package.json` fields as fallbacks.\n. Sounds like this is unnecessary.\n. When you pass methods to other functions in JavaScript, you must `bind` them first. Thus, it should be\n\n``` js\nQ.nfcall(db.collection.bind(db), 'users')\n```\n\nor better,\n\n``` js\nQ.ninvoke(db, 'collection', 'users')\n```\n\n---\n\nYou can see this same problem outside of the Q context if you tried assigning the method to a variable and using that without binding it:\n\n``` js\nvar collection = db.collection;\ncollection('users', function (err, collection) { /* won't work */ });\n\n// or parameter passing:\n\nfunction call(func, arg1, arg2) {\n  func(arg1, arg2);\n}\n\ncall(db.collection, 'users', function (err, collection) { /* won't work */ });\n```\n. Yeah, maybe we should pick better examples in the docs for these things, and add a warning about using methods without binding them. Reopening until we do that.\n. Docs updated!\n. The top of the documentation explains the correspondence: `Q(x).method(...args)` <--> `Q.method(x, ...args)`. In this case it's `Q(array).all()` <--> `Q.all(array)`.\n\nFurthermore, `all` is in the \"promises for arrays\" section, which I would think would help.\n. Not sure. Will think about it more. Perf certainly could be an issue.\n. For reference implicit `promised` is tracked as #160.\n. Small back-compat hazard; tagging as such.\n. Note that `Future.when` seems to have gone away, replaced by `Future.every`, so that reason is no longer there.\n. Ooh, exciting. https://github.com/kriskowal/q/wiki/API-Reference may help.\n\nIs there a good place to discuss that document? A few thoughts come to mind.\n. I think at the very least we should create `Q.then` as a synonym for our current `Q.when`. I'd then personally kill `Q.when`, but if we wanted to come up with a new meaning for it we could do that too.\n. Looks nice, except for the test ugliness. Will merge tonight. Thanks a bunch!\n. Merged as e45d9a9d8d3928f4f63ff240268dfdc0a3f246d9, sorry for the delay.\n. Is it really _O(t log n)_? Because as _n_ -> 0, that's amazing ;).\n. I am +1 on this. `thenResolve` is quite useful so far, and adding `thenReject` for symmetry alone would make me happy. The compelling use case provided clinches it, in my mind, overcoming any concerns about API surface area bloat.\n. @kriskowal is that a +1?\n. Now I know! :)\n\nAlthough, to be fair: https://www.google.com/search?q=%E3%80%83\n. Uh so I think I'm running into this with Mongoose + Q as well. @mgcrea did you figure it out?\n. For me it occurred when trying to serialize a structure that contained a Mongoose object. That is, I got a Mongoose model `x`, took the property `x.foo`, then tried to update another Mongoose model `y` with `{ fooFromX: x.foo }`.\n\nThis seems confined to Mongoose, but then again, I tried doing this without Q and didn't seem to get the infinite recursion. Hrm.\n. This is in fact not correct; thenables should be recursively resolved. I'll let @kriskowal confirm, but generally the consensus has been that `return thenableFor5` should act the same as `return 5`.\n\nSee also https://github.com/promises-aplus/promises-spec/pull/76\n. No, a _fulfilled_ value is a fulfilled value; a _resolved_ value is propagated.\n\nQ is not \"broken\" if a resolved value is a thenable. Q is simply incompatible with thenables where `then` means something too different from what it does in promises. You should wrap them (e.g. `deferred.resolve({ thenable: badThenable })`) if you need to pass them through the promise chain.\n. Right, I believe that our view is that it's impossible for a thenable to have a legitimate fulfillment value that is a thenable; it is our responsibility to squash chains of \"x represents something that represents y\" into \"x represents y\".\n. @rkatic I believe it does go against Promises/A+ 1.1, though, as per the earlier-linked issue.\n. \"Drastic,\" lol. This is an edge case by any definition.\n\nI think I explained it rather well above. Promises represent values. Conceptually, promises for promises are nonsensical: they are chains of \"x represents something that represents y,\" which really just should be collapsed to \"x represents y.\" Furthermore, promises for promises are hazardous, but I won't bother trying to link you somewhere demonstrating this, since you are too busy to read any reasoning longer than a few sentences it seems.\n\nAs for the difference between \"promise for promise for x\" and \"promise for thenable for x,\" @kriskowal explained this well above: we simply don't have the ability to tell the difference, so we assume in good faith that thenables are promises. Anyone who really needs to use non-promise thenables while also wanting to use a promise system will take the effort to wrap it in e.g. `[nonPromiseThenable]` or `{ thenable: nonPromiseThenable }`.\n. > When the `onFulfilled(value)` is called, `value` should be considered fulfilled, even if thenable.\n\nI agree. But only promise implementations call `onFulfilled`, and what we are arguing over in this thread---I thought---was what `value` should be. And my argument is that `value` should never be a thenable.\n. Sadly I don't think I can repeat myself any longer. You should never have a promise for a promise, as I tried to explain above, and we can't distinguish between promises and thenables, thus `value` should never be a thenable.\n. Just in case, let me try to rephrase my most recent comment in a way that seems a bit less circular:\n1. Promises for promises are nonsensical.\n2. Therefore, promises should never have as their fulfillment value another promise. (We guarantee this by collapsing chains when assimilating, when dealing with return values from `onFulfilled` and `onRejected`, and by eliminating `Q.fulfill` as per #205.)\n3. We cannot distinguish between promises and thenables, therefore, promises should never have as their fulfillment value another thenable.\n4. Promise implementations call `onFulfilled` with the fulfillment value of a promise.\n5. If the fulfillment value can never be a thenable, `onFulfilled` will never be called with a thenable.\n\nTa-da! :)\n. Let's take a different approach.\n\nCan you show us why this would be beneficial by including a test that (a) does not currently pass; and (b) is not about a cyclic promise chain (i.e. a promise resolving to itself)?\n\n\"should propagate fulfilled value as it is\" currently passes, without your code modifications.\n\n\"should coerce thenables which resoved value is also thenable\" is actually about promise cycles, which is covered by #223.\n. Oh, sorry for the wrong assumption then. The fact that \"should propagate fulfilled value as it is\" doesn't pass seems worrying and is a convincing argument. I'll try to look into it.\n\nThanks for your persistence.\n. I think we're going to wait until the Promises/A+ test suite 1.1 is done, which contains tests to ensure that returned thenable-for-thenable chains are flattened. Q already passes those, but having them in place will prevent regressions from pull requests like this. Then we can investigate how to make the tests you included pass.\n\nI should be done with the test suite by this weekend, most likely.\n. FWIW Promises/A+ 1.1 is wrapping up soon, so my strategy of waiting until we have those tests in place, then trying to merge this because it contains some tests-that-fail-but-probably-shouldn't, still seems like the way to go.\n. _A very unpolitical and now-removed version of @kriskowal's below statements were previously found here. Let's pretend I never said them, as I do not wish to represent Q in such ways :)._\n. We probably do want a reference to that link in the readme though, along with all the other ways of acquiring Q.\n. This is a small backward-compat hazard; tagging it as such. Also I'd like to point out that the upcoming Promises/A+ 1.1 revision requires self-resolution detection. (It encourages, but does not mandate, vicious cycle detection.) Search for \"if x and promise\" at https://github.com/promises-aplus/promises-spec.\n. I guess `Q.nonPromise` is named for its argument, not for its return value, which is unfortunate.\n\nNot to start off another round of \"name that API,\" but it's more like `Q.promiseForNotAPromise`.\n. 0.9.1 published with this fix.\n. Wow, thanks for finding subtle bugs; those are the worst :).\n\n@kriskowal now that we've got the 0.9 release out the door, I'd love to adopt a \"release often\" strategy to let people get their bugfixes ASAP. So maybe a 0.9.1 tonight?\n. 0.9.1 published with this fix.\n. We could also link to\n\nhttps://rawgithub.com/kriskowal/q/master/spec/q-spec.html\n\nwhich isn't cached I believe.\n. @mbriggs links to documentation for such libraries would be helpful, as I personally can't recall any libraries that don't allow asynchronous failures, only asynchronous success.\n\nAlso, this might be good as a separate package (e.g. `q-browser-adapter`), especially given the variety out there.\n. Re: alternate browser implementation mappings, yeah, as of 2.0 browserify supports [this spec](https://gist.github.com/shtylman/4339901).\n. I can't see any overriding patterns in the DOM that are making this effort feasible. @ELLIOTTCABLE's case is an interesting one, in Node.js: certain Node.js callback-taking functions are actually proxies for `someObject.on('specialEvent', ...)`, like `http.createServer` or `readline.question`, and there's always the `fs.exists` outlier. I'm not sure it'd be worth providing something specifically for those cases though, especially since people would have to remember to use it. (I.e. the workflow would be \"get bitten by `Q.nwhatever` not working, then use `Q.weirdnwhatever`\" which isn't much better than \"get bitten by `Q.nwhatever` not working, then write a small wrapper yourself.\")\n\nAs such, I think it'd be best to leave any experimentation here in user space. If people come up with some really compelling libraries around these ideas, we should link to them. @kriskowal, what do you think---time to close this issue, or is there still some productive work we can do here?\n. Merged as a3f0b85cd9f10332caaf3263c9741b2e865f88e0, with tests in 14bbc8ce3e09f476f3d722b52a4ccdbc7c6b488c. Going to do a pass through the rest of our promise-construction methods for similar problems.\n. `delay` fixed in dd934f1443aa3997f802183c12789dc3abc751a7.\n. Fixed by #233.\n. Nice catch, thank you!\n. I agree this could be quite useful, but then again, we're already fighting API surface area bloat. We'll see what @kriskowal says.\n\nIn the meantime, you may enjoy [Qx](https://github.com/SLaks/Qx), which someone has put together with lots of useful promise + array stuff.\n. Great, I'll update and merge this (with @Redsandro as the author of course) because tonight I am on a streak to close as many Q issues as possible ^_^\n. Merged as f587e75d997556e84bcf5d9a9c85939414056f99; updating API reference now. I kind of like them :)\n. @Redsandro indeed you can!\n. To be fair, there's some agreement that the existing synchronous-inspection mechanisms are confusing, and might be replaced or augmented with something like https://github.com/promises-aplus/synchronous-inspection-spec/issues/6\n. Is this Node 0.10-only?\n\nI don't have much time this week, but maybe next...\n. This seems to be q-io related, since the following does not cause the problem:\n\n``` js\nvar Q = require('q');\n\nQ.reject(\"boo!\")\n.fail(function(err) {\n    console.log('error caught!');\n});\n```\n\ninvestigating...\n. Nope, it's Q's problem. This triggers it:\n\n``` js\nvar Q = require(\"q\");\n\nQ.reject(\"foo\").get(\"bar\").fail(function (err) {\n    console.log(\"error caught!\", err);\n});\n```\n. @kriskowal, I'm at my wits end on how to fix this one. I added a failing test in a branch, as above, but am not sure how to approach it myself.\n. @mikerobe, just as a point of etiquette, it is very rude to post bug reports in CoffeeScript to a JavaScript repo.\n. An API for disabling this is planned; see #265.\n. Remember that .then and .fail create new promises, which are unhandled if the original one is unhandled.\n\nOn May 30, 2014, at 17:45, \"Trevor Burnham\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nI'm wondering why this was closed... surely it's a bug that attaching additional success handlers to a promise causes additional entries to be added to unhandledReasons/unhandledExceptions? Here's a test case:\n\ndeferred = Q.defer();\ndeferred.reject(new Error('foo'));\ndeferred.promise.fail(function() {\n  console.log(Q.getUnhandledReasons().length);  // 0\n});\ndeferred.promise.then(function() {  /\\* ... */ });\ndeferred.promise.fail(function() {\n  console.log(Q.getUnhandledReasons().length);  // 1\n});\n\nIt's perfectly valid to attach more success handlers than failure handlers to a promise, and should not complicate debugging. N'est pas?\n\n## \n\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/238#issuecomment-44703133.\n. Even shorter:\n\n``` js\nQ.allResolved(promises)\n.invoke(\"filter\", Q.isFulfilled)\n.invoke(\"map\", Q.nearer);\n```\n. https://github.com/kriskowal/q/wiki/API-Reference#promisevalueofexception\n. `.fail(onRejected)` returns a new promise (it's shorthand from `.then(undefined, onRejected)`). The relevant section of the spec is thus 3.2.6, governing the behavior of the returned promise.\n\nThat new promise is fulfilled, since you implicitly returned `undefined` from the `onRejected` handler. If you had thrown an exception, the new promise would be rejected, and that step would be skipped, but since you returned, you're signaling that you handled the error.\n\nHere is the analogous synchronous code:\n\n``` js\ntry {\n  console.log('Throwing error');\n  throw new Error('Catch!');\n\n  console.log('You shall skip this step!');\n} catch (e) {\n  console.log('I caught ya! :D');\n}\n\nconsole.log('Shouldn't this step be skipped?');\n```\n. Errors bubble! But if you handle them, then they're handled! :)\n. I'd suggest something like\n\n``` js\n// ...\n.fail(function (err) {\n    console.log('This is not a real error. etc.');\n    return false;\n})\n.then(function (value) {\n    if (value !== false) {\n        // do normal stuff\n    }\n})\n```\n\nAssuming that `...` will fulfill with a non-`false` value in non-error conditions.\n\nAs always, it's good to think how you would handle this in the sync case. If you end up in a `catch` block for something that's not a real error, but this would affect whether or not subsequent steps are executed, you'd probably set a flag and use that to modify the subsequent steps---like we're doing here.\n. I think we'd be best served if you could come up with an example of what you're trying to do, but synchronous. Remembering that promises are just an asynchronous parallel to synchronous function calls, that should help.\n. I look forward to seeing your synchronous counterpart code so I can help you further.\n. You never showed me synchronous code that emulates your desired workflow, which I asked for a few times under the reasoning that once I have a synchronous version, I can show you the optimal promise-based asynchronous counterpart. If you show me synchronous code that does what you want (e.g. with hypothetical synchronous HTTP request functions, like you would have in other runtimes besides Node.js) we can continue.\n. I don't like the idea of `then` ever passing more than one value to its callbacks, or `resolve` accepting more than one value. It breaks the sync/async parallel: a single return value from a sync function <=> a single fulfillment value for an async promise.\n. I think there's been some good discussion here, and maybe the `Q.spreading` idea could be experimented with in the future. But at least for now, I don't think Q will change its semantics in this area, so let's close this issue.\n\n@killdream, if you feel strongly that `Q.spreading` is a good idea, please open a new issue and we can debate its merits there. Personally I feel that it's not better than what we have, and is especially confusing if the `deferred.resolve` call is separated in space or time from the `promise.then` call. But that's just my opinion.\n. Remember that promises parallel synchronous functions, which can only return a single value or throw a single exception. The fact that Node's callbacks don't have any such contract is unfortunate, but there's not much we can do to work around it (besides perhaps throwing away any called-back-with values after the first one, but arrays seem like a better choice).\n\nSo fulfilling with multiple values doesn't work and doesn't make sense.\n. It looks like this is coming from\n\n```\nat /Users/realyze/code/salsita/trunk/src/Project-Evolution/node_modules/q/q.js:665:13\n```\n\nwhich is where Q adds the `process.on(\"exit\", ...)` listener to notify of unhandled rejections before exiting. Interesting.\n\nI'd guess sandboxed-module gets a new copy of Q for each test, and thus the `process.on(\"exit\", ...)` gets run each time. If you end up with 11 or more copies of Q, you get this warning.\n\nI'm not sure there's a great solution here. Since there are indeed 11 copies of Q, there are 11 possible sources of unhandled rejections, so we need all 11 listeners. If anyone has any ideas though, let us know...\n. > Well, strange thing is that this happens even if I use describe.only and run a suite of 6 tests (it still complains about setting 11 listeners).\n\nI am not sure exactly how `describe.only` works, but if I've learned anything about Mocha, it's that its internals are complicated and hard to predict. Maybe it still executes `describe` or `beforeEach` blocks for things outside the `describe.only`, just not `it` blocks... or something. I would try putting a `console.log` next to all instances of `sandboxedModule.require` that reference Q and seeing how many times/where it happens.\n\n> Also, shouldn't the listener be unset when the test ends?\n\nHow would Q know when the test ends? Q only knows when the process exits, but all tests run in the same process, and there are 11 (or so) copies of Q created in the process before it's time to exit.\n\nJust to be clear, in normal code execution, there is only one copy of Q at any time; normal `require` has an internal cache. But by introducing sandboxed-module, the cache is reset every time you do `sandboxedModule.require`, so Q's main code will be executed and a new `process.on(\"exit\", ...)` listener will be added.\n. Is there a page or URL we can link to that wouldn't require us updating the version number in the README every time a new release is published?\n. I mean, if you're just after the latest version, then https://rawgithub.com/kriskowal/q/master/q.js would work well (notice \"rawgithub.com\", instead of \"raw.github.com\"). I assume the benefits of cdnjs are that it's a CDN, and thus presumably distributed worldwide so people get lower ping times.\n. Sadly without a maintenance-free way for us to link to this, we can't really include it in the README like we do other sources of getting Q :(. Let me know if cdnjs grows a new feature like that.\n. Remember that promises represent asynchronous function calls. Since functions can only return a single value, promises can only be fulfilled with a single value. Similarly, since promises can only throw a single exception, promises can only be rejected with a single reason.\n\n[See this presentation of mine](http://www.slideshare.net/domenicdenicola/promises-promises) for more detail on the parallel.\n. Thanks! Merged with some slight wording tweaks as 5a565c0b52ec50aa6e5828727b55e845e42b9428.\n. Superceded by #296.\n. I think `Q.parallel` sounds pretty cool, but I'm not sure it's a common enough use case that we want to add it to the base Q library. @kriskowal, any thoughts in that direction?\n\nEven if we don't add it, it might be a great npm package just by itself!\n. Sounds like a bad bug. Will investigate and fix ASAP. Thanks for reporting it!\n. I am unable to reproduce this, although I did replace the `_.map`s with normal ES5 `map`s (e.g. `out.map(...)` instead of `_.map(out, ...)`.\n\nCan you produce a test case that fails in a JSFiddle, preferably one that does not rely on any third party libraries which might themselves have bugs? We'll reopen if so.\n. I've been starting to think we should turn it off by default, for performance reasons. :/\n. Yes, set `q.stackJumpLimit = 0` or something similar; it should be documented near the bottom of the README.\n. Yes, we used to use the stack trace API, but found it to cause various issues. The idea is that if you use Q, you opt into our `error.stack` handling behavior. If you want to use Q with another library that also manipulates error stacks, you'll want to turn off our stack manipulations (just like, hopefully, other libraries like raven-node also have the ability to turn off their manipulations).\n. I am going to close this, and track any further work in this area (e.g. deciding whether to turn off long stack traces by default) under #264.\n. Optionally, `{ state = \"pending\", resolution = promiseWeAreWaitingOn }`?\n\nAlso, we'd of course keep the rather-convenient `Q.isFulfilled`, `Q.isRejected`, `Q.isPending`, and their promise-prototype counterparts. We could additionally add `Q.isSettled` and `Q.nearest` (`nearer`? both?). If we added the `resolution` idea then `Q.nearest` could be easily implemented in terms of that, which is kind of nice, I think.\n. Ah, and I forgot to mention: Node.js's `util.inspect` treats `inspect` methods specially, by using their output instead of the usual enumerable-keys-and-their-values display. I think this is actually a plus, but, it's something to be aware of.\n. Thanks! Merged as c2da8515431e64cebf6d6a1f03f11409ffc6dbd8.\n. I believe as per comments in #263 this has been obsoleted by #337. Please reopen if I'm mistaken.\n. Sounds good. But,\n\n> Long stack support is useless if it does not get shown by debuggers.\n\nThis is definitely not true in my experience, since in Node.js we don't really use debuggers but we see stack traces get printed all the time :).\n. @kriskowal an update: it turns out infinitely long stacks don't consume any more memory than single-level \"long\" stacks. This is because (a) all promises store their own stack trace already, and (b) when a promise is resolved to another promise, it already stores a closure reference to that promise. Infinite long stack support consists entirely of making that closure reference into a property reference (i.e. `promise.source = resolvedPromise`), then crawling that chain of `promise.source`s when it's time to assemble the infinitely long stack.\n\nWith that in mind, I'm thinking `Q.longStackSupport = true | false`, defaulting to `false`. Hooray, simplicity!\n\n---\n\nNow, for a question: what do you think of switching it on or off depending on environment, like @tgriesser suggests? I found out that [you can find out whether Web Inspector is open](http://stackoverflow.com/questions/7798748/find-out-whether-chrome-console-is-open), and if we combine that with `NODE_ENV`, we'd be in pretty good shape. One potential wrinkle is that the convention for `NODE_ENV` as per Express seems to be to assume it's \"development\" unless it's explicitly set to \"production\".\n. Thanks. I've noticed this in several libraries recently; I wonder if it's a recent change in Mocha. Will fix ASAP.\n. Thanks, merged as 5c10c12c539c22bca079899977cbd8f0111ecb5c!\n. I am becoming increasingly convinced something like this is necessary. Here are some random thoughts:\n- when.js has an implementation that is very simple, [from what I can see](https://github.com/cujojs/when/blob/master/when.js#L699-L752). Tagging in @briancavalier in case he has any comments.\n- RSVP.js makes use of Mutation Observers, which are very fast as they occur in \"micro tasks\" instead of \"macro tasks\". The number of browsers that support [MessageChannel](http://caniuse.com/#feat=channel-messaging) but not [mutation observers](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#Browser_compatibility) is pretty low, and IE10 has `setImmediate` which does allow paints but is pretty fast anyway. We'd basically lose Safari 5.x.\n- Both RSVP and when seem to make the simplifying assumption that enqueued functions cannot throw. This seems reasonable if we carefully control who uses this function.\n- It might be worthwhile to rename per #298?\n. > I do not believe that we catch exceptions before nextTick in all cases. Quick scan shows nodeify in particular.\n\nSure, but we could put the burden on `nodeify` instead of on `asap` (hahahahaha).\n. Thanks, merged as 27e35483977d3638e200dc25f0e2007d16333c31!\n. Thanks; merged!\n. Indeed, @kitcambridge is correct. We point this out at the bottom of our [Adapting Node](https://github.com/kriskowal/q#adapting-node) section in the readme.\n\nAnother solution is to upgrade to Node.js 0.10 or higher, where streams don't start emitting `\"data\"` events until someone is listening to them.\n. Good question. I do this all the time in my code. Here's the idea:\n\n``` js\n// success: return a promise fulfilled with `5`:\nsomeStub.withArgs(\"foo\").returns(Q.resolve(5));\n\n// error: return a promise rejected with an error\nsomeStub.withArgs(\"bar\").returns(Q.reject(new Error(\"bar is bad, foo is good\")));\n\n// advanced: return a promise whose fate you can control later\nvar deferred = Q.defer();\nsomeStub.withArgs(\"bar\").returns(deferred.promise);\n\n// later:\nif (Math.random() > 0.5) {\n    deferred.resolve(5);\n} else {\n    deferred.reject(new Error(\"the winds of fate have carried you to a bad place.\"));\n}\n```\n. I'm afraid at this point I'm not sure how to help, as I've never used Sinon's \"mocks\" (only its stubs and spies). If you have an example using only stubs and spies I can try to be more helpful.\n. I'm sorry to say I'm pretty lost. I don't know what your code is doing anymore because of the mock-related stuff, and thus can't really help.\n. Thanks! Merged, with some minor tweaks, as 5cbbfe8138bf4108a7e543058a3be2b925e8e283.\n. That sounds horrifying! A simple failing test case would be appreciated, if you could.\n. @rkatic, any comments?\n\n@blalor, a small reproducible test case would be extremely valuable.\n. Oh wow, multithreading!? Yeah I imagine that breaks a bunch of assumptions that Q (and every other JS library on the planet) makes :-/.\n\nIf it's an easy fix we'll be happy to take it though. E.g. if you get a small reproducible test case, and then make a small change to the queueing code, and that fixes your test case, we'll very likely accept it.\n. Let's close this for now, but my above words stand: if you have an easy fix and a reproducible test case, we'll take it, even if just for Rhino's sake :).\n. Actually, the way that the unhandled rejection display works is by logging an array to the console, which is live-updated when you push into it. Browser consoles do that automatically these days. So the order shouldn't matter.\n\nIf you have failing JSFiddle though, e.g. one that fails before that change and works after it, I'd be happy to take a second look!\n. What do you mean by \"results in\", \"fails\", and \"works\"? Which browser does it \"result in\" that?\n\nI'm seeing different results. You can test using https://rawgithub.com/domenic/q/master/q.js\n. I can't see how this has anything possible to do with Q, given that Q never touches your filesystem. It sounds like a bug in nodefront.\n. Long stack traces are kind of intimately tied to Q's internals at the moment, but yes, if we could expose appropriate hooks that'd be a good idea.\n\nI'd like to nominate generator-related stuff for being moved to a separate package as well.\n. This code has a syntax error, so it seems unlikely to be actually working code. If you could produce a JSFiddle that shows the problem, that would be helpful.\n. Thank you! Merged as 89a549b6f25b52c46048b81408e59b3e9bc4c145.\n. Hi @necolas, as you can see from #162, we're not interested in maintaining support for other package managers inside this repo. You can file issues against @ForbesLindesay's repo, or maintain your own fork of Q.\n. Indeed, if the package manager cannot draw all it needs from `package.json`, we are not interested in supporting it. As for catering to client-side package managers, we already cater to npm, and [that should be enough for anyone](http://www.slideshare.net/domenicdenicola/client-side-packages) :).\n\n(Opinions in this last sentence not necessarily supported by the Q project as a whole or @kriskowal. Opinions in the first sentence are, however.)\n. `Q.nearer`, which I think used to be called `Q.valueOf`, is I think not compatible with the current release. However, `promise.valueOf` is. That might be source of potential complaint/confusion.\n. > while `all` replaces values of the input array\n\nEeek, that doesn't sound like something we should do! @kriskowal, can we remove that behavior??\n. Yeah, we somehow haven't gotten complaints about `all` so far... still... I'm fingering my lynch-mob-designated pitchfork.\n. So if I'm understanding @rkatic's proposal correctly:\n- The default behavior for `all` would be to create a new fresh array, but optionally one could pass in their own array `results` to be reused\n- The default behavior for `allSettled` would be to reuse the `promises`, but optionally one could pass in a new array `results` to be used?\n\nThis seems inconsistent... Maybe that first line is supposed to be `results = results || promises`?\n. OK, rebased with `allSettled` matching `all` in that both modify their input array.\n. I'm happy to go whichever way @kriskowal prefers.\n. @kriskowal poke\n. Q shouldn't be interfering with `process.on('uncaughtException', ...)`; can you post some sample (JavaScript) code that reproduces the problem?\n. This is one of the most exciting things I've seen :D. Amazing work sir! Will let @kriskowal do the honors of merging, but I can't wait to start using these.\n. @kriskowal if you could look at #238 and maybe #278, a lot of people are getting hurt by those.\n. Yeah, dupe of the unfortunate #238. We want this fixed badly; if you have any ideas let us know!\n. Woah, OK, nice find! I'll try to turn that into a patch tonight or tomorrow. Maybe I'll implement #265 as well in order to be able to test it nicely.\n. Awesome, thanks very much :D. Will merge tonight, and maybe we'll do a 0.9.4 release with it before doing the whole API overhaul as per #265.\n. Thanks so much. Merged as bba609d0f25f9d046c53c58d75d0ee5125424d7d.\n\n@kriskowal, if you want to push the button and do a 0.9.4 release I'm totally ready. I'll try to spend some time this weekend doing #265 but no need to wait up I think.\n. Exceptions thrown inside `onFulfilled` or `onRejected` reject the promise returned by `then`:\n\n``` js\nvar promise2 = def.promise.then(function(val) { assert(false) });\npromise2.then(\n  function () { console.log(\"this will never happen\"); },\n  function (err) { console.log(\"the assertion error:\", err); }\n);\n```\n\nYou can learn more about how this works [in the readme](https://github.com/kriskowal/q#propagation), and get some reasoning behind it [in my blog post](http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/).\n\nWith regard to testing promises, you have a few options. If you use `done` instead of `then`, any rejections (including ones resulting from `throw`s inside `onFulfilled` or `onRejected`) will be thrown in the next tick. For example:\n\n``` js\ndef.promise.done(function(val) { assert(false) });\n```\n\nIf you need more complicated assertions, e.g. with an async testing framework, you can do things like\n\n``` js\nit(\"should be 5\", function (done) {\n  def.promise.then(function (val) {\n    assert(val === 5);\n  })\n  .then(done, done);\n}\n```\n\nThis works because the returned promise either fulfills to `undefined`, resulting in a call to `done()` which async test runners interpret as no error, or the returned promise rejects with an assertion error, resulting in a call to `done(assertionError)` which the test framework then uses.\n\nFinally, if you want something more streamlined, you can try [Mocha as Promised](https://github.com/domenic/mocha-as-promised) and [Chai as Promised](https://github.com/domenic/chai-as-promised/).\n. :)!\n. @Lacrymology while @rkatic's advice is correct, it's a bit more advanced than you might be needing. So the simple answer to your question is just \"yes\" :).\n\n(That said, his first point about exceptions thrown by `handler` is a good one even at the beginner level; [we cover it in the readme](https://github.com/kriskowal/q#handling-errors) for that reason.)\n. The [Q Continuum](https://groups.google.com/forum/#!forum/q-continuum)!\n. Thanks, merged as 1c024d5721f3179e76051ea71ce3851e8feb0a0a.\n. Hmm, I thought I had good arguments against this, but when I start typing them out they seem less strong. Tagging in @briancavalier in case he has any thoughts; I know it's an area he's considered a lot in when.js.\n. Thanks Brian; I knew that rejecting `p` was out of the question, but @eden's suggestion was allowing `p`'s progress handlers to reject children of `p`, and your example from that thread was exactly the counterexample I'd forgotten about.\n\nI agree that that other idea was pretty interesting. Although, the strangeness of it (i.e. the way that `notify` ends up behaving so differently from `resolve` or `reject`) makes me further dislike how we've mixed progress into the `then` signature.\n. OK, it's decided. `notify` will return a promise derived from the various `onProgress` handlers. See #340.\n. Could you write that code in JavaScript, which is the language of this repository?\n. Yes. Asynchronous code is generally slower than synchronous code. If you are using Q for synchronous code (e.g. switching synchronous code to Q-based code), you are making a mistake. If you are using Q for asynchronous code, it won't be that much slower than other asynchronous solutions---which you don't seem to be comparing against.\n. Even ignoring your continued rudeness in posting another language: event emitters are synchronous, not asynchronous.\n. Use `setImmediate` for a real test.\n. You need to call `doit` from inside `doit` to simulate a chain of promises. You can't just run a bunch of `setTimeout`s in parallel.\n. To be clearer: you need nested (recursive) `setTimeout`s to simulate nested promises. Your latest code does not contain any nested `setTimeout` calls.\n. Using the branch that turns off long stack traces by default (see #311) and running [this test suite](https://github.com/kriskowal/q/blob/ebb3769bf7cdb818f46caf7864c819ef8761d1a2/benchmark/compare-with-callbacks.js), I get the results\n\n```\n                      A single simple async operation\n          49,311 op/s \u00bb with an immediately-fulfilled promise\n         436,358 op/s \u00bb with direct setImmediate usage\n              64 op/s \u00bb with direct setTimeout(\u2026, 0)\n\n                      1000 operations in parallel\n              48 op/s \u00bb with immediately-fulfilled promises\n             897 op/s \u00bb with direct setImmediate usage\n```\n\nQ is slower than we would like, but only about 10x slower than callbacks. Running many promises in parallel seems to make Q about 20x slower.\n. @sobotklp you appear to have introduced long stack traces in your upgrade. You can turn them off with `Q.longStackJumpLimit = 0`. In version 0.9.5 they will be off by default.\n. I think it's time to close this. Thanks for prompting us to finally get a performance test suite up and running. If you have any further cases that you think are slower than they should be, we'd appreciate them either over in #312, or even better as pull requests that add to the existing suite.\n. @kriskowal thoughts on this? I guess my preference would be to stop exposing `nextTick` entirely. That way we could eventually move toward a faster implementation that assumes the enqueued functions never throw (by moving any `try`/`catch`ing to the specific cases where we `nextTick` user-supplied functions).\n. There's still the issue of what we expose as an external API, e.g. would we do `exports.nextTick = require(\"asap\")` to maintain backward compatibility?\n. OK, so let's rename this issue to \"remove `Q.nextTick`\"\n. This kinda-sorta argues for an extension to `inspect()` that lets you know what a promise is resolved to, e.g. `{ state: \"pending\", resolution: otherPendingPromise }`. Maybe `{ state: \"fulfilled\", value: 5, resolution: promiseIGot5From }`, but I think that might prevent garbage collection if we need to be able to produce it on-demand.\n\nDunno, haven't though too much about it, but might be useful especially if we were to try to build the unhandled rejection tracking as a kind of external plugin on top of a core Q.\n. Alternately, once @kriskowal reviews and accepts #296, you'll be able to turn off the unhandled rejection tracking :). -poke poke-\n. @kriskowal Yeah I mean we don't want to delay a patch release indefinitely, we've already made great progress on tidying up unhandled rejections, but maybe one of us can try to take on this issue and maybe also #292?\n\n@ravi as Kris says, I don't think `Q.getUnhandledReasons()` would be too useful to you; it would just give you the list of rejection reasons that Q thinks are unhandled (which, as we're discussing in this issue, is not an accurate list).\n. It's not really clear what you even mean by this... What do you want `obj.method1().method2().method3()` to do? Does it have anything to do with promises? You can implement that in normal JavaScript without a promise library, so what are you asking, exactly?\n. Indeed, @wychi and @killdream have this covered. Let us know if you need further clarification.\n. I'm going to give a Grunt build system a shot. Thanks for bringing this to our attention.\n. @kriskowal if I can pull it off, what do you think of some automated way of uploading the minified version to S3 and linking to it instead of storing it in the repo?\n. Second question: it looks like [grunt-contrib-uglify](https://npmjs.org/package/grunt-contrib-uglify) has a way of automatically reporting gzipped size. Given that fact, is there any point in committing the `.min.js.gz` file?\n. +1 to the idea, both on the level of simple sugar for `Q.async(...)()` and also on the level of tracking down unhandled rejections better. I've definitely accidentally created unhandled rejections myself via just simple generator usage, so it could use some work. Approved, if you can add a few tests showing that it does what it says it does (which should be nice and easy with a combination of `Q.onerror` and the new `Q.getUnhandledRejections()` etc.).\n. @kriskowal IMO that's the correct division of responsibilities, although I hadn't seen it put so clearly until you did so :). Ideally, with generators, we should be able to completely avoid unhandled rejections. The only time they should be possible is if you use a promise-returning side-effecting function but forget that it's promise-returning, i.e. you just fire-and-forget it. And async side-effecting functions are the perfect use case for `spawn`, so if `spawn` calls `done` for you... seems good.\n. Hmm I see the idea but am not too happy with parameters that can sometimes be rejection reasons and sometimes fulfillment values. Also, the correct term is actually \"settled\"; `allResolved` uses \"resolved\" incorrectly. (Because if you resolve a promise with another pending promise, the first promise is resolved but still pending; it is not yet settled to either fulfilled or rejected.)\n\n<del>Note that you can accomplish something similar today with the awkward `allResolved`:</del> <ins>This is actually not true, see below</ins>\n\n``` js\nQ.allResolved([\n  promiseThatFulfills,\n  promiseMaybeRejected,\n  promiseThatFulfills]).spread(function (a, b, c) {\n  if (\"exception\" in b.valueOf()) {\n    // .. awkward...\n  }\n});\n```\n\nWith the upcoming #257, which replaces `allResolved` with a more accurately-named and less-awkward `allSettled`, you'd get access to objects of the form `{ state: \"fulfilled\", value: v }` or `{ state: \"rejected\", reason: r }`, which would make the code into\n\n``` js\nQ.allSettled([\n  promiseThatFulfills,\n  promiseMaybeRejected,\n  promiseThatFulfills]).spread(function (a, b, c) {\n  a = a.state === \"fulfilled\" ? a.value : \"default A\";\n  b = b.state === \"fulfilled\" ? b.value : \"default B\";\n  c = c.state === \"fulfilled\" ? c.value : \"default C\";\n});\n```\n\nWhat do you think of that?\n. Oh nice gist; you're right, you can't combine `spread` and `allResolved` in the way I'd thought you would, because of the way `spread` does an `all` internally. Thankfully `allSettled` doesn't have the same problem :).\n. @Redsandro are you using the latest version of Q? The non-extensibility was removed a while ago.\n. `Object.freeze` is a superset of `Object.preventExtensions`, and we used to do that.\n\nAs to which is preferred, technically most methods should be defined with `Object.defineProperty`and `configurable: true`, and probably `writable: true`. `enumerable: false` is the default so you don't need to explicitly state that.\n\nBUT, Q itself doesn't use `Object.defineProperty` since Q maintains IE8-compatibility, so using just assignment is fine and possibly better since it fits with Q's existing practice.\n. Oh, also maybe I should add this to the `prepublish` step? It's not quite what prepublish is made for, since it has no impact on the packaged artifacts, but _if_ you do `npm publish` before you do a `git push`, it's nice, and if you do it after (like I usually do), it'll possibly be a \"whoops, forgot to minify\" reminder.\n. Oh, nope, I lied, we need it for `promiseDispatch` which is pretty fundamental (lol). Not getting away with this after all.\n. @kriskowal after looking into it, Chrome [removed](https://groups.google.com/a/chromium.org/forum/?fromgroups=#!topic/blink-dev/JJ7I6BOX8qA) the ability to detect if the console was open. And it was kind of hacky anyway, either cluttering your console with \"Profile Started ... Profile Ended\" or forcing Q to do a `console.clear()` and lose any console data before Q loads.\n\nCombined with my slight unease about the dominant pattern for `NODE_ENV` defaulting to development, I think it's best to just leave the long stacks off by default. So, this pull request is good as is.\n\nAny comments before I merge?\n. @kriskowal when you have time I think this is the only thing I want to get in before doing a 0.9.5. Then we can move on to more experiments like #313 and the nextTick stuff, mwuahaha.\n. Awesome :). Yeah, will do tomorrow\u2014bedtime now!\n\nOn Jun 10, 2013, at 1:07, \"Kris Kowal\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nThis looks good. Would you like me to merge this and cut the release?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/311#issuecomment-19181017.\n. Merged as 49d920d067619cbd751677302b3d396bb32b0eb5 and 97f4c6b17ce45d0ac5bcd871b5ac37e616c3cff0, w00t (and yay for avoiding merge commits!).\n. I have tests in a branch https://github.com/kriskowal/q/tree/perf but am not sure they're any good. This match thing was _way_ easier to use than BenchmarkJS, but doesn't run in browsers. And I think we'll need to write a custom reporter anyway to get relevant data (e.g., we care about the quotient of Q to setImmediate rather than how many ops/s each takes).\n. My perf tests are rudimentary and should eventually be replaced by something much better, but after breakfast I think I'll merge them in just to give us something.\n. OK, merged in to master. Let's please use this thread for ideas on additional performance tests. It also needs to be rewritten with BenchmarkJS I think; Matcha is super easy to use, but not very maintained or rigorous or browser-compatible.\n. That first blog post has major methodology issues that have been discussed at length. I would not be surprised if the third does as well, given that it's from someone who believes that synchronous resolution is The One True Way.\n. I like this as a good first step but I think two generated files in the repo is getting into bad news territory. If we did this I'd prefer to do some kind of automated upload-to-S3 thing.\n. Thanks for finding this! The inline documentation is in need of some love... I just pushed an update that includes this, except it uses the more correct term \"settled\" (= \"fulfilled or rejected\") instead of \"resolved\" (= \"fate has been sealed, possibly by resolving to another promise that hasn't yet settled\").\n. Here are the results from my nascent perf test suite:\n\n### Before\n\n```\nDomenic@REVAN ~/Dropbox/Programming/GitHub/q (perf)\n$ npm run benchmark\n\n> q@0.9.6 benchmark C:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\n> matcha\n\n\n                      A single simple async operation\n          52,342 op/s \u00bb with an immediately-fulfilled promise\n         388,053 op/s \u00bb with direct setImmediate usage\n              64 op/s \u00bb with direct setTimeout(\u2026, 0)\n\n                      1000 operations in parallel\n              46 op/s \u00bb with immediately-fulfilled promises\n             751 op/s \u00bb with direct setImmediate usage\n\n                      Chaining\n              41 op/s \u00bb Chaining many already-fulfilled promises together\n              45 op/s \u00bb Chaining and then fulfilling the end of the chain\n\n\n  Suites:  3\n  Benches: 7\n  Elapsed: 11,221.02 ms\n```\n\n### After\n\n```\nDomenic@REVAN ~/Dropbox/Programming/GitHub/q (perf)\n$ npm run benchmark\n\n> q@0.9.6 benchmark C:\\Users\\Domenic\\Dropbox\\Programming\\GitHub\\q\n> matcha\n\n\n                      A single simple async operation\n          71,349 op/s \u00bb with an immediately-fulfilled promise\n         317,659 op/s \u00bb with direct setImmediate usage\n              64 op/s \u00bb with direct setTimeout(\u2026, 0)\n\n                      1000 operations in parallel\n              46 op/s \u00bb with immediately-fulfilled promises\n             904 op/s \u00bb with direct setImmediate usage\n\n                      Chaining\n              48 op/s \u00bb Chaining many already-fulfilled promises together\n              57 op/s \u00bb Chaining and then fulfilling the end of the chain\n\n\n  Suites:  3\n  Benches: 7\n  Elapsed: 10,575.42 ms\n```\n. @ForbesLindesay I believe Montage Require uses normal CommonJS modules, with no special syntax (i.e. no AMD `define` analog). But, Q is a special case since a promise library is used for \"bootstrapping\" the module system itself---you can imagine how promises are useful in writing module loaders. So including `bootstrap` code is both (a) not necessary for any modules except Q, and (b) necessary for Q.\n\nSimilarly, I am pretty sure a \"Q implementation\" is a privileged part of SES used for secure communication channels, and SES doesn't generically expose libraries via `ses.makeLibraryName` functions. So, similarly... not necessary except for Q.\n\nSo ideally UMD would remove the `bootstrap` and SES code. Which leaves us wondering how Q can include them. Custom templates, or perhaps template additions, would be one idea... maybe browserify's `browser` field could be extend to include a `umdSupplements` string or something?\n. Another idea: if a module exports a `__umd__` function, then UMD calls that; if it returns `true`, UMD does nothing else, but if it returns `false`, UMD sets up the global or `module.exports` or `define`.\n. @rkatic I have thoughts in making that work via [zuul](https://github.com/shtylman/zuul). It would require switching to Mocha, but I think I can pull that off.\n. @kriskowal re:\n\n> This is part of a move to introduce modularity to Q, and shuck dependencies out to other packages. I\u2019m not sure what the ramifications of this will be for the AMD world.\n\nWe should be able to get away with no real impact, since browserify's standalone option bundles up everything into one big AMD module. So if we end up depending on a CommonJS WeakMap and \"asap\" implementation, those just get stuffed inside the main UMD closure and never exposed; the outside world ends up seeing only the `Q` export. This has a minor downside in potential code duplication if e.g. a user ends up including both Q and asap, as then they will have two copies of asap. But I don't think for our case that will matter much.\n. @kriskowal yeah, I understand that one, was more just addressing your concern about the impact of using other packages as part of Q. In terms of the upgrade headache, I think it will be that those users have to change their mappings config from\n\n```\n\"q\": \"/path/to/externals/q/q\"\n```\n\nto\n\n```\n\"q\": \"/path/to/externals/q/release/q.umd\"\n```\n\nwhich hopefully is OK for users.\n. @ForbesLindesay\n\n> It sounds like it might be best to have a custom script that takes a CommonJS module or a UMD module and adds montageRequire/SES exports?\n\nNot sure exactly what this would look like but maybe you meant something like this appended to Q?\n\n``` js\n(function () {\n  var savedQ = Q;\n  if (typeof ses === \"undefined\") {\n   delete window.Q; // i guess we need to get the global, not always use `window`.\n   ses.makeQ = function () { return savedQ; };\n  }\n  // etc.\n}());\n```\n\nCould work I guess, hmm. Not as nicely integrated into the browserify pipeline, and we'd have to find some concat-files grunt plugin for cross-platformness, but seems possible.\n. Now that GItHub has releases what do we think of having the release-maker upload the `.min.js` and `.umd.js` scripts as part of the release, instead of checking them in to source control? https://github.com/blog/1547-release-your-software\n. @ForbesLindesay what's our plan?\n. Closing in favor of #352.\n. Nope, not sure where you got that impression? We switched from put to set in 0.9.0 I believe.\n. We should probably switch the name from q.js to q while we're at it.\n\nIt looks like they do new versions via GitHub pull requests. I know @ForbesLindesay has some experience with the GitHub API---I bet he could whip something up really quickly, or at least point us in the right direction :)\n. Relevant: https://github.com/cdnjs/cdnjs/pull/1583\n. We don't believe that minified files should be in the source repository. That is, there is no such thing as an official q.min.js. If you would like those on your CDN, you will need to generate them yourself.\n. Indeed, it was introduced in 0.9.5: https://github.com/kriskowal/q/blob/master/CHANGES.md#095\n\n> (aside, it might be better to have a method to enable long stack support so I get an error if I use the wrong name)\n\nThat seems like a pretty good idea actually; @kriskowal thoughts?\n. Promises can only be fulfilled with one value, just like sync functions can only return one value. This kind of consistency guarantee is a very important part of programming with promises.\n\nIf you encounter such an ill-behaved Node method, which calls back with more than one value, Q fulfills the resulting promise with an array composed from those values. Note that if you have a promise for an array, you can use `spread` to get a slightly nicer syntax for extracting values from it. In fact, it would be very close to your second hypothetical piece of code, except it would explicitly call out the fact that your async function call \"returns\" (i.e. returns a promise that fulfills with) an array, by saying \"spread\".\n. This is an interesting idea. @kriskowal, what do you think of these semantics? Would they be desirable? I'm not sure myself... leaning toward \"no, too much magic.\"\n\nNote that the following already works with Q:\n\n``` js\n\"use strict\";\n\nvar Q = require(\"q\");\nvar domain = require(\"domain\");\n\nvar d = domain.create();\nd.on(\"error\", function (err) {\n    console.log(\"error caught\", err);\n});\n\nd.run(function () {\n    Q.nfcall(function() {\n        setTimeout(function() {\n            throw new Error(\"not catched\");\n        }, 100);\n    })\n    .then(function() {\n        console.log(\"ok\");\n    })\n    .fail(function() {\n        console.log(\"fail\");\n    });\n});\n```\n. FWIW I've really started to come around to this idea as a way of plugging a \"hole\" in the promises + Node.js love story. I was talking with @piscisaureus at NodeConf who wants to make some changes to domains to make them more robust and nice to work with, and part of his idea was vaguely promise-like, but a key part of that was this domain safety net.\n\nIt is something we may explore in a separate package or something in the future, creating super-promises augmented by domains that can wrap Node functions to make them ergonomic, `yield`able, and bulletproof against both user-derived errors (e.g. `throw`ing inside the callback) and bug-derived logic errors (e.g. double-callbacking or calling back with both an error and a result). These super-promises would likely be highly micro-optimized as well, e.g. sacrificing encapsulation and integrity in favor of prototype-based approaches or purposefully not-next-ticking when coming from a known-async operation (like https://github.com/promises-aplus/promises-spec/pull/104#issuecomment-19279854).\n\nStay tuned.\n. Yes. That is how `allSettled` works.\n- https://github.com/kriskowal/q#combination\n- https://github.com/kriskowal/q/wiki/API-Reference#promiseallsettled\n. > I\u2019m also thinking that we should not delay rejection.\n\nWatching from the side, I think I agree.\n. Please don't minify when submitting pull requests. I believe that is in the Contributing.md? (If not we should add it.)\n\nOn Jun 29, 2013, at 1:59, \"wmertens\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nI agree as well :)\n\nNew semantics, all tests pass, minified.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/326#issuecomment-20226751.\n. I kind of like it... Not sure we can make it conceptually coherent, however. I want a solid story so that `yield anything` has a straightforward meaning. The easiest meaning is that `yield anything` means `yield Q.resolve(anything)`, i.e. if it's not a promise, we just pass it through. But... so convenient...\n\nI've toyed with this before, in the context of extending `Q.all` so that it works on both objects and arrays. But, once we got that far, it feels a bit strange to special-case `Array.prototype` and `Object.prototype`. To show what I mean...\n\n``` js\nvar x = yield promiseForX;\n// it's a promise, this is our base case, it does what you expect.\n\nyield [doOneThing(), doAnother()];\n// could we make this equivalent to\nyield Q.all([doOneThing(), doAnother()])\n// ?\n\n// what about this??\nvar { one, two } = yield { one: doOneThing(), two: doAnother() };\n// if #328 is adopted and Q.all works with objects, then the translation\nvar { one, two } = yield Q.all({ one: doOneThing(), two: doAnother() });\n// does what you'd want\n\n// but what about:\nvar x = yield regExp;\n// regExp is an object, so what does Q.all do to it? When do we do Q.all vs. Q.resolve?\n```\n. I am hesitantly in favor of this approach, but @kriskowal favors #159. I can see his point, because where do we stop? What about custom class instances that aren't just derived from `Object.prototype` or `Array.prototype`? Arrays are just objects too, so why do we use special logic for them? It's a bit weird.\n\nThat said, your example could be much nicer written as\n\n``` js\nQ.all([getCost(), getTaxes(), getShipping()]).spread(function (cost, taxes, shipping) {\n});\n```\n\nassuming you had no use for the actual `results` object. Which might not be the case; @stefanpenner has mentioned how RSVP's `RSVP.hash` is pretty useful in Ember for building objects out of promises over time.\n\nAnyway, I'll let @kriskowal make the decision on whether to close this one or reconsider, but spoiler warning: I think he probably will close :P.\n. @kriskowal does this work now?\n. Any interest in `Q.hash` to match the original functionality request without overloading `all`?\n. [`Q.allProperties`](https://github.com/kriskowal/q/issues/159)?\n\nI personally am not that excited about this method (I think `spread` covers it pretty nicely) but I know other people are. Some people use it to build up an object's properties asynchronously.\n. > is there a dev switch i can flip and make it halt my app on all unhandled errors ? \n\nFWIW the idea of building a dev console that tracks all unhandled reasons has been in the back of our minds for a long time. There's something hacky in place with outputting a live array to the console, but it doesn't seem to always work (and doesn't help in Node.js). In Node.js we output all unhandled reasons to the console on exit. Finally you can always check `Q.getUnhandledReasons()`. But in the future we'd like a nicer story here.\n. -1, this just introduces a weird way of writing `then` chains which makes your code non-idiomatic.\n. I think we shouldn't gear our opening paragraph toward solving Node users' problems; it's fine to relegate that to the bottom of the readme. Promises are much bigger than Node :). That said, I can see how the juxtaposition of example code might be confusing as is. Perhaps if we changed it to\n\n``` js\nQ.fcall(promisedStep1)\n.then(promisedStep2)\n.then(promisedStep3)\n.then(promisedStep4)\n.then(function (value4) {\n    // Do something with value4\n})\n.catch(function (error) {\n    // Handle any error from all above steps\n})\n.done();\n```\n\nAnd maybe add \"where `promisedStepN` is a version of `stepN` that returns a promise\".\n\n@kriskowal, @danieldkim let me know what you think, if that sounds good I'll update the readme with it.\n. This isn't really a supported scenario. We can't determine what \"progress\" means for a promise composed from `Q.all`. For example, assume you had three promises emitting `\"33%\"`, `\"67%\"`, and `\"100%\"` progress data, but at various speeds. Then you `Q.all`ed them. The resulting promise could end up emitting a stream of progress data that looks something like `\"33%\", \"33%\", \"67%\", \"100%\", \"33%\", \"67%\", \"67%\", \"100%\", \"100%\"`, which is pretty darn WTF.\n\nOnly you know your domain well enough to say what the progress from an aggregated promise is, so we can't have `Q.all` just combine everything.\n. Nope. If you know your domain well enough to recommend aggregation, then explicitly aggregating inside your code is a good way to show it.\n\nYou can also use `Q.promise` for a different syntax, e.g.\n\n``` js\nvar aggregated = Q.promise(function (resolve, reject, notify) {\n    resolve(Q.all([promise1.progress(notify), promise2.progress(notify)]));\n});\n```\n. Hmm, well then! Sounds like a feature. Reopening!\n. @rkatic Hmm I think you're right, that's better especially in light of the promise-streams branch. I'll try to get around to fixing that.\n. I couldn't think of a way for `done` to make sense, but switched to object literals instead of arrays.\n. We should remove `allResolved`.\n. LGTM, thanks for the catch.\n. Fixed by #339. Thanks for being persistent and bugging us until this got fixed :).\n. This is very exciting. It's also more new concepts than I can reasonably judge before seeing them in practice :). So if you're happy with it, let's include it!\n\nThe only concern I have is that this seems pretty different from how I envisioned an ES6-based API, which was just as a naive iterator of promises. For example the existence of `return` and `send` confuses me; ES6 merged `send` and `next`, but doesn't even have a `return`. So I'm a bit confused. But I haven't thought about this whole thing nearly as hard as you have and am willing to trust your judgement.\n\nFinally there's the age-old question of whether this should be in the main file or in a separate module (`require(\"q/queue\")`, etc.), or even package. I'm not sure, to be honest: I like the idea of keeping the core lean, but I don't want to relegate this innovative new stuff into a place where people might not think to use them.\n. > Breaking it into a module is even more problematic since a promise is a promise for an object of _any_ type.\n\nI don't quite understand this part?\n. Probably want to move the primary implementations to the prototype, since that's our main strategy now?\n. Ah yeah, it looks like just `all` is left out. https://github.com/kriskowal/q/blob/master/q.js#L1713-L1725\n. We can probably do a release without browserifying anything, right?\n. What do we think of making `all` consistent with `allSettled`?\n. This seems great in general. Maybe I should merge in my rudimentary perf test suite, even if it's not very great, just so we can get some numbers.\n. Awesome!\n. Ignoring Q's long stack trace rewriting, what happens if you just use CoffeeScript and Browserify and then do `console.log((new Error()).stack)`?\n. Yeah it sounds like browsers just don't support source-mapped `.stack` properties yet :(. I don't think it's a Q-related problem, but rather something to take up with the browser vendors.\n\nIn the meantime people seem to be attempting to work around it in user space: https://github.com/evanw/node-source-map-support https://github.com/janekp/mapstrace etc.\n. > Regarding streams2, the readable callback may still get invoked before the promise callback, right?\n\nThat's correct; more robust code would just call `res.read()`, and only subscribing to `'readable'` if `res.read()` returns `null`.\n\nBut the main point is that the data doesn't go anywhere until you call `read()`. In streams1, since it \"pushed\" data at you in `'data'` events, if you missed that event you would lose data. In streams2, no data is ever lost, since you have to \"pull\" it with `read()`.\n. > It might make sense to include a small section in the tutorial for jQuery users though.\n\nFrom https://github.com/kriskowal/q#the-middle:\n\n> When working with promises provided by other libraries, you should convert it to a Q promise. Not all promise libraries make the same guarantees as Q and certainly don\u2019t provide all of the same methods. Most libraries only provide a partially functional then method. This thankfully is all we need to turn them into vibrant Q promises.\n> \n> ``` js\n> return Q($.ajax(...))\n> .then(function () {\n> });\n> ```\n. > It can be confusing for new programmers looking into promises, what exactly promiseMeSomething() is.\n\nI guess the issue here is that we leave creating promises for later in the tutorial. I think that's still the right approach, but perhaps we could clarify in prose something like \"`promiseMeSomething()` is a function that returns a promise; we'll get to how to create such functions later.\" Or maybe just add an introductory sentence or two at the start of the tutorial saying something like \"we'll first explore how to consume promises given to you, then move on to how to construct your own.\"\n. I added a paragraph saying that we'll explain how to create promises later in the document. Hopefully that helps. I don't think suddenly introducing promise creation, with an unexplained `promiseMeSomething` implementation, is quite the right approach. But thanks so much for pointing this out to us! Let us know if you think it's still unclear or if there's anything else we can do.\n. Gah, nice catch! Why is this such an easy mistake for us to make... Seems like every all/allSettled implementation I've seen for any promise library always has this bugfix in their commit history.\n\nPull request welcome if you want all the fame and glory for yourself. Should be a pretty quick one :). Otherwise we will fix it ASAP.\n\n@kriskowal I'm feeling another 0.9 point release coming on...\n. I can't reproduce this on the latest master; it was probably fixed as part of some architectural changes that have been going on. In any case, I added a test so we can be sure it doesn't happen again.\n. Seems like a really good idea overall. I'm assuming that keeping writing capabilities to yourself, and vending reading capabilities, will be much less common with queues than it is with promises. (Otherwise I imagine we'd move more toward a deferred-style interface, where the reading capabilities are only exposed on the iterator, not on the queue itself.)\n. I wonder about the naming; `get` seems to me to be too much of a false parallel with `Promise.prototype.get`. Alternate pairings, just as a possibility:\n- enqueue and dequeue\n- push and pull\n- unshift and pop\n- push and shift\n- yield and next (so e.g. `queue.yield(x)` would call `queueGenerator.yield({ value: x, index: 0 })`)\n. @kriskowal probably another candidate for backporting to a 0.9 branch, along with #345.\n. Well, if we don't need q.montage.js and q.ses.js, then that makes things easy. We can just do q.umd.js with Browserify's built-in support. (See also https://github.com/ForbesLindesay/umd/pull/5.)\n\nI don't think we get free S3. It's pretty cheap though? Maybe there's something else that does this kind of hosting free? But anyway, Travis has the ability to use encrypted data to perform stuff ([docs](http://about.travis-ci.org/docs/user/encryption-keys/)). The two-second version, from what I understand, is that you run some stuff on your computer that takes confidential stuff like S3, then it spits out some encrypted gibberish you put in the .travis.yml, and then the decrypted stuff will be available as environment variables.\n\nNot sure exactly what you mean by keeping it simple to fork the project infrastructure, but hopefully the above helps answer that?\n. @stefanpenner @fivetanley how do you guys deal with S3 costs for Ember/what do they approximately end up being?\n. Sounds reasonable. A bit more work (will need to browserify an intermediate module that does `global.Q = require(\"./q\");` for the global version, and will need to use the RequireJS optimizer's CJS -> AMD mode for the AMD-only version).\n\nI think it's a bit confusing to call the `<script>` version simply \"q.js\". I'd prefer \"q.global.js\".\n\nYay for S3! I'll give it a try on domenic/q (since presumably Travis won't let me encrypt things as if I were kriskowal). If it works out hopefully you'll just run something to generate some encrypted API keys and we can be good to go.\n. +1 for killing the .min.js's.\n\nI'm agnostic to giving our users both CommonJS and UMD options vs. giving them CommonJS, global, and AMD separately.\n. OK guys, check out https://github.com/kriskowal/q/compare/from-commonjs. S3 is up next if you're happy with this.\n\n@kriskowal, let me know if the output and input look good.\n\n@jrburke, let me know if there's a way to configure the RequireJS optimizer to not make q.amd.js a named module.\n. @jrburke I was hoping to not have to write a custom tool to do cross-platform prefixing of `define(function (require, exports, module) {` and suffixing of `});`. Indeed, I was hoping that the RequireJS optimizer's `cjsTranslate` option was exactly that.\n\nIt sounds like I was not on the right track there, though. Do you know of any such tool?\n. We might also, at some point, want to use multiple modules within the `q` package itself, even if those modules do not deserve to be separate packages. For example I've always envisioned putting the promise-for-object methods in one file, promise-for-array in another, etc.\n\nFor simplicity's sake let's consider the following scenario, with regard to the CommonJS source files:\n\n```\nq.js (contains `require(\"./q-extras\")` and `require(\"asap\")`)\nq-extras.js\nnode_modules/\n  asap/asap.js\n```\n\nI wonder if the AMD deliverables should then be simply `q.amd.js` and `asap.amd.js`, or whether they should be `amd/q.js` and `amd/q-extras.js` for Q, and `amd/asap.js`? (I switched from `.amd.js` to `amd/` prefix because `require(\"./q-extras\")` wouldn't work for `q-extras.amd.js`.)\n. Right, \"and `amd/asap.js`\" should have been \"and `amd/asap.js` for ASAP.\"\n. @jrburke ahah, that was it! I knew I'd done this before successfully, and it was the command line switch that did it. Might not work so well since Q doesn't isolate its .js files under a `lib/` directory, but your next trick should be enough. \n. I made some things and now it is nicer: https://github.com/kriskowal/q/commit/515eea1cf63215acd0785e0a3ee9fdbe7400d149\n. @kriskowal I think it's probably ready to go if we leave S3 for later. Not entirely sure though, it's been a few days. I'll try to do the following tonight or tomorrow night:\n1. Make sure it's good to go besides S3/volo (i.e. I didn't forget anything).\n2. Get the Volo stuff in there\n3. Hook up S3\n\nPresumably 1 and 2 are easy and if I manage to do those but don't find enough time for 3, then we'll still be OK.\n. TADA!\n\nhttp://q-releases.s3-website-us-west-1.amazonaws.com/q.js etc.\n\nvia https://travis-ci.org/kriskowal/q/jobs/10262956#L1068\n. @jrburke how does e69e08b190ac5d9cf1f6f9ddc2bba87b0d479786 look?\n. Yeah, I think I'm going to have to do something smart and upload versioned releases (not sure exactly how; detecting if the current push is tagged or something?).\n\nBut once we do that it's not so bad; volo supports `{version}` in the URL string.\n. volo is also tied to GitHub I believe so we can't host the package.json elsewhere.\n. Implemented!\n. Yeah, unfortunately there's not really anything we can do here. If you want those parameters you'll have to do the wrapping yourself; Q can only absorb one parameter.\n\nExample code would be:\n\n``` js\nfunction withAllParams(jQueryPromise) {\n    var deferred = Q.defer();\n    jQueryPromise.then(\n        function () {\n            deferred.resolve(arguments);\n        },\n        function () {\n            deferred.reject(arguments);\n        }\n    );\n\n    return deferred.promise;\n}\n```\n\nMy preference is to create methods that wrap `$.ajax`'s semantics more correctly, e.g. as in https://github.com/domenic/client-side-packages-demo/blob/e60197d8e331dd5a1716af12d657f42f7c7336ff/lib/github.js#L7-L33\n. I believe (@kriskowal can confirm) that we have transitioned away from safety and toward speed in this instance, in #181.\n. We're still vulnerable to modifications to `Function.prototype.apply`, but, moving that line out was probably a good idea anyway.\n. LGTM\n. Yeah, promises can only be fulfilled with one value, just like functions can only return one value. If you need multiple values, you should use an array.\n. I could swear this worked until recently; I thought util.inspect recursed on itself.\n. Ah, this is fixed in Node 0.11, but the fix was not back-ported to 0.10: https://github.com/joyent/node/commit/66280de133a56964641a08291b06fc0e5ca2b4e1\n. Look closer at your code. The moment you call `qecho(4)`, it generates a random timeout, then uses `setTimeout` to schedule a `console.error` some milliseconds in the future. Since you call `qecho(2)`, `qecho(3)`, `qecho(4)`, and `qecho(5)` all at once, not waiting until the `then` calls you back, all these timeouts will be scheduled at once.\n\nAlso, doing `.then(qecho(4))` will be equivalent to passing `.then` a promise, since that's what `qecho(4)` returns. That doesn't work; only passing functions works.\n. Q 0.9.7 was released a while ago and should work great.\n. +1\n. Do you want to merge this ahead of the from-commonjs stuff?\n. Merged as f7a75056188321cfb7b079ec571164338aa506a5.\n. Seems good. Loses a little bit of information by coercing all reasons to strings, and makes the method name slightly inaccurate, but since the method is for debugging purposes it's definitely a win in terms of functionality.\n. I am ambivalent. That sounds better in theory, but in practice it hopefully never matters, and might bloat the API or make it more complicated to use. I guess it depends how nice the alternate solution would be. We probably _can_ figure out something nice, I suppose :).\n. Wow it looks like you did all the hard stuff. The further work sounds pretty easy to me :D.\n\nOvertaxed with real-life events, finishing off vm2, and some Promises/A+ and JSIDL stuff this week, but I am definitely down for finishing this up on the weekend.\n. Hmm, on my computer `headHash` ends up containing `ref: refs/heads/from-commonjs-release`. I guess it's probable that on Travis they'll check out specific commits and it'll contain a hash. Would be nice to be able to run releases locally though.\n\nWe could make it work by checking to see if it's in the form `ref: ...` and then reading the `...` path. Not sure.\n\nPushing a combined branch with my original stuff + your stuff + some stuff on top of it to this PR. (EDIT: well, that push didn't work, at least from GitHub's perspecive because it still wants to put it on top of from-commonjs.)\n. Verified, it does work on Travis: https://travis-ci.org/kriskowal/q/jobs/10962943#L1086\n. If only Node had `execSync`, this would all be a lot easier. Coming in 0.12, but still.\n. @stefanpenner @fivetanley how do you guys make the pretty page at http://builds.emberjs.com/\n. @kriskowal made this listing page, should be nicer http://q-releases.s3-website-us-west-1.amazonaws.com/\n. @kriskowal a few questions:\n- Do you think we should produce minified versions of all the AMD files? I am thinking probably not, since people will use e.g. the RequireJS optimizer to minify and concat. We can just produce minified q.js.\n- Should we set headers to text/plain to discourage hotlinking, like raw.github.com does?\n- Any thoughts on directory structure, e.g. maybe `commits/{sha}`, `versions/{version}`, `latest/*`, etc.?\n. This has been merged, w00t.\n. See also https://github.com/promises-aplus/promises-spec/issues/128, wherein a few implementers have shared their work on this. It appears to be largely painless.\n. So it sounds like on Node 0.11.x there's a bug in `inspect`? Seems like not our problem.\n. Sounds like this was not a bug in Q. Feel free to open a Node 0.11.x bug, if someone confirms that this is the problem.\n. I dislike exposing accepted as a state. Unfortunately I am not sure I know of a way around it. Perhaps inspect() could trigger the unwrapping process? But no, access to untrusted \"then\" methods must be done in a fresh stack, so that would never be useful. Sigh. It definitely complicates the pedagogical story.\n. lol!\n\nThe memoization plan makes sense to me, as does the analogy :). Sigh, now to spec all this...\n. BTW @kriskowal would love your feedback on https://github.com/domenic/promises-unwrapping, which tries to capture this late-unwrapping shift. It still needs memoization work though.\n. Have you actually tested those two code samples? The first works; the second does not.\n. Right, if there is a badly-behaved node API that sends more than one non-error parameter, we wrap that up in an array. I suppose that should be noted. Most Node APIs do not do this, though.\n. You can make your code slightly shorter with `spread`:\n\n``` js\nreturn Q.nfcall(request.get, opts).spread(function(res) {\n    if (res.statusCode === 200) {\n        // etc ...\n```\n. Nah, let's leave it open to track the desired documentation note about badly-behaved APIs.\n. Turns out we already have that note in the API reference:\n\n> Note that if a Node.js-style API calls back with more than one non-error\n> parameter (e.g. [`child_process.execFile`][cpef]), Q packages these into an\n> array as the promise's fulfillment value when doing the translation.\n. @kriskowal have you seen https://github.com/kriskowal/q/wiki/General-Promise-Resources ? :)\n. This has been considered and rejected in the past. For me the most compelling argument is the slippery-slope one. What about `Error` instances which have properties which are promises? What about arbitrarily-nested prototype chains with promises as properties at each level of the chain? What about arrays with non-numeric properties that are promises? What about if someone adds a promise property to `Number.prototype` and then does `Q.all(5)`? Why are arrays treated specially, since they are just objects too? ETc.\n\nYou can find more discussion in previous issues on the subject: #159, #171, #328.\n. I am surprised this would occur with http.get, but maybe try doing `http.get.bind(http)` before passing it in?\n\nA small piece of code illustrating this failure would be helpful for us to debug.\n. Ah! Yes, of course. `http.get` is one of the unfortunate functions in Node whose callback doesn't follow the standard `(err, value)` form, but instead just passes you `(value)`. Q can't automatically adapt those :(.\n. BTW you may enjoy this version of your code that I put together for testing. It uses [pipe](http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options) to get much better flow control (e.g. the TCP socket will slow down reads if the FS is slow), and ensures all errors are handled (since there is no error parameter you can rely on).\n\nIt's also a good example of a small self-contained file that you can use when reporting bugs on peoples' projects :).\n\n``` js\n'use strict';\n\nvar Q = require('q');\nvar http = require('http');\nvar fs = require('fs');\n\nfunction httpQ(opts) {\n    var deferred = Q.defer();\n    http.get(opts, deferred.resolve);\n    return deferred.promise;\n}\n\nhttpQ('http://www.sachinbhatnagar.com').then(function (response) {\n    var writeStream = fs.createWriteStream('./newoutfile.txt', { encoding: 'utf-8' });\n    response.pipe(writeStream);\n\n    response.on('error', function (err) {\n        console.log('There was an error reading');\n    });\n\n    writeStream.on('error', function (err) {\n        console.log('There was an error writing');\n    });\n\n    writeStream.on('finish', function () {\n        console.log('JOB DONE!');\n    });\n}).done();\n```\n. > Hey thanks Domenic. The code i pasted here was a part of a bigger script, so I posted only what was causing issues. \n\nRight, but when asking for help, it's considered polite to spend the extra time to create a self-contained example that the maintainers can run on their own, instead of forcing them to do so themselves.\n\n> So, for functions which do not follow the standard node style callback, the way out would be to use the Q.defer() method ? Is that correct ?\n\nYeah, that's it! Kind of sad, but when Node is inconsistent with itself, what can we do?\n. That wouldn't really work very well with the nature of promises; for example:\n\n``` js\ndoXHR(url)\n  .then(JSON.parse)\n  .then(function (parsed) { console.log(parsed); }, function (err) { console.error(err); });\n```\n\nLet's say `doXHR(url)` returns a rejected promise. We omitted an error handler from the next step, `.then(JSON.parse)`, so your default error handler kicks in and it does `.then(JSON.parse, defaultErrorHandler)` instead. But now, since your default error handler got in the way, the promise is no longer rejected---you intercepted the error, after all---and the `console.error(err)` never happens!\n\nIn short, chaining is the appropriate way to deal with this. Put your shared code in a function, call it `defaultErrorHandler`, and then at the end of your chain, do `.catch(defaultErrorHandler)`. Note that you only need to do it at the end of the chain!\n. OK cool! Yeah, ideally promise-based programs are chains all the way up. The only reason to start a new chain is if some outside source (usually an event source, like a click or a incoming connection) starts up a new call stack, and you need to do some new async stuff there in that context.\n. Merged as 188f4cdce3a60aa530b4a10f2d32cc8648a30593.\n. Done. Please everyone feel free to add more. https://github.com/kriskowal/q/wiki/General-Promise-Resources\n. Whoops, accidentally merged this while trying to merge #379 :(. Um, @kriskowal, please look it over so I feel less bad.\n. >  'function(...){console.log(...)}' is the same as 'console.log'\n\nThis is actually not true unless `console.log` is bound to `console` which is only the case in Firefox (EDIT: and, as Kris says, in Node).\n. What version of Q? Also maybe upgrade the Node version to 0.11.7.\n. Node 0.11.2 does not support generators correctly. Upgrade to 0.11.7.\n. You are ignoring the promise returned from the function you immediately invoke. You should either call .done() on it, or use Q.spawn, which was made for exactly this use case. Q.spawn(...) <-> Q.async(...)().done()\n. You can't pass a promise to `.then`; you have to pass functions.\n\nYou may be interested in `.thenResolve`.\n. Thank you! Merged as 0b4aa3f1c267e2d75220334375123e47a14530c3 with some minor tweaks.\n. This is strictly more useful than what we have now, I suppose.\n\nI would prefer that we do what ECMAScript does, i.e. `return value[name] = rhs` and `return delete value[name]`, but I admit those return values are not very useful and that returning `value` would be more useful.\n\n@kriskowal, thoughts? I know we've changed this a few times already in various directions.\n. Right, I knew there was a good reason... should have looked back through old issues.\n. We're definitely going to need to split the API reference page into v1 and v2. Probably keep the existing page as one containing links to the two sub-pages so as not to break links.\n. LGTM, maybe get rid of the merge commit. Exciting times!!\n. Are we OK with including Q meaning that you automatically modify the user's environment to have a full ES5 shim? I wonder if we'd prefer a shims.js module inside the Q package.\n. Note that personally, I have no problem doing the modification, as I think everyone's entitled to some good old ES5, and should be using es5-shim anyway. But then again, maybe the correct thing to do would be to just start using the shimmable subset of ES5, and say that having set up es5-shim yourself is a prerequisite for using Q in older browsers. That way it's in the user's hands.\n. That actually isn't a problem, as it just looks things up in the internal map. The reason it happens is that we write the intermediate file to `os.tmpDir()`, instead of to the project directory, so as to avoid breaking watch workflows. (See https://github.com/domenic/global-wrap/commit/b421a2d2ee78280ba4022537018274a58b7d3a8f.) It makes the generated code a bit weird, but does not impact functionality.\n. weak-map is ES5 only, right?\n. This seems very nice. I am excited.\n. > I think we should consider the shift anyway.\n\nI agree. Although I might consider something less sophisticated but with similar properties, e.g. [this approach](http://cwestblog.com/2011/05/04/private-variables-in-javascript/).\n. Weak map also allows us to maintain a [thenable coercions weak map](https://github.com/domenic/promises-unwrapping#the-thenablecoercions-weak-map).\n. Right, I suppose it'd be pretty easy to intercept the \"key\" in that linked example by just shadowing `_` on a given person instance. I see what you mean.\n. I wonder how `postMessage` fares...\n\nI actually have an IE10 mobile device, so I can help test this! After I do the other billion things on my to-do list for the weekend...\n. [Or is there...](https://github.com/NobleJS/setImmediate/blob/master/setImmediate.js#L161-L179)\n. They're not part of the API, so this doesn't really make any sense to me...\n. This will not work, because q.js is CommonJS and not browser-consumable.\n\nThe correct thing to do is to run `npm run test-browser` to run the browser tests; this will put a built q.js in the release directory.\n. Don't use the complete handler; just convert the jQuery promise to a Q promise using the Q function as soon as possible and then you can manipulate it like normal.\n. Right, you will get the first argument (data). If you need `xhr` you should save it in a variable then refer to it inside the handler.\n. I am -1; I find chaining interfaces unintuitive and confusing. ([Command-query separation](http://en.wikipedia.org/wiki/Command-query_separation) and all that.) Up to @kriskowal though.\n. `any` is not a great name, because you would expect it to be the dual of `all` (i.e., the \"there exists\" to `all`'s \"for all\"), and the semantics of `all` are \"if all fulfill.\" Thus `any` would be expected to be \"if any fulfill,\" not \"if any settle.\"\n\nIf anything, `race` could be (re)named `anySettled`, and we could add a new \"any\", giving a total of four operations: all, allSettled, any, anySettled.\n. This looks absolutely lovely. I wonder about adding a `npm run test-browser` script that does something like `opener http://localhost:1234/ && ecstatic spec/ --port 1234`.\n. This is working as intended, sorry to say. I'll try to explain here what the situation is; hopefully you'll see that it cannot be any other way.\n\nWhen you resolve a promise to another promise, it must follow the behavior of that promise exactly; they must be indistinguishable to any other code. For example, once `deferred.promise` is resolved to `p`, `deferred.promise` and `p` must be indistinguishable. Part of this is making `deferred.resolve` and `deferred.reject` into no-ops, but that must also be the case for `deferred.notify`, as otherwise part of `deferred.promise`'s behavior would come from `deferred.notify`, and the rest would be controlled by `p`.\n\nThis perhaps becomes clearer if you set up a situation where `p` has progress notifications as well. Then, when you resolve `deferred.promise` to `p`, you would want `deferred.promise` to give off the same progress notifications as `p` does. After all, they now represent the same asynchronous operation. But that means we can't have `deferred.notify` interfering with `deferred.promise` any more, just like we can't have `deferred.reject` interfering with `deferred.promise`; the responsibility for fulfillment, rejection, or notification now lies with `p` (or perhaps with any promise that `p` gets resolved to).\n\nMake sense? Closing as working-as-intended, but feel free to continue discussion.\n. Q.all only takes one argument; why are you passing it two?\n\nOn 16 Oct 2013, at 06:28, \"Ludwig Magnusson\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nI have two promises, each of an array. I want to use Q.all on these two promises so that I can work on both arrays when both promises are resolved. However, I can't seem to get hold of the second array. Below is a model of my code.\n\nvar Q = require('q'),\n    promise1 = Q([1,2,3]),\n    promise2 = Q([4,5,6]),\n    promise = Q.all(promise1, promise2);\n\npromise.then(function(val) {\n    //val is [1,2,3]\n});\n\npromise.spread(function(first, second){\n  //first is 1\n  //second is 2\n  //arguments contains 1, 2 and 3\n});\n\nIs this a bug?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/410.\n. Yes, Q.fapply.\n\nOn 16 Oct 2013, at 18:34, \"Rafael Kaufmann\" <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nIn order to be able to use a consistent .then().fail()-based structure in my code, I've found myself having to introduce the following wrapper for promisifying synchronous functions:\n\nfunction applyDeferred(f, params) {\n    var deferred = Q.defer();\n\n```\ntry {\n    var result = f.apply(this, params);\n    deferred.resolve(result);\n} catch (e) {\n    deferred.reject(e);\n}\n\nreturn deferred.promise;\n```\n\n}\n\nIs there a Q built-in helper that already performs this?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/411.\n. Looks great, maybe add that one more sentence and then ship it.\n. Q cannot catch this error, as it is not happening inside Q, but inside MongoDB.\n\nThat line does not throw the error; that line creates an event emitter, and fails to attach an error handler to it, so later, when the error occurs inside MongoDB, the error gets thrown there.\n\nYou can verify this by wrapping that line in a `try`/`catch`; the `catch` clause will never be called.\n. Hah! This is an unintended consequence of us originally overriding valueOf() for our own inspection purposes, and then later deprecating it. We forgot that valueOf() is used when converting an object to a string (or number).\n. Yes, there's not really anything we can do; this is a GitHub bug. https://github.com/isaacs/github/issues/45\n. :shipit: \n. `onFulfilled` and `onRejected` handlers must be handlers, i.e. functions. You cannot pass a promise, or any other object, as a handler; it will be ignored.\n. It's probable that your browser or IDE is not displaying the value of `exception.stack`, but instead some kind of internal, hidden stack value that is not user-modifiable. Unfortunately there's nothing Q can do about modifying that one...\n. A rejection can be anything, just like a thrown exception can be anything.\n\nAnd just like a thrown exception should always be `instanceof Error` unless you hate kittens, a rejection should always be `instanceof Error` as well.\n\nBut, it's not part of the promise library protocol to babysit users and convert their non-`Error`s into `Error`s. So, think of the kittens, and only ever reject with `Error`s.\n. :) The formatting trick is kind of nice. But then, `deferred.reject(formatString, arg1, arg2, ...)` is not that much better than `function f(formatString, args...) { ... }; deferred.reject(f(formatString, arg1, arg2))`. That is, you can make your own `Error`-from-format-string creator function.\n. Yeah, Q is pretty closure-based (at least for now), so it's not possible to change that at the moment. In the future it probably will be. (Maybe even in master, haven't checked...)\n. You are looking for [`nodeify`](https://github.com/kriskowal/q/wiki/API-Reference#wiki-promisenodeifycallback).\n. Oh, I am sorry, I did not read closely enough. You are already aware of nodeify.\n\nThere is no such method in Q already. Your \"wrap\" might be a good package to publish for others with this need. The trick would be coming up with a nice name...\n. IMO it's really best as a third-party module, as Q already provides the relevant tools here and this is just sugar for people who prefer a different style of writing their callback-allowing functions. But @kriskowal might disagree.\n. That information is in the URL though.\n. FWIW @kriskowal I am -1 on this (metadata doesn't belong in source files; people should maintain it externally). But not terribly strongly.\n\nRelatedly I'd prefer keeping the license block in LICENSE, not the source file.\n. To be explicit: `then` takes as its argument a function. You are passing it a promise, which is no good.\n. Well, @kriskowal's strategy should work. Here are a few other ideas.\n\n``` js\nwaitp(1000)\n  .then(function () { return waitp(500); })\n  .then(function () { return waitp(1000); })\n  .then(function () { return waitp(200); })\n  .done(function () {\n    console.log('ok')\n  });\n```\n\nor\n\n``` js\nfunction makeWaiterFunction(time) {\n  return function () {\n    return waitp(time);\n  };\n}\n\nwaitp(1000)\n  .then(makeWaiterFunction(500))\n  .then(makeWaiterFunction(1000))\n  .then(makeWaiterFunction(200))\n  .done(function () {\n    console.log('ok')\n  });\n```\n\nand in all cases you can of course replace `waitp` with `Q.delay`.\n. [You may be interested in `thenResolve`](https://github.com/kriskowal/q/wiki/API-Reference#promisethenresolvevalue). It wouldn't quite do what you want, since the delay would start the moment you call `setTimeout` (which is the same moment you call `waitp(...)`), but maybe for other cases it's what you'd want.\n. We already have this feature! It's called [nodeify](https://github.com/kriskowal/q/wiki/API-Reference#promisenodeifycallback).\n\nWill close the ticket for now, but feel free to ask further questions.\n. In general I find many of the changes and deprecations made in master to be a step backward in usability, but I have not had time to make my case to @kriskowal yet :(\n. To give an idea of my thoughts: I agree with most of what you say, Kris; there are indeed lots of subtleties and you've pretty much laid them all out.\n\nI am sympathetic to `call` + `invoke` as the fundamentals, which in an ES6 world would need nothing else. `apply` and `applyInvoke`/`invokeApply` as the spread variants is one idea I had. This would work especially well if `Q` did not have any of these methods so we could ignore `fcall`/`fapply`.\n\nBut the remaining wrinkle is Node support. I use `ninvoke` extensively. I am sad to see most of the Node support move out of Q proper, and I need to look into the plan there and comment more in depth. This somewhat informs the discussion.\n\nIn the end, the understandability of `call` + `apply`, plus single-letter prefixes of `f`, `m`, and `n`, is pretty nice. It is hard to beat and I am not sure aligning with ES6 abstract operation names is enough of a win to outweigh it. And it allows us to keep the static <-> method parallel, which I have always found to be one of Q's most attractive and useful features.\n. I am sympathetic to how nice this is, but am not a big fan of overloaded behavior in general. Converting whatever is `yield`ed to a promise seems conceptually cleaner to me.\n\nOne thing that seems apparent from how much people want this feature is that it would be worthwhile doing in ES7-timeframe `await` work, e.g. maybe\n\n``` js\nawait all [asyncOp1(), asyncOp2(), asyncOp3()];\n```\n\n/cc @erights @lukehoban\n. > In such cases you can explicitly just .cast.\n\nThis seems pretty reasonable to me, especially given that in Q `.cast` is so short, i.e.\n\n``` js\nyield Q(maybePromise);\n```\n\nIt's still weird IMO to have that much magic packed into the type of the argument. I.e., you can yield two things, promises and arrays, and if it's arrays, we do this parallel thing...\n. It's interesting that\n\n``` js\nyield Q.all([promiseA, promiseB, promiseC]);\n```\n\nis equivalent to\n\n``` js\n[yield promiseA, yield promiseB, yield promiseC];\n```\n\nbut unfortunately\n\n``` js\nyield Q.all([asyncOp1(), asyncOp2(), asyncOp3()]);\n```\n\nis _not_ equivalent to\n\n``` js\n[yield asyncOp1(), yield asyncOp2(), yield asyncOp3()];\n```\n. I think it should be renamed `Q.then` personally :)\n. Q is currently running the Promises/A+ 1.0 tests; it is not up to Promises/A+ 1.1 yet. Thus it's a bit premature to upgrade the adapter to 1.1 format. Also, if this were done, we should upgrade the test version in package.json's devDependencies.\n\nLet's close this and open a new issue to upgrade to 1.1.\n. Q is Promises/A+ 1.0 compliant, but not 1.1.\n. I do not think @kriskowal's `thenCall` is the same as @bluepnume's.\n\n@bluepnume: I think you would be best off using standard JavaScript practices:\n\n``` js\nreturn promise.then(myFunction.bind(args...))\n```\n\n@kriskowal: outside of message passing use cases, I could imagine `thenInvoke` being nice sometimes. I'll keep an eye out for potential uses.\n. No, we have this right. It's next, not send. OP must be using an outdated version of node.\n. Yes,  that page itself says that it's outdated at the top of it.\n\nI am not sure which Node version made the switch.\n. I am -1. I think deferreds are an anti-pattern and Q should move away from them in favor of the Promise constructor. I definitely think they should never be part of a module's public API. People should not be manipulating deferreds; they should be doing async operations and handing out promises. Deferreds are not first-class, and should not have an API that parallels that of promises.\n. Can you write some synchronous try/catch code that illustrates what you're envisioning? Remember that promises parallel synchronous control flow constructs.\n. There are a few issues about this not working correctly. It seems browser consoles no longer do live array updates like they used to. We've since removed the feature from Q and are working toward building a separate unhandled rejection tracker as a browser extension.\n. The entire point of the live-ness of the unhandled reasons array is that once reasons become handled, you should not see them in the console.\n. @kriskowal I feel there is still a decent bit of use to it. Perhaps a minimal interface like:\n\n``` js\nQ.onPossiblyUnhandledRejection(function (reason) { ... })\nQ.onRejectionHandled(function (reason) { ... })\n```\n\nWe could rip it out of v2 for now though and consider adding those back later.\n. Don't do it Kris!!\n\nWhat problems did Mocha give you?\n\nThe split into multiple files, and the switch to Istanbul, seem good and worthwhile.\n\nhttps://npmjs.org/package/lab might be a smaller alternative to Mocha.\n. LGTM :D\n. Oh right, I forgot about the thenable issue :-S. I guess we can close this then. Kind of unappealing but not a big deal.\n. fs.exists does not follow standard node callback conventions, so it won't work with denodeify. Use fs.stat instead, or better yet, just do the operation you're trying to do and handle an ENOENT error.\n. Pretty good interim hack. The lack of accurate .constructor is a bit sad but no big deal. +1\n. If the \"leak\" persists across reloading the page, then this is a bug with Chrome, not with any particular JS script.\n. As I said, it is impossible for a library to cause memory to persist across page reloads, since JavaScript does not have that ability---only C++ does. If this is occurring, then it is a bug in Chrome. I would suggest filing it on http://crbug.com/.\n. Q is not designed for your requirements, and I suggest you write your own version of nodeify.\n. Because otherwise any errors thrown in the callback would be caught and transformed into rejected promises, which would be unexpected.\n. I think TypeScript-specific functionality does not belong in a JS library. A separate q-with-typescript-helpers package would make more sense there.\n. For that you should just use `Q.async`, as Petka pointed out.\n. >  I find the syntax a bit too much prone to error, I'll stick to return the promise itself.\n\nHave you used `try`/`catch` before? If so it should be pretty familiar.\n. Nobody can break your chain in another part of the code. If you have a promise and don't give it to anyone else, nobody else can cause it to fulfill or reject. They can cause the promise _returned_ from _their_ `then` call to fulfill or reject, but that's _their_ code, not yours---and in their code, they need to understand `try`/`catch` to use promises.\n. @kriskowal I think we should explicitly say in the readme that bower is not supported.\n. > The first problem is that Q is already registered with bower (as far as I can tell, by @kriskowal)\n\nNope, that was some independent third-party. You should contact them.\n\n> Also, keep in mind that q was supported in bower previously (prior to version 2) \n\nThis is not true; our policy has not changed.\n. What if your catch code throws an error?\n. The existing code is correct; the change proposed here is incorrect.\n. `then` can only be passed functions that accept arguments, since `promise.then(f)` passes the fulfillment value of `promise` to `f`. Thus `Q().then(f)`, aka `Q(undefined).then(f)`, will pass `undefined` to `f`.\n\nIf you modify your test case to `Q(5).then(Q.nfbind(test))....` you can see the problem more clearly. In that case your proposed solution would throw away the `5` value, which is not acceptable.\n. Dupe of #502. Bower is not directly supported by Q, which targets npm. You're welcome to maintain a fork that is compatible with whatever bower's requirements are; they seem to involve distasteful practices like checking in bundled versions to a source control repository, which we won't be doing. But yes, as in #502, if there are documentation tweaks you would suggest, feel free.\n. Does https://github.com/kriskowal/q/wiki/API-Reference#error-handling-and-tracking meet your needs?\n. I was responding in particular to\n\n> I think this could work by manually calling a function to log all unterminated promises, or calling it every few seconds.\n\nWhich seems like something we already provide.\n. Ah, I see. So this isn't about .then vs. .done. It's about promises who nobody is listening to the results of (for now).\n\nI guess we could add such a thing, but it seems best to just push ahead on the promise-debugger idea. If you've seen Ember's promise debugger, it has this functionality and more.\n. What command did you use to install? What version of npm are you using? `npm install q` with npm 1.4.7 works fine for me.\n. The correct way to think of this is that rejections and throws are exactly the same, and distinguishing between them is not possible.\n\nSo for example, you should solve the problem of distinguishing between \"operation failed to complete\" and \"bad JSON\" the same as you would with sync exceptions. A function could throw either of those (synchronously); if you put a try-catch around that function, what would you do within the catch to distinguish?\n\nWhatever your answer is to that question, about sync exceptions, should be the same as your answer for async exceptions, aka rejections.\n\n---\n\nFrom: Adam Zielinskimailto:notifications@github.com\nSent: \u00fd2014-\u00fd05-\u00fd28 19:43\nTo: kriskowal/qmailto:q@noreply.github.com\nCc: Domenic Denicolamailto:domenic@domenicdenicola.com\nSubject: Re: [q] Why isn't Q.onerror called for promises without explicit error handlers? (#529)\n\nActually I still have one more concern. catch callback is called when any Error is thrown\nLet's assume:\n-   I am either deliberately using throw new Error() or expect an error from a library call like JSON.parse as in your example\n-   I want to do something when promise is rejected so I define a catch callback.\n-   I want to know if there was a runtime Error I didn't expect, perhaps from an invalid function call, or type mismatch, or accessing a property on undefined object - just usual stugg\n\nDo I have to specifically whitelist all expected errors in my catch function and act if rejection reason is not known, or is there some generic way of dealing with that?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/529#issuecomment-44478705.\n. We should switch to only using MutationObserver or setTimeout in browsers, I think.\n. This is good motivation for me to dive back in to Q's code and fix a few outstanding stack-related bugs. I'm at JSConf this week and on vacation in Japan the next one, but I am moving this up to near the top of my queue.\n. Thank you for the really thoughtful critique. We should definitely take it to heart.\n\nQ is a bit of a special case because a large part of its target audience is people who know about promises in some fashion already, or at least have been told that promises are a solution to their callback woes. But I think there is a definite potential for shifting toward beginners.\n. Thanks to everyone in this thread for the kind and encouraging words :). They are awesome.\n\n> and for some reason was intrigued enough by the README to jump over and take a look at the documentation. And I that is what sold me on the idea in about 30 seconds flat. \n\nTo clarify, when you say \"documentation\" are you talking about the README, or the [API reference](https://github.com/kriskowal/q/wiki/API-Reference)? You kind of make it sound like the readme and the documentation are different, which has me a bit confused.\n. You should use `.thenResolve` instead of `.then`. Argument overloading is the root of much evil.\n. > In your words, if a function which returns a promise to someone else, it is OK to call done() to terminate \n\nNo, that is the opposite of what the golden rule states. It states _either_ return it to someone else _or_ call .done() on it, not both.\n. > not one that bring promises.\n\n+1; this will be a dealbreaker for using Q in many shops.\n\nAre we using more of collections than is provided by the WeakMap shim?\n. allSettled is definitely not meant to be a drop-in replacement for all.\n. .then takes functions, not promises\n\n---\n\nFrom: Matthewmailto:notifications@github.com\nSent: \u00fd2014-\u00fd07-\u00fd20 19:49\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] Derived Promises don't propagate reject correctly (#557)\n\nGivent the following snippet\n\nq = require('q');\n\nvar deferredA = q.defer();\nvar promiseA = deferredA.promise;\n\nvar derivedPromiseA = promiseA.then(function() {\n  var equation = 1+1;\n  throw 'fuuuuuuuuuuuuuu';\n});\n\npromiseA\n  .then( derivedPromiseA )\n  .then(function onSuccess() {\n    console.log(\"Unexpected :(\");\n  })\n  .fail(function onFail() {\n    console.log(\"Expected state\");\n  })\n;\n\ndeferredA.resolve('go');\n\nWhat actually happens is it prints \"Unexpected :(\"\n\nConversely, if you run\n\nderivedPromiseA\n  .then(function onSuccess() {\n    console.log(\"Unexpected :(\");\n  })\n  .fail(function onFail() {\n    console.log(\"Expected state\");\n  })\n;\n\nThis prints \"Expected State\"\n\nThe use case for having a longer chain is that you can get explicit dependency declaration despite the redundancy.\n\n---\n\nDetail:\n-   Node v0.10.29\n-   Q v1.0.1\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/557.\n. Q.all takes arrays. Several of your examples do not pass it arrays.\n\n---\n\nFrom: Matthewmailto:notifications@github.com\nSent: \u00fd2014-\u00fd07-\u00fd20 20:25\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] q.all([...]) eats resolved resultants when other q.all([..]) calls are embedded inside it (#558)\n\nWhen you have a couple of branching dependent code paths, you might end up structuring your code such that you need to chain off promises to get at resulted data. This means you don't need to leak information out of your function scopes gives an explicit order in which things should be resolved when the next person comes to read that code.\n\nThis kind of mindset makes the q.all([...]) function very attractive if you have a group of deps that all have data you need to marshal into a function.\n\nHowever, I've run into a bug when composing q.all([...]) on load methods that are themselves also called in the context of q.all([...]). For example, if you:\n1.  Set up a function loadUserConfigs that returns q.all([ loadUsers(), loadGroups() ])\n2.  And set up a function loadDatabaseConnection that returns a promise wrapping a connection handler\n3.  And compose these two calls and chaining them as q.all( loadUserConfigs(), loadDatabaseConnection() ).then(...)\n4.  Then setup a handler that needs to get at resultants from loadUserConfigs() and loadDatabaseConnection()\n\nYou're going to run into a situation where one the handler only has access to the result of the first promise.\n\nHere's a snippet to demonstrate:\n\nvar q = require('q');\n\nvar process = function(i) {\n  var done = q.defer();\n  setTimeout(function() {\n    done.resolve( 'done! ' + i );\n  },0);\n  return done.promise;\n};\n\nvar finishedProcessing = q.all( [1,2,3].map(process) );\n\nvar loadSecondConfig = function() {\n  var done = q.defer();\n\n  setTimeout(function(){\n    done.resolve('finished!!');\n  },0);\n\n  return done.promise;\n};\n\nq.all( finishedProcessing, loadSecondConfig() )\n  .then( function() {\n    console.log(\"\\n\\n\\n\");\n    console.log(\"Test 1: q.all(\\n  q.all( q.all( p1,p2,p3 ), p4 )\\n)\");\n    console.log(\"...gives...\");\n    console.log(arguments);\n  });\n\nq.all( loadSecondConfig(), finishedProcessing )\n  .then( function() {\n    console.log(\"\\n\\n\\n\");\n    console.log(\"Test 2: q.all(\\n  p4, q.all( p1,p2,p3 )\\n)\");\n    console.log(\"...gives...\");\n    console.log(arguments);\n  });\n\nThis prints out\n\nTest 2: q.all(\n  p4, q.all( p1,p2,p3 )\n)\n...gives...\n{ '0': 'finished!!' }\n\nTest 1: q.all(\n  q.all( q.all( p1,p2,p3 ), p4 )\n)\n...gives...\n{ '0': [ 'done! 1', 'done! 2', 'done! 3' ] }\n\nTest 1, we lost the result of p4.\n\nIn Test 2, we lost the combined result of q.all(p1,p2,p3).\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/558.\n. Nitpicking: more correct would be to say that `Promise.race([...])` returns a promise which behaves the same as the first **settled** (fulfilled or rejected) promise in the list. Agreed the comment is incorrect.\n. Hi @franksrevenge,\n\nThanks for your contribution, but I don't think we're interested in duplicating features of the JavaScript language (i.e., local variables). I'd suggest refactoring this code to be\n\n``` js\nvar myVariable;\nQ.all([a, b])\n.then(function() {\n    myVariable = 'Hello world';\n})\n.all([a, b])\n.all([c, d])\n.then(function() {\n    return Q.all([c, d])\n        .then(function() {\n            console.log(myVariable);\n        });\n});\n```\n. $q is unrelated to kriskowal/q\n. `fin` is an alias for `finally`. Just like you use `.catch`/`.fail` when you'd use `catch` in synchronous code, you should use `.finally`/`.fin` when you'd use `finally`.\n\nDoes that help?\n. Yep, that's it exactly!\n. `.finally` is supposed to parallel the keyword `finally`, as in `try`/`catch`/`finally`. Since `finally` does not receive any args, neither will `.finally`.\n\nYour above example seems like you want to notify the message service no matter if there are errors or not. In synchronous code, we already have a pattern for that: `try { ... } catch (e) {}`. So I would suggest\n\n``` js\ndoThing().catch(() => {}).then(() => msgService.notify(data));\n```\n. Yes. I am telling you why the current functionality is designed that way and will not be changing.\n\nThe code I wrote is exactly equivalent to the code you wrote, so it will work in the same way.\n. That's false ... because I have caught the error, the subsequent .then will execute. That is how promises work... Try it in your browser console:\n\n``` js\nPromise.reject(new Error(\"boo!\"))\n  .catch(function () { })\n  .then(function () { console.log(\"this is reached\"); });\n```\n. How would you know ahead of time whether the promise is fulfilled or rejected?\n. Regardless, if the promise is fulfilled, the `.catch` will have no effect. (Just like the `try { doStuff() } catch (e) { }` has no effect if `doStuff()` does not throw an error.)\n. Yes, because the promise returned by `.catch(() => {})` is always fulfilled (the entire purpose of `.catch(() => {})` is to convert rejections into fulfillments, just like `try { } catch (e) { }` converts thrown errors into normal flow).\n\nAll of this applies to $q as well, by the way. I encourage you to just try this in your browser, whether with Q, $q, or window.Promise.\n. What I am saying, is just write your code as if it was synchronous, then convert any `catch`s into `.catch`s, and `finally`s into `.finally`s :). The amount of code you have to write will be parallel in both cases, because promises error flow is parallel to sync control flow in this regard.\n. Well, you can always write a function. Similar to how you might not like to write `try { x(); } catch (e) { } y();` and prefer to write `foo(x, y)`, you could write a promise-based function that does the same thing:\n\n``` js\nfunction foo(x, y) {\n  return x().catch(() => {}).then(y);\n}\n```\n. I disagree that what you are proposing is a feature that encourages clean code. I think clean code for promises is code that makes the structure of error flow clear. Hiding that behind a function is unclean code, whereas making it explicit by only using those structures that have clear analogies in synchronous code is clean.\n. You should be OK creating your own abstractions on top of solid base ones.\n\n`.finally` as an abstraction will not change in promises (I say this as a Q collaborator and the ES6 promises spec editor), because it is important it parallel synchronous `finally`.\n\nIf you want your own abstractions you can try to convince library authors to make them for you, or you can make them yourself. I advise the latter as it helps get work done faster.\n. And I take issue with the description of making your error flow clear as a hack. If you understand promises, or more simply just understand that promise error flow is exactly the same as try/catch/finally error flow, is it entirely natural and non-hacky, and anyone who sees it with that same shared understanding will understand it. I assume you have read http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/ ?\n. > And as a final word: \"finally\" is called anyway - if you are so keen on having the \"try-catch-finally\" blocks, why are you calling the finally when no catch is there?\n\nFinally is used when you _don't_ catch the error, or when you rethrow. E.g.\n\n``` js\ntry {\n  doThing();\n} catch (e) {\n  logToServer(e);\n  throw e;\n} finally {\n  cleanUpResources();\n}\n\n// this code doesn't run since the error is still thrown\n```\n\n<=>\n\n``` js\ndoThing()\n  .catch(e => { logToServer(e); throw e; })\n  .finally(cleanUpResources)\n  .then(() => { /* this code doesn't run since the promise is still rejected */ });\n```\n. Finally is always called in Q as well (try it in your browser). It's just not _useful_ if you don't expect there to be an error.\n. Anyone who understands how promise code parallels synchronous try/catch/finally---which should be everyone using promises---will find such a pattern natural and obvious because that is how you would do it in sync code. So indeed no need to document, not because it's hilarious, but because it's obvious.\n. In your example, `configInitialized` is a promise. `.then(anyPromise)` will do nothing useful, since `.then` takes functions and `anyPromise` is not a function. The same for `Q.fcall`, actually.\n\nBetter would be\n\n``` js\nfirstPromise1.then(function () {\n  return configInitialized;\n}).then(function (data) {\n  // data is now AJAX response data\n});\n```\n\nWe have a shortcut for this:\n\n``` js\nfirstPromise1\n  .thenResolve(configInitialized)\n  .then(function (data) {\n    // data is now AJAX response data\n  });\n```\n. Seems bad for web workers; use `self` instead?\n. Yep, q.denodeify only works on functions that follow the Node callback convention. Many functions do not, including fs.exists.\n. In general you should not use `fs.exists` anyway. You should either (a) just perform the operation you want to perform, and handle ENOENT errors if they occur; or (b) use `fs.stat`.\n\n(a) is better because it prevents race conditions where the file stops existing between your call to `fs.exists` and the operation you're performing. (b) is still subject to race conditions, but `fs.stat` uses the Node callback convention.\n. This is not possible in JavaScript, the language.\n. Would be tricky in ES5... on the other hand, latest IE preview means all major browsers support iterables.\n\n---\n\nFrom: Oliver Joseph Ashmailto:notifications@github.com\nSent: \u00fd2014-\u00fd11-\u00fd18 11:35\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] Q.all(iterable) (#613)\n\nES6 Promise.allhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all allows you to pass an iterable. Could Q provide this functionality today?\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/613.\n. We might be able to do it using only ES5 syntax by re-implementing for-of's semantics. There was some es-discuss post from @anba with the full desugaring, but I can't find it anymore...\n. @kriskowal my thought would be that we only support iterables if `Symbol.iterator` (and `Symbol`) are present.\n. This is called \"nodeify\"\n. Sorry I misread; it turns out I meant Q.denodeify.\n. Q.all(data).then(func)\n\n---\n\nFrom: slawomailto:notifications@github.com\nSent: \u00fd2014-\u00fd11-\u00fd23 18:56\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] Q.onAll(func, values_array) (#615)\n\nIs there an equivalent of this:\n\nvar runOnAll = function(func, data) {\n    var results = [];\n    return _(data).reduce(function(res, val) {\n        return res.then(function() {\n            var out = Q(func(val));\n            out.then(function(r) {\n                results.push(r);\n            })\n            return out;\n        });\n    }, Q(0)).then(function() {\n        return Q(results);\n    })\n}\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/615.\n. Use yield, not yield*\n. Ah I see. Yeah readURL should return a promise, not a generator object. Wrap it in Q.async to get that effect. Then you can yield readURL(), i.e. yield the promise.\n. At that point it's seeming like a bug in Firefox...\n. OK, back at a real computer and keyboard now. \n\nWhat you're doing with this code is very strange. In general, the pattern is to create promise-returning functions and, inside functions wrapped in Q.async or Q.spawn, yield promises.\n\nYour original example creates a generator function and inside it, it yields a promise value. That's not too useful; it just creates an iterator that is equivalent to a one-element sequence of a promise. Delegating to that iterator inside Q.spawn seems to confuse the code.\n\nYou seem to be trying to build the readURL function in stages, e.g. first build a promise-returning function that just immediately fulfills onload, and then build something more complicated. For that, try this kind of code:\n\n``` js\nfunction loadXHR(url) {\n    var d = Q.defer();\n    var req = new XMLHttpRequest();\n    req.onload = function () {\n        d.resolve(req);\n    };\n\n    req.open(\"GET\", url);\n    req.send();\n\n    return d.promise;\n}\n\nvar readURL = Q.async(function *(url) {\n    var request = yield loadXHR(url);\n\n    if (request.readyState === request.DONE) {\n        if (request.status == 200) {\n            return request.responseText;\n        } else {\n            throw new Error(\"readURL failed with code \" + request.status + \" at URL: \" + url);  \n        }\n    } else {\n        throw new Error(\"readURL did not complete: \" + url);\n    }\n});\n\nfunction test() {\n    Q.spawn(function* () {\n        console.log(yield readURL(\"http://echo.jsontest.com/\")); // Cross-origin friendly URL for fiddle\n    });\n}\n```\n\nUnfortunately, I am still seeing Firefox get an infinite loop. So I guess I wasn't being very useful after all :(\n. Oh, interesting! Well, Firefox is relatively evergreen; we may wish to just eliminate that workaround and direct people to older Q versions if they want to support old Firefox.\n\nFiled https://bugzilla.mozilla.org/show_bug.cgi?id=1104014 on Firefox.\n. It's under Promise.prototype.then.\n\nOn Nov 24, 2014, at 06:26, Oliver Joseph Ash <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nThe Q website mentions Q.when, but this is not listed in the API Reference on the wiki.\n\nHappy to contribute but I'm not confident that I'll describe it correctly.\n\n## \n\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/617.\n. Example code? Does not occur in any of the code I try.\n\nA method to subscribe only the onFulfilled handler is to pass only a single argument to `.then`.\n. Yeah, exactly. That's why the name `.catch` is preferred to `.fail`, because it makes it clearer that what you're doing is like this synchronous code:\n\n``` js\ntry {\n  functionThatThrewError();\n} catch (e) {\n  console.log('this failed');\n}\n\n// then:\nconsole.log('I thought this would not be called, but is being called');\n```\n. Use Q.spawn for running code; Q.async for creating promise-returning functions.\n\n---\n\nFrom: Adrian Pungamailto:notifications@github.com\nSent: \u00fd2014-\u00fd12-\u00fd08 04:23\nTo: kriskowal/qmailto:q@noreply.github.com\nSubject: [q] Q.async eats thrown exceptions (#623)\n\nvar Q = require('q');\n\nQ.async(function*(){\nthrow new Error('Eaten by Q exception...');\n})();\n\ndoes not display anything.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/623.\n. > Run M-x markdown-toc/generate-toc\n\nHow do we do this ourselves, when the readme gets changed?\n. It'd be important for any PR to add a npm script that will update the ToC, so we can do `npm run update-toc`.\n. @arikon I don't think that updates the README though. And http://documentup.com/kriskowal/q/ already has a TOC, so I assume @ardumont is specifically interested in the README.\n. Exactly.\n. Using bower to consume q is not a supported scenario. Please use npm.\n. You are not returning the promise.\n. I think it really should get tests. I'm not sure where the impression that the Q tests are for browsers came from? See e.g. the domain tests: https://github.com/kriskowal/q/blob/v1/spec/q-spec.js#L2319-L2413\n. A promise is like an async return value. I.e., synchronous functions return values, asynchronous functions return promises.\n\nThe caller of a synchronous function can't change the return value of that function. Similarly, the caller of an asynchronous function can't change the return value of that function, i.e., nobody can reset a promise.\n. Dupe of #449 \n. Have you tried io.JS? The V8 version in Node 0.12 is unsupported and full of bugs.\n. You could use browserify, or you could do this:\n\n``` js\nvar Q = window.Q;\ndelete window.Q;\n```\n. Deleting window.$ is exactly what jQuery.no conflict does so I don't really understand what you want.\n. Let's translate that code: substitute the return value of the getter where you put `mail.attachments`. The result is:\n\n``` js\nq.resolve()\n    .then(function() {\n        return 'First then';\n    })\n    .then(q.resolve(['Attachment #1']))\n    .done(function(result) {\n        console.log(result);\n    });\n```\n\nSo you are passing a promise to `.then`, which does not work, since `.then` only accepts functions.\n. That code will indeed pass all relevant information. Can you give a test showing otherwise?\n\nEquivalent code would be `df.resolve(test())`.\n. Well your best scenario is if you are using promise functions instead of adapting callback code like setTimeout. For example if you use Q.delay then you can just do\n\n``` js\nfunction test() {\n  return Q.resolve(123);\n}\n\nfunction test2() {\n  return Q.delay(1000).then(test);\n}\n\ntest2().then(function () {\n  console.log(arguments);\n}).done();\n```\n. Ah I see #693 takes care of this for the 1.x branch.\n. Can you try doing this without Q and seeing if the CPU usage remains high?\n. Can you create a reproduction step without google-api-nodejs-client?\n. Yes, this is the antipattern in action. Instead you should use\n\n``` js\nfunction memcachedGet(key) {\n  return Q.ninvoke(memcached, \"get\", key).then(function (data) {\n    if (!data) {\n      throw new Error(\"no data\");\n    }\n  });\n}\n```\n\nor similar.\n\nAlso, in the future you may find StackOverflow a better outlet for these questions, as this is not a bug with Q.\n. It is because that is not how finally works:\n\n``` js\ntry {\n  // code here\n} finally {  // not finally (something)\n  // cleanup actions\n}\n```\n. This is a pretty major change in semantics and as such should only go into 2.0. I am neutral on the functionality; I can see how it might make sense to test fn.length to find the last argument, but in general I think that's fragile and am not sure relying on it is a good idea.\n. Right, those are intentional semantics currently, because they are the simplest thing that can be done without any magic guessing that might e.g. hide bugs. Magic guessing is OK to add, but it's a major semantic change and deserves 2.0 only.\n\nfn.length is not incompatible between implementations, but it's just not always useful. For example, many core functions in the Node.js standard library have fn.lengths that mismatch their actual call signature, since they switch on `arguments[n]` where `n > fn.length`.\n. ",
    "chikamichi": "Nice :)\n. Nice :)\n. ",
    "ThomasBurleson": "@DomenicDenicola\nIt seems that you just described the $.Deferred().promise.then( ) syntax.\n\njQuery [and AS3 Promises] also has a \n\n```\n$.when( func1, func2, func3, ...).then( ... ) \n```\n\nfeature which will process all promises (func1 returns a promise, etc.) in PARALLEL as a batch group. Only when all items in the batch resolve will the .then( ) be invoked. . \n\n@KrisKowal\nWhat seems to be missing [in Q] is the feature to defer futures in a chain sequence; not a parallel batch. Other libraries supports this in two ways:\n\n```\n$.Deferred.promise.then( \n        func1.then(\n            func2.then (\n                func3.then( ) \n            )\n        )\n).then( ... sequence resolved ).   \n```\n\nBut the above is very hard to manually do programmatically while iterating an array. So the Promise::pipe() solves that problem [and more]:\n\n```\n$.Deferred( )\n   .promise\n   .pipe( func1 )\n   .pipe( func2 )\n   .pipe( func3 )\n   .then( ... )\n```\n\nPromise::pipe() is very powerful in that it supports:\n\n  1) Transforming results of a resolved value\n  2) Rejecting a resolved value (for example, the resultHandler was invoked, but the data status code indicates an issue).\n  3) Sequence chaining to another deferred/promise\n\nWhat developers want is an API/syntax that is terse, condensed, intuitive, and adaptable. \nThe jQuery one is amazingly verstaile. I would love to see Q for Node.js with similar qualities.\n. @DomenicDenicola\nThank you for your reply.\nYour `.then( )` sequence will work for me also; and seems equivalent to my `.pipe( <promise> )` sequence. \n\nPermit me to suggest an _issue_ with your example <grin>. \n\nTypically we have the `.then()` api as follows:\n\n```\npromise.then( resultHandler, faultHandler, progressHandler );\n```\n\nIn the `resultHandler`, I do not want to throw an error; I want to process the expected result data. That is what the `faultHandler` will do. The pipe allows me to intercept the response results before my _true_ handlers are called. Status code checks can then _reject_ the resolved... the rejection then calls the `faultHandler`. \n\nLikewise the result data [in the .pipe() handlers] can parse the data to remove package constructs.\ne.g. If the async response is an EventResult then I can do this:\n\n```\n.pipe( function(event:EventResult) {\n  return event.result;   // only want the data; not the wrapper\n)}\n.then( function( result) {\n\n)}\n```\n\nThese seems more elegant to me. Thanks for your consideration regarding my thoughts.\n. @kiskowal\nYour explaination regarding parallel processing helped. \nJust to note that $.when() is parallel. So if I wanted to use work with both jQuery and Q promises, I must be aware of the api differences. \nThanks again guys.\n. I did not really consider the `nextTick` usage; which btw seems _very odd_. \nSince the then() handler is already async/nextTick, why add another nextTick.\n\nWould this not be a better approach:\n\n```\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        return this.then(function (value) {\n            return (nodeback(null, value) || value);\n        }, function (error) {\n                nodeback(error);\n                throw error;\n        });\n    } else {\n        return this;\n    }\n};\n```\n. I strongly disagree. My usage sample above may seem redundant, but it illustrates that promises are often chained. So while the initial call to `mongoQuery.execute( db, collectionName, callback )` is normally sufficient, often the returned promise is delivered to other processes for subsequent chaining.\n\nWith chaining, it is critical that the result/rejection propagation continues. Hence my submission that this is a bug; not a feature.\n. My original goal is to build NodeJS libraries that support **both** promises and optional callbacks. \nThe `nodeback` (aka callback) is optional, but the API always returns promises. \n-  If the `nodeback` is specified, it should be called first.\n-  If the `nodeback` is not specified, then the promise chain can manage the response\n-  There is no requirement for the promise to be chained (so it may be unused)\n\nWith these requirements, the `nodeify()` feature does not work as expected.\n\nI do not want to force the developer [using my libraries] to understand when/under-what-conditions my API will not work as expected. It is just works as expected for promises (regardless of the use of `node back`).\n. @domenic \nUnderstood. As I am sure I must be missing something, help me understand why the current implementation uses nextTick() in the promise resolve handler? What is the intention and background?\n\nPlease note that I am not intending to be argumentative. Rather I want to understand the intentions of code and the cautions/concerns that implementations attempt to address.\n. Aah, now I understand the `nextTick()`... it is used to exclude `nodeback` errors from chain propagation.\nI assume nextTick() would also all `nodeback` exceptions to propagation normally outside/independent of the chain sequence?\n\nAnd finally, yes I think a `nodeify()` decorator is needed for my needs instead of modifying the current, **default** `nodeify()` functionality change.\n\nThanks again for the clarification. \n. @DomenicDenicola\nIt seems that you just described the $.Deferred().promise.then( ) syntax.\n\njQuery [and AS3 Promises] also has a \n\n```\n$.when( func1, func2, func3, ...).then( ... ) \n```\n\nfeature which will process all promises (func1 returns a promise, etc.) in PARALLEL as a batch group. Only when all items in the batch resolve will the .then( ) be invoked. . \n\n@KrisKowal\nWhat seems to be missing [in Q] is the feature to defer futures in a chain sequence; not a parallel batch. Other libraries supports this in two ways:\n\n```\n$.Deferred.promise.then( \n        func1.then(\n            func2.then (\n                func3.then( ) \n            )\n        )\n).then( ... sequence resolved ).   \n```\n\nBut the above is very hard to manually do programmatically while iterating an array. So the Promise::pipe() solves that problem [and more]:\n\n```\n$.Deferred( )\n   .promise\n   .pipe( func1 )\n   .pipe( func2 )\n   .pipe( func3 )\n   .then( ... )\n```\n\nPromise::pipe() is very powerful in that it supports:\n\n  1) Transforming results of a resolved value\n  2) Rejecting a resolved value (for example, the resultHandler was invoked, but the data status code indicates an issue).\n  3) Sequence chaining to another deferred/promise\n\nWhat developers want is an API/syntax that is terse, condensed, intuitive, and adaptable. \nThe jQuery one is amazingly verstaile. I would love to see Q for Node.js with similar qualities.\n. @DomenicDenicola\nThank you for your reply.\nYour `.then( )` sequence will work for me also; and seems equivalent to my `.pipe( <promise> )` sequence. \n\nPermit me to suggest an _issue_ with your example <grin>. \n\nTypically we have the `.then()` api as follows:\n\n```\npromise.then( resultHandler, faultHandler, progressHandler );\n```\n\nIn the `resultHandler`, I do not want to throw an error; I want to process the expected result data. That is what the `faultHandler` will do. The pipe allows me to intercept the response results before my _true_ handlers are called. Status code checks can then _reject_ the resolved... the rejection then calls the `faultHandler`. \n\nLikewise the result data [in the .pipe() handlers] can parse the data to remove package constructs.\ne.g. If the async response is an EventResult then I can do this:\n\n```\n.pipe( function(event:EventResult) {\n  return event.result;   // only want the data; not the wrapper\n)}\n.then( function( result) {\n\n)}\n```\n\nThese seems more elegant to me. Thanks for your consideration regarding my thoughts.\n. @kiskowal\nYour explaination regarding parallel processing helped. \nJust to note that $.when() is parallel. So if I wanted to use work with both jQuery and Q promises, I must be aware of the api differences. \nThanks again guys.\n. I did not really consider the `nextTick` usage; which btw seems _very odd_. \nSince the then() handler is already async/nextTick, why add another nextTick.\n\nWould this not be a better approach:\n\n```\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        return this.then(function (value) {\n            return (nodeback(null, value) || value);\n        }, function (error) {\n                nodeback(error);\n                throw error;\n        });\n    } else {\n        return this;\n    }\n};\n```\n. I strongly disagree. My usage sample above may seem redundant, but it illustrates that promises are often chained. So while the initial call to `mongoQuery.execute( db, collectionName, callback )` is normally sufficient, often the returned promise is delivered to other processes for subsequent chaining.\n\nWith chaining, it is critical that the result/rejection propagation continues. Hence my submission that this is a bug; not a feature.\n. My original goal is to build NodeJS libraries that support **both** promises and optional callbacks. \nThe `nodeback` (aka callback) is optional, but the API always returns promises. \n-  If the `nodeback` is specified, it should be called first.\n-  If the `nodeback` is not specified, then the promise chain can manage the response\n-  There is no requirement for the promise to be chained (so it may be unused)\n\nWith these requirements, the `nodeify()` feature does not work as expected.\n\nI do not want to force the developer [using my libraries] to understand when/under-what-conditions my API will not work as expected. It is just works as expected for promises (regardless of the use of `node back`).\n. @domenic \nUnderstood. As I am sure I must be missing something, help me understand why the current implementation uses nextTick() in the promise resolve handler? What is the intention and background?\n\nPlease note that I am not intending to be argumentative. Rather I want to understand the intentions of code and the cautions/concerns that implementations attempt to address.\n. Aah, now I understand the `nextTick()`... it is used to exclude `nodeback` errors from chain propagation.\nI assume nextTick() would also all `nodeback` exceptions to propagation normally outside/independent of the chain sequence?\n\nAnd finally, yes I think a `nodeify()` decorator is needed for my needs instead of modifying the current, **default** `nodeify()` functionality change.\n\nThanks again for the clarification. \n. ",
    "jpillora": "Quick question relating to this thread. I'm also used to jQuery's `pipe`. Here's my use case:\n\n``` js\nfunction getFiles() {\n  var d = Q.defer();\n\n  fs.readdir(myDir, function(err, files) {\n\n    Q.all(files.map(processFile))\n      // im doing:\n      .then(d.resolve, d.reject);\n      // though, would be nice if i could:\n      //.pipe(d); \n\n  });\n\n  d.promise;\n}\n```\n\nSince in between my promise API `getFiles` and `processFile`, I have the intermediate callback API `fs`, I need to create a placeholder deferred object which I'm using as a proxy (any success and any failure). Is what I'm doing the simplest way to do this?\n. Ah very nice. Thanks @domenic\n. Quick correction, I needed to use `Q.ninvoke`\n. Quick question relating to this thread. I'm also used to jQuery's `pipe`. Here's my use case:\n\n``` js\nfunction getFiles() {\n  var d = Q.defer();\n\n  fs.readdir(myDir, function(err, files) {\n\n    Q.all(files.map(processFile))\n      // im doing:\n      .then(d.resolve, d.reject);\n      // though, would be nice if i could:\n      //.pipe(d); \n\n  });\n\n  d.promise;\n}\n```\n\nSince in between my promise API `getFiles` and `processFile`, I have the intermediate callback API `fs`, I need to create a placeholder deferred object which I'm using as a proxy (any success and any failure). Is what I'm doing the simplest way to do this?\n. Ah very nice. Thanks @domenic\n. Quick correction, I needed to use `Q.ninvoke`\n. ",
    "indutny": "Yes, running callbacks on stack is not preferable for flow control module, I agreed.\n\nBut can you please point me to any place where such `nextTick` behaviour is documented? I spent some time on figuring out, why streams was broken in my app, and it'll be great to let everyone know that callbacks are running not immediately.\n. Yes, running callbacks on stack is not preferable for flow control module, I agreed.\n\nBut can you please point me to any place where such `nextTick` behaviour is documented? I spent some time on figuring out, why streams was broken in my app, and it'll be great to let everyone know that callbacks are running not immediately.\n. ",
    "IgorMinar": "The way I handle this issue in my Q-like mini implementation of deferreds/promises is by logging any exception thrown from success/error callbacks in addition to rejecting the derived promises with the exception being the rejection reason. So essentially, my stance is that an exception unhandled in a callback represents a programming error and should be logged. To signal that derived promises should be intentionally rejected, one must return a rejected promise instead of a value or an exception.\n\nSo Q could be fixed to differentiate between these two scenarios (currently it does not):\n1. promise.then(function(val) { **throw 'something went unexpectedly wrong'** }).then(..); // log exception and reject derived promise\n2. promise.then(function(val) { return **Q.reject('I am unable to compute the value')**}).then(..); // don't log anything, just reject derived promise\n\nThis approach has been working quite well for me so far and I believe that it is in the \"spirit\" of deferreds/promises.\n\nFrom a quick glance at the code, a good place to start would be to log these exceptions:\n\nhttps://github.com/kriskowal/q/blob/8ff517e193185b100feb881185957a7f211b4c72/q.js#L506\nhttps://github.com/kriskowal/q/blob/8ff517e193185b100feb881185957a7f211b4c72/q.js#L514\n\nKeep in mind that this is a breaking change, because throwing an exception and returning a rejected promise is not the same thing any more. So developers would likely have to go back and fix the old code that merely relies on throwing, rethrowing or unhandling an exception.\n. @kriskowal can share more details about why this logging was removed?\n. @kriskowal if an existing system communicates a result of an action by throwing an exception then the success callback should expect that (since its part of the contract of the api that it relies on). Isn't it reasonable to expect the developer of the success callback to wrap the call into try/catch and reject return rejection if an expected exception is thrown?\n\nI actually use an alternative method - I made the logger configurable, so at runtime I can choose to display the exception logs during development and in production I silence them.\n. The way I handle this issue in my Q-like mini implementation of deferreds/promises is by logging any exception thrown from success/error callbacks in addition to rejecting the derived promises with the exception being the rejection reason. So essentially, my stance is that an exception unhandled in a callback represents a programming error and should be logged. To signal that derived promises should be intentionally rejected, one must return a rejected promise instead of a value or an exception.\n\nSo Q could be fixed to differentiate between these two scenarios (currently it does not):\n1. promise.then(function(val) { **throw 'something went unexpectedly wrong'** }).then(..); // log exception and reject derived promise\n2. promise.then(function(val) { return **Q.reject('I am unable to compute the value')**}).then(..); // don't log anything, just reject derived promise\n\nThis approach has been working quite well for me so far and I believe that it is in the \"spirit\" of deferreds/promises.\n\nFrom a quick glance at the code, a good place to start would be to log these exceptions:\n\nhttps://github.com/kriskowal/q/blob/8ff517e193185b100feb881185957a7f211b4c72/q.js#L506\nhttps://github.com/kriskowal/q/blob/8ff517e193185b100feb881185957a7f211b4c72/q.js#L514\n\nKeep in mind that this is a breaking change, because throwing an exception and returning a rejected promise is not the same thing any more. So developers would likely have to go back and fix the old code that merely relies on throwing, rethrowing or unhandling an exception.\n. @kriskowal can share more details about why this logging was removed?\n. @kriskowal if an existing system communicates a result of an action by throwing an exception then the success callback should expect that (since its part of the contract of the api that it relies on). Isn't it reasonable to expect the developer of the success callback to wrap the call into try/catch and reject return rejection if an expected exception is thrown?\n\nI actually use an alternative method - I made the logger configurable, so at runtime I can choose to display the exception logs during development and in production I silence them.\n. ",
    "axelson": "@kriskowal is there a write-up on how to use `done()` to avoid \"exception swallowing\"?\n. @kriskowal is there a write-up on how to use `done()` to avoid \"exception swallowing\"?\n. ",
    "randallb": "So I love Q, and prefer it, except this error handling case is really difficult on me.\n\nhttps://github.com/tildeio/rsvp.js/#error-handling\n\nIn RSVP, they have an \"error\" event that fires, meaning as a user you can have some `console.assert` thing show any unhandled errors. I'd love to have some way of surfacing all exceptions at least while developing... would this be something you'd be interested in having in Q? Even if as \"Q.onError` if there's no native event bus. (I haven't yet looked at code.)\n. well... i fail at reading docs then. Thank you very much.\n. Ah it'll only catch errors if you use the `.done()` method. I was proposing trying to trigger some event handler whenever an error is caught in a promise chain.\n. So I love Q, and prefer it, except this error handling case is really difficult on me.\n\nhttps://github.com/tildeio/rsvp.js/#error-handling\n\nIn RSVP, they have an \"error\" event that fires, meaning as a user you can have some `console.assert` thing show any unhandled errors. I'd love to have some way of surfacing all exceptions at least while developing... would this be something you'd be interested in having in Q? Even if as \"Q.onError` if there's no native event bus. (I haven't yet looked at code.)\n. well... i fail at reading docs then. Thank you very much.\n. Ah it'll only catch errors if you use the `.done()` method. I was proposing trying to trigger some event handler whenever an error is caught in a promise chain.\n. ",
    "n2liquid": "If Q\n- held weak references to all promises upon creation,\n- and strong references to all errors upon rejection,\n- and dropped those error references whenever they're successfuly handled by a `catch()` clause,\n\ncouldn't we implement a function that runs once per event loop and throws unhandled errors if their corresponding promise has been garbage collected?\n\nWeak references to promises that have been garbage collected but have no outstanding unhandled errors are just dropped as well.\n\nSince this comes at a performance cost and not every JavaScript engine Q runs on would necessarily support ES6's WeakMaps or whatever we use to implement this, this feature could just be disabled (either explicitly by client code or implicitly, if Q detects weak references aren't supported), and people who either don't want it or can't use it can just keep using `Q.done`.\n\nCouldn't that work pretty well?\n\nGranted, if the object takes too long to be garbage collected, the program may keep running for a while before the exception is logged and/or the process is killed, but that's better than nothing in my case, at least.\n. From https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap:\n\n```\nBecause of references being weak, WeakMap keys are not enumerable\n(i.e. there is no method giving you a list of the keys). If they were, the list\nwould depend on the state of garbage collection, introducing non-determinism.\nIf you want to have a list of keys, you should maintain it yourself.\n```\n\nAre you talking about this? It looks like you can kind of do it if you maintain a list of things that _should_ be on the WeakMap, and check them periodically, no?\n. True. How about adding unique IDs to promises and keeping a list of those, though?\n. Crap, true. They're not enumerable. That sucks :(\n. @kriskowal I see, it's a very tricky thing, indeed. But boy, I just don't feel safe that even things like TypeErrors would just be swallowed if I forget to use `Q.done` or yield the promise into a `Q.spawn` generator.\n\nI guess dumping unhandled errors to the console before exiting the program is as good as it'll get for me (I'm not writing a server, so this is reasonable in this particular case).\n. > I'm sorry, but really?? This is all kinds of wrong. Not only are we swallowing exceptions, we're destroying the stack too. I don't know what the solution is, but this ain't it.\n\nI don't think rethrowing destroys the stack. The stack will be that of when the Error object was created.\n. If Q\n- held weak references to all promises upon creation,\n- and strong references to all errors upon rejection,\n- and dropped those error references whenever they're successfuly handled by a `catch()` clause,\n\ncouldn't we implement a function that runs once per event loop and throws unhandled errors if their corresponding promise has been garbage collected?\n\nWeak references to promises that have been garbage collected but have no outstanding unhandled errors are just dropped as well.\n\nSince this comes at a performance cost and not every JavaScript engine Q runs on would necessarily support ES6's WeakMaps or whatever we use to implement this, this feature could just be disabled (either explicitly by client code or implicitly, if Q detects weak references aren't supported), and people who either don't want it or can't use it can just keep using `Q.done`.\n\nCouldn't that work pretty well?\n\nGranted, if the object takes too long to be garbage collected, the program may keep running for a while before the exception is logged and/or the process is killed, but that's better than nothing in my case, at least.\n. From https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap:\n\n```\nBecause of references being weak, WeakMap keys are not enumerable\n(i.e. there is no method giving you a list of the keys). If they were, the list\nwould depend on the state of garbage collection, introducing non-determinism.\nIf you want to have a list of keys, you should maintain it yourself.\n```\n\nAre you talking about this? It looks like you can kind of do it if you maintain a list of things that _should_ be on the WeakMap, and check them periodically, no?\n. True. How about adding unique IDs to promises and keeping a list of those, though?\n. Crap, true. They're not enumerable. That sucks :(\n. @kriskowal I see, it's a very tricky thing, indeed. But boy, I just don't feel safe that even things like TypeErrors would just be swallowed if I forget to use `Q.done` or yield the promise into a `Q.spawn` generator.\n\nI guess dumping unhandled errors to the console before exiting the program is as good as it'll get for me (I'm not writing a server, so this is reasonable in this particular case).\n. > I'm sorry, but really?? This is all kinds of wrong. Not only are we swallowing exceptions, we're destroying the stack too. I don't know what the solution is, but this ain't it.\n\nI don't think rethrowing destroys the stack. The stack will be that of when the Error object was created.\n. ",
    "constfun": "```\n// In browsers, uncaught exceptions are not fatal.\n// Re-throw them asynchronously to avoid slow-downs.\n```\n\nhttps://github.com/kriskowal/q/blob/v1/q.js#L158\n\nI'm sorry, but really?? This is all kinds of wrong. Not only are we swallowing exceptions, we're destroying the stack too. I don't know what the solution is, but this ain't it.\n. `e.stack` is available (only sometimes, it seems) but as a string, which means I can't step up from it in the debugger and inspect values, etc.\n. ```\n// In browsers, uncaught exceptions are not fatal.\n// Re-throw them asynchronously to avoid slow-downs.\n```\n\nhttps://github.com/kriskowal/q/blob/v1/q.js#L158\n\nI'm sorry, but really?? This is all kinds of wrong. Not only are we swallowing exceptions, we're destroying the stack too. I don't know what the solution is, but this ain't it.\n. `e.stack` is available (only sometimes, it seems) but as a string, which means I can't step up from it in the debugger and inspect values, etc.\n. ",
    "jdavisclark": "thanks a bunch\n. thanks a bunch\n. ",
    "yiminghe": "thanks to @DomenicDenicola \n\n i misunderstood the error callback of promise at first, i thought it is just used for error propagation and notification.\n\nNow i see it can also be used for recovery :)\n. thanks to @DomenicDenicola \n\n i misunderstood the error callback of promise at first, i thought it is just used for error propagation and notification.\n\nNow i see it can also be used for recovery :)\n. ",
    "Yaffle": "@domenic \nie 10 supports MessageChannel, does nextTick via MessageChannel works under IE10 ?\n. @domenic \nie 10 supports MessageChannel, does nextTick via MessageChannel works under IE10 ?\n. ",
    "arikon": "I'm telling just about wrapped-callback-style functions that accept only js primitives or objects.\nCould you provide some example where passing promise will be legitimate?\n. @domenic Done. Could you please approve my post?\n. https://groups.google.com/forum/?fromgroups=#!topic/q-continuum/aJO8QkvnS8s\n. So we tested Q and [Vow](https://github.com/dfilatov/jspromise) on the high load and here are the results.\n\nThe mathematical expectation of response time on the load till 100 rps (\u00b1 sigma).\n![constant-load](https://f.cloud.github.com/assets/75247/30082/e1434282-4e0c-11e2-94a1-3bc1af24dc04.png)\nX \u2014\u00a0requests per second\nY \u2014\u00a0response time, ms\n\nThe mathematical expectation of response time on the constantly increasing load (\u00b1 sigma).\n![max-load](https://f.cloud.github.com/assets/75247/30083/e194f19a-4e0c-11e2-9c56-5f19d0431aef.png)\nX \u2014\u00a0requests per second\nY \u2014\u00a0response time, ms\n. @kriskowal Have a look at the results, please. We want faster Q ;)\n. @kriskowal The problem is that Q is functional by design, there are a lot of functions that are created (and collected) in the runtime. And this produces overhead. Here are the examples:\n- https://github.com/kriskowal/q/blob/master/q.js#L474-L476\n- https://github.com/kriskowal/q/blob/master/q.js#L673-L699\n\nVow is prototype based in it nature. There are no functions that are created in the runtime, so there is no overhead.\n\nCan we redesign Q code so it will be more prototype based than functional?\n. Should we reopen this issue? I changed the title.\n. Bower can use package.json also. The problem with component.json is that `npm version` command does not touch it.\n\n02.01.2013, 05:02, \"George Adams\" notifications@github.com:\n\n> I have added a component.json file, which is really just a simplified package.json file. This is what Bower uses to define a package.\n> \n> You can merge this Pull Request by running:\n>   git pull https://github.com/geowa4/q master\n> \n> Or view, comment on, or merge it at:\n> \n>   https://github.com/kriskowal/q/pull/161\n> \n> Commit Summary\n> \n>   adding component.json file for bower support\n> \n> File Changes\n> \n>   A component.json (6)\n> \n> Patch Links\n> \n>   https://github.com/kriskowal/q/pull/161.patch\n>   https://github.com/kriskowal/q/pull/161.diff\n> \n> ```\n>           \u2014\n> \n>           Reply to this email directly or view it on GitHub.\n> ```\n\n## \n\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0438\u0437 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u0439 \u042f\u043d\u0434\u0435\u043a\u0441.\u041f\u043e\u0447\u0442\u044b: http://m.ya.ru/ymail\n. I think that maintaining separate repo for this is not a good idea at all. I think we should simply add prepublish script that will generate component.json from package.json.\n\n03.01.2013, 05:41, \"Kris Kowal\" notifications@github.com:\n\n> @forbeslindesay Yes, you\u2019re welcome to add it to the README in the section describing supported platforms.\n> \n> ```\n>           \u2014\n> \n>           Reply to this email directly or view it on GitHub.\n> ```\n\n## \n\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0438\u0437 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u0439 \u042f\u043d\u0434\u0435\u043a\u0441.\u041f\u043e\u0447\u0442\u044b: http://m.ya.ru/ymail\n. So you should inspect the rejection object to get the reason. Some of your commands could be failing sometimes.\n\nQ is nothing to do here, there are no any limitations.\n\n24.01.2013, 09:28, \"Guan Qing\" notifications@github.com:\n\n> I want to running a lot of unix command a child process.\n> \n> For example:\n> \n> var Q = require('q');\n> var cp = require('child_process');\n> \n> function exec(cmd) {\n>   var deferred = Q.defer();\n> \n>   cp.exec(cmd, function(err, stderr, stdout) {\n>     if (err) {\n>     deferred.reject(err);\n>     } else {\n>     deffered.resolve(stdout);\n>     }\n>   });\n> \n>   return deferred.promise;\n> }\n> \n> function runAlotOfCommands(commands) {\n>   var promises = [];\n> \n>   commands.forEach(function(cmd) {\n>     promises.push(exec(cmd));\n>   });\n> \n>   return Q.allResolved(promises);\n> };\n> \n> In this case, if use runAlotOfCommands to run some commands, sometime it will be resolved, sometime it was rejected.\n> \n> Did I do something wrong, or, it is the limitation of promise?\n> \n> ```\n>           \u2014\n> \n>           Reply to this email directly or view it on GitHub.\n> ```\n\n## \n\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0438\u0437 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u0439 \u042f\u043d\u0434\u0435\u043a\u0441.\u041f\u043e\u0447\u0442\u044b: http://m.ya.ru/ymail\n. Cool addition!\n\n14.03.2013, 19:29, \"Keith Cirkel\" notifications@github.com:\n\n> It would be nice as part of the promise object to have a function which will parallel execute alongside the previous function, but also be part of the set of resolved functions, similar to a then().\n> \n> Consider the following:\n> \n> function doSomething(n) {\n>     var deferred = Q.defer();\n>     setTimeout(function () {\n>         deferred.resolve(n);\n>     }, 500);\n>     return deferred.promise;\n> }\n> Q.all([\n>     doSomething(1),\n>     doSomething(2),\n>     doSomething(3),\n> ]).spread(function () {\n>     console.log(arguments); // [1, 2, 3]\n> });\n> \n> This could be chained using a function, let's call this function and:\n> \n> doSomething(1)\n>     .and(doSomething(2))\n>     .and(doSomething(3)),\n>     .spread(function () {\n>         console.log(arguments); // [1, 2, 3]\n>     });\n> \n> Each chunk of code should be considered equal.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n\n## \n\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0438\u0437 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u0439 \u042f\u043d\u0434\u0435\u043a\u0441.\u041f\u043e\u0447\u0442\u044b: http://m.ya.ru/ymail\n. @domenic Have a look at this, please. It blocks us from moving to q 0.9.x.\n. @domenic @kriskowal Any progress on fixing this issue? It still blocks us from migration to q 0.9.x.\n. This was broken again in `q 0.9.6`\n. That brokes our code in [bem/bem-tools](https://github.com/bem/bem-tools), that utilizes thousands of promises.\n. @rkatic I'll look into it. I need to check if usage of promises chains is correct in [apw](http://github.com/bem/apw) module first.\n. @happylynx `Q.all()` accepts single argument \u2014\u00a0array of promises. It is said [in the docs](https://github.com/kriskowal/q#combination).\n\nYour code should be:\n\n``` js\nvar q = require('q');\nvar promise = q.all( [q('a'), q('b')] );\n\n// try it\n\npromise.then(function(values) {\n    console.log('%j', values);\n});\n```\n. @umarashfaq So, what is your proposal?\n. @kahnjw I think it should be in a helper library\n. @ardumont @domenic We could do it like this: https://github.com/enb-bem/enb-bem-docs/pull/29/files\n. Or maybe we just need to add support for positional arguments\n. It could be replaced with:\n\n``` js\nvar promiseA = someSource;\nvar promiseB = anotherSource;\n\npromiseA\n    .then(function(res) {\n        return promiseB.thenResolve(res);\n    })\n    .then(continueWithA, dealWithRejection);\n```\n. @aadamsx You could use it like this:\n\n``` js\ndeffered.resolve([file, data]);\n\ndeffered.promise.spread(function(file, data) {\n   // ...\n});\n```\n. @domenic :+1: \n. I'm telling just about wrapped-callback-style functions that accept only js primitives or objects.\nCould you provide some example where passing promise will be legitimate?\n. @domenic Done. Could you please approve my post?\n. https://groups.google.com/forum/?fromgroups=#!topic/q-continuum/aJO8QkvnS8s\n. So we tested Q and [Vow](https://github.com/dfilatov/jspromise) on the high load and here are the results.\n\nThe mathematical expectation of response time on the load till 100 rps (\u00b1 sigma).\n![constant-load](https://f.cloud.github.com/assets/75247/30082/e1434282-4e0c-11e2-94a1-3bc1af24dc04.png)\nX \u2014\u00a0requests per second\nY \u2014\u00a0response time, ms\n\nThe mathematical expectation of response time on the constantly increasing load (\u00b1 sigma).\n![max-load](https://f.cloud.github.com/assets/75247/30083/e194f19a-4e0c-11e2-9c56-5f19d0431aef.png)\nX \u2014\u00a0requests per second\nY \u2014\u00a0response time, ms\n. @kriskowal Have a look at the results, please. We want faster Q ;)\n. @kriskowal The problem is that Q is functional by design, there are a lot of functions that are created (and collected) in the runtime. And this produces overhead. Here are the examples:\n- https://github.com/kriskowal/q/blob/master/q.js#L474-L476\n- https://github.com/kriskowal/q/blob/master/q.js#L673-L699\n\nVow is prototype based in it nature. There are no functions that are created in the runtime, so there is no overhead.\n\nCan we redesign Q code so it will be more prototype based than functional?\n. Should we reopen this issue? I changed the title.\n. Bower can use package.json also. The problem with component.json is that `npm version` command does not touch it.\n\n02.01.2013, 05:02, \"George Adams\" notifications@github.com:\n\n> I have added a component.json file, which is really just a simplified package.json file. This is what Bower uses to define a package.\n> \n> You can merge this Pull Request by running:\n>   git pull https://github.com/geowa4/q master\n> \n> Or view, comment on, or merge it at:\n> \n>   https://github.com/kriskowal/q/pull/161\n> \n> Commit Summary\n> \n>   adding component.json file for bower support\n> \n> File Changes\n> \n>   A component.json (6)\n> \n> Patch Links\n> \n>   https://github.com/kriskowal/q/pull/161.patch\n>   https://github.com/kriskowal/q/pull/161.diff\n> \n> ```\n>           \u2014\n> \n>           Reply to this email directly or view it on GitHub.\n> ```\n\n## \n\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0438\u0437 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u0439 \u042f\u043d\u0434\u0435\u043a\u0441.\u041f\u043e\u0447\u0442\u044b: http://m.ya.ru/ymail\n. I think that maintaining separate repo for this is not a good idea at all. I think we should simply add prepublish script that will generate component.json from package.json.\n\n03.01.2013, 05:41, \"Kris Kowal\" notifications@github.com:\n\n> @forbeslindesay Yes, you\u2019re welcome to add it to the README in the section describing supported platforms.\n> \n> ```\n>           \u2014\n> \n>           Reply to this email directly or view it on GitHub.\n> ```\n\n## \n\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0438\u0437 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u0439 \u042f\u043d\u0434\u0435\u043a\u0441.\u041f\u043e\u0447\u0442\u044b: http://m.ya.ru/ymail\n. So you should inspect the rejection object to get the reason. Some of your commands could be failing sometimes.\n\nQ is nothing to do here, there are no any limitations.\n\n24.01.2013, 09:28, \"Guan Qing\" notifications@github.com:\n\n> I want to running a lot of unix command a child process.\n> \n> For example:\n> \n> var Q = require('q');\n> var cp = require('child_process');\n> \n> function exec(cmd) {\n>   var deferred = Q.defer();\n> \n>   cp.exec(cmd, function(err, stderr, stdout) {\n>     if (err) {\n>     deferred.reject(err);\n>     } else {\n>     deffered.resolve(stdout);\n>     }\n>   });\n> \n>   return deferred.promise;\n> }\n> \n> function runAlotOfCommands(commands) {\n>   var promises = [];\n> \n>   commands.forEach(function(cmd) {\n>     promises.push(exec(cmd));\n>   });\n> \n>   return Q.allResolved(promises);\n> };\n> \n> In this case, if use runAlotOfCommands to run some commands, sometime it will be resolved, sometime it was rejected.\n> \n> Did I do something wrong, or, it is the limitation of promise?\n> \n> ```\n>           \u2014\n> \n>           Reply to this email directly or view it on GitHub.\n> ```\n\n## \n\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0438\u0437 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u0439 \u042f\u043d\u0434\u0435\u043a\u0441.\u041f\u043e\u0447\u0442\u044b: http://m.ya.ru/ymail\n. Cool addition!\n\n14.03.2013, 19:29, \"Keith Cirkel\" notifications@github.com:\n\n> It would be nice as part of the promise object to have a function which will parallel execute alongside the previous function, but also be part of the set of resolved functions, similar to a then().\n> \n> Consider the following:\n> \n> function doSomething(n) {\n>     var deferred = Q.defer();\n>     setTimeout(function () {\n>         deferred.resolve(n);\n>     }, 500);\n>     return deferred.promise;\n> }\n> Q.all([\n>     doSomething(1),\n>     doSomething(2),\n>     doSomething(3),\n> ]).spread(function () {\n>     console.log(arguments); // [1, 2, 3]\n> });\n> \n> This could be chained using a function, let's call this function and:\n> \n> doSomething(1)\n>     .and(doSomething(2))\n>     .and(doSomething(3)),\n>     .spread(function () {\n>         console.log(arguments); // [1, 2, 3]\n>     });\n> \n> Each chunk of code should be considered equal.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n\n## \n\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0438\u0437 \u043c\u043e\u0431\u0438\u043b\u044c\u043d\u043e\u0439 \u042f\u043d\u0434\u0435\u043a\u0441.\u041f\u043e\u0447\u0442\u044b: http://m.ya.ru/ymail\n. @domenic Have a look at this, please. It blocks us from moving to q 0.9.x.\n. @domenic @kriskowal Any progress on fixing this issue? It still blocks us from migration to q 0.9.x.\n. This was broken again in `q 0.9.6`\n. That brokes our code in [bem/bem-tools](https://github.com/bem/bem-tools), that utilizes thousands of promises.\n. @rkatic I'll look into it. I need to check if usage of promises chains is correct in [apw](http://github.com/bem/apw) module first.\n. @happylynx `Q.all()` accepts single argument \u2014\u00a0array of promises. It is said [in the docs](https://github.com/kriskowal/q#combination).\n\nYour code should be:\n\n``` js\nvar q = require('q');\nvar promise = q.all( [q('a'), q('b')] );\n\n// try it\n\npromise.then(function(values) {\n    console.log('%j', values);\n});\n```\n. @umarashfaq So, what is your proposal?\n. @kahnjw I think it should be in a helper library\n. @ardumont @domenic We could do it like this: https://github.com/enb-bem/enb-bem-docs/pull/29/files\n. Or maybe we just need to add support for positional arguments\n. It could be replaced with:\n\n``` js\nvar promiseA = someSource;\nvar promiseB = anotherSource;\n\npromiseA\n    .then(function(res) {\n        return promiseB.thenResolve(res);\n    })\n    .then(continueWithA, dealWithRejection);\n```\n. @aadamsx You could use it like this:\n\n``` js\ndeffered.resolve([file, data]);\n\ndeffered.promise.spread(function(file, data) {\n   // ...\n});\n```\n. @domenic :+1: \n. ",
    "utvara": "Sure, will post it there right now. \n. Great, tnx. \n. Sure, will post it there right now. \n. Great, tnx. \n. ",
    "rauschma": "My proposal: `createNodejsCallback`. Rationale:\n- Makes it obvious that a new object is created for each invocation.\n- `Callback` is more self-explanatory than `back`.\n- The same holds for `node` versus `nodejs`. Especially with the DOM, `node` can mean many things.\n- @domenic mentions `as` as an alternative to `create`. Another possibility is `resolveVia`:\n  \n  ```\n  deferred.resolveViaNodejsCallback\n  ```\n\nHaving a long identifier here is a feature (not a bug ;-), because that method is so powerful and does so much. Then we want its name to be descriptive.\n. I\u2019m arguing for two variants: `qcall` with `this`and `qfcall` without `this`. But having just a single variant (with `this`) is fine, too \u2013 the extra `null` is not a deal-breaker and people are already used to `Function.prototype.call`.\n\nDo you agree that it would be nice to add such a method to `Function.prototype`?\n. +1\n. Yes, I understand why you hesitate. More options:\n1. Use `Q` itself for calling:\n   \n   ```\n   Q(func, arg1, arg2, ...)\n   Q(obj, obj.method, arg1, arg2, ...)  // optional thisp as the *first* argument (obj vs. function)\n   ```\n   \n   The idea is to make things look as much like function calls and method calls as possible.\n2. Use Q to wrap a value, jQuery-style:\n   \n   ```\n   Q(func).ncall(arg1, arg2)\n   Q(obj.method).ncall(obj, arg1, arg2)\n   Q(obj, obj.method).ncall(arg1, arg2)  // not sure if this is a good idea\n   ```\n. Right. I still like the idea of putting `thisp` first, but it might confuse some people.\n\n```\nQ.nfcall(func, arg1, arg2, ...)\nQ.nfcall(obj, obj.method, arg1, arg2, ...)  // thisp as optional first arg (obj vs. function)\n```\n. My proposal: `createNodejsCallback`. Rationale:\n- Makes it obvious that a new object is created for each invocation.\n- `Callback` is more self-explanatory than `back`.\n- The same holds for `node` versus `nodejs`. Especially with the DOM, `node` can mean many things.\n- @domenic mentions `as` as an alternative to `create`. Another possibility is `resolveVia`:\n  \n  ```\n  deferred.resolveViaNodejsCallback\n  ```\n\nHaving a long identifier here is a feature (not a bug ;-), because that method is so powerful and does so much. Then we want its name to be descriptive.\n. I\u2019m arguing for two variants: `qcall` with `this`and `qfcall` without `this`. But having just a single variant (with `this`) is fine, too \u2013 the extra `null` is not a deal-breaker and people are already used to `Function.prototype.call`.\n\nDo you agree that it would be nice to add such a method to `Function.prototype`?\n. +1\n. Yes, I understand why you hesitate. More options:\n1. Use `Q` itself for calling:\n   \n   ```\n   Q(func, arg1, arg2, ...)\n   Q(obj, obj.method, arg1, arg2, ...)  // optional thisp as the *first* argument (obj vs. function)\n   ```\n   \n   The idea is to make things look as much like function calls and method calls as possible.\n2. Use Q to wrap a value, jQuery-style:\n   \n   ```\n   Q(func).ncall(arg1, arg2)\n   Q(obj.method).ncall(obj, arg1, arg2)\n   Q(obj, obj.method).ncall(arg1, arg2)  // not sure if this is a good idea\n   ```\n. Right. I still like the idea of putting `thisp` first, but it might confuse some people.\n\n```\nQ.nfcall(func, arg1, arg2, ...)\nQ.nfcall(obj, obj.method, arg1, arg2, ...)  // thisp as optional first arg (obj vs. function)\n```\n. ",
    "ForbesLindesay": "How do you use LongMueller?  I can't find any docs\n. Looks like a nice API :)  I take it the intention is not to standardise at all on what args to use (or even how many args) in a progress notification?\n\nThere's an interesting related case of transferring meta information.  For example if you use the request library to make a web-request, you get a response, but you also get an object containing headers etc. I'm not sure whether meta handling makes sense to be handled in a special way within Q.\n. > Indeed, although I was inclined to maybe standardize on a single arg. Dunno.\n\nI'm inclined to agree with standardising on a single arg, that makes it a closer match to the other callbacks.\n\n> I don't really see it. I'd return a promise for { headers, response }, which is still a single object.\n\nI guess that makes sense, and that's what I'm looking at doing at the moment for my APIs, but it's a surprisingly common use case, and although I'm not sure if Q should add any library functionality to support this, perhaps there should be some kind of recommendation for whether we go for `{ metadata, body }` or `metadata` as a property of the body then just return `body` or something else entirely.\n. Fair enough, I guess what you've described is the parallel with synchronous methods.  I was attempting to draw a parallel with non-promised asynchronous methods.  It's common in such scenarios to have the callback take more than 2 arguments so that it becomes `callback(err, meta, result)` or `callback(err, result, meta)`.  I think you're right to place higher importance on keeping the parallels with synchronous APIs strong though.\n. What does WinJS do?  I thought they just made their functions take a `cancellationToken` argument and that it had nothing to do with the promises/tasks returned?\n. Would it be possible to listen for just rejections which happen with nobody to observe them?  i.e. can you tell when a promise has been observed properly.  If so then this would seem like a  great plan, as you could very quickly write a basic system to ensure errors never go un-observed, and could build more complex (and awesome) debuggers later.\n. promise.when is not really the primary intended method for resolving a promise, instead you should really use either:\n\n``` javascript\npromise.then(onResolved,onRejected);\n//or\nQ.when(promise, onResolved, onRejected);\n```\n\nHowever both these exhibit the same behaviour, so that's not the problem.  I've submitted a pull request which fixes this, but since makePromise is an advanced feature, I'll have to defer to the author for how it's meant to be used.\n. I do really like the idea of sticking to the natural choices of words, I think it might be a nice idea to go with something like Q(promise).then though as the static version, that way they'd both be then.\n. As I understand it (from reading the code, not from seeing any spec) when you call `promise.promiseSend('when',onResolved, onRejected)` it gives your implementation a callback to call when there's an error, which would trigger the bottom of the 3 cases, but if you return a promise which resolves to an error, it calls both the top two cases (before my fix)\n. Still hadn't been resolved as far as I know?  It doesn't directly affect me, but we should probably look to get this fixed.\n. beyond working out that this change would fix it, I'm not really that sure what's going on, I think some work may need to go into refactoring at some point :s\n. For a well behaved promise, does it actually make a difference whether they're resolved in serial or parallel?  I would envisage error handling code for arguments having to sit outside the function:\n\n``` javascript\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    // ...\n}).fail(function(err){\n    //error recovery for rejected parameters\n});\n```\n\nbut error recovery is a good argument for doing it the manual way, I hadn't thought of that.\n. I like the idea of having a separate Q.promised function, it should be simple enough to wrap\n\n``` javascript\nvar function = Q.promised(Q.async(function* (arg1, arg2){\n\n}));\n```\n\nSo I think that's a good solution.  Remote objects are a very different scenario.  My initial thought would be to stick to the current get, invoke etc. but let people easily extend that by adding their own functions which just call into those base functions.\n\nIf you're looking at processing lists, I think it's well worth considering libraries like Reactive Extensions.  Lists are very different to promises, and if we want to do work on remote lists and apply things like remote filter functions, we should consider a separate library (and learn from things like LINQ to SQL).  I do think many of these libraries may benefit from an 'all' method, which returns a promise for the complete list/stream returned as an array.\n\nJust my 2 cents worth.\n. Depreciate is now gone completely.  Spacing now matches the rest of the file.  Double quotes now used throughout.  All tests still pass.\n. How about replacing everything from ' and the following libraries are based on Q.' to 'use Q inernally or provide Q promises.' with something like:\n\nand there are many libraries that produce and consume Q promises for everything from file system access or RPC to templating.  For a list of some of the more popular ones, see [Libraries](https://github.com/kriskowal/q/wiki/Libraries).\n\nI guess the key here is to keep in mind that the readme file needs to sell Q, whereas the wiki needs to give useful links and info.  So the question becomes, what would help sell Q?  [Passport](https://github.com/jaredhanson/passport) really sells itself with a huge list of login strategies, perhaps a similarly huge list of libraries might help sell Q?\n. OK, here's a suggestion, I think Q is drastically under-publicised at the moment.  I think it's a really cool library, that really does help the async problem.  I think that's no more true than when you look at the solution that will be possible in the future when the `yield` keyword works everywhere.\n\nI think one really effective way of getting some publicity would be for one of us to submit a fairly short article to http://thechangelog.com about Q, and potentially mentioning some of the more useful libraries that go with it.  That would drive a lot of publicity, and more users will mean that we're more likely to end up as the defacto implementation of promises in the future.\n\nI think before we do that we probably want to tidy up the documentation as much as possible though, and try and close/deal with as many of the open issues as possible.  Having old open issues may make our project look un-maintained, which isn't the case.\n\nI think it's probably worth creating a static web-site in gh-pages for documentation.  I'm happy to try and create this if people agree with me?  It would allow for much more in the way of cool formatting and navigation menus.  We could also try and create a very succinct and bold landing page, that gets across the key purpose of Q.  We could also purchase a url.  q.io was available last time I looked, but .io domains are quite expensive.  Alternatively something like qpromise.org?\n\nWe could have a shared twitter account for Q as well, it could be used to publicise the library by answering async related questions in twitter, as well as for notifications of changes to the api?\n\nIf you think I'm being stupid/too enthusiastic, feel free to shoot me down and give me a healthy dose of realism?\n. So it would call `next(null, promiseValue)` if promise just exited normally?  I guess some might exect that behaviour, whereas my suggestion only really applies to express, hmm.\n. ah, yeh I like that suggestion, both for a node-end and for a `.end(callback, errback)` assuming both could be null/undefined.  For a node end, a really nice pattern could then be:\n\n``` javascript\nfunction usePromisesIfYouWant(in, cb) {\n    return promisedAPI(in).endNode(cb);\n}\n```\n\nThat way if cb is undefined, we return a promise for someone to use, but if it is defined, we call it in the normal node style.\n. If we agree that both these methods would be useful `end` and `endNode` then shall we add some tests and code and get implementing?\n\nCan we agree what the methods should be called?  I think `end` is fairly obvious, but `endNode` or `nodeEnd` ?  Neither is perfect, but neither is terrible so I'm open to suggestions personally.\n. +1 for done over end if it matches other libraries\n. We could do `done(callback, errback)` and `end(nodeCallback)` ? \n. Yes, although `.fail(function () {}).end()` would silence all errors, nothing can guarantee errors are never silenced.  The key point is that `.nend(function (err) { if (err) throw err;})` would not silence the error.  On the other hand, I'm happy to keep things moderately verbose if that makes it clearer what's going on, so perhaps `.nodeCallback` or we could go for `.ndone` as it's very similar to the new `.done` method\n. Should it be:\n\n``` javascript\nwhen(promise, fulfilled, rejected).fail(onUnhandledError);\n```\n\ninstead of:\n\n``` javascript\nwhen(promise, fulfilled, rejected || onUnhandledError);\n```\n\nThe idea is to throw exceptions even if they happen in the fulfilled or rejected handlers.\n. And another for 'when the promise is rejected, and the errback throws, it should rethrow the error in the next turn'\n. How does this relate to `nend` etc. ?\n. I do like the idea of having an easy way to make my public interfaces directly support node-style and promise-style use just by either passing or not passing a callback.\n. +1 for `supportNode`\n+1 for `nodeify`\n+0.5 for `toNodeback`\n\nIn the use case described of \"I wish to expose an api that's familiar to people used to node style callbacks\" I'd go with `supportNode` as the hands-down winner.\n\nFor the alternative case of working with things like express.js where you must call a callback as a node.js callback, it seems a little counter-intuitive to call it `supportNode`, which makes me favour something like `nodeify`.\n\n`toNodeBack` seems nice and un-offensive, but could be confused with Deffered's makeNodeResolver.\n. Are we agreed on the functionality of this?  I'm happy to implement and test this.\n\n``` javascript\nQ.promised = function (fn) {\n    return function() {\n        return Q.all(arguments).spread(fn);\n    };\n}\n```\n. I agree we need to pass `this` on, my mistake, should we treat `this` as a promise though?  I wasn't thinking that we would?:\n\n``` javascript\nQ.promised = function (fn) {\n    return function() {\n        return Q.all(arguments).spread(fn.bind(this));\n    };\n}\n```\n\nor\n\n``` javascript\nQ.promised = function (fn) {\n    return function() {\n        return Q.all([this, Q.all(arguments)]).spread(function (self, args) {\n          return fn.apply(self, args);\n        });\n    };\n}\n```\n. Fair enuf, the question remains as to whether we want to resolve `this` as a promise, the alternative code now looks like:\n\n``` javascript\nQ.promised = function (fn) {\n    return function() {\n        var self = this;\n        return Q.all(arguments).then(function (args) {\n            fn.apply(self, args);\n        });\n    };\n}\n```\n. I guess I don't really have a good reason not to, just thought we should consider which is right, as we'll want to keep the api stable so won't want to change this.  If nobody has any further issues, lets treat `this` as a promise and resolve that too.\n. Also, how about an `npromised` function that would essentially look like:\n\n``` javascript\nnpromised = function (fn) {\n  return promised(nbind(fn));\n}\n```\n. I like that idea.  It's confusing to have a library log something when absolutely nothing's wrong.  It also makes the behaviour different on node.js\n.  Are we close to being ready to push this now?\n. I've just downloaded from master, and I don't get the same error there, but I still get poor behaviour.\n\nWith the same code posted above, but modified to use q at master, I get:\n\n```\nC:\\src\\q-master\\q.js:1354\n            throw error;\n                  ^\n[object Object]\n```\n\nIf I change the code to:\n\n``` javascript\nvar Q = require('./q-master');\nfunction CustomError() {\n    this.name = 'CustomError';\n    this.message = 'Foo Bar Foo';\n}\n\nQ.when(null, function foo() {\n    throw new CustomError();\n}).end();\n```\n\nI get:\n\n```\nC:\\src\\q-master\\q.js:1354\n            throw error;\n                  ^\nCustomError: Foo Bar Foo\n```\n\nAnd nothing I can seem to do will bring back that missing stack trace (except changing it back to a native error).\n. I've tried setting the prototype:\n\n`CustomError.prototype = Error.prototype`\n\nAnd using util.inherits:\n\n`require('util').inherits(CustomError, Error)`\n\nAnd neither make any difference.\n. Ah, just worked out, you have to call `Error.captureStackTrace(this, this.constructor)` to get a stack trace for an error.  I wonder whether Q could help people out by attaching a stack trace even when one wasn't originally present though.\n. fixed :)\n. Done, hopefully all ready to merge now.\n. lol, ok, I'll try and keep JAM as in sync with npm as I can :)\n. Have an app that has to  run a task once a day as a cron job so we catch all errors and just log them.  I want a way to log them with their extended stack traces but without terminating the process.\n. I'm not sure.  A global handler is different, because there may be some exceptions I want to handle separately, so I'm not sure if a global error handler works.  I still want to do stuff after logging the error.  I need to have a but more of q look at the global error handler proposal before I can be sure.\n. If you force non-valueOf methods to resolve in the next turn of the event loop that can be very expensive when promises are resolved synchronously.  I like to build as much as possible of my libraries to be OK with being given promises, so often they're given resolved promises, or plain old values.\n. That's allso usually my experience.  I agree that we need to exercise caution with bloating the library.  I wonder if we could split it into two files (Core and Extensions)?  I think 2 modules would be a shame, I'd always end up requiring in extensions, but I think it would be nice when reading the code to see just the stuff that's needed for promises as a separate thing to all the cool stuff that makes the api look nice.\n. See #130\n. Generally you shouldn't minify libraries when making pull requests as it makes your changes harder to merge with other changes that may have happened at the same time.\n\nWe discussed this issue in #88.  The problem is that you do need to log when there's an error, so there needs to be a log when the first error occurs if we're going to take this log out.\n. If we had a Q debug we could provide options to automatically end all promises that don't get used after a couple of seconds.  We could also timeout promises automatically.\n. This is proving to be quite a complex issue.  I'd almost be inclined to require users to be explicit about what progress gets forwarded and how it gets forwarded.\n. What about code using `Q.defer()`...how does that work with arbitrary resolving code.\n. Something like the following, where `request` hasn't done anything specific to be domain aware?\n\n``` javascript\nvar error = new Error(\"should be caught by the domain\");\nvar d = domain.create();\n\nd.run(function () {\n    callAsync().done();\n});\n\nvar errorTimeout = setTimeout(function () {\n    done(new Error(\"Wasn't caught\"));\n}, 500);\n\nd.on(\"error\", function (theError) {\n    expect(theError).toBe(error);\n    clearTimeout(errorTimeout);\n    done();\n});\n\nfunction callAsync() {\n    var def = Q.defer();\n    request('https://www.google.com', function (err, res) {\n        def.reject(error);\n    });\n    return def.promise;\n}\n```\n\n(I haven't actually tried this)\n. So the test case (which we suspect fails) could look like:\n\n``` javascript\nvar error = new Error(\"should be caught by the domain\");\nvar d = domain.create();\n\nvar e = new require('events').EventEmitter\n\nd.run(function () {\n    callAsync().done();\n});\ne.emit('beep');\n\nvar errorTimeout = setTimeout(function () {\n    done(new Error(\"Wasn't caught\"));\n}, 500);\n\nd.on(\"error\", function (theError) {\n    expect(theError).toBe(error);\n    clearTimeout(errorTimeout);\n    done();\n});\n\nfunction callAsync() {\n    var def = Q.defer();\n    e.once('beep', function () {\n        def.reject(error);\n    });\n    return def.promise;\n}\n```\n\nP.S. I hadn't been referring to @mikeal's request library, but rather a generic, badly behaved request method that retrieved something from a web-server.\n. The only thing I can think of is assimilating poorly behaved promises (where poorly behaved means they don't work with domains)\n. :+1: \n. Must've been half asleep, give me a moment...\n. Tests added\n. Personally I'm not really a fan of adding progress as a third argument to `.then()`.  If we instead treated it as a totally separate `.progress(progback)` that might open up completely different options with regards to error handling.  In the once case where I've had to deal with progress so far (when using promises) I did so by having my promise also be an event emitter and emit a `progress` event, which just let exceptions throw.\n. My two cents:\n\nseparate propagation from handling.  The propagation API is then `.then(callback, errback, progressPropagator)` and is just there to transform the progress.  I'm not sure what the best bet is here, but I'm not totally against it being thrown in nextTick.\n\nWe should then discourage actually handling progress in the propagation handler, and instead have a separate `.progress(cb)` which should just throw in next tick and return undefined.\n\nAs an alternative, axe propagation handling from promises altogether (except the most basic case).  Instead, just forward progress evens if the `progressPropogator` is `true` and drop them if it's `false`.  That takes care of the case:\n\n``` javascript\nvar json = request('foo.com/file.json')\n  .then(function (res) {\n    return JSON.parse(res);\n  }, null, true);\n```\n\nBut ignores the case:\n\n``` javascript\nvar res = asyncOpA()\n  .then(function (res) {\n    return asyncOpB(res);\n  }, null, false);\n```\n\nAt that point we just say \"You're on your own\".  But we let people do the propagation manually like so:\n\n``` javascript\nvar opA = asyncOpA();\nopA.handleProgress(progressA);\nvar res = opA\n  .then(function (res) {\n    var opB = asyncOpB(res);\n    opB.handleProgress(progressB);\n    return opB;\n  }, null, false);\n\nfunction progressA(val) {\n  res.emitProgress(val / 2);\n}\nfunction progressB(val) {\n  res.emitProgress(0.5 + val/2);\n}\n```\n\nThe idea here is to do exactly what event emitters do, let an outside party add progress events into a promise, so that the consumer of a promise can still choose to make the promise emit progress events even if it wouldn't do so naturally.\n\nThis has other nice use cases.  Consider the case that you're given an API that returns promises, which don't support progress, but where you know approximately how long each async operation takes, you could add progress with something like:\n\n``` javascript\nfunction addProgress(promise, expectedTime) {\n  var start = Date.getTime();\n  var int = setInterval(function () {\n    promise.emitProgress(Math.min((Date.getTime() - start) / expectedTime, 1));\n  }, 100);\n  promise.then(function () {\n    clearInterval(int);\n  }, function () {\n    clearInterval(int);\n  });\n}\n```\n. Is this fine with Promises/A+ promises, which don't always have a valueOf function?\n. Ah, I didn't realise it existed on object.  That makes sense of how it was originally coded.  Perhaps we should specify that `valueOf` displays this behaviour (if provided) in promises/A+  e.g.\n\n`promise#valueOf` should either return `this` or the value a promise was fulfilled with.  It is free to return `this` even on a fulfilled promise, so the default implementation provided by `Object.prototype` is sufficient.\n. Yes, but we still wouldn't get the original site where the string was thrown, I'm not sure how much help it would be...Ideally I'd like the JavaScript spec changed so that throwing a string gives the compiler permission to re-format your hard-drive (provided you were the author of the function that throws).\n. Good grief, you are ambitious @thesmart...I had no intention of attempting to stop people shooting themselves in the foot with JavaScript, there are loads of ways for them to do that.  I just wish there was a way to stop other people shooting **me** in the foot with JavaScript.  The most common way they seem to do it is by throwing strings/numbers/plain objects without stack traces.\n. I use that pattern all the time, and it serves me well.  To make it equivallent to the original example you need to do:\n\n``` javascript\ngetEmail(...)\n    .then(function(email) {\n        return Q.all([ email, getUserInfo(email) ]);\n    }).spread(function(email, user) {\n        return {email: email, user: user};\n    });\n```\n\nwhich I assumed you felt was too clunky.  It can be a little clunky and a deep-resolve would probably be useful in more complex scenarios.\n. Hmm, that would make Q.all unusable in QEJS because it makes the performance unbearable.\n\nHow about changing isFulfilled so that it's interoperable?  We don't want to change `isPromise` because other parts of the library already use that to mean 'is a Q promise'.\n\n``` javascript\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    var val = valueOf(object);\n    return !(val && typeof val === 'object' && typeof val.then === 'function');\n}\n```\n. Thanks\n. Why would it deprecate the promised wrapper?\n. doesn't it make `fbind` equivalent to `promised`? since `nfbind` also adds a callback function.  Good point though.\n. I'm definitely :+1: for this then.\n. If you make it:\n\n``` javascript\n{\n  \"name\": \"q\",\n  \"repo\": \"kriskowal/q\",\n  \"version\": \"0.8.12\",\n  \"dependencies\": {},\n  \"scripts\": [\"q.js\"],\n  \"main\": \"q.js\"\n}\n```\n\nIt would work for [component](https://github.com/component/component) as well as bower.\n. OK, I'll maintain it as https://github.com/microjs/q so could we put a note somewhere in the readme to point out that it's available there as a component?\n. The justification (whether you agree with it or not) is that client side packages require sufficiently different description to server side packages to merit a different file name.  If you're going to avoid having a separate database you also ideally need to keep listings of all scripts in the description file, so that you don't have to scan the repository for files to download.\n\nIf any of the package.json based package managers were anywhere nearing suficent for use on the client then I'd agree but at the moment that's not the case.  The component one is the only one that seems to have struck upon a format that actually has enough information.  By listing all the scripts and their purpose, it becomes stupidly easy to build your own program to consume that format.\n. Agreed, I'm happy to discuss elsewhere.  I've added a pull request to update the readme and will maintain the microjs fork fo component + bower support until a better alternative arises.\n. nope, I no longer use component since browserify has been updated to work on Windows.  I have no further interest in supporting JavaScript package managers other than npm.\n. `IsResolved` fits better with what actually happens when you take into account third party promises though.  I.e. if it's true then the promise **is** resolved, but it it's false it could still be a resolved third party promise.\n. I'm essentially a +0 for this, but the down side I see with it is as follows.\n\nThe results of calling isResolved/isPending on a foreign promise:\n\n``` javascript\nQ.isResolved(foreignPromise);//always false\nQ.isPending(foreignPromise);//always true\n```\n\nIdeally a resolved foreign promise would return `true` for `isResolved` and `false` for `isPending`.  So in both cases it's not \"correct\" (by which I mean it doesn't fit with intuition).  Saying `false` when you should say `true` seems less wrong than saying `true` when you should say `false`, because `true` in natural languages implies much greater certainty than `false`.\n\nIt's a fairly week objection though.\n. When would you choose this over done?\n. So you'd use it when you wanted to provide an API of `do(cb, eb)`?\n\nSeems like an odd thing to do.  jQuery does it, but not much else and it's pretty universally a pain to work with.\n. I would ideally like to support all promises that define `.valueOf()` to return the current value when `fulfilled`\n. `.valueOf` is fine if you only call it on promises.  We got stung before, but that was an easily fixed mistake.  The advantage of `valueOf` is that you don't need to check for its existence.  You always need to check things are promises because e.g. calling a method `.nearest()` would be a very reasonable thing when talking about points on a graph.\n. We really want the `.then` check to be the only thing that might cause us to falsely treat something like a promise, we don't want to add things like `.nearest` or `.mostResolved`\n. My point is that we have:\n\n``` javascript\nif (isPromiseLike(val) && typeof val.nearer === 'function') {\n  return val.nearer();\n} else {\n  return val;\n}\n```\n\nor\n\n``` javascript\nif (isPromiseLike(val)) {\n  return val.valueOf();\n} else {\n  return val;\n}\n```\n\nThe second one is a slight bit neater.  Either way, this should probably be discussed with the entire promises-a-plus community, since it's effectively a defacto standard.\n. There's a typo in your naming of functions (depths vs bowels). It would be helpful if you could prevent q from gathering stack trace info for a specific jump (e.g. Within a library like QEJ)\n. I suppose it would.  Ideally it would be nice to be able to 'skip a step'\n\n``` javascript\n//the stack up to here matters\n\nPromise.then(function (){\n  //this stack doesn't matter\n}).then(function(){\n  //this stack matters\n  throw new Error('foo')\n})\n```\n. `spread` can also be used in the same way as then:\n\n``` javascript\nQ.resolve([oneP, twoP, threeP])\n  .spread(function (one, two, three) {\n  });\n```\n\nJust replace `then` with `spread` wherever you want this behavior.\n. I've answered the stack overflow question, but to duplicate here:\n\n`return function(){withCB(arguments[1])}` is not a legal way of using a promise library.  As detailed in [the promises spec](http://promises-aplus.github.com/promises-spec/) that Q aims to comply with, anything you return from a `.then` callback that is not a promise should be passed directly through.\n\nEssentially callback based code should be treated as `legacy` when you're using promises.\n\nYou have two basic options.  If you use funcWithCallback lots of times you can do something like:\n\n``` javascript\nvar promisedFunc = Q.nfbind(funcWithCallback);\n\nsomePromiseFunc(value1)\n.then(function(value2) {\n    return promisedFunc();\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n\nor if you need to pass arguments:\n\n``` javascript\nvar promisedFunc = Q.nfbind(funcWithCallback);\n\nsomePromiseFunc(value1)\n.then(function(value2) {\n    return promisedFunc(value1, value2);\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n\nIf you're only using it once you can do\n\n``` javascript\nsomePromiseFunc(value1)\n.then(function(value2) {\n    return Q.nfcall(funcWithCallback);\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n\nor if you need to pass arguments:\n\n``` javascript\nsomePromiseFunc(value1)\n.then(function(value2) {\n    return Q.nfcall(funcWithCallback, value1, value2);\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n. P.S. I can't make what you say works work:\n\n``` javascript\nvar Q = require('q');\n\nQ.resolve(null)\n  .then(function (v) {\n    return function(){arguments[1](null, 'foo');};\n  })\n  .then(function (v) {\n    console.log(v);\n  })\n```\n\nlogs `[Function]`\n\nCan you provide a complete example that fails so the bug can be fixed?\n. You will get stack traces if and only iff you throw real exceptions (i.e. `throw new Error('message')` not `throw 'message'`) and you either throw in the next tick or call `.done` at the end of your promise chain.\n\n``` javascript\nasyncOpThatMightThrow()\n  .then(function (res) {\n    //do something with the result if successful\n  })\n  .done();//makes sure error isn't silenced\n```\n\nis approximately equivalent to:\n\n``` javascript\nasyncOpThatMightThrow()\n  .then(function (res) {\n    //do something with the result if successful\n  })\n  .then(null, function (err) {\n    setTimeout(function () { //make sure the error isn't silenced\n      throw err;\n    }, 0)\n  });\n```\n. If you want to escape the error handling that's built into Q.\n\ni.e.\n\n``` javascript\nvar promise = doSomething()\n  .then(function () {\n    throw new Error('foo');\n  });\n\n//some time later...\n\npromise.then(null, function (err) {\n  console.log('there was an error: ' + err.message);\n});\n```\n\nThe above only works because Q traps errors in callbacks (and errbacks) and stores them to be handled later.  Since Q has no way of knowing whether or not you're going to handle the error (it's not a computable question in the general case), it must save the error for later in case you handle it.  As such you don't get told that there was an error until you explicitly handle it.\n\nCalling `.done()` on a promise is essentially saying \"I'm done handling errors, so if there are any left you should throw them and crash the app.\"  If you do that then Q will make sure to throw the error for you.\n\nThe golden rule of Q promises is that you must always either return the promise (so someone else can call done) or call `.done()`\n\n``` javascript\nfunction goodA() {\n  return doAsyncWork()\n    .then(function (res) {\n      console.log(res);\n      return res;\n    });\n}\nfunction goodB() {\n  doAsyncWork()\n    .then(function (res) {\n      console.log(res);\n      return res;\n    })\n    .done();\n}\nfunction goodC() {\n  doAsyncWork()\n    .done(function (res) {\n      console.log(res);\n      return res;\n    });\n}\nfunction badA() {\n  doAsyncWork()\n    .then(function (res) {\n      console.log(res);\n      return res;\n    });\n}\nfunction badB() {\n  doAsyncWork()\n    .then(function (res) {\n      console.log(res);\n      return res;\n    })\n    .then(null, function (err) {\n      reportError(err);\n      //what if reportError throws an error.\n    });\n}\n```\n. One error with:\n\n``` javascript\n.then(function(value2) {\n    return q.nfcall(mysql.client.query, query, [lang_code, autocomplete]);\n})\n.then(function(err, results, fields) {\n    if (err) {\n        throw err;\n    }\n    // Have a party\n})\n.done();\n```\n\nIs that you don't do error handling like that in Q.\n\n``` javascript\n.then(function(value2) {\n    return q.nfcall(mysql.client.query, query, [lang_code, autocomplete]);\n})\n.spread(function(results, fields) {\n    // Have a party\n}, function (err) {\n   // Handle error\n})\n.done();\n```\n\nor\n\n``` javascript\n.then(function(value2) {\n    return q.nfcall(mysql.client.query, query, [lang_code, autocomplete]);\n})\n.then(function(args) {\n    var results = args[0], fields = args[1];\n    // Have a party\n}, function (err) {\n   // Handle error\n})\n.done();\n```\n\nare preferred\n. You kind of can, but you \"plug that callback in\" by using `Q.nfinvoke` and friends. And it only works if they follow the node.js pattern of using error as the first argument.  And if they have more than 2 arguments then you get an array as you results.  But you can use `spread` to fix that.  Mostly for things like mysql your going to end up with some sort of wrapper anyway because you're going to want to do connection pooling and logging.  Mine looks like:\n\n``` javascript\nmodule.exports.update = update;\nfunction update(str, values) {\n  var def = Q.defer();\n  pool(function(connection, done) {\n    var log = debug.time();\n    connection.query(str, values, function(err, rows, fields) {\n      var debugI = 0;\n      log(str.replace(/\\?/g, function (_) {\n        return JSON.stringify(values[debugI++]);\n      }));\n      if (err) def.reject(err);\n      else def.resolve(rows);\n      done();\n    });\n  });\n  return def.promise;\n}\n```\n\nMost of which is connection pooling and logging rather than handling the callback/promise divide.\n. This seems pretty specific to your use case. It would be pretty cool to have a giant system that let you say `\"Step 5 depends on the output of Step 4 and Step 3.  Step 3 depends on the output of Step 2.  Step 4 depends on the output of Step 2 and Step 1.\"  At which point it would run Step 1 and Step 2 in parallel, passing the results to Step 3 and Step 4 which it would run in parallel and pass the results to Step 5.\n\nQ has to draw a line in the land somewhere though, so I think this is probably over that line.\n. Running it again this seems to work fine.  The error appears to be intermittent.  Could there be a race condition somewhere in the unit testing framework?\n. Style now fixed as per @domenic's request\n. Oops, I've added them now\n. You can just do:\n\n``` javascript\nQ.nextTick(function () {\n  deferred.notify(args);\n});\n```\n\nbut you don't need to, the issue is that progress can't be emitted once the promise has been resolved, so you have to delay resolution until people have had a chance to see the progress.  delaying progress will just make the problem worse again.\n. Because if you actually do some asynchronous work then you won't see any of these problems.  \"progress\" is only meant for \"progress\" on asynchronous jobs.  As such if it completes before anyone starts listening for progress, why bother sending any progress.\n. I'd be inclined to have an option `denodeify` (I wonder whether a better name could be found) that doesn't accept any additional arguments, but probably accepts an optional `this` (not a `thisp`).  The only reason I ever use these things is to turn 'legacy' node APIs into promised APIs, so I only ever do the bare minimum.\n\n``` javascript\nvar readFile = Q.promise(fs.readFile, fs);\nvar readFile = Q.promise(fs, 'readFile');\nvar readFile = Q.denodeify(fs.readFile, fs);\nvar readFile = Q.denodeify(fs, 'readFile');\n```\n. It annoys me every time I come to use `fs.exists` that I can't do `Q.nfbind(fs.exists)`.\n. It's not that, exists is \"special\" because it doesn't have a node style callback syntax:\n\n``` javascript\nfs.exists('path-to-file', function (exists) {\n  //win\n});\n```\n\nnot\n\n``` javascript\nfs.exists('path-to-file', function (err, exists) {\n  if (err) throw err;\n  //win\n});\n```\n. Interesting, thanks for that link @medikoo.  It would be good if that stuff was included in the node.js API docs.\n. We still have the same problem with `rl.question(query, callback)` though.  That's still 'unstable' so we really should do something about it now.  Do you know if there's an issue open anywhere?\n. +1\n. Can't really comment on what test runner to use as the only one I've tried extensively is Mocha (which I wish had native non-hacky support for promises).  As for browser-ci I run http://jepso-ci.com which is fairly beta at the moment, and doesn't yet report **why** tests failed, but I've already done an integration of Q in [this repo](https://github.com/jepso-ci-examples/q) which produces the following badge:\n\n[![build status](https://jepso-ci.com/jepso-ci-examples/q.svg)](https://jepso-ci.com/jepso-ci-examples/q)\n\nI'm happy to also integrate it with whatever you migrate to after jasmine.\n. P.S. jepso-ci is based off of the sauce-labs on-demand service.\n. You do have the option of `Q.nfbind(myObject.myMethod.bind(myObject))`\n. :+1: from me\n. Promised currently causes a few extra calls to `nextTick` which may be worth attempting to optimize out if we're going to be using it a lot.\n\nI'm broadly in favor of using it everywhere though.\n. True, fine with me.  proxy.jepso-ci.com aims to do a lot more than rawgithub.com, but none of the extra stuff it does is actually needed for this specific use case.  Regardless of which provider, would be nice to see the link.\n. Looking at this I can't help but feel we should just use a separate `next-tick` library.  There already is one, but it doesn't do any of this clever trampolining stuff.  I just feel it's not at all specific or unique to Q that we have this requirement.\n\nThe downside would be that it wouldn't be dependency free by default, but we could use `browserify` to generate a dependency free version.  It has a `--standalone` option that outputs a complete UMD wrapper that's actually based off the UMD wrapper in this repository (I used this repo as my starting point for building [umd](https://github.com/ForbesLindesay/umd)).\n\nWe could then just build the standalone one:\n\n```\n$ browserify q.js --standalone Q > q-standalone.js\n```\n\nand then minify\n\n```\n$ uglifyjs q-standalone.js > q.min.js\n```\n\nThe browserify headers are actually a very small overhead in the latest version.\n. I was suggesting a separate `next-tick` library controlled by @kriskowal or someone else similarly invested in q, not just a generic one.  It can be a highly specialized one that pretty much states its aims as \"implement a next-tick that meets the requirements of promise libraries\".  My point is that there are tonnes of different promise libraries out there and I'd happily change `then` to use Qs `next-tick` implementation, since it's faster than what we're using in lots of situations, but I don't want to just copy and paste it.\n. I agree, Q's needs should come first.  My point is simply that as I see it Q's needs are:\n1. The highest priority next-tick possible\n2. Still breaks up the stack to avoid stack overflow\n3. Errors in one handler don't interact with other handlers (e.g. in the browser or when there's a global error handler present).\n\nI imagine there are quite a few applications of such a function.\n. For reference, https://github.com/ForbesLindesay/umd/blob/master/template.js is the template used to generate browserify's UMD wrapper.  I've mostly copied the logic from here anyway, so hopefully it should work.  `source()` gets replaced with `return module-export`.  `{{camelcase}}` and `{{pascalcase}}` would be replaced with `Q`.  `{{name}}` would be replaced with `q`.\n. I think that's the idea.  Although it's not just for outsourcing.  It's also because nextTick will be useful to other libraries that don't depend on Q\n. @AlexGalays we're not talking about making parts of Q optional here.  We're talking about splitting out the parts that would be useful for other libraries so that you can use them on their own.\n\nOne option would be to modularize it to the extent of having a \"Q core\" that could be the minimum to get things working.  I don't think that would necessarily be that useful though.\n. I still think I like that idea better than anything else I've tried.  I've not had a chance to experiment with it but returning a promise from the `triggerProgress` method makes it easy to ignore, crash or reject.\n\nI still think making progress handlers deal with the errors thrown by other progress handlers is downright weird.  I think I prefer crashing to that option.\n. I'd be keen for that too, just wanted to get the ball rolling :)\n. cool, browserify would be pretty much equivalent (it uses umd internally) so that sounds like a good idea.  I haven't really looked at the Closure Compiler.\n. I'd love to have UMD support montage require as well as possible.  I don't really want to just make it take completely arbitrary templates though, I'd prefer to have it take an options object in place of the current `commonJS = false / true` option.  This way we could make exposing it to SES optional and also add the option to override the name on a case by case basis (e.g. for Montage).\n\nThe key thing for me is maintaining a \"best effort\" approach when given a module and a CommonJS style name (possibly with extra capitalized letters).  At some point soon I'd like to build a \"browserify CDN\" that would provide browserify modules already wrapped in UMD modules to make it super easy to use any npm module on the client even without browserify.\n\nThe hope then would be to have modules like Q not include any of the build output in the repository (which I consider to be the wrong place for such output) but instead just link to an automatically generated build.\n. OK, I'm up for removing montage and SES from umd if they're not generally applicable.  It sounds like it might be best to have a custom script that takes a CommonJS module or a UMD module and adds montageRequire/SES exports?\n. It's about time I started converting my GitHub API experience (which has grown fairly extensive) into useful modules.\n\nFirst up, [github-basic](https://github.com/ForbesLindesay/github-basic) provides a really simple API for github via `github.json` where response.body is parsed JSON response.  This is based off of an internal method in the [github](https://github.com/mikedeboer/node-github) module which I liked, but found was way too high level as a starting point.  What you want is something where you can easily read the docs for a method, and then call it.\n\nNext up will be a method for forking, committing, and submitting pull requests.\n. OK, [pull-request](https://github.com/ForbesLindesay/pull-request) is now released.  It has a nice set of unit tests and should provide a great starting point.\n\nAll the promises are Promises/A+ compliant and use the [promise](https://github.com/then/promise) library (mostly a subset of Q).\n\nWith the current API, the code should look something like the following.  It should be noted that I've only just built this module and it's currently 6am so I'd really welcome advice on improvements to the API.\n\n``` js\nvar pr = require('pull-request')\nvar options = {auth:{fill this in}}\n\n//you need something else (that I have yet to write) that updates the fork if it already exists\n//you can't change the name while forking\npr.fork('cdnjs', 'q-bot', 'cdnjs', options)\n  .then(function () {\n    return pr.branch('q-bot', 'cdnjs', 'master', q.version, options)\n  })\n  .then(function () {\n    var commit = {\n      branch: q.version,\n      message: 'update version of q',\n      updates: [{path: 'ajax/libs/q/' + q.version + '/q.js', content: 'q source code'},\n                {path: 'ajax/libs/q/' + q.version + '/q.min.js', content: 'mini q source code'},\n                {path: 'ajax/libs/q/package.json', content: 'q\\'s package.json'}]\n    }\n    return pr.commit('q-bot', 'cdnjs', commit, options)\n  })\n  .then(function () {\n    return pr.pull({user: 'q-bot', repo: 'cdnjs', branch: q.version},\n                   {user: 'cdnjs', repo: 'cdnjs'},/*branch:'master' is default*/\n                   {title: 'update version of q', body: 'this PR was generated by a bot...'},\n                   options)\n  })\n  .done()\n```\n. My thoughts from trying to catch up with the discussion so far:\n\n## Costs\n\nFor S3, http://www.regexplained.co.uk/ is fully hosted on S3 and the costs have never gone above $0.03 in any given month for the last year.  By not enabling SSL or setting a nasty content type you could discourage hot linking if you wanted to.\n\nUsing Cloud Flare, which is free providing that you don't need SSL, will prevent costs spiralling if suddenly everyone in the world decides to download Q simultaneously (you'd pay for one request per Cloud Flare edge location per cache timeout)\n\n## UMD vs. AMD + Global\n\nI strongly recommend having one UMD file rather than separate amd, global, ...  It's a lot less confusing for people who are really new to JavaScript and don't yet know about all these module systems.  Also, global is harder to get right than you think when you consider `global` vs `window` vs `self` for each of the different environments.\n\nI'd also say that it'll be a lot of work to maintain seperate AMD versions of all the dependencies... I don't think it's worth it, but it's up to you.\n\nThere is a fully automated feature for browserify to generate the right outputs providing you go with one UMD file.\n\n## Another option for hosing UMD version\n\nwww.promisejs.org [source](https://github.com/ForbesLindesay/promisejs.org) currently gets the latest version of about 4 different promise libraries and generates a UMD version for them and hosts it in S3, so you could just point people at that.  It doesn't have HTTPS support, but I could add that via Cloud Flare for $5 per month.\n\nI do plan to keep the versions on that site pretty up to date, but it doesn't support lots of package managers.\n\n## A more ambitious idea\n\nI have another, more ambitious idea.  This problem applies to all CommonJS + npm packages that support use on the browser.  How about we create a bot which takes every npm package, as it is released, and attempts to publish it to every other package manager in existance?\n- All of the GitHub based ones can just be done by pushing commits to GitHub using [pull-request](https://github.com/ForbesLindesay/pull-request).  We could have an organisation per package manager.\n- We could automate the submission of pull requests into cdnjs.\n- We could host and display our own download page for a UMD version (minified + unminified).  We could attempt to publish to every package manager unde the sun.\n- We could support PMs like http://jamjs.org/ providing our bot was added as a maintainer.\n\nIf we listened to npmjs's changes field, we could do all of this automatically...for every single module.\n\nIt's an amount of trouble that it would seem insane to go to just for Q, not least because you'd need a virtual server for the system to run on.  It could be well worth it if it was for **all** packages on npm though.\n. :smile:\n. Should the encoding be specified for `'q-io/fs'`'s `read` method?\n. Cool, just thought I'd check.  Thanks for the link to my presentation :)\n. You should return `deferred.promise` outside the `client.query` callback (I.e. Swap it the line after it)\n. How do you use LongMueller?  I can't find any docs\n. Looks like a nice API :)  I take it the intention is not to standardise at all on what args to use (or even how many args) in a progress notification?\n\nThere's an interesting related case of transferring meta information.  For example if you use the request library to make a web-request, you get a response, but you also get an object containing headers etc. I'm not sure whether meta handling makes sense to be handled in a special way within Q.\n. > Indeed, although I was inclined to maybe standardize on a single arg. Dunno.\n\nI'm inclined to agree with standardising on a single arg, that makes it a closer match to the other callbacks.\n\n> I don't really see it. I'd return a promise for { headers, response }, which is still a single object.\n\nI guess that makes sense, and that's what I'm looking at doing at the moment for my APIs, but it's a surprisingly common use case, and although I'm not sure if Q should add any library functionality to support this, perhaps there should be some kind of recommendation for whether we go for `{ metadata, body }` or `metadata` as a property of the body then just return `body` or something else entirely.\n. Fair enough, I guess what you've described is the parallel with synchronous methods.  I was attempting to draw a parallel with non-promised asynchronous methods.  It's common in such scenarios to have the callback take more than 2 arguments so that it becomes `callback(err, meta, result)` or `callback(err, result, meta)`.  I think you're right to place higher importance on keeping the parallels with synchronous APIs strong though.\n. What does WinJS do?  I thought they just made their functions take a `cancellationToken` argument and that it had nothing to do with the promises/tasks returned?\n. Would it be possible to listen for just rejections which happen with nobody to observe them?  i.e. can you tell when a promise has been observed properly.  If so then this would seem like a  great plan, as you could very quickly write a basic system to ensure errors never go un-observed, and could build more complex (and awesome) debuggers later.\n. promise.when is not really the primary intended method for resolving a promise, instead you should really use either:\n\n``` javascript\npromise.then(onResolved,onRejected);\n//or\nQ.when(promise, onResolved, onRejected);\n```\n\nHowever both these exhibit the same behaviour, so that's not the problem.  I've submitted a pull request which fixes this, but since makePromise is an advanced feature, I'll have to defer to the author for how it's meant to be used.\n. I do really like the idea of sticking to the natural choices of words, I think it might be a nice idea to go with something like Q(promise).then though as the static version, that way they'd both be then.\n. As I understand it (from reading the code, not from seeing any spec) when you call `promise.promiseSend('when',onResolved, onRejected)` it gives your implementation a callback to call when there's an error, which would trigger the bottom of the 3 cases, but if you return a promise which resolves to an error, it calls both the top two cases (before my fix)\n. Still hadn't been resolved as far as I know?  It doesn't directly affect me, but we should probably look to get this fixed.\n. beyond working out that this change would fix it, I'm not really that sure what's going on, I think some work may need to go into refactoring at some point :s\n. For a well behaved promise, does it actually make a difference whether they're resolved in serial or parallel?  I would envisage error handling code for arguments having to sit outside the function:\n\n``` javascript\nlet sumOfStuff = Q.async(function* (a, b, c) {\n    // ...\n}).fail(function(err){\n    //error recovery for rejected parameters\n});\n```\n\nbut error recovery is a good argument for doing it the manual way, I hadn't thought of that.\n. I like the idea of having a separate Q.promised function, it should be simple enough to wrap\n\n``` javascript\nvar function = Q.promised(Q.async(function* (arg1, arg2){\n\n}));\n```\n\nSo I think that's a good solution.  Remote objects are a very different scenario.  My initial thought would be to stick to the current get, invoke etc. but let people easily extend that by adding their own functions which just call into those base functions.\n\nIf you're looking at processing lists, I think it's well worth considering libraries like Reactive Extensions.  Lists are very different to promises, and if we want to do work on remote lists and apply things like remote filter functions, we should consider a separate library (and learn from things like LINQ to SQL).  I do think many of these libraries may benefit from an 'all' method, which returns a promise for the complete list/stream returned as an array.\n\nJust my 2 cents worth.\n. Depreciate is now gone completely.  Spacing now matches the rest of the file.  Double quotes now used throughout.  All tests still pass.\n. How about replacing everything from ' and the following libraries are based on Q.' to 'use Q inernally or provide Q promises.' with something like:\n\nand there are many libraries that produce and consume Q promises for everything from file system access or RPC to templating.  For a list of some of the more popular ones, see [Libraries](https://github.com/kriskowal/q/wiki/Libraries).\n\nI guess the key here is to keep in mind that the readme file needs to sell Q, whereas the wiki needs to give useful links and info.  So the question becomes, what would help sell Q?  [Passport](https://github.com/jaredhanson/passport) really sells itself with a huge list of login strategies, perhaps a similarly huge list of libraries might help sell Q?\n. OK, here's a suggestion, I think Q is drastically under-publicised at the moment.  I think it's a really cool library, that really does help the async problem.  I think that's no more true than when you look at the solution that will be possible in the future when the `yield` keyword works everywhere.\n\nI think one really effective way of getting some publicity would be for one of us to submit a fairly short article to http://thechangelog.com about Q, and potentially mentioning some of the more useful libraries that go with it.  That would drive a lot of publicity, and more users will mean that we're more likely to end up as the defacto implementation of promises in the future.\n\nI think before we do that we probably want to tidy up the documentation as much as possible though, and try and close/deal with as many of the open issues as possible.  Having old open issues may make our project look un-maintained, which isn't the case.\n\nI think it's probably worth creating a static web-site in gh-pages for documentation.  I'm happy to try and create this if people agree with me?  It would allow for much more in the way of cool formatting and navigation menus.  We could also try and create a very succinct and bold landing page, that gets across the key purpose of Q.  We could also purchase a url.  q.io was available last time I looked, but .io domains are quite expensive.  Alternatively something like qpromise.org?\n\nWe could have a shared twitter account for Q as well, it could be used to publicise the library by answering async related questions in twitter, as well as for notifications of changes to the api?\n\nIf you think I'm being stupid/too enthusiastic, feel free to shoot me down and give me a healthy dose of realism?\n. So it would call `next(null, promiseValue)` if promise just exited normally?  I guess some might exect that behaviour, whereas my suggestion only really applies to express, hmm.\n. ah, yeh I like that suggestion, both for a node-end and for a `.end(callback, errback)` assuming both could be null/undefined.  For a node end, a really nice pattern could then be:\n\n``` javascript\nfunction usePromisesIfYouWant(in, cb) {\n    return promisedAPI(in).endNode(cb);\n}\n```\n\nThat way if cb is undefined, we return a promise for someone to use, but if it is defined, we call it in the normal node style.\n. If we agree that both these methods would be useful `end` and `endNode` then shall we add some tests and code and get implementing?\n\nCan we agree what the methods should be called?  I think `end` is fairly obvious, but `endNode` or `nodeEnd` ?  Neither is perfect, but neither is terrible so I'm open to suggestions personally.\n. +1 for done over end if it matches other libraries\n. We could do `done(callback, errback)` and `end(nodeCallback)` ? \n. Yes, although `.fail(function () {}).end()` would silence all errors, nothing can guarantee errors are never silenced.  The key point is that `.nend(function (err) { if (err) throw err;})` would not silence the error.  On the other hand, I'm happy to keep things moderately verbose if that makes it clearer what's going on, so perhaps `.nodeCallback` or we could go for `.ndone` as it's very similar to the new `.done` method\n. Should it be:\n\n``` javascript\nwhen(promise, fulfilled, rejected).fail(onUnhandledError);\n```\n\ninstead of:\n\n``` javascript\nwhen(promise, fulfilled, rejected || onUnhandledError);\n```\n\nThe idea is to throw exceptions even if they happen in the fulfilled or rejected handlers.\n. And another for 'when the promise is rejected, and the errback throws, it should rethrow the error in the next turn'\n. How does this relate to `nend` etc. ?\n. I do like the idea of having an easy way to make my public interfaces directly support node-style and promise-style use just by either passing or not passing a callback.\n. +1 for `supportNode`\n+1 for `nodeify`\n+0.5 for `toNodeback`\n\nIn the use case described of \"I wish to expose an api that's familiar to people used to node style callbacks\" I'd go with `supportNode` as the hands-down winner.\n\nFor the alternative case of working with things like express.js where you must call a callback as a node.js callback, it seems a little counter-intuitive to call it `supportNode`, which makes me favour something like `nodeify`.\n\n`toNodeBack` seems nice and un-offensive, but could be confused with Deffered's makeNodeResolver.\n. Are we agreed on the functionality of this?  I'm happy to implement and test this.\n\n``` javascript\nQ.promised = function (fn) {\n    return function() {\n        return Q.all(arguments).spread(fn);\n    };\n}\n```\n. I agree we need to pass `this` on, my mistake, should we treat `this` as a promise though?  I wasn't thinking that we would?:\n\n``` javascript\nQ.promised = function (fn) {\n    return function() {\n        return Q.all(arguments).spread(fn.bind(this));\n    };\n}\n```\n\nor\n\n``` javascript\nQ.promised = function (fn) {\n    return function() {\n        return Q.all([this, Q.all(arguments)]).spread(function (self, args) {\n          return fn.apply(self, args);\n        });\n    };\n}\n```\n. Fair enuf, the question remains as to whether we want to resolve `this` as a promise, the alternative code now looks like:\n\n``` javascript\nQ.promised = function (fn) {\n    return function() {\n        var self = this;\n        return Q.all(arguments).then(function (args) {\n            fn.apply(self, args);\n        });\n    };\n}\n```\n. I guess I don't really have a good reason not to, just thought we should consider which is right, as we'll want to keep the api stable so won't want to change this.  If nobody has any further issues, lets treat `this` as a promise and resolve that too.\n. Also, how about an `npromised` function that would essentially look like:\n\n``` javascript\nnpromised = function (fn) {\n  return promised(nbind(fn));\n}\n```\n. I like that idea.  It's confusing to have a library log something when absolutely nothing's wrong.  It also makes the behaviour different on node.js\n.  Are we close to being ready to push this now?\n. I've just downloaded from master, and I don't get the same error there, but I still get poor behaviour.\n\nWith the same code posted above, but modified to use q at master, I get:\n\n```\nC:\\src\\q-master\\q.js:1354\n            throw error;\n                  ^\n[object Object]\n```\n\nIf I change the code to:\n\n``` javascript\nvar Q = require('./q-master');\nfunction CustomError() {\n    this.name = 'CustomError';\n    this.message = 'Foo Bar Foo';\n}\n\nQ.when(null, function foo() {\n    throw new CustomError();\n}).end();\n```\n\nI get:\n\n```\nC:\\src\\q-master\\q.js:1354\n            throw error;\n                  ^\nCustomError: Foo Bar Foo\n```\n\nAnd nothing I can seem to do will bring back that missing stack trace (except changing it back to a native error).\n. I've tried setting the prototype:\n\n`CustomError.prototype = Error.prototype`\n\nAnd using util.inherits:\n\n`require('util').inherits(CustomError, Error)`\n\nAnd neither make any difference.\n. Ah, just worked out, you have to call `Error.captureStackTrace(this, this.constructor)` to get a stack trace for an error.  I wonder whether Q could help people out by attaching a stack trace even when one wasn't originally present though.\n. fixed :)\n. Done, hopefully all ready to merge now.\n. lol, ok, I'll try and keep JAM as in sync with npm as I can :)\n. Have an app that has to  run a task once a day as a cron job so we catch all errors and just log them.  I want a way to log them with their extended stack traces but without terminating the process.\n. I'm not sure.  A global handler is different, because there may be some exceptions I want to handle separately, so I'm not sure if a global error handler works.  I still want to do stuff after logging the error.  I need to have a but more of q look at the global error handler proposal before I can be sure.\n. If you force non-valueOf methods to resolve in the next turn of the event loop that can be very expensive when promises are resolved synchronously.  I like to build as much as possible of my libraries to be OK with being given promises, so often they're given resolved promises, or plain old values.\n. That's allso usually my experience.  I agree that we need to exercise caution with bloating the library.  I wonder if we could split it into two files (Core and Extensions)?  I think 2 modules would be a shame, I'd always end up requiring in extensions, but I think it would be nice when reading the code to see just the stuff that's needed for promises as a separate thing to all the cool stuff that makes the api look nice.\n. See #130\n. Generally you shouldn't minify libraries when making pull requests as it makes your changes harder to merge with other changes that may have happened at the same time.\n\nWe discussed this issue in #88.  The problem is that you do need to log when there's an error, so there needs to be a log when the first error occurs if we're going to take this log out.\n. If we had a Q debug we could provide options to automatically end all promises that don't get used after a couple of seconds.  We could also timeout promises automatically.\n. This is proving to be quite a complex issue.  I'd almost be inclined to require users to be explicit about what progress gets forwarded and how it gets forwarded.\n. What about code using `Q.defer()`...how does that work with arbitrary resolving code.\n. Something like the following, where `request` hasn't done anything specific to be domain aware?\n\n``` javascript\nvar error = new Error(\"should be caught by the domain\");\nvar d = domain.create();\n\nd.run(function () {\n    callAsync().done();\n});\n\nvar errorTimeout = setTimeout(function () {\n    done(new Error(\"Wasn't caught\"));\n}, 500);\n\nd.on(\"error\", function (theError) {\n    expect(theError).toBe(error);\n    clearTimeout(errorTimeout);\n    done();\n});\n\nfunction callAsync() {\n    var def = Q.defer();\n    request('https://www.google.com', function (err, res) {\n        def.reject(error);\n    });\n    return def.promise;\n}\n```\n\n(I haven't actually tried this)\n. So the test case (which we suspect fails) could look like:\n\n``` javascript\nvar error = new Error(\"should be caught by the domain\");\nvar d = domain.create();\n\nvar e = new require('events').EventEmitter\n\nd.run(function () {\n    callAsync().done();\n});\ne.emit('beep');\n\nvar errorTimeout = setTimeout(function () {\n    done(new Error(\"Wasn't caught\"));\n}, 500);\n\nd.on(\"error\", function (theError) {\n    expect(theError).toBe(error);\n    clearTimeout(errorTimeout);\n    done();\n});\n\nfunction callAsync() {\n    var def = Q.defer();\n    e.once('beep', function () {\n        def.reject(error);\n    });\n    return def.promise;\n}\n```\n\nP.S. I hadn't been referring to @mikeal's request library, but rather a generic, badly behaved request method that retrieved something from a web-server.\n. The only thing I can think of is assimilating poorly behaved promises (where poorly behaved means they don't work with domains)\n. :+1: \n. Must've been half asleep, give me a moment...\n. Tests added\n. Personally I'm not really a fan of adding progress as a third argument to `.then()`.  If we instead treated it as a totally separate `.progress(progback)` that might open up completely different options with regards to error handling.  In the once case where I've had to deal with progress so far (when using promises) I did so by having my promise also be an event emitter and emit a `progress` event, which just let exceptions throw.\n. My two cents:\n\nseparate propagation from handling.  The propagation API is then `.then(callback, errback, progressPropagator)` and is just there to transform the progress.  I'm not sure what the best bet is here, but I'm not totally against it being thrown in nextTick.\n\nWe should then discourage actually handling progress in the propagation handler, and instead have a separate `.progress(cb)` which should just throw in next tick and return undefined.\n\nAs an alternative, axe propagation handling from promises altogether (except the most basic case).  Instead, just forward progress evens if the `progressPropogator` is `true` and drop them if it's `false`.  That takes care of the case:\n\n``` javascript\nvar json = request('foo.com/file.json')\n  .then(function (res) {\n    return JSON.parse(res);\n  }, null, true);\n```\n\nBut ignores the case:\n\n``` javascript\nvar res = asyncOpA()\n  .then(function (res) {\n    return asyncOpB(res);\n  }, null, false);\n```\n\nAt that point we just say \"You're on your own\".  But we let people do the propagation manually like so:\n\n``` javascript\nvar opA = asyncOpA();\nopA.handleProgress(progressA);\nvar res = opA\n  .then(function (res) {\n    var opB = asyncOpB(res);\n    opB.handleProgress(progressB);\n    return opB;\n  }, null, false);\n\nfunction progressA(val) {\n  res.emitProgress(val / 2);\n}\nfunction progressB(val) {\n  res.emitProgress(0.5 + val/2);\n}\n```\n\nThe idea here is to do exactly what event emitters do, let an outside party add progress events into a promise, so that the consumer of a promise can still choose to make the promise emit progress events even if it wouldn't do so naturally.\n\nThis has other nice use cases.  Consider the case that you're given an API that returns promises, which don't support progress, but where you know approximately how long each async operation takes, you could add progress with something like:\n\n``` javascript\nfunction addProgress(promise, expectedTime) {\n  var start = Date.getTime();\n  var int = setInterval(function () {\n    promise.emitProgress(Math.min((Date.getTime() - start) / expectedTime, 1));\n  }, 100);\n  promise.then(function () {\n    clearInterval(int);\n  }, function () {\n    clearInterval(int);\n  });\n}\n```\n. Is this fine with Promises/A+ promises, which don't always have a valueOf function?\n. Ah, I didn't realise it existed on object.  That makes sense of how it was originally coded.  Perhaps we should specify that `valueOf` displays this behaviour (if provided) in promises/A+  e.g.\n\n`promise#valueOf` should either return `this` or the value a promise was fulfilled with.  It is free to return `this` even on a fulfilled promise, so the default implementation provided by `Object.prototype` is sufficient.\n. Yes, but we still wouldn't get the original site where the string was thrown, I'm not sure how much help it would be...Ideally I'd like the JavaScript spec changed so that throwing a string gives the compiler permission to re-format your hard-drive (provided you were the author of the function that throws).\n. Good grief, you are ambitious @thesmart...I had no intention of attempting to stop people shooting themselves in the foot with JavaScript, there are loads of ways for them to do that.  I just wish there was a way to stop other people shooting **me** in the foot with JavaScript.  The most common way they seem to do it is by throwing strings/numbers/plain objects without stack traces.\n. I use that pattern all the time, and it serves me well.  To make it equivallent to the original example you need to do:\n\n``` javascript\ngetEmail(...)\n    .then(function(email) {\n        return Q.all([ email, getUserInfo(email) ]);\n    }).spread(function(email, user) {\n        return {email: email, user: user};\n    });\n```\n\nwhich I assumed you felt was too clunky.  It can be a little clunky and a deep-resolve would probably be useful in more complex scenarios.\n. Hmm, that would make Q.all unusable in QEJS because it makes the performance unbearable.\n\nHow about changing isFulfilled so that it's interoperable?  We don't want to change `isPromise` because other parts of the library already use that to mean 'is a Q promise'.\n\n``` javascript\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    var val = valueOf(object);\n    return !(val && typeof val === 'object' && typeof val.then === 'function');\n}\n```\n. Thanks\n. Why would it deprecate the promised wrapper?\n. doesn't it make `fbind` equivalent to `promised`? since `nfbind` also adds a callback function.  Good point though.\n. I'm definitely :+1: for this then.\n. If you make it:\n\n``` javascript\n{\n  \"name\": \"q\",\n  \"repo\": \"kriskowal/q\",\n  \"version\": \"0.8.12\",\n  \"dependencies\": {},\n  \"scripts\": [\"q.js\"],\n  \"main\": \"q.js\"\n}\n```\n\nIt would work for [component](https://github.com/component/component) as well as bower.\n. OK, I'll maintain it as https://github.com/microjs/q so could we put a note somewhere in the readme to point out that it's available there as a component?\n. The justification (whether you agree with it or not) is that client side packages require sufficiently different description to server side packages to merit a different file name.  If you're going to avoid having a separate database you also ideally need to keep listings of all scripts in the description file, so that you don't have to scan the repository for files to download.\n\nIf any of the package.json based package managers were anywhere nearing suficent for use on the client then I'd agree but at the moment that's not the case.  The component one is the only one that seems to have struck upon a format that actually has enough information.  By listing all the scripts and their purpose, it becomes stupidly easy to build your own program to consume that format.\n. Agreed, I'm happy to discuss elsewhere.  I've added a pull request to update the readme and will maintain the microjs fork fo component + bower support until a better alternative arises.\n. nope, I no longer use component since browserify has been updated to work on Windows.  I have no further interest in supporting JavaScript package managers other than npm.\n. `IsResolved` fits better with what actually happens when you take into account third party promises though.  I.e. if it's true then the promise **is** resolved, but it it's false it could still be a resolved third party promise.\n. I'm essentially a +0 for this, but the down side I see with it is as follows.\n\nThe results of calling isResolved/isPending on a foreign promise:\n\n``` javascript\nQ.isResolved(foreignPromise);//always false\nQ.isPending(foreignPromise);//always true\n```\n\nIdeally a resolved foreign promise would return `true` for `isResolved` and `false` for `isPending`.  So in both cases it's not \"correct\" (by which I mean it doesn't fit with intuition).  Saying `false` when you should say `true` seems less wrong than saying `true` when you should say `false`, because `true` in natural languages implies much greater certainty than `false`.\n\nIt's a fairly week objection though.\n. When would you choose this over done?\n. So you'd use it when you wanted to provide an API of `do(cb, eb)`?\n\nSeems like an odd thing to do.  jQuery does it, but not much else and it's pretty universally a pain to work with.\n. I would ideally like to support all promises that define `.valueOf()` to return the current value when `fulfilled`\n. `.valueOf` is fine if you only call it on promises.  We got stung before, but that was an easily fixed mistake.  The advantage of `valueOf` is that you don't need to check for its existence.  You always need to check things are promises because e.g. calling a method `.nearest()` would be a very reasonable thing when talking about points on a graph.\n. We really want the `.then` check to be the only thing that might cause us to falsely treat something like a promise, we don't want to add things like `.nearest` or `.mostResolved`\n. My point is that we have:\n\n``` javascript\nif (isPromiseLike(val) && typeof val.nearer === 'function') {\n  return val.nearer();\n} else {\n  return val;\n}\n```\n\nor\n\n``` javascript\nif (isPromiseLike(val)) {\n  return val.valueOf();\n} else {\n  return val;\n}\n```\n\nThe second one is a slight bit neater.  Either way, this should probably be discussed with the entire promises-a-plus community, since it's effectively a defacto standard.\n. There's a typo in your naming of functions (depths vs bowels). It would be helpful if you could prevent q from gathering stack trace info for a specific jump (e.g. Within a library like QEJ)\n. I suppose it would.  Ideally it would be nice to be able to 'skip a step'\n\n``` javascript\n//the stack up to here matters\n\nPromise.then(function (){\n  //this stack doesn't matter\n}).then(function(){\n  //this stack matters\n  throw new Error('foo')\n})\n```\n. `spread` can also be used in the same way as then:\n\n``` javascript\nQ.resolve([oneP, twoP, threeP])\n  .spread(function (one, two, three) {\n  });\n```\n\nJust replace `then` with `spread` wherever you want this behavior.\n. I've answered the stack overflow question, but to duplicate here:\n\n`return function(){withCB(arguments[1])}` is not a legal way of using a promise library.  As detailed in [the promises spec](http://promises-aplus.github.com/promises-spec/) that Q aims to comply with, anything you return from a `.then` callback that is not a promise should be passed directly through.\n\nEssentially callback based code should be treated as `legacy` when you're using promises.\n\nYou have two basic options.  If you use funcWithCallback lots of times you can do something like:\n\n``` javascript\nvar promisedFunc = Q.nfbind(funcWithCallback);\n\nsomePromiseFunc(value1)\n.then(function(value2) {\n    return promisedFunc();\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n\nor if you need to pass arguments:\n\n``` javascript\nvar promisedFunc = Q.nfbind(funcWithCallback);\n\nsomePromiseFunc(value1)\n.then(function(value2) {\n    return promisedFunc(value1, value2);\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n\nIf you're only using it once you can do\n\n``` javascript\nsomePromiseFunc(value1)\n.then(function(value2) {\n    return Q.nfcall(funcWithCallback);\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n\nor if you need to pass arguments:\n\n``` javascript\nsomePromiseFunc(value1)\n.then(function(value2) {\n    return Q.nfcall(funcWithCallback, value1, value2);\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n. P.S. I can't make what you say works work:\n\n``` javascript\nvar Q = require('q');\n\nQ.resolve(null)\n  .then(function (v) {\n    return function(){arguments[1](null, 'foo');};\n  })\n  .then(function (v) {\n    console.log(v);\n  })\n```\n\nlogs `[Function]`\n\nCan you provide a complete example that fails so the bug can be fixed?\n. You will get stack traces if and only iff you throw real exceptions (i.e. `throw new Error('message')` not `throw 'message'`) and you either throw in the next tick or call `.done` at the end of your promise chain.\n\n``` javascript\nasyncOpThatMightThrow()\n  .then(function (res) {\n    //do something with the result if successful\n  })\n  .done();//makes sure error isn't silenced\n```\n\nis approximately equivalent to:\n\n``` javascript\nasyncOpThatMightThrow()\n  .then(function (res) {\n    //do something with the result if successful\n  })\n  .then(null, function (err) {\n    setTimeout(function () { //make sure the error isn't silenced\n      throw err;\n    }, 0)\n  });\n```\n. If you want to escape the error handling that's built into Q.\n\ni.e.\n\n``` javascript\nvar promise = doSomething()\n  .then(function () {\n    throw new Error('foo');\n  });\n\n//some time later...\n\npromise.then(null, function (err) {\n  console.log('there was an error: ' + err.message);\n});\n```\n\nThe above only works because Q traps errors in callbacks (and errbacks) and stores them to be handled later.  Since Q has no way of knowing whether or not you're going to handle the error (it's not a computable question in the general case), it must save the error for later in case you handle it.  As such you don't get told that there was an error until you explicitly handle it.\n\nCalling `.done()` on a promise is essentially saying \"I'm done handling errors, so if there are any left you should throw them and crash the app.\"  If you do that then Q will make sure to throw the error for you.\n\nThe golden rule of Q promises is that you must always either return the promise (so someone else can call done) or call `.done()`\n\n``` javascript\nfunction goodA() {\n  return doAsyncWork()\n    .then(function (res) {\n      console.log(res);\n      return res;\n    });\n}\nfunction goodB() {\n  doAsyncWork()\n    .then(function (res) {\n      console.log(res);\n      return res;\n    })\n    .done();\n}\nfunction goodC() {\n  doAsyncWork()\n    .done(function (res) {\n      console.log(res);\n      return res;\n    });\n}\nfunction badA() {\n  doAsyncWork()\n    .then(function (res) {\n      console.log(res);\n      return res;\n    });\n}\nfunction badB() {\n  doAsyncWork()\n    .then(function (res) {\n      console.log(res);\n      return res;\n    })\n    .then(null, function (err) {\n      reportError(err);\n      //what if reportError throws an error.\n    });\n}\n```\n. One error with:\n\n``` javascript\n.then(function(value2) {\n    return q.nfcall(mysql.client.query, query, [lang_code, autocomplete]);\n})\n.then(function(err, results, fields) {\n    if (err) {\n        throw err;\n    }\n    // Have a party\n})\n.done();\n```\n\nIs that you don't do error handling like that in Q.\n\n``` javascript\n.then(function(value2) {\n    return q.nfcall(mysql.client.query, query, [lang_code, autocomplete]);\n})\n.spread(function(results, fields) {\n    // Have a party\n}, function (err) {\n   // Handle error\n})\n.done();\n```\n\nor\n\n``` javascript\n.then(function(value2) {\n    return q.nfcall(mysql.client.query, query, [lang_code, autocomplete]);\n})\n.then(function(args) {\n    var results = args[0], fields = args[1];\n    // Have a party\n}, function (err) {\n   // Handle error\n})\n.done();\n```\n\nare preferred\n. You kind of can, but you \"plug that callback in\" by using `Q.nfinvoke` and friends. And it only works if they follow the node.js pattern of using error as the first argument.  And if they have more than 2 arguments then you get an array as you results.  But you can use `spread` to fix that.  Mostly for things like mysql your going to end up with some sort of wrapper anyway because you're going to want to do connection pooling and logging.  Mine looks like:\n\n``` javascript\nmodule.exports.update = update;\nfunction update(str, values) {\n  var def = Q.defer();\n  pool(function(connection, done) {\n    var log = debug.time();\n    connection.query(str, values, function(err, rows, fields) {\n      var debugI = 0;\n      log(str.replace(/\\?/g, function (_) {\n        return JSON.stringify(values[debugI++]);\n      }));\n      if (err) def.reject(err);\n      else def.resolve(rows);\n      done();\n    });\n  });\n  return def.promise;\n}\n```\n\nMost of which is connection pooling and logging rather than handling the callback/promise divide.\n. This seems pretty specific to your use case. It would be pretty cool to have a giant system that let you say `\"Step 5 depends on the output of Step 4 and Step 3.  Step 3 depends on the output of Step 2.  Step 4 depends on the output of Step 2 and Step 1.\"  At which point it would run Step 1 and Step 2 in parallel, passing the results to Step 3 and Step 4 which it would run in parallel and pass the results to Step 5.\n\nQ has to draw a line in the land somewhere though, so I think this is probably over that line.\n. Running it again this seems to work fine.  The error appears to be intermittent.  Could there be a race condition somewhere in the unit testing framework?\n. Style now fixed as per @domenic's request\n. Oops, I've added them now\n. You can just do:\n\n``` javascript\nQ.nextTick(function () {\n  deferred.notify(args);\n});\n```\n\nbut you don't need to, the issue is that progress can't be emitted once the promise has been resolved, so you have to delay resolution until people have had a chance to see the progress.  delaying progress will just make the problem worse again.\n. Because if you actually do some asynchronous work then you won't see any of these problems.  \"progress\" is only meant for \"progress\" on asynchronous jobs.  As such if it completes before anyone starts listening for progress, why bother sending any progress.\n. I'd be inclined to have an option `denodeify` (I wonder whether a better name could be found) that doesn't accept any additional arguments, but probably accepts an optional `this` (not a `thisp`).  The only reason I ever use these things is to turn 'legacy' node APIs into promised APIs, so I only ever do the bare minimum.\n\n``` javascript\nvar readFile = Q.promise(fs.readFile, fs);\nvar readFile = Q.promise(fs, 'readFile');\nvar readFile = Q.denodeify(fs.readFile, fs);\nvar readFile = Q.denodeify(fs, 'readFile');\n```\n. It annoys me every time I come to use `fs.exists` that I can't do `Q.nfbind(fs.exists)`.\n. It's not that, exists is \"special\" because it doesn't have a node style callback syntax:\n\n``` javascript\nfs.exists('path-to-file', function (exists) {\n  //win\n});\n```\n\nnot\n\n``` javascript\nfs.exists('path-to-file', function (err, exists) {\n  if (err) throw err;\n  //win\n});\n```\n. Interesting, thanks for that link @medikoo.  It would be good if that stuff was included in the node.js API docs.\n. We still have the same problem with `rl.question(query, callback)` though.  That's still 'unstable' so we really should do something about it now.  Do you know if there's an issue open anywhere?\n. +1\n. Can't really comment on what test runner to use as the only one I've tried extensively is Mocha (which I wish had native non-hacky support for promises).  As for browser-ci I run http://jepso-ci.com which is fairly beta at the moment, and doesn't yet report **why** tests failed, but I've already done an integration of Q in [this repo](https://github.com/jepso-ci-examples/q) which produces the following badge:\n\n[![build status](https://jepso-ci.com/jepso-ci-examples/q.svg)](https://jepso-ci.com/jepso-ci-examples/q)\n\nI'm happy to also integrate it with whatever you migrate to after jasmine.\n. P.S. jepso-ci is based off of the sauce-labs on-demand service.\n. You do have the option of `Q.nfbind(myObject.myMethod.bind(myObject))`\n. :+1: from me\n. Promised currently causes a few extra calls to `nextTick` which may be worth attempting to optimize out if we're going to be using it a lot.\n\nI'm broadly in favor of using it everywhere though.\n. True, fine with me.  proxy.jepso-ci.com aims to do a lot more than rawgithub.com, but none of the extra stuff it does is actually needed for this specific use case.  Regardless of which provider, would be nice to see the link.\n. Looking at this I can't help but feel we should just use a separate `next-tick` library.  There already is one, but it doesn't do any of this clever trampolining stuff.  I just feel it's not at all specific or unique to Q that we have this requirement.\n\nThe downside would be that it wouldn't be dependency free by default, but we could use `browserify` to generate a dependency free version.  It has a `--standalone` option that outputs a complete UMD wrapper that's actually based off the UMD wrapper in this repository (I used this repo as my starting point for building [umd](https://github.com/ForbesLindesay/umd)).\n\nWe could then just build the standalone one:\n\n```\n$ browserify q.js --standalone Q > q-standalone.js\n```\n\nand then minify\n\n```\n$ uglifyjs q-standalone.js > q.min.js\n```\n\nThe browserify headers are actually a very small overhead in the latest version.\n. I was suggesting a separate `next-tick` library controlled by @kriskowal or someone else similarly invested in q, not just a generic one.  It can be a highly specialized one that pretty much states its aims as \"implement a next-tick that meets the requirements of promise libraries\".  My point is that there are tonnes of different promise libraries out there and I'd happily change `then` to use Qs `next-tick` implementation, since it's faster than what we're using in lots of situations, but I don't want to just copy and paste it.\n. I agree, Q's needs should come first.  My point is simply that as I see it Q's needs are:\n1. The highest priority next-tick possible\n2. Still breaks up the stack to avoid stack overflow\n3. Errors in one handler don't interact with other handlers (e.g. in the browser or when there's a global error handler present).\n\nI imagine there are quite a few applications of such a function.\n. For reference, https://github.com/ForbesLindesay/umd/blob/master/template.js is the template used to generate browserify's UMD wrapper.  I've mostly copied the logic from here anyway, so hopefully it should work.  `source()` gets replaced with `return module-export`.  `{{camelcase}}` and `{{pascalcase}}` would be replaced with `Q`.  `{{name}}` would be replaced with `q`.\n. I think that's the idea.  Although it's not just for outsourcing.  It's also because nextTick will be useful to other libraries that don't depend on Q\n. @AlexGalays we're not talking about making parts of Q optional here.  We're talking about splitting out the parts that would be useful for other libraries so that you can use them on their own.\n\nOne option would be to modularize it to the extent of having a \"Q core\" that could be the minimum to get things working.  I don't think that would necessarily be that useful though.\n. I still think I like that idea better than anything else I've tried.  I've not had a chance to experiment with it but returning a promise from the `triggerProgress` method makes it easy to ignore, crash or reject.\n\nI still think making progress handlers deal with the errors thrown by other progress handlers is downright weird.  I think I prefer crashing to that option.\n. I'd be keen for that too, just wanted to get the ball rolling :)\n. cool, browserify would be pretty much equivalent (it uses umd internally) so that sounds like a good idea.  I haven't really looked at the Closure Compiler.\n. I'd love to have UMD support montage require as well as possible.  I don't really want to just make it take completely arbitrary templates though, I'd prefer to have it take an options object in place of the current `commonJS = false / true` option.  This way we could make exposing it to SES optional and also add the option to override the name on a case by case basis (e.g. for Montage).\n\nThe key thing for me is maintaining a \"best effort\" approach when given a module and a CommonJS style name (possibly with extra capitalized letters).  At some point soon I'd like to build a \"browserify CDN\" that would provide browserify modules already wrapped in UMD modules to make it super easy to use any npm module on the client even without browserify.\n\nThe hope then would be to have modules like Q not include any of the build output in the repository (which I consider to be the wrong place for such output) but instead just link to an automatically generated build.\n. OK, I'm up for removing montage and SES from umd if they're not generally applicable.  It sounds like it might be best to have a custom script that takes a CommonJS module or a UMD module and adds montageRequire/SES exports?\n. It's about time I started converting my GitHub API experience (which has grown fairly extensive) into useful modules.\n\nFirst up, [github-basic](https://github.com/ForbesLindesay/github-basic) provides a really simple API for github via `github.json` where response.body is parsed JSON response.  This is based off of an internal method in the [github](https://github.com/mikedeboer/node-github) module which I liked, but found was way too high level as a starting point.  What you want is something where you can easily read the docs for a method, and then call it.\n\nNext up will be a method for forking, committing, and submitting pull requests.\n. OK, [pull-request](https://github.com/ForbesLindesay/pull-request) is now released.  It has a nice set of unit tests and should provide a great starting point.\n\nAll the promises are Promises/A+ compliant and use the [promise](https://github.com/then/promise) library (mostly a subset of Q).\n\nWith the current API, the code should look something like the following.  It should be noted that I've only just built this module and it's currently 6am so I'd really welcome advice on improvements to the API.\n\n``` js\nvar pr = require('pull-request')\nvar options = {auth:{fill this in}}\n\n//you need something else (that I have yet to write) that updates the fork if it already exists\n//you can't change the name while forking\npr.fork('cdnjs', 'q-bot', 'cdnjs', options)\n  .then(function () {\n    return pr.branch('q-bot', 'cdnjs', 'master', q.version, options)\n  })\n  .then(function () {\n    var commit = {\n      branch: q.version,\n      message: 'update version of q',\n      updates: [{path: 'ajax/libs/q/' + q.version + '/q.js', content: 'q source code'},\n                {path: 'ajax/libs/q/' + q.version + '/q.min.js', content: 'mini q source code'},\n                {path: 'ajax/libs/q/package.json', content: 'q\\'s package.json'}]\n    }\n    return pr.commit('q-bot', 'cdnjs', commit, options)\n  })\n  .then(function () {\n    return pr.pull({user: 'q-bot', repo: 'cdnjs', branch: q.version},\n                   {user: 'cdnjs', repo: 'cdnjs'},/*branch:'master' is default*/\n                   {title: 'update version of q', body: 'this PR was generated by a bot...'},\n                   options)\n  })\n  .done()\n```\n. My thoughts from trying to catch up with the discussion so far:\n\n## Costs\n\nFor S3, http://www.regexplained.co.uk/ is fully hosted on S3 and the costs have never gone above $0.03 in any given month for the last year.  By not enabling SSL or setting a nasty content type you could discourage hot linking if you wanted to.\n\nUsing Cloud Flare, which is free providing that you don't need SSL, will prevent costs spiralling if suddenly everyone in the world decides to download Q simultaneously (you'd pay for one request per Cloud Flare edge location per cache timeout)\n\n## UMD vs. AMD + Global\n\nI strongly recommend having one UMD file rather than separate amd, global, ...  It's a lot less confusing for people who are really new to JavaScript and don't yet know about all these module systems.  Also, global is harder to get right than you think when you consider `global` vs `window` vs `self` for each of the different environments.\n\nI'd also say that it'll be a lot of work to maintain seperate AMD versions of all the dependencies... I don't think it's worth it, but it's up to you.\n\nThere is a fully automated feature for browserify to generate the right outputs providing you go with one UMD file.\n\n## Another option for hosing UMD version\n\nwww.promisejs.org [source](https://github.com/ForbesLindesay/promisejs.org) currently gets the latest version of about 4 different promise libraries and generates a UMD version for them and hosts it in S3, so you could just point people at that.  It doesn't have HTTPS support, but I could add that via Cloud Flare for $5 per month.\n\nI do plan to keep the versions on that site pretty up to date, but it doesn't support lots of package managers.\n\n## A more ambitious idea\n\nI have another, more ambitious idea.  This problem applies to all CommonJS + npm packages that support use on the browser.  How about we create a bot which takes every npm package, as it is released, and attempts to publish it to every other package manager in existance?\n- All of the GitHub based ones can just be done by pushing commits to GitHub using [pull-request](https://github.com/ForbesLindesay/pull-request).  We could have an organisation per package manager.\n- We could automate the submission of pull requests into cdnjs.\n- We could host and display our own download page for a UMD version (minified + unminified).  We could attempt to publish to every package manager unde the sun.\n- We could support PMs like http://jamjs.org/ providing our bot was added as a maintainer.\n\nIf we listened to npmjs's changes field, we could do all of this automatically...for every single module.\n\nIt's an amount of trouble that it would seem insane to go to just for Q, not least because you'd need a virtual server for the system to run on.  It could be well worth it if it was for **all** packages on npm though.\n. :smile:\n. Should the encoding be specified for `'q-io/fs'`'s `read` method?\n. Cool, just thought I'd check.  Thanks for the link to my presentation :)\n. You should return `deferred.promise` outside the `client.query` callback (I.e. Swap it the line after it)\n. ",
    "arcanis": "Why is it closed exactly ? What are the issues ?\n\n**edit**; [#64 - Cancellation](https://github.com/kriskowal/q/issues/64)\n. Why is it closed exactly ? What are the issues ?\n\n**edit**; [#64 - Cancellation](https://github.com/kriskowal/q/issues/64)\n. ",
    "ignacioiglesias": "would this use some kind of event-emitting?\n. Oh, okay\u2026 I'm really a noob so I don't think I will be able to provide much code. However, I'd like to take a look if you don't mind.\n. would this use some kind of event-emitting?\n. Oh, okay\u2026 I'm really a noob so I don't think I will be able to provide much code. However, I'd like to take a look if you don't mind.\n. ",
    "leonerd": "This sounds exactly like the same discussion happening with Perl's `Future` module, here\n\nhttps://rt.cpan.org/Public/Bug/Display.html?id=96685\n\nEssentially the conclusion seems to be \"add a ->reuse method to mark that something else is using it, so require an extra ->cancel before it counts\".\n. This sounds exactly like the same discussion happening with Perl's `Future` module, here\n\nhttps://rt.cpan.org/Public/Bug/Display.html?id=96685\n\nEssentially the conclusion seems to be \"add a ->reuse method to mark that something else is using it, so require an extra ->cancel before it counts\".\n. ",
    "tolmasky": "I'm curious on thoughts about wanting to use q.race to run a number of intense computations simultaneously and give up on all the ones that don't finish first: q.race(expensive op 1, expensive op 2, etc). Here once you have your answer you don't want to be wasting resources any more. How could similar patterns be implemented in a compost or way without for example w.race just canceling the incomplete promises?\n. I'm curious on thoughts about wanting to use q.race to run a number of intense computations simultaneously and give up on all the ones that don't finish first: q.race(expensive op 1, expensive op 2, etc). Here once you have your answer you don't want to be wasting resources any more. How could similar patterns be implemented in a compost or way without for example w.race just canceling the incomplete promises?\n. ",
    "sp": "I just ran into this and in the process of starting to patch it found the \"gh-73\" test which led me here. Thanks for fixing this - now can we get it released to NPM?\n. I just ran into this and in the process of starting to patch it found the \"gh-73\" test which led me here. Thanks for fixing this - now can we get it released to NPM?\n. ",
    "danfuzz": "FWIW, I just looked at the Q implementation a bit closer and figured out that you get this same behavior without defining `when()` in the descriptor at all, since the default rejector is written in exactly the same way. That is, you can comment out the line `when: when` in my example and still see the bad behavior.\n\nAlso, to be clear, I did these tests with version 0.8.5 as fetched via npm.\n. Total sidebar here:\n\nI thought `promise.when()` and `promise.then()` were synonyms. I'm betraying my prior work experience (on E, quite a while ago) by having picked that over `promise.then()` in my example.\n\nThanks for the recommendation, and thanks for the fix.\n. Hey there. I've been trying to work my way through this code a bit more, and I've begun to wonder if the `if (done)` checks, while necessary to guarantee the desired property at the level of `Q.when()`'s implementation, are also hiding a bug or deficiency in the implementation of `makePromise.promiseSend()`. What I'm seeing is that method will always make an extra `resolved()` call in cases where the callback it calls issues a rejection.\n\nFor example, take this code:\n\n``` javascript\nvar rej = Q.reject(new Error(\"umm\"));\nQ.when(rej, function () {}, function () {});\n```\n\nThe call to `Q.when()` causes (on `q.js` line 875) a call to be made to `makePromise.promiseSend()`, passing it two function arguments.\n\n`makePromise.promiseSend()` (on line 545) ends up calling the `reject()`'s `when` handler (line 683), which (a) calls the rejector it was handed and (b) returns whatever that rejector returns (in this case `undefined`). The rejector will be the second function argument that was passed in back on line 875.\n\nBack in `makePromise.promiseSend()` the result of that call (that is, `undefined`) gets saved as `result` which then (line 553) becomes the argument to a call to the `resolved` argument. This resolver will be the first function argument passed in back on line 875. It is at this point that the `if (done)` check prevents any more work from being done.\n\nIn the original bug I filed (issue #75), a similar pattern of double calls ends up happening, except on the functions passed into the inner `promiseSend()` of the `when()` implementation.\n\nWhat I'm wondering is if `makePromise.promiseSend()` should have known better than to call both of its argument functions. As I said, it's clear that the `if (done)` checks are handy to help prevent _external_ abuse, but what's happening here is a purely internal call pattern.\n\nThanks again. I'm learning a lot from all this.\n. @domenic I'm afraid the last research I did on the topic was a couple of months ago, with the results posted here.\n. FWIW, I just looked at the Q implementation a bit closer and figured out that you get this same behavior without defining `when()` in the descriptor at all, since the default rejector is written in exactly the same way. That is, you can comment out the line `when: when` in my example and still see the bad behavior.\n\nAlso, to be clear, I did these tests with version 0.8.5 as fetched via npm.\n. Total sidebar here:\n\nI thought `promise.when()` and `promise.then()` were synonyms. I'm betraying my prior work experience (on E, quite a while ago) by having picked that over `promise.then()` in my example.\n\nThanks for the recommendation, and thanks for the fix.\n. Hey there. I've been trying to work my way through this code a bit more, and I've begun to wonder if the `if (done)` checks, while necessary to guarantee the desired property at the level of `Q.when()`'s implementation, are also hiding a bug or deficiency in the implementation of `makePromise.promiseSend()`. What I'm seeing is that method will always make an extra `resolved()` call in cases where the callback it calls issues a rejection.\n\nFor example, take this code:\n\n``` javascript\nvar rej = Q.reject(new Error(\"umm\"));\nQ.when(rej, function () {}, function () {});\n```\n\nThe call to `Q.when()` causes (on `q.js` line 875) a call to be made to `makePromise.promiseSend()`, passing it two function arguments.\n\n`makePromise.promiseSend()` (on line 545) ends up calling the `reject()`'s `when` handler (line 683), which (a) calls the rejector it was handed and (b) returns whatever that rejector returns (in this case `undefined`). The rejector will be the second function argument that was passed in back on line 875.\n\nBack in `makePromise.promiseSend()` the result of that call (that is, `undefined`) gets saved as `result` which then (line 553) becomes the argument to a call to the `resolved` argument. This resolver will be the first function argument passed in back on line 875. It is at this point that the `if (done)` check prevents any more work from being done.\n\nIn the original bug I filed (issue #75), a similar pattern of double calls ends up happening, except on the functions passed into the inner `promiseSend()` of the `when()` implementation.\n\nWhat I'm wondering is if `makePromise.promiseSend()` should have known better than to call both of its argument functions. As I said, it's clear that the `if (done)` checks are handy to help prevent _external_ abuse, but what's happening here is a purely internal call pattern.\n\nThanks again. I'm learning a lot from all this.\n. @domenic I'm afraid the last research I did on the topic was a couple of months ago, with the results posted here.\n. ",
    "dfilatov": "I'm using Q in nodejs (0.6.5) and profile heap's size by profiler middleware in expressjs. Without patch heap size continuously grows when i'm using Q.timeout.\n. Take the following code (test.js):\n\n``` javascript\nvar Q = require('q'),\n    originalDefer = Q.defer();\n\nQ.timeout(originalDefer.promise, 5000);\n\noriginalDefer.reject('error');\n```\n\nRun it in nodejs before patch, defer will be rejected, but nodejs process will hang in for 5 seconds.\nAfter applying of patch the process will be completed immediately after defer was rejected.\n. I'm using Q in nodejs (0.6.5) and profile heap's size by profiler middleware in expressjs. Without patch heap size continuously grows when i'm using Q.timeout.\n. Take the following code (test.js):\n\n``` javascript\nvar Q = require('q'),\n    originalDefer = Q.defer();\n\nQ.timeout(originalDefer.promise, 5000);\n\noriginalDefer.reject('error');\n```\n\nRun it in nodejs before patch, defer will be rejected, but nodejs process will hang in for 5 seconds.\nAfter applying of patch the process will be completed immediately after defer was rejected.\n. ",
    "strmpnk": "In that case shouldn't be be replacing the current value not modifying it then?\n. Do we have any significant code that makes use of put at this point? I'd love to see how people are using it. My one attempt ended with a modification of put to act like a set but also return the object (this patch) but a separate value replacement operation could also be useful.\n\nIn the end, this tiny edit solved the immediate case which was later replaced by alternative code which doesn't use put at all. This makes me wonder if we should refine the role and reason for having this API in the first place.\n. If we don't find use of the core Q implementation of those parts, it's likely a good candidate for removal.\n\nOn a theoretical standpoint of parallel semantics, I think it makes sense to return the object and modify the value (just set the given key) rather than replace the value (the HTTP like verbs seem to only induce confusion here anyway, maybe set is better than put).\n\nOn the practical standpoint, this is not nearly enough to commute parallel operations in many real world cases so it'd be better off specifically being sugar for common operations and if it's not common, we shouldn't add the sugar.\n\nGiven all that, I'd vote to remove the API and have q-comm add it back in such a way that works appropriate for those applications, which would take care of the concerns of both local and remote objects rather than have half the implementation in q and half in q-comm.\n\nIf the feature is not removed, I still find my patch more practical but I'll be avoiding that side of the API for future projects unless I find myself using q-comm.\n. It's interesting to note that it's not a chained use case though. I'll let you guys reserve the final judgement on this feature.\n. In that case shouldn't be be replacing the current value not modifying it then?\n. Do we have any significant code that makes use of put at this point? I'd love to see how people are using it. My one attempt ended with a modification of put to act like a set but also return the object (this patch) but a separate value replacement operation could also be useful.\n\nIn the end, this tiny edit solved the immediate case which was later replaced by alternative code which doesn't use put at all. This makes me wonder if we should refine the role and reason for having this API in the first place.\n. If we don't find use of the core Q implementation of those parts, it's likely a good candidate for removal.\n\nOn a theoretical standpoint of parallel semantics, I think it makes sense to return the object and modify the value (just set the given key) rather than replace the value (the HTTP like verbs seem to only induce confusion here anyway, maybe set is better than put).\n\nOn the practical standpoint, this is not nearly enough to commute parallel operations in many real world cases so it'd be better off specifically being sugar for common operations and if it's not common, we shouldn't add the sugar.\n\nGiven all that, I'd vote to remove the API and have q-comm add it back in such a way that works appropriate for those applications, which would take care of the concerns of both local and remote objects rather than have half the implementation in q and half in q-comm.\n\nIf the feature is not removed, I still find my patch more practical but I'll be avoiding that side of the API for future projects unless I find myself using q-comm.\n. It's interesting to note that it's not a chained use case though. I'll let you guys reserve the final judgement on this feature.\n. ",
    "matthewp": "Thank you domenic, I grok Q a lot better after reading your response.\n\nWith that being said I think the question has to be asked: why is someone going to use Q? I think you laid out 2 excellent ones (wrap code that might throw an error, wrap code that might-or-might-not be async) but let me add a 3rd: to wrap around a traditional callback-based API.\n\nI think the 3rd is underrepresented in the documentation currently and I think my confusion is due to the fact that it's the reason why I'm coming to Q in the first place.  From your response it sounds like deferreds are the way to go when you want to wrap a traditional callback-based API.  So how about an example of xhr that return promises?\n\n``` javascript\nfunction xhr(options) {\n  var deferred = Q.defer(),\n       req = new XMLHttpRequest();\n\n  req.open(options.method || 'GET', options.url, true);\n  req.onreadystatechange = function(e) {\n    if(req.readyState !== 4) {\n      return;\n    }\n\n    if([200,304].indexOf(req.status) === -1) {\n      deferred.reject(req.status);\n    } else {\n      deferred.resolve(e.target.result);\n    }\n  };\n  req.send(options.data);\n\n  return deferred.promise;\n}\n```\n\nOverall I think the documentation on Q.fcall would be less confusing if the explanation for why to use it (as you describe) were included.  Thank you for your help!\n. Ah, sweet. Anyways, here's my implementation with Q as the only prereq (added to the gallery): https://gist.github.com/3099268\n. Thank you domenic, I grok Q a lot better after reading your response.\n\nWith that being said I think the question has to be asked: why is someone going to use Q? I think you laid out 2 excellent ones (wrap code that might throw an error, wrap code that might-or-might-not be async) but let me add a 3rd: to wrap around a traditional callback-based API.\n\nI think the 3rd is underrepresented in the documentation currently and I think my confusion is due to the fact that it's the reason why I'm coming to Q in the first place.  From your response it sounds like deferreds are the way to go when you want to wrap a traditional callback-based API.  So how about an example of xhr that return promises?\n\n``` javascript\nfunction xhr(options) {\n  var deferred = Q.defer(),\n       req = new XMLHttpRequest();\n\n  req.open(options.method || 'GET', options.url, true);\n  req.onreadystatechange = function(e) {\n    if(req.readyState !== 4) {\n      return;\n    }\n\n    if([200,304].indexOf(req.status) === -1) {\n      deferred.reject(req.status);\n    } else {\n      deferred.resolve(e.target.result);\n    }\n  };\n  req.send(options.data);\n\n  return deferred.promise;\n}\n```\n\nOverall I think the documentation on Q.fcall would be less confusing if the explanation for why to use it (as you describe) were included.  Thank you for your help!\n. Ah, sweet. Anyways, here's my implementation with Q as the only prereq (added to the gallery): https://gist.github.com/3099268\n. ",
    "medikoo": "Just to share my experiences. I'm working as well on promise implementation - [Deferred](https://github.com/medikoo/deferred), and once I've approached same problems, the way I've solved them, works well on my side:\n\nCurrently I have three functions that have same signature as `then`\n- `then(callback, errback)` - As we know it, extends the chain by returning newly created promise\n- `aside(callback, errback)` - Returns input promise, does not create a new one and doesn't end the chain. It's useful when we want to return promise for further processing but also need to do something with result on the side.\n- `end(callback, errback)` - Ends promise chain. doesn't return anything and doesn't create any new promise. Both callbacks are optional. If _errback_ is not provided eventual error will throw. As I think of it now `done` name also describes very well this case.\n\nSo currently more often I use `end` or `aside` than `then` as in many cases I don't need promises returned by `then`, it's much cleaner and definitely more performant.\n\nFor bridging Node CPS I have [`cb`](https://github.com/medikoo/deferred#cb) function, that takes callback, and calls it in Node.js style. Callback is optional and if provided it is run in _next tick_ the earliest, this function also returns input promise, so it's handy when building hybrid functions that both return promise and handle Node.js style callback, e.g.:\n\n``` javascript\nvar asyncFunc = function (a, b, cb) {\n    // ...\n    return promise.cb(cb);\n};\n```\n. @ForbesLindesay not sure what you're asking, but as I mentioned for transforming back to Node CPS style Deferred has [promise.cb](https://github.com/medikoo/deferred#cb).\n\nWhen talking about `nend` specifically, I see that `nend` additionally creates and returns new promise which would be resolved right before callback is called. I have problems understanding what use case does it address, as technically all that information (if needed) is already accessible on input promise.\n. @suedama1756 jQuery's implementation is very basic and lacks a lot for a _promise_ solution, Q would be very limited if it would try to be compliant with jQuery's Deferred.\n\nPromise can be either _resolved_ or _unresolved_ and when it's resolved can be either _fulfilled_ or _rejected_, it's very logical and valid approach.\n. @ForbesLindesay you should never use `fs.exists`, logically it's deprecated, check this discussion: https://groups.google.com/forum/?fromgroups=#!topic/nodejs/gRRuly79oRc\n. @tyrsius You should never run `done` on promise that you return for further processing. `done` should be called when you're _done_ with promises and you just want to process final result, and for this very reason it returns `undefined` which is very expected.\n\nInstead of running `done` on each promise in a collection you should have use `done` instead of `then` after `all(..)`  as this is where you process final result. This is right [fiddle](http://jsfiddle.net/medikoo/FUFMA/5/)\n. @tyrsius sorry, I didn't note you take result of `done` as a _promise_. I thought premature `done` call was the issue.\n\nWhy exactly was it hard to debug? Resolved array of `undefined` values didn't raise the warning flag? Was it one of the possibilities if correctly promises were used?\n. @tyrsius I think you can misuse that way any other function which returns `undefined` but you expected it to return _something_ instead, it's not strictly related to `done`.\nThe only aid I see is learning more about the API, we all fall into such traps when learning new things. To me it also looks as thing quite easy to debug, you immediately knew something is not right, it's not error that was swallowed and you learned about few months later.\n. @AsaAyers unlearn `then` and treat `done` as first choice function. You should rather call `done` by mistake instead of `then` ;-) .. still I understand the issue, it's effect of tutorials that promote `then` for every kind of promise value access.\n. Shouldn't progress be solved with basic _EventEmitter_ interface implemented into _Promise_? Then each promise can also be an event emitter, with no restrictions on what may be emitted.\nAt least that's how I solve progress in deferred lib I maintain, works well for my use cases.\n. Just to share my experiences. I'm working as well on promise implementation - [Deferred](https://github.com/medikoo/deferred), and once I've approached same problems, the way I've solved them, works well on my side:\n\nCurrently I have three functions that have same signature as `then`\n- `then(callback, errback)` - As we know it, extends the chain by returning newly created promise\n- `aside(callback, errback)` - Returns input promise, does not create a new one and doesn't end the chain. It's useful when we want to return promise for further processing but also need to do something with result on the side.\n- `end(callback, errback)` - Ends promise chain. doesn't return anything and doesn't create any new promise. Both callbacks are optional. If _errback_ is not provided eventual error will throw. As I think of it now `done` name also describes very well this case.\n\nSo currently more often I use `end` or `aside` than `then` as in many cases I don't need promises returned by `then`, it's much cleaner and definitely more performant.\n\nFor bridging Node CPS I have [`cb`](https://github.com/medikoo/deferred#cb) function, that takes callback, and calls it in Node.js style. Callback is optional and if provided it is run in _next tick_ the earliest, this function also returns input promise, so it's handy when building hybrid functions that both return promise and handle Node.js style callback, e.g.:\n\n``` javascript\nvar asyncFunc = function (a, b, cb) {\n    // ...\n    return promise.cb(cb);\n};\n```\n. @ForbesLindesay not sure what you're asking, but as I mentioned for transforming back to Node CPS style Deferred has [promise.cb](https://github.com/medikoo/deferred#cb).\n\nWhen talking about `nend` specifically, I see that `nend` additionally creates and returns new promise which would be resolved right before callback is called. I have problems understanding what use case does it address, as technically all that information (if needed) is already accessible on input promise.\n. @suedama1756 jQuery's implementation is very basic and lacks a lot for a _promise_ solution, Q would be very limited if it would try to be compliant with jQuery's Deferred.\n\nPromise can be either _resolved_ or _unresolved_ and when it's resolved can be either _fulfilled_ or _rejected_, it's very logical and valid approach.\n. @ForbesLindesay you should never use `fs.exists`, logically it's deprecated, check this discussion: https://groups.google.com/forum/?fromgroups=#!topic/nodejs/gRRuly79oRc\n. @tyrsius You should never run `done` on promise that you return for further processing. `done` should be called when you're _done_ with promises and you just want to process final result, and for this very reason it returns `undefined` which is very expected.\n\nInstead of running `done` on each promise in a collection you should have use `done` instead of `then` after `all(..)`  as this is where you process final result. This is right [fiddle](http://jsfiddle.net/medikoo/FUFMA/5/)\n. @tyrsius sorry, I didn't note you take result of `done` as a _promise_. I thought premature `done` call was the issue.\n\nWhy exactly was it hard to debug? Resolved array of `undefined` values didn't raise the warning flag? Was it one of the possibilities if correctly promises were used?\n. @tyrsius I think you can misuse that way any other function which returns `undefined` but you expected it to return _something_ instead, it's not strictly related to `done`.\nThe only aid I see is learning more about the API, we all fall into such traps when learning new things. To me it also looks as thing quite easy to debug, you immediately knew something is not right, it's not error that was swallowed and you learned about few months later.\n. @AsaAyers unlearn `then` and treat `done` as first choice function. You should rather call `done` by mistake instead of `then` ;-) .. still I understand the issue, it's effect of tutorials that promote `then` for every kind of promise value access.\n. Shouldn't progress be solved with basic _EventEmitter_ interface implemented into _Promise_? Then each promise can also be an event emitter, with no restrictions on what may be emitted.\nAt least that's how I solve progress in deferred lib I maintain, works well for my use cases.\n. ",
    "tlrobinson": "- hermaphrodite\n. - hermaphrodite\n. ",
    "rstacruz": "For those coming in via a Google search, let me save you some reading:\n- This has been merged and is now called [promise.nodeify()](https://github.com/kriskowal/q/wiki/API-Reference#promisenodeifycallback).\n- Calling `.nodeify(done)` is the the equivalent of `.then(function(data) { done(null, data); }, done)`.\n- There's also [promise.done()](https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-onprogress), where `.done(x,y,z)` is the same as `.then(x,y,z).done()`.\n\nExpress.js example:\n\n``` js\nfunction (req, res, next) {\n  Q.when(Posts.findAll())\n  .then(function() {\n    // Do things\n  })\n  .nodeify(next);\n});\n```\n\nMocha.js example:\n\n``` js\nit(\"should work properly\", function(done) {\n  Q.when(Posts.findAll())\n  .then(function(posts) {\n    assert.equal posts.length, 40\n  })\n  .nodeify(done);\n});\n```\n. For those coming in via a Google search, let me save you some reading:\n- This has been merged and is now called [promise.nodeify()](https://github.com/kriskowal/q/wiki/API-Reference#promisenodeifycallback).\n- Calling `.nodeify(done)` is the the equivalent of `.then(function(data) { done(null, data); }, done)`.\n- There's also [promise.done()](https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-onprogress), where `.done(x,y,z)` is the same as `.then(x,y,z).done()`.\n\nExpress.js example:\n\n``` js\nfunction (req, res, next) {\n  Q.when(Posts.findAll())\n  .then(function() {\n    // Do things\n  })\n  .nodeify(next);\n});\n```\n\nMocha.js example:\n\n``` js\nit(\"should work properly\", function(done) {\n  Q.when(Posts.findAll())\n  .then(function(posts) {\n    assert.equal posts.length, 40\n  })\n  .nodeify(done);\n});\n```\n. ",
    "munro": ":heart:\n. heh dammit, I guess I didn't have to escape the `#`\n. :heart:\n. heh dammit, I guess I didn't have to escape the `#`\n. ",
    "ef4": "Sure. Do you mean just these two commits, or the original #90 commit too (since you already merged it)?\n. Style fixes applied & squashed.\n. Yeah, I considered supporting multiple listeners but couldn't come up with a practical reason I'd ever need that.\n. But doesn't `defend(exports)` rule out that kind of API? \n\nAs far as I can see (in Chrome), I'm unable to set properties on `Q` from outside the `Q` module itself.\n. I found a worse case. Here, the promises aren't chained together at all. Simply initiating one promise in the `then` handler of another seems to link them together (via closure references somewhere down inside Q).\n\n``` javascript\n\nfunction test(i){\n    if (i <=0){\n       console.log(\"Done\"); \n    } else { \n       Q.when(i-1).then(test);\n    }\n}\n\n```\n\nThe above keeps all the intermediate values in memory until the last one finishes. But if we insert a delay like this the problem goes away:\n\n``` javascript\n\n\nfunction fixed(i){\n    if (i <=0){\n       console.log(\"Done\"); \n    } else { \n       Q.nextTick(function(){\n         Q.when(i-1).then(fixed);\n       });\n    }\n}\n\n```\n\nThis `fixed` function run in constant memory, whereas the `test` function runs in linear memory.\n. PS: I realized my use of `when` above for coercing a value into a promise may be less correct than using `resolve`, but you get the same problem behavior either way.\n. I think I found the root cause. If I comment out this line in `defer`, we get nice constant memory usage:\n\n```\n        Error.captureStackTrace(promise, defer);\n```\n\nAnd this makes sense. If your current stack contains a bunch of closures, you're going to grab references to them here and they can't get GCed until you let go of the `stack` reference. Those closures in turn have many things in scope that can't get GCed, including other promises with their own `stack` references, and so on. \n\nI don't know what the fix is here, other than to enable a mode that disables these nice stack traces in favor of better memory performance.\n. A workaround that doesn't require altering Q is to set `Error.stackTraceLimit = 0`. \n\nEDITED TO ADD:\n\nI posted the above before seeing domenic's reply. Yes, agreed, I think Error.stackTraceLimit is probably sufficient. I'm don't think any Q-specific limit is needed.\n. Ah right, got it. I was only considering the limit==0 case, which mitigates my immediate problem. \n\nA constant-but-nonzero amount of stack frames would be even better. :-)\n. Sure. Do you mean just these two commits, or the original #90 commit too (since you already merged it)?\n. Style fixes applied & squashed.\n. Yeah, I considered supporting multiple listeners but couldn't come up with a practical reason I'd ever need that.\n. But doesn't `defend(exports)` rule out that kind of API? \n\nAs far as I can see (in Chrome), I'm unable to set properties on `Q` from outside the `Q` module itself.\n. I found a worse case. Here, the promises aren't chained together at all. Simply initiating one promise in the `then` handler of another seems to link them together (via closure references somewhere down inside Q).\n\n``` javascript\n\nfunction test(i){\n    if (i <=0){\n       console.log(\"Done\"); \n    } else { \n       Q.when(i-1).then(test);\n    }\n}\n\n```\n\nThe above keeps all the intermediate values in memory until the last one finishes. But if we insert a delay like this the problem goes away:\n\n``` javascript\n\n\nfunction fixed(i){\n    if (i <=0){\n       console.log(\"Done\"); \n    } else { \n       Q.nextTick(function(){\n         Q.when(i-1).then(fixed);\n       });\n    }\n}\n\n```\n\nThis `fixed` function run in constant memory, whereas the `test` function runs in linear memory.\n. PS: I realized my use of `when` above for coercing a value into a promise may be less correct than using `resolve`, but you get the same problem behavior either way.\n. I think I found the root cause. If I comment out this line in `defer`, we get nice constant memory usage:\n\n```\n        Error.captureStackTrace(promise, defer);\n```\n\nAnd this makes sense. If your current stack contains a bunch of closures, you're going to grab references to them here and they can't get GCed until you let go of the `stack` reference. Those closures in turn have many things in scope that can't get GCed, including other promises with their own `stack` references, and so on. \n\nI don't know what the fix is here, other than to enable a mode that disables these nice stack traces in favor of better memory performance.\n. A workaround that doesn't require altering Q is to set `Error.stackTraceLimit = 0`. \n\nEDITED TO ADD:\n\nI posted the above before seeing domenic's reply. Yes, agreed, I think Error.stackTraceLimit is probably sufficient. I'm don't think any Q-specific limit is needed.\n. Ah right, got it. I was only considering the limit==0 case, which mitigates my immediate problem. \n\nA constant-but-nonzero amount of stack frames would be even better. :-)\n. ",
    "enyo": "Thanks for your reply. Of course I meant `.then(function [...]`; thanks for correcting.\n\nYour example of `resolve()` witch rejected and fulfilled promises convinced me that it's a bad idea ;)\n\nWhich popular library are you talking about (just so I get to know the libraries)?\n. Thanks. I've been struggling with this problem the whole day. Thought I did something wrong until I found your issue.\n. Mh.. well then maybe it would make sense to mention those functions there. Because the `Q.ncall` etc... functions are mentioned at the bottom where it's not that obvious to make that connection.\n\nSo maybe the best way to write this section is to say:\n\n> If you have to work with asynchronous functions, `Q` provides a few shortcuts (see `Q.ncall` and `Q.ninvoke`) or you work with deferreds etc...\n\nSomething like that?\n. Thanks for your reply. Of course I meant `.then(function [...]`; thanks for correcting.\n\nYour example of `resolve()` witch rejected and fulfilled promises convinced me that it's a bad idea ;)\n\nWhich popular library are you talking about (just so I get to know the libraries)?\n. Thanks. I've been struggling with this problem the whole day. Thought I did something wrong until I found your issue.\n. Mh.. well then maybe it would make sense to mention those functions there. Because the `Q.ncall` etc... functions are mentioned at the bottom where it's not that obvious to make that connection.\n\nSo maybe the best way to write this section is to say:\n\n> If you have to work with asynchronous functions, `Q` provides a few shortcuts (see `Q.ncall` and `Q.ninvoke`) or you work with deferreds etc...\n\nSomething like that?\n. ",
    "mmocny": "Sorry to resurrect an old bug.. but I just spent a bit of time tracking down why `nfcall` [returns an array of results](https://github.com/kriskowal/q/blob/v1/q.js#L621) instead of applying them as arguments to callback.\n\nFor the record, I agree with the decision now that I know the philosophy and can see why this decision helps with many use cases (e.g. `spawn()` type generator based workflows).\n\nHowever, I did not catch this reasoning from reading your `README.md` (many times).  Maybe I just missed it, but the [specs for `nfcall`](https://github.com/kriskowal/q#adapting-node) etc do not make it obvious.\n. Sorry to resurrect an old bug.. but I just spent a bit of time tracking down why `nfcall` [returns an array of results](https://github.com/kriskowal/q/blob/v1/q.js#L621) instead of applying them as arguments to callback.\n\nFor the record, I agree with the decision now that I know the philosophy and can see why this decision helps with many use cases (e.g. `spawn()` type generator based workflows).\n\nHowever, I did not catch this reasoning from reading your `README.md` (many times).  Maybe I just missed it, but the [specs for `nfcall`](https://github.com/kriskowal/q#adapting-node) etc do not make it obvious.\n. ",
    "michahell": "Thanks for this discussion, it becomes immediately clear why (also other promise based libraries) we only would want to allow for one resolve() and reject() value.\n. Thanks for this discussion, it becomes immediately clear why (also other promise based libraries) we only would want to allow for one resolve() and reject() value.\n. ",
    "briancavalier": "I noticed that master is ahead of what's in npm (specifically that the [double-when message in q.when() was removed](https://github.com/kriskowal/q/commit/be4af4afb54e96db04422d61d1ab6d41ec252228)), so I tried npm installing directly from the github url, and retried the test.  I still get the infinite loop and CPU/mem spike.\n\nI haven't dug any deeper yet, but I may this weekend.  Any insight you guys have would be much appreciated.\n. Thanks, Domenic.\n. I still don't know what's going on, but I was able to trim down the [test case](https://gist.github.com/3309660).  Now it shows the 4 possible combinations of `.then()` chaining using `when.resolve` and `q.resolve`.  It seems to be some sort of weird interaction between the two since q + q works, and when + when works, but not when + q or q + when.\n. I think I've narrowed it down a bit further.  At first, I thought the `nextTick()` in q.when around 906 was unnecessary ... interestingly, commenting it out avoids the loop.  But, after running Q's unit tests and looking more at the code, I see why it's there.\n\nSo, I tried a different angle.  Here's [another test case](https://gist.github.com/3342531) where it seems like using `q.when()` and `deferred.promise.promiseSend()` should produce equivalent behavior, but they done.  I don't know if that assumption is valid, though.  I tried some other combinations (using when.js's defer or when(), etc. etc.), but the loop seems to happen when I use q.when().\n\n@domenic, have you found any clues?\n. Oops, forgot the [test case link](https://gist.github.com/3342531), added above as well\n. Thanks, Kris, I really appreciate it.  I'll try out the patch tonight with the volo use case where I first encountered the problem.  If all goes well, I'll do a new release tomorrow.\n\nI've actually resisted implementing `valueOf` (or `nearer`) because I felt it encourages people, especially those new to promises, to poll instead of observing with `when/then`.  This might be a reason to implement it.\n\nInterestingly, I haven't run into this problem when dealing with other promise impls (I've used when pretty extensively with Dojo Deferred pre-1.8 and, gasp, $.Deferred, among a few others).  Those implementations don't coerce/assimilate (Dojo 1.8 does), though, which is probably the reason it all works out.\n\nSo, it seems like Promises/A _can_ interoperate without `valueOf`, but perhaps only if there's at least one implementation in the mix that _doesn't_ assimilate in order to break the cycle?\n\nI'll certainly give more thought to adding `valueOf` to when.js.\n. Yeah, I think limiting valueOf calls to promises should work. I had to [do the same](https://github.com/cujojs/when/commit/84fa3f5ead351a157117f801704fb17e0384db3e), but only ran into it today when I mixed when.js and Q promises.\n. I just did a quick experiment where I removed the `valueOf()` call in when.js to see if I could find another way to prevent the Q/when.js infinite coercion loop.  Interestingly enough, if I change when.js's `deferred.resolve()` and `deferred.reject()` to always return `undefined`, that also prevents the loop.  Normally, those methods always return a promise, which is almost purely for convenience.  I think this prevents the loop because of the way both Q and when.js introduce a middle-man deferred using each other's `.then()`.\n\nI noticed that Q returns a promise from the first resolve/reject, but undefined from subsequent ones.  The reason I chose to always return a promise is so that it doesn't reveal anything about the state of the deferred's promise to code that only has the resolver.\n\nSo, maybe there's a solution here, or at least a clue.  It's kinda convenient sometimes for resolve/reject to return a promise, but the better thing is just to always return `undefined`.  That seems to prevent loops, and also doesn't reveal anything to the caller.\n\nOf course, that could be a breaking API change for some Q and when.js users.  Thoughts?\n. Cool, I'll ping the cujo.js google group to see how much of an impact this change might have.  I'm also hoping it'll be minimal.  I do know that `jQuery.Deferred.resolve()/reject()` return promises, so people coming from that universe may get tripped up occasionally, but seems like they'll adapt pretty quickly.\n. Seems like a good call. I'll try it out, but it should work, and should also prevent the infinite loop.\n. Here's a bit more about why rejecting the returned promise seems weird/dangerous to me.\n\n``` js\nvar p2 = p1.then(null, handleRejected, handleProgress);\n```\n\nI think most people interpret Promises/A to mean that `handleProgress` receives updates on progress toward fulfillment/rejection of `p1`.  By extension, that also means progress toward `p2`, but I don't think most people perceive it that way.  On the other hand, `handleRejection` is related only to the time at/after `p1` is rejected.  So, `handleProgress` and `handleRejection` deal with completely disjoint times in `p1`'s lifecycle.\n\nOne might think that since `handleProgress` deals with progress leading (most directly) to `p1`'s fulfillment/rejection, it should reject `p1` if it throws, but that's obviously wrong.  It grants too much authority to anyone who has a reference to `p1`--authority that is reserved for the resolver.  That leaves the option to reject `p2`.\n\nLet's assume it works that way.  I don't necessarily think it's _wrong_, but I think it creates some weird situations.  For example:\n\n``` js\nvar pending = createPending();\nvar p1 = pending.promise;\n\nvar p2 = p1.then(handleFulfilled1, handleRejected1, function(update) {\n    throw new Error();\n});\n\np2.then(handleFulfilled2, handleRejected2)\n\npending.progress('wat');\n```\n\nAt this point, `p2` would become rejected, while `p1` is still pending.  That's kind of a weird state: The tail of the promise chain is unwinding, but the head is still pending!\n\nThat leads to the obvious next question of what happens when the head does start to unwind?  IOW, what should happen when `p1` fulfills or rejects?  Promises/A+ says that `handleFulfilled1` or `handleRejected1`, respectively, must be called.  But what do we do with the result (be it a return value or a thrown exception), since `p2` has already been rejected?\n\nThis seems like a huge problem: No one can observe the result of `handleFulfilled1` or `handleRejected1`\n\nI don't have any better options to offer right now, but just wanted to write down some of the potential pitfalls.\n. Yeah, propagating the error was my short-term \"solution\", until we could figure out something better.  We listed progress propagation as an experimental feature in a recent release.\n\nI'm beginning to think separating progress from `then` might be the path to the best solution.\n. [This comment](https://github.com/kriskowal/q/issues/136#issuecomment-10665116) has most of my thoughts on why this is tricky.  Honestly, I had to re-read them, since I haven't throught about this issue in a while.  The biggest problems that I see (see the above comment for more detail) are: 1) allowing promise `p`'s progress handlers to cause `p` to reject grants too much authority, and 2) allowing `p`'s progress handlers to reject children of `p` creates a weird situation where the outcome of `p` can't be observed.\n\nI hope there's a better alternative, but the only things that seem at all reasonable to me right are:\n1. pass errors through as progress and force progress handlers to deal with them. This is what when.js does.\n2. \"crash\", what Q does. This effectively forces devs to ensure progress handlers cannot throw, which honestly doesn't seem like a bad thing at all.\n\nI just re-read [this idea from over at Promises/A+](https://github.com/promises-aplus/progress-spec/issues/3#issuecomment-11609297), and now I'm very intrigued by it.  I need to give it more thought, but would be interested to hear @domenic's and @ForbesLindesay's latest thinking on it as well.\n. @kriskowal A minor version bump should be fine since the required AMD config change is simple.  If you further split Q into submodules that users may want to `require` individually, you'll likely want to look into [AMD package configs](https://github.com/amdjs/amdjs-api/wiki/Common-Config#packages-)--still simple stuff, tho.\n. I noticed that master is ahead of what's in npm (specifically that the [double-when message in q.when() was removed](https://github.com/kriskowal/q/commit/be4af4afb54e96db04422d61d1ab6d41ec252228)), so I tried npm installing directly from the github url, and retried the test.  I still get the infinite loop and CPU/mem spike.\n\nI haven't dug any deeper yet, but I may this weekend.  Any insight you guys have would be much appreciated.\n. Thanks, Domenic.\n. I still don't know what's going on, but I was able to trim down the [test case](https://gist.github.com/3309660).  Now it shows the 4 possible combinations of `.then()` chaining using `when.resolve` and `q.resolve`.  It seems to be some sort of weird interaction between the two since q + q works, and when + when works, but not when + q or q + when.\n. I think I've narrowed it down a bit further.  At first, I thought the `nextTick()` in q.when around 906 was unnecessary ... interestingly, commenting it out avoids the loop.  But, after running Q's unit tests and looking more at the code, I see why it's there.\n\nSo, I tried a different angle.  Here's [another test case](https://gist.github.com/3342531) where it seems like using `q.when()` and `deferred.promise.promiseSend()` should produce equivalent behavior, but they done.  I don't know if that assumption is valid, though.  I tried some other combinations (using when.js's defer or when(), etc. etc.), but the loop seems to happen when I use q.when().\n\n@domenic, have you found any clues?\n. Oops, forgot the [test case link](https://gist.github.com/3342531), added above as well\n. Thanks, Kris, I really appreciate it.  I'll try out the patch tonight with the volo use case where I first encountered the problem.  If all goes well, I'll do a new release tomorrow.\n\nI've actually resisted implementing `valueOf` (or `nearer`) because I felt it encourages people, especially those new to promises, to poll instead of observing with `when/then`.  This might be a reason to implement it.\n\nInterestingly, I haven't run into this problem when dealing with other promise impls (I've used when pretty extensively with Dojo Deferred pre-1.8 and, gasp, $.Deferred, among a few others).  Those implementations don't coerce/assimilate (Dojo 1.8 does), though, which is probably the reason it all works out.\n\nSo, it seems like Promises/A _can_ interoperate without `valueOf`, but perhaps only if there's at least one implementation in the mix that _doesn't_ assimilate in order to break the cycle?\n\nI'll certainly give more thought to adding `valueOf` to when.js.\n. Yeah, I think limiting valueOf calls to promises should work. I had to [do the same](https://github.com/cujojs/when/commit/84fa3f5ead351a157117f801704fb17e0384db3e), but only ran into it today when I mixed when.js and Q promises.\n. I just did a quick experiment where I removed the `valueOf()` call in when.js to see if I could find another way to prevent the Q/when.js infinite coercion loop.  Interestingly enough, if I change when.js's `deferred.resolve()` and `deferred.reject()` to always return `undefined`, that also prevents the loop.  Normally, those methods always return a promise, which is almost purely for convenience.  I think this prevents the loop because of the way both Q and when.js introduce a middle-man deferred using each other's `.then()`.\n\nI noticed that Q returns a promise from the first resolve/reject, but undefined from subsequent ones.  The reason I chose to always return a promise is so that it doesn't reveal anything about the state of the deferred's promise to code that only has the resolver.\n\nSo, maybe there's a solution here, or at least a clue.  It's kinda convenient sometimes for resolve/reject to return a promise, but the better thing is just to always return `undefined`.  That seems to prevent loops, and also doesn't reveal anything to the caller.\n\nOf course, that could be a breaking API change for some Q and when.js users.  Thoughts?\n. Cool, I'll ping the cujo.js google group to see how much of an impact this change might have.  I'm also hoping it'll be minimal.  I do know that `jQuery.Deferred.resolve()/reject()` return promises, so people coming from that universe may get tripped up occasionally, but seems like they'll adapt pretty quickly.\n. Seems like a good call. I'll try it out, but it should work, and should also prevent the infinite loop.\n. Here's a bit more about why rejecting the returned promise seems weird/dangerous to me.\n\n``` js\nvar p2 = p1.then(null, handleRejected, handleProgress);\n```\n\nI think most people interpret Promises/A to mean that `handleProgress` receives updates on progress toward fulfillment/rejection of `p1`.  By extension, that also means progress toward `p2`, but I don't think most people perceive it that way.  On the other hand, `handleRejection` is related only to the time at/after `p1` is rejected.  So, `handleProgress` and `handleRejection` deal with completely disjoint times in `p1`'s lifecycle.\n\nOne might think that since `handleProgress` deals with progress leading (most directly) to `p1`'s fulfillment/rejection, it should reject `p1` if it throws, but that's obviously wrong.  It grants too much authority to anyone who has a reference to `p1`--authority that is reserved for the resolver.  That leaves the option to reject `p2`.\n\nLet's assume it works that way.  I don't necessarily think it's _wrong_, but I think it creates some weird situations.  For example:\n\n``` js\nvar pending = createPending();\nvar p1 = pending.promise;\n\nvar p2 = p1.then(handleFulfilled1, handleRejected1, function(update) {\n    throw new Error();\n});\n\np2.then(handleFulfilled2, handleRejected2)\n\npending.progress('wat');\n```\n\nAt this point, `p2` would become rejected, while `p1` is still pending.  That's kind of a weird state: The tail of the promise chain is unwinding, but the head is still pending!\n\nThat leads to the obvious next question of what happens when the head does start to unwind?  IOW, what should happen when `p1` fulfills or rejects?  Promises/A+ says that `handleFulfilled1` or `handleRejected1`, respectively, must be called.  But what do we do with the result (be it a return value or a thrown exception), since `p2` has already been rejected?\n\nThis seems like a huge problem: No one can observe the result of `handleFulfilled1` or `handleRejected1`\n\nI don't have any better options to offer right now, but just wanted to write down some of the potential pitfalls.\n. Yeah, propagating the error was my short-term \"solution\", until we could figure out something better.  We listed progress propagation as an experimental feature in a recent release.\n\nI'm beginning to think separating progress from `then` might be the path to the best solution.\n. [This comment](https://github.com/kriskowal/q/issues/136#issuecomment-10665116) has most of my thoughts on why this is tricky.  Honestly, I had to re-read them, since I haven't throught about this issue in a while.  The biggest problems that I see (see the above comment for more detail) are: 1) allowing promise `p`'s progress handlers to cause `p` to reject grants too much authority, and 2) allowing `p`'s progress handlers to reject children of `p` creates a weird situation where the outcome of `p` can't be observed.\n\nI hope there's a better alternative, but the only things that seem at all reasonable to me right are:\n1. pass errors through as progress and force progress handlers to deal with them. This is what when.js does.\n2. \"crash\", what Q does. This effectively forces devs to ensure progress handlers cannot throw, which honestly doesn't seem like a bad thing at all.\n\nI just re-read [this idea from over at Promises/A+](https://github.com/promises-aplus/progress-spec/issues/3#issuecomment-11609297), and now I'm very intrigued by it.  I need to give it more thought, but would be interested to hear @domenic's and @ForbesLindesay's latest thinking on it as well.\n. @kriskowal A minor version bump should be fine since the required AMD config change is simple.  If you further split Q into submodules that users may want to `require` individually, you'll likely want to look into [AMD package configs](https://github.com/amdjs/amdjs-api/wiki/Common-Config#packages-)--still simple stuff, tho.\n. ",
    "shockie": "Hi, \n\nThanks for all the replies, just tested the pattern of @domenic and it works:) Perhaps the docs can be updated with this example, since I didn't understood the magic of spread based on the docs:)\n. Hi, \n\nThanks for all the replies, just tested the pattern of @domenic and it works:) Perhaps the docs can be updated with this example, since I didn't understood the magic of spread based on the docs:)\n. ",
    "JamesMGreene": "@domenic @kriskowal Did the file structure refactor get logged somewhere else as discussed here?  I didn't see any pertinent open issues to that effect.\n. @domenic @kriskowal Did the file structure refactor get logged somewhere else as discussed here?  I didn't see any pertinent open issues to that effect.\n. ",
    "dominykas": "We've been running this hack in production for over 6 months now, and only recently it occurred to me to check what effect it has on memory. In our case, the app is normally ~100-120Mb with the hack on, and ~70-90Mb with the hack off. We're creating ~250 promises/minute. IMHO it's not too bad and totally worth it :)\n\nAs a nice side effect, we're plotting a number of \"slow promises\" (>2s to fulfill) - this has helped us detect a failing hard drive (it took us a while to pinpoint, but the increase in \"slow promises\" was the first symptom) :)\n. Then again, I have no clue what the order of execution should be in this case:\nStrand 1: promise.then().fail().fin(/_1_/)\nStrand 2: promise.then().fail().fin(/_2_/).then().fail().fin(/_3_/);\nStrand 3: promise.then().fail().fin(/_4_/)\n\n1-2-3-4? 2-1-3-4?\n\nCurrent situation: 1-2-4-3 - which kind of makes sense, but is also not very intuitive... or is it?\n. OK, gotcha. \n\nI start to understand what's going on... after having created another gist: https://gist.github.com/3935913\n\nI still feel it is unnatural, although it might just be me, and I can't define what \"natural\" should be, so I'd better shut up for now :)\n. Yes, I was fixated on the notion that .fin() is special. It isn't. If you swap 2/3 in the original example everything becomes very clear :)\n\nI assume nend/done/ndone/whatever else will work the same way?\n\nPS: .fin() sounds more like .whatever() in try/catch/finally grammar :)\n. OK. I guess it kind of makes sense to do it that way - move down the promise chain ASAP.\n\nI don't need a particular order, I just need to be able to have \"one last handler to rule them all\" - but it would not make sense in the API anyways, so I'll probably just stuff all the chains into an array and Q.all() - this is something I was planning to do later for the particular use case, and it's probably for the better.\n\nAlthough this is not a bug, there might be a need for an improvement in the docs...\n. We've been running this hack in production for over 6 months now, and only recently it occurred to me to check what effect it has on memory. In our case, the app is normally ~100-120Mb with the hack on, and ~70-90Mb with the hack off. We're creating ~250 promises/minute. IMHO it's not too bad and totally worth it :)\n\nAs a nice side effect, we're plotting a number of \"slow promises\" (>2s to fulfill) - this has helped us detect a failing hard drive (it took us a while to pinpoint, but the increase in \"slow promises\" was the first symptom) :)\n. Then again, I have no clue what the order of execution should be in this case:\nStrand 1: promise.then().fail().fin(/_1_/)\nStrand 2: promise.then().fail().fin(/_2_/).then().fail().fin(/_3_/);\nStrand 3: promise.then().fail().fin(/_4_/)\n\n1-2-3-4? 2-1-3-4?\n\nCurrent situation: 1-2-4-3 - which kind of makes sense, but is also not very intuitive... or is it?\n. OK, gotcha. \n\nI start to understand what's going on... after having created another gist: https://gist.github.com/3935913\n\nI still feel it is unnatural, although it might just be me, and I can't define what \"natural\" should be, so I'd better shut up for now :)\n. Yes, I was fixated on the notion that .fin() is special. It isn't. If you swap 2/3 in the original example everything becomes very clear :)\n\nI assume nend/done/ndone/whatever else will work the same way?\n\nPS: .fin() sounds more like .whatever() in try/catch/finally grammar :)\n. OK. I guess it kind of makes sense to do it that way - move down the promise chain ASAP.\n\nI don't need a particular order, I just need to be able to have \"one last handler to rule them all\" - but it would not make sense in the API anyways, so I'll probably just stuff all the chains into an array and Q.all() - this is something I was planning to do later for the particular use case, and it's probably for the better.\n\nAlthough this is not a bug, there might be a need for an improvement in the docs...\n. ",
    "novemberborn": "> This is proving to be quite a complex issue. I'd almost be inclined to require users to be explicit about what progress gets forwarded and how it gets forwarded.\n\nI'm planning to add progress propagation to Dojo 1.8.1. If the progback returns a non-undefined value, that value is emitted as a progress update on the returned promise.\n. > It would also follow that progress is a single value, so we should need to lock down the arity of the progress emitter.\n\nIIRC deferreds only have single resolution, rejection or progress values.\n\n> It is probably okay, for the purpose of progress notifications, to assume that the operation will not fail, and to reset the progress to the resolution of the handler.\n\nDoes that assumption mean there is no rejection of the promise if the operation does fail? I don't think that's right.\n\n> Maybe it is okay for progress to pass-through by default, and to be able to adapt the progress in the progback. \n\nIn Dojo the progress is pass-through if there is no progback registered.\n. > If you recall what correctly? Promises/A gives no guidance. On the other hand all libraries but jQuery do have single progress values (and jQuery doesn't count, they don't even have single fulfillment values or rejection reasons).\n\nHa, fair enough. Single values all the way for me.\n\nI'm not familiar with the `promise.progress()` syntax you use, so allow me to give an example:\n\n``` js\nvar dfd = new Deferred();\ndfd.then(f, r, p);\n\ndfd.progress(\"foo\"); // --> p(\"foo\")\ndfd.progress(otherPromise); // --> p(otherPromise)\ndfd.resolve(\"bar\");  // --> f(\"bar\");\ndfd.progress(\"baz\"); // noop\n```\n. > The example I gave was trying to figure out how returning a promise from a progressback behaves. Any feedback on that?\n\nThe promise is passed on as a progress update.\n\nI don't think progress is used often enough to warrant much sugar. In Dojo for instance there is no sugar for `promise.then(null, null, p)`, yet there is `promise.otherwise(e)` for `promise.then(null, e)`. It's just not a common use case.\n\nFor the scenario you're describing:\n\n``` js\nvar otherPromise = promise.progress(function(update){\n  // Process the update asynchronously, return a promise to propagate more progress later\u2026\n  return asyncPromise;\n});\n```\n\nWithout magic handling of the progress promise you can still achieve the same by manually forwarding the promise state:\n\n``` js\nvar otherDeferred = new Deferred(promise.cancel);\npromise.then(otherDeferred.resolve, otherDeferred.reject, function(update){\n  asyncPromise.then(null, null, otherDeferred.progress);\n});\n\nvar otherPromise = otherDeferred.promise;\n```\n. > This is proving to be quite a complex issue. I'd almost be inclined to require users to be explicit about what progress gets forwarded and how it gets forwarded.\n\nI'm planning to add progress propagation to Dojo 1.8.1. If the progback returns a non-undefined value, that value is emitted as a progress update on the returned promise.\n. > It would also follow that progress is a single value, so we should need to lock down the arity of the progress emitter.\n\nIIRC deferreds only have single resolution, rejection or progress values.\n\n> It is probably okay, for the purpose of progress notifications, to assume that the operation will not fail, and to reset the progress to the resolution of the handler.\n\nDoes that assumption mean there is no rejection of the promise if the operation does fail? I don't think that's right.\n\n> Maybe it is okay for progress to pass-through by default, and to be able to adapt the progress in the progback. \n\nIn Dojo the progress is pass-through if there is no progback registered.\n. > If you recall what correctly? Promises/A gives no guidance. On the other hand all libraries but jQuery do have single progress values (and jQuery doesn't count, they don't even have single fulfillment values or rejection reasons).\n\nHa, fair enough. Single values all the way for me.\n\nI'm not familiar with the `promise.progress()` syntax you use, so allow me to give an example:\n\n``` js\nvar dfd = new Deferred();\ndfd.then(f, r, p);\n\ndfd.progress(\"foo\"); // --> p(\"foo\")\ndfd.progress(otherPromise); // --> p(otherPromise)\ndfd.resolve(\"bar\");  // --> f(\"bar\");\ndfd.progress(\"baz\"); // noop\n```\n. > The example I gave was trying to figure out how returning a promise from a progressback behaves. Any feedback on that?\n\nThe promise is passed on as a progress update.\n\nI don't think progress is used often enough to warrant much sugar. In Dojo for instance there is no sugar for `promise.then(null, null, p)`, yet there is `promise.otherwise(e)` for `promise.then(null, e)`. It's just not a common use case.\n\nFor the scenario you're describing:\n\n``` js\nvar otherPromise = promise.progress(function(update){\n  // Process the update asynchronously, return a promise to propagate more progress later\u2026\n  return asyncPromise;\n});\n```\n\nWithout magic handling of the progress promise you can still achieve the same by manually forwarding the promise state:\n\n``` js\nvar otherDeferred = new Deferred(promise.cancel);\npromise.then(otherDeferred.resolve, otherDeferred.reject, function(update){\n  asyncPromise.then(null, null, otherDeferred.progress);\n});\n\nvar otherPromise = otherDeferred.promise;\n```\n. ",
    "mikeal": "actually, after a small refactor several months ago, the calling of the request callback always happens in an event handler on the Request event emitter so it's already bound to the current domain (assuming there is one) by nature of being an event emitter. in other words it's better to think of request's callback API as an eventemitter event handler. a better illustration might be redis' callback API which works on top of a connection pool and therefor isn't automatically scoped to the current domain.\n. you could create a little callback api around a tcp server and hit it a few times, popping the callbacks off of an array.\n\nsetTimeout and nextTick will both already get trapped.\n\nOn Nov 28, 2012, at November 28, 20129:04 PM, Domenic Denicola notifications@github.com wrote:\n\n> @mikeal is there a simple async function we can call (or setup we can create) to exhibit this behavior, without dragging in a redis library? E.g. some way I could modify the test case above to use something other than setTimeout and somehow escape the domain.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. actually, after a small refactor several months ago, the calling of the request callback always happens in an event handler on the Request event emitter so it's already bound to the current domain (assuming there is one) by nature of being an event emitter. in other words it's better to think of request's callback API as an eventemitter event handler. a better illustration might be redis' callback API which works on top of a connection pool and therefor isn't automatically scoped to the current domain.\n. you could create a little callback api around a tcp server and hit it a few times, popping the callbacks off of an array.\n\nsetTimeout and nextTick will both already get trapped.\n\nOn Nov 28, 2012, at November 28, 20129:04 PM, Domenic Denicola notifications@github.com wrote:\n\n> @mikeal is there a simple async function we can call (or setup we can create) to exhibit this behavior, without dragging in a redis library? E.g. some way I could modify the test case above to use something other than setTimeout and somehow escape the domain.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "isaacs": "@domenic Here's some code that will not behave properly.\n\n``` javascript\n// The \"pool\"\nvar EE = require('events').EventEmitter\nvar e = new EE\ne._interval = setInterval(function() {\n  e.emit('beep', Math.random())\n}, 100)\n\n// the API\nfunction beep(cb) {\n  e.once('beep', cb)\n}\n\n// the client\nvar domain = require('domain')\nvar d = domain.create()\nd.on('error', function(er) {\n  console.error('got an error', er)\n})\nd.run(function() {\n  beep(function(n) {\n    // we've escaped the domain!\n    throw new Error('oops i accidentaly the javascript')\n  })\n})\n```\n. So, the Bad Thing only happens because the \"async\" call is not using any new async mechanism, but instead hopping onto the event emitted by something that was set up _before_ entering the domain.\n\nAs a result, because callbacks are not implicitly bound (though any way to get them \"into the future\" IS implicitly bound, if it's created right now), the callback gets called outside the domain.\n\nIn this case, it can be solved by using an explicitly bound callback:\n\n``` javascript\n// The \"pool\"\nvar EE = require('events').EventEmitter\nvar e = new EE\ne._interval = setInterval(function() {\n  e.emit('beep', Math.random())\n}, 100)\n\n// the API\nfunction beep(cb) {\n\n  // -=-=-=--=-=-=-=-=-=-=-=-=-\n  // THE FIX:\n  if (process.domain)\n    cb = process.domain.bind(cb)\n  // -=-=-=--=-=-=-=-=-=-=-=-=-\n\n  e.once('beep', cb)\n}\n\n// the client\nvar domain = require('domain')\nvar d = domain.create()\nd.on('error', function(er) {\n  console.error('got an error', er)\n})\nd.run(function() {\n  beep(function(n) {\n    // there is no escape!\n    throw new Error('oops i accidentaly the javascript')\n  })\n})\n```\n\nThere are two ways to look at this.\n\nSince a lot of people use flow control libs, you can solve a lot of un-found problems by putting explicit binding in the flow control libs.  (Q, async, etc.)\n\nOtoh, that's potentially adding a cost which is unnecessary most of the time.  There are not many client-pooling libs out there that re-use event emitters, and provide a callback API.  It's probably easier to just patch it in the few places where it's actually broken, especially they're still broken even if the flow control libs are patched, that won't help people who aren't using Q or async.\n. @domenic No, it would not fix it.  When you create the nextTick, you're out of the domain.  nextTick will be implicitly bound to the currently active domain, but when you're calling process.nextTick, _there is no currently active domain_, because you're in the context of the `e` object, which does not have a domain.\n. @domenic Here's some code that will not behave properly.\n\n``` javascript\n// The \"pool\"\nvar EE = require('events').EventEmitter\nvar e = new EE\ne._interval = setInterval(function() {\n  e.emit('beep', Math.random())\n}, 100)\n\n// the API\nfunction beep(cb) {\n  e.once('beep', cb)\n}\n\n// the client\nvar domain = require('domain')\nvar d = domain.create()\nd.on('error', function(er) {\n  console.error('got an error', er)\n})\nd.run(function() {\n  beep(function(n) {\n    // we've escaped the domain!\n    throw new Error('oops i accidentaly the javascript')\n  })\n})\n```\n. So, the Bad Thing only happens because the \"async\" call is not using any new async mechanism, but instead hopping onto the event emitted by something that was set up _before_ entering the domain.\n\nAs a result, because callbacks are not implicitly bound (though any way to get them \"into the future\" IS implicitly bound, if it's created right now), the callback gets called outside the domain.\n\nIn this case, it can be solved by using an explicitly bound callback:\n\n``` javascript\n// The \"pool\"\nvar EE = require('events').EventEmitter\nvar e = new EE\ne._interval = setInterval(function() {\n  e.emit('beep', Math.random())\n}, 100)\n\n// the API\nfunction beep(cb) {\n\n  // -=-=-=--=-=-=-=-=-=-=-=-=-\n  // THE FIX:\n  if (process.domain)\n    cb = process.domain.bind(cb)\n  // -=-=-=--=-=-=-=-=-=-=-=-=-\n\n  e.once('beep', cb)\n}\n\n// the client\nvar domain = require('domain')\nvar d = domain.create()\nd.on('error', function(er) {\n  console.error('got an error', er)\n})\nd.run(function() {\n  beep(function(n) {\n    // there is no escape!\n    throw new Error('oops i accidentaly the javascript')\n  })\n})\n```\n\nThere are two ways to look at this.\n\nSince a lot of people use flow control libs, you can solve a lot of un-found problems by putting explicit binding in the flow control libs.  (Q, async, etc.)\n\nOtoh, that's potentially adding a cost which is unnecessary most of the time.  There are not many client-pooling libs out there that re-use event emitters, and provide a callback API.  It's probably easier to just patch it in the few places where it's actually broken, especially they're still broken even if the flow control libs are patched, that won't help people who aren't using Q or async.\n. @domenic No, it would not fix it.  When you create the nextTick, you're out of the domain.  nextTick will be implicitly bound to the currently active domain, but when you're calling process.nextTick, _there is no currently active domain_, because you're in the context of the `e` object, which does not have a domain.\n. ",
    "CrabDude": "If you want to guarantee all async errors are \"caught\" / callbacks are bound to the appropriate domain, there are only 2 options:\n1. Shim EventEmitter to bind callbacks to the active domain at time of binding instead of ee.domain.\n   \n   This solves the long lived connection issue but fails for socket pooling (e.g., forever-agent used with http.request). [trycatch](https://github.com/CrabDude/trycatch) does this.\n2. Ensure callbacks are bound to the active domain.\n   \n   This is cumbersome at the application level, but expected at the library level (e.g., forever-agent should reset domains appropriately). Unfortunately, Q has no control over call stacks where Q is not used, which is why trycatch takes the first approach.\n\nSo, why am I mentioning this?\n\nBecause really the test that you're trying to get passing isn't related to promises or Q in any way; it's an issue with domains. My recommendation? Use trycatch.\n. @danawoodman I'm not certain who you're asking or which recommendation you're referring to, but... \n\nUsing domains is no longer recommended since, as you pointed out, they're deprecated. The issue of catching all (async) errors remains an outstanding issue that [`trycatch`](https://github.com/CrabDude/trycatch) alone solves. `trycatch` alone also properly resets the _current stack_ in a consistent predictable manner.\n\nLast I checked, `trycatch` works with `q` and other promise libraries as I use `q` myself in production.\n. FWIW, this won't ever work with domains, because the reason you must restart with domains is the same reason you must restart without them: the core call stack is not allowed to unwind, creating an undefined state.\n\nIt's also coincidentally the same reason why promises catching all exceptions can actually be a liability, since exceptions from core, or exceptions with a slice of core frames sandwiched between userland frames in its call stack should not be caught.\n\nThere are two ways to solve this, wrap the userland boundary in try/catch blocks to guarantee core stacks always unwind and don't catch / rethrow [TRESUR errors](https://twitter.com/CrabDude/status/318876149608501248) from core (which is what [trycatch](https://github.com/CrabDude/trycatch) does), or a [Generators + Asynchrony Implementation](https://github.com/AsynchronousGenerators/agen-spec) that separates errors from exceptions, in addition to catching JSON.parse exceptions and never ever throwing.\n\nEither way, we're now using Q at LinkedIn, and eventually we'll be using Generators + Promises, so I'd like to raise awareness of this common misunderstanding of domains since without a solution like trycatch's it would actually be a bug.\n\n@domenic If you remember, I explained all of this to you at nodeconf after your domains presentation included the same inaccurate information.\n. @domenic WRT coherency, see #427\n. If you want to guarantee all async errors are \"caught\" / callbacks are bound to the appropriate domain, there are only 2 options:\n1. Shim EventEmitter to bind callbacks to the active domain at time of binding instead of ee.domain.\n   \n   This solves the long lived connection issue but fails for socket pooling (e.g., forever-agent used with http.request). [trycatch](https://github.com/CrabDude/trycatch) does this.\n2. Ensure callbacks are bound to the active domain.\n   \n   This is cumbersome at the application level, but expected at the library level (e.g., forever-agent should reset domains appropriately). Unfortunately, Q has no control over call stacks where Q is not used, which is why trycatch takes the first approach.\n\nSo, why am I mentioning this?\n\nBecause really the test that you're trying to get passing isn't related to promises or Q in any way; it's an issue with domains. My recommendation? Use trycatch.\n. @danawoodman I'm not certain who you're asking or which recommendation you're referring to, but... \n\nUsing domains is no longer recommended since, as you pointed out, they're deprecated. The issue of catching all (async) errors remains an outstanding issue that [`trycatch`](https://github.com/CrabDude/trycatch) alone solves. `trycatch` alone also properly resets the _current stack_ in a consistent predictable manner.\n\nLast I checked, `trycatch` works with `q` and other promise libraries as I use `q` myself in production.\n. FWIW, this won't ever work with domains, because the reason you must restart with domains is the same reason you must restart without them: the core call stack is not allowed to unwind, creating an undefined state.\n\nIt's also coincidentally the same reason why promises catching all exceptions can actually be a liability, since exceptions from core, or exceptions with a slice of core frames sandwiched between userland frames in its call stack should not be caught.\n\nThere are two ways to solve this, wrap the userland boundary in try/catch blocks to guarantee core stacks always unwind and don't catch / rethrow [TRESUR errors](https://twitter.com/CrabDude/status/318876149608501248) from core (which is what [trycatch](https://github.com/CrabDude/trycatch) does), or a [Generators + Asynchrony Implementation](https://github.com/AsynchronousGenerators/agen-spec) that separates errors from exceptions, in addition to catching JSON.parse exceptions and never ever throwing.\n\nEither way, we're now using Q at LinkedIn, and eventually we'll be using Generators + Promises, so I'd like to raise awareness of this common misunderstanding of domains since without a solution like trycatch's it would actually be a bug.\n\n@domenic If you remember, I explained all of this to you at nodeconf after your domains presentation included the same inaccurate information.\n. @domenic WRT coherency, see #427\n. ",
    "grahamrhay": "Hi,\n\nIs there a reason why this wouldn't (/shouldn't) work?\n\n``` js\nit(\"wtf\", function (done) {\n    var domain1 = domain.create();\n    domain1.run(function() {\n        console.log('domain1');\n        var promiseFactory = Q.fbind(function() {\n            console.log('here1');\n            return true;\n        });\n        var promise = promiseFactory();\n        promise.done(function() {\n            console.log('here2');\n            throw new Error('something bad');\n        }); \n    });\n    domain1.on('error', function(err) {\n        console.log('error', err.stack);\n        domain1.exit();\n        domain1.dispose();\n        var domain2 = domain.create();\n        domain2.run(function() {\n            console.log('domain2');\n            var promiseFactory = Q.fbind(function() {\n                console.log('here3');\n                return true;\n            }); \n            var promise = promiseFactory();\n            promise.done(function() {\n                console.log('here4');\n                done();\n            }); \n        }); \n    }); \n});\n```\n\nWhere by \"doesn't work\", I mean that the promise in the 2nd domain is not executed. If I remove the call to dispose the 1st domain, it works as expected.\n. I rebased this on v1, I assume that's the current development branch?\n. fine with me!\n. Hi,\n\nIs there a reason why this wouldn't (/shouldn't) work?\n\n``` js\nit(\"wtf\", function (done) {\n    var domain1 = domain.create();\n    domain1.run(function() {\n        console.log('domain1');\n        var promiseFactory = Q.fbind(function() {\n            console.log('here1');\n            return true;\n        });\n        var promise = promiseFactory();\n        promise.done(function() {\n            console.log('here2');\n            throw new Error('something bad');\n        }); \n    });\n    domain1.on('error', function(err) {\n        console.log('error', err.stack);\n        domain1.exit();\n        domain1.dispose();\n        var domain2 = domain.create();\n        domain2.run(function() {\n            console.log('domain2');\n            var promiseFactory = Q.fbind(function() {\n                console.log('here3');\n                return true;\n            }); \n            var promise = promiseFactory();\n            promise.done(function() {\n                console.log('here4');\n                done();\n            }); \n        }); \n    }); \n});\n```\n\nWhere by \"doesn't work\", I mean that the promise in the 2nd domain is not executed. If I remove the call to dispose the 1st domain, it works as expected.\n. I rebased this on v1, I assume that's the current development branch?\n. fine with me!\n. ",
    "behrad": "and whats the best decision when composing a ROBUST ACK-based callback-based IOC container which call's user's callback and at the end should be notified with the passed done callback, providing that the container wants to guard against user's code probable un-handled errors (which will cause no done callback be called later, and container won't get notified) and also not to swallow un-handled errors in user's code context?\n\nif should use domains (to guard against all type of errors), then\n1) If user has not any active domains, we provide a domain, catch errors, re-emit them on an EE so that user can know about it!?\n2) What if user had an active domain? How can we chain/propagate errors between different domains so that both container and user can do their handlings?\n\nI've seen libs like https://github.com/epeli/qdomain and https://github.com/CrabDude/trycatch but can't yet get the benefits from mixing promises with domains, I found no other solutions for catching all types of errors with promises without domains.\n. @danawoodman That section in Kue docs is older than domains deprecation, so please create an issue in Kue to update the docs.\n. and whats the best decision when composing a ROBUST ACK-based callback-based IOC container which call's user's callback and at the end should be notified with the passed done callback, providing that the container wants to guard against user's code probable un-handled errors (which will cause no done callback be called later, and container won't get notified) and also not to swallow un-handled errors in user's code context?\n\nif should use domains (to guard against all type of errors), then\n1) If user has not any active domains, we provide a domain, catch errors, re-emit them on an EE so that user can know about it!?\n2) What if user had an active domain? How can we chain/propagate errors between different domains so that both container and user can do their handlings?\n\nI've seen libs like https://github.com/epeli/qdomain and https://github.com/CrabDude/trycatch but can't yet get the benefits from mixing promises with domains, I found no other solutions for catching all types of errors with promises without domains.\n. @danawoodman That section in Kue docs is older than domains deprecation, so please create an issue in Kue to update the docs.\n. ",
    "danawoodman": "Why is this the recommended approach if domains is being depricated? https://nodejs.org/api/domain.html\n. Sorry, I was referring to a linked issue above in [kue](https://github.com/Automattic/kue) where they recommend using domains despite their deprecation: https://github.com/Automattic/kue#prevent-from-stuck-active-jobs\n. Why is this the recommended approach if domains is being depricated? https://nodejs.org/api/domain.html\n. Sorry, I was referring to a linked issue above in [kue](https://github.com/Automattic/kue) where they recommend using domains despite their deprecation: https://github.com/Automattic/kue#prevent-from-stuck-active-jobs\n. ",
    "suedama1756": "Sorry, but this makes no sense. There are two distinct ways to complete a defer, either reject, or resolve. The isResolved and isRejected functions should report this state. How can both isRejected AND isResolved be true? I understand that isFulfilled will report if the whole chain has been fullied.\n. \"A promise one primary axis of state:\", that statement makes me think you agree with me, it should either be resolved, or rejected NOT both?\n. OK, so I should think of reject as resolveWithRejection :), thanks for taking the time to go through it\n. Still not sure I like the terminology, especially as your own description uses terms like pending. An isPending, or isComplete with isRejected and isResolved being mutually exclusive would IMO make more sense. But its a bit late to make that sort of change (lol). I guess I'm just coming at it from a .NET TPL library perspective. Thanks a lot  for the really quick responses, its rare, but means I can get on now and finish my work :)\n. In case you are interested, in jQuery these states are mutually exclusive.\n\nhttp://api.jquery.com/deferred.state/\nhttp://api.jquery.com/deferred.isResolved/\n\nI'm not saying they are right, just that interop becomes an issue...\n. Guys, I'm not for one minute suggesting that you limit Q's functionality (and I'm not a fan of jQuery full stop, for me, its a library from a different era). I think the functionality provided by Q is fantastic, I really do. I just think the naming of promise states is a little unfortunate, they are not symmetrical with the methods resolve, reject (unless reject is named resolveWithRejection). API's should be discoverable, symmetrical and obvious, so far not one single developer in my team has answered the question correctly, \"what do you think isResolved returns when you have rejected a deferred object\". In reference to the Promise/A specification there is no mention of the isRejected/isResolved states. In practice, most developers will use then() so this becomes a non-issue.\n\nThe reality is that the states DO make sense once you know about them, but you can't really argue with the fact that for most people, the isRejected and isResolved states do not return what is intuitively expected.\n\nGreat work regardless :)\n. Thanks guys for the awesome responses, I knew it was too late to change. But the discussion and feedback are most welcome :)\n. Sorry, but this makes no sense. There are two distinct ways to complete a defer, either reject, or resolve. The isResolved and isRejected functions should report this state. How can both isRejected AND isResolved be true? I understand that isFulfilled will report if the whole chain has been fullied.\n. \"A promise one primary axis of state:\", that statement makes me think you agree with me, it should either be resolved, or rejected NOT both?\n. OK, so I should think of reject as resolveWithRejection :), thanks for taking the time to go through it\n. Still not sure I like the terminology, especially as your own description uses terms like pending. An isPending, or isComplete with isRejected and isResolved being mutually exclusive would IMO make more sense. But its a bit late to make that sort of change (lol). I guess I'm just coming at it from a .NET TPL library perspective. Thanks a lot  for the really quick responses, its rare, but means I can get on now and finish my work :)\n. In case you are interested, in jQuery these states are mutually exclusive.\n\nhttp://api.jquery.com/deferred.state/\nhttp://api.jquery.com/deferred.isResolved/\n\nI'm not saying they are right, just that interop becomes an issue...\n. Guys, I'm not for one minute suggesting that you limit Q's functionality (and I'm not a fan of jQuery full stop, for me, its a library from a different era). I think the functionality provided by Q is fantastic, I really do. I just think the naming of promise states is a little unfortunate, they are not symmetrical with the methods resolve, reject (unless reject is named resolveWithRejection). API's should be discoverable, symmetrical and obvious, so far not one single developer in my team has answered the question correctly, \"what do you think isResolved returns when you have rejected a deferred object\". In reference to the Promise/A specification there is no mention of the isRejected/isResolved states. In practice, most developers will use then() so this becomes a non-issue.\n\nThe reality is that the states DO make sense once you know about them, but you can't really argue with the fact that for most people, the isRejected and isResolved states do not return what is intuitively expected.\n\nGreat work regardless :)\n. Thanks guys for the awesome responses, I knew it was too late to change. But the discussion and feedback are most welcome :)\n. ",
    "jmreidy": "As someone caught by this change, I can at least say that it's really easy to find (as it breaks anyone's app/library as soon as they push to .10), and there's a note about it in the change log anyway. So I guess that's a belated +1 for cowboying. \n. As someone caught by this change, I can at least say that it's really easy to find (as it breaks anyone's app/library as soon as they push to .10), and there's a note about it in the change log anyway. So I guess that's a belated +1 for cowboying. \n. ",
    "geowa4": "I just got home. I'll fork this in a bit.\n. I noticed that the code is now different from what I pulled down. It now reads\n\n```\nif (Object(value) !== value) {\n    return value;\n} else if (isPromise(value)) {\n    return value.valueOf();\n}\nreturn value;\n```\n\nThis change solves my problem since `valueOf` is only called if it's a promise. However, this seems odd to me. Shouldn't it just be \n\n```\nif (isPromise(value)) {\n    return value.valueOf();\n}\nreturn value;\n```\n\nChanging it to that passes all the tests. I'm going to submit a pull request for that change, but I'm also going to close this issue since my problem isn't there in the latest code.\n. The current GitHub status is preventing me from submitting the pull request: \"We're currently working through a backlog of background jobs. An update will be provided once we've caught back up.\"\n. I don't believe Bower reads package.json, though I wish it did. Try installing Q with it.\n\n```\n$ bower install q\nbower cloning git://github.com/kriskowal/q.git\nbower cached git://github.com/kriskowal/q.git\nbower fetching q\nbower checking out q#v0.8.11\nbower copying $HOME/.bower/cache/q/31342087dd663a818f035ad7875662de\nbower installing q#0.8.11\n\n$ bower list --map\n{\n  \"q\": {\n    \"source\": {}\n  }\n}\n```\n\nNow, if you install something that has a component.json file, it has no problem finding the main file.\n\n```\n$ bower install pajamas\nbower cloning git://github.com/geowa4/pajamas.git\nbower cached git://github.com/geowa4/pajamas.git\nbower fetching pajamas\nbower checking out pajamas#1.3.3\nbower copying $HOME/.bower/cache/pajamas/10e507a540545986942011874064b731\nbower cloning git://github.com/kriskowal/q.git\nbower cached git://github.com/kriskowal/q.git\nbower fetching q\nbower checking out q#v0.8.11\nbower copying $HOME/.bower/cache/q/31342087dd663a818f035ad7875662de\nbower installing pajamas#1.3.3\nbower installing q#0.8.11\n\n$ bower list --map\n{\n  \"pajamas\": {\n    \"source\": {\n      \"main\": \"components/pajamas/dist/pajamas.js\"\n    },\n    \"dependencies\": {\n      \"q\": {\n        \"source\": {}\n      }\n    }\n  },\n  \"q\": {\n    \"source\": {}\n  }\n}\n```\n\nI don't know why Bower would behave differently when a package.json file would suffice, but it does. Try `bower install pajamas#1.3.2` too; it's the version before I added the component.json file.\n\n```\n$ bower install pajamas#1.3.2\nbower cloning git://github.com/geowa4/pajamas.git\nbower cached git://github.com/geowa4/pajamas.git\nbower fetching pajamas\nbower checking out pajamas#1.3.2\nbower copying $HOME/.bower/cache/pajamas/10e507a540545986942011874064b731\nbower installing pajamas#1.3.2\n\n$ bower list --map\n{\n  \"pajamas\": {\n    \"source\": {}\n  }\n}\n```\n. I just got home. I'll fork this in a bit.\n. I noticed that the code is now different from what I pulled down. It now reads\n\n```\nif (Object(value) !== value) {\n    return value;\n} else if (isPromise(value)) {\n    return value.valueOf();\n}\nreturn value;\n```\n\nThis change solves my problem since `valueOf` is only called if it's a promise. However, this seems odd to me. Shouldn't it just be \n\n```\nif (isPromise(value)) {\n    return value.valueOf();\n}\nreturn value;\n```\n\nChanging it to that passes all the tests. I'm going to submit a pull request for that change, but I'm also going to close this issue since my problem isn't there in the latest code.\n. The current GitHub status is preventing me from submitting the pull request: \"We're currently working through a backlog of background jobs. An update will be provided once we've caught back up.\"\n. I don't believe Bower reads package.json, though I wish it did. Try installing Q with it.\n\n```\n$ bower install q\nbower cloning git://github.com/kriskowal/q.git\nbower cached git://github.com/kriskowal/q.git\nbower fetching q\nbower checking out q#v0.8.11\nbower copying $HOME/.bower/cache/q/31342087dd663a818f035ad7875662de\nbower installing q#0.8.11\n\n$ bower list --map\n{\n  \"q\": {\n    \"source\": {}\n  }\n}\n```\n\nNow, if you install something that has a component.json file, it has no problem finding the main file.\n\n```\n$ bower install pajamas\nbower cloning git://github.com/geowa4/pajamas.git\nbower cached git://github.com/geowa4/pajamas.git\nbower fetching pajamas\nbower checking out pajamas#1.3.3\nbower copying $HOME/.bower/cache/pajamas/10e507a540545986942011874064b731\nbower cloning git://github.com/kriskowal/q.git\nbower cached git://github.com/kriskowal/q.git\nbower fetching q\nbower checking out q#v0.8.11\nbower copying $HOME/.bower/cache/q/31342087dd663a818f035ad7875662de\nbower installing pajamas#1.3.3\nbower installing q#0.8.11\n\n$ bower list --map\n{\n  \"pajamas\": {\n    \"source\": {\n      \"main\": \"components/pajamas/dist/pajamas.js\"\n    },\n    \"dependencies\": {\n      \"q\": {\n        \"source\": {}\n      }\n    }\n  },\n  \"q\": {\n    \"source\": {}\n  }\n}\n```\n\nI don't know why Bower would behave differently when a package.json file would suffice, but it does. Try `bower install pajamas#1.3.2` too; it's the version before I added the component.json file.\n\n```\n$ bower install pajamas#1.3.2\nbower cloning git://github.com/geowa4/pajamas.git\nbower cached git://github.com/geowa4/pajamas.git\nbower fetching pajamas\nbower checking out pajamas#1.3.2\nbower copying $HOME/.bower/cache/pajamas/10e507a540545986942011874064b731\nbower installing pajamas#1.3.2\n\n$ bower list --map\n{\n  \"pajamas\": {\n    \"source\": {}\n  }\n}\n```\n. ",
    "thesmart": "Hmm, in trying to build a repro, I noticed that mongodb is throwing a string, not an Error.  If an Error is thrown, then strack trace is preserved.  So, not your bug. :)\n. It's a hard road we travel: preventing people from shooting themselves in the foot with JavaScript. :+1: \n. IMHO, Q.ncall's `thisP` argument seems counter-intuitive.  Doing `myFunction.bind(this)` is pretty vanilla, and one could argue that the API could err on the side of \"least surprises\". \n\nInterested to hear from @kriskowal \n. Hmm, in trying to build a repro, I noticed that mongodb is throwing a string, not an Error.  If an Error is thrown, then strack trace is preserved.  So, not your bug. :)\n. It's a hard road we travel: preventing people from shooting themselves in the foot with JavaScript. :+1: \n. IMHO, Q.ncall's `thisP` argument seems counter-intuitive.  Doing `myFunction.bind(this)` is pretty vanilla, and one could argue that the API could err on the side of \"least surprises\". \n\nInterested to hear from @kriskowal \n. ",
    "rictic": "Apologies for this being several commits, I apparently started my changes on an old version of the file.\n. Squashed it into one commit. Documented and specced the behavior, as I suspect that others will find this useful.\n. Apologies for this being several commits, I apparently started my changes on an old version of the file.\n. Squashed it into one commit. Documented and specced the behavior, as I suspect that others will find this useful.\n. ",
    "nponeccop": "JFYI the leak still exists in `q v0.8.12` with `node v0.8.18` and `v0.9.7`, \n. JFYI the leak still exists in `q v0.8.12` with `node v0.8.18` and `v0.9.7`, \n. ",
    "kaerus": "right now, in safari 5.1.7. \nin nodejs v0.8.6, I don't get this error.\n. ok, I'll try to isolate the issue.\n. no problems, so far it has been a pleasure to use, just this little annoyance. :) \n. There you have it.\n\n``` javascript\nvar depends = [\n    'q',\n    'jQuery/jquery-1.8.2.min'\n];\n\nrequire(depends,function(Q){\n\n    function test(call) {\n        var deferred = Q.defer();\n\n        $.ajax(call)\n            .done(function(result) { deferred.resolve(result) })\n            .fail(function(error) { deferred.reject(error) });\n\n        return deferred.promise;\n    }   \n\n    test(\"something\")\n    .then(function(res) { console.log(\"ok:\",res) },\n        function(err) { console.log(\"err:\", err) } );\n});\n```\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"Cache-control\" content=\"no-cache\">\n    <title>Should be empty</title>\n</head>\n\n<body>\n    <script data-main=\"js/should_be_empty\" src=\"js/require.js\"></script>\n</body>\n```\n. Sorry, I missed the part about a self contained version.\n\n``` html\n<!DOCTYPE html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Should be empty</title>\n</head>\n\n<body>\n    <h1>Should be empty</h1>\n    <div></div>\n\n    <script src=\"https://raw.github.com/kriskowal/q/master/q.min.js\"></script>\n    <script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"></script>\n    <script>\n    var e = document.getElementsByTagName(\"div\")[0];\n\n    function test(call) {\n            var deferred = Q.defer();\n\n            $.ajax(call)\n                .done(function(result) { deferred.resolve(result) })\n                .fail(function(error) { deferred.reject(error) });\n\n            return deferred.promise;\n        }   \n\n        test(\"something\")\n        .then(function(res) { e.innerHTML = JSON.stringify(res) },\n            function(err) { e.innerHTML = JSON.stringify(err) } );\n    </script>\n</body>\n```\n\n...or without jquery/ajax stuff.\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"Cache-control\" content=\"no-cache\">\n    <title>Should be empty</title>\n</head>\n\n<body>\n    <h1>Should be empty</h1>\n    <div></div>\n\n    <script src=\"https://raw.github.com/kriskowal/q/master/q.min.js\"></script>\n    <script>\n    var e = document.getElementsByTagName(\"div\")[0];\n\n    function test(call) {\n            var deferred = Q.defer();\n\n            deferred.reject(\"rejected \" + call);\n\n            return deferred.promise;\n        }   \n\n        test(\"something\")\n        .then(function(res) { e.innerHTML = JSON.stringify(res) },\n            function(err) { e.innerHTML = JSON.stringify(err) } );\n    </script>\n</body>\n```\n. same with FireFox 17.x, Omniweb 5.11.1, Chrome 23.0.1271.97...\nHowever in Chrome Canary it seems to work.\n. I can see that the rejection is pushed twice into the rejections array in the reject method. \nWhich means that reject() is being called two times where this snippet lies.\n\n```\n...\n   displayErrors();\n   rejections.push(rejection);\n   errors.push(exception);\n...\n```\n\nAfter a little more debugging:\nFirst it is called by this function\n\n```\n  deferred.reject = function (exception) {\n        become(reject(exception));\n    };\n```\n\nLater it is called again by this function\n\n```\n\"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                var at = array_indexOf(rejections, this);\n                if (at !== -1) {\n                    errors.splice(at, 1);\n                    rejections.splice(at, 1);\n                }\n            }\n            return rejected ? rejected(exception) : reject(exception);\n        }\n```\n\nit seems like the above function is actually being called twice. \nFirst when `rejected` is `undefined` and later when it is set to a function. \n\nWhich in turn gets called twiced by promise.promiseDispatch function at Line 481 with the following arguments: \n\n```\npromiseDispatch resolve=(undefined) op=(when) args=(Array[2])\n```\n\nand again by \n\n```\npromiseDispatch resolve=(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }) op=(when) args=(Array[1])\n```\n\noh my... this gets complicated.\n\n```\nq.js:640reject called by: function (exception) {\n        become(reject(exception));\n    }\nq.js:629Should be empty: [\nObject\n]\nq.js:484promiseDispatch caller: function () {\n                value.promiseDispatch.apply(value, pending);\n            }\nq.js:652rejected: undefined\nq.js:640reject called by: function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                var at = array_indexOf(rejections, this);\n                if (at !== -1) {\n                    errors.splice(at, 1);\n                    rejections.splice(at, 1);\n                }\n            }\n            console.log(\"rejected:\", rejected);\n            return rejected ? rejected(exception) : reject(exception);\n        }\nq.js:484promiseDispatch caller: function () {\n                value.promiseDispatch.apply(value, pending);\n            }\nq.js:652rejected: function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n            console.log(\"asdfds\");\n            deferred.resolve(_rejected(exception));\n        }\n```\n. I don't understand the dance with displayErrors.\nWhy have a errorDisplayed flag and why care about touch devices and so on ?\n\n```\nvar errorsDisplayed;\nfunction displayErrors() {\n    if (\n        !errorsDisplayed &&\n        typeof window !== \"undefined\" &&\n        !window.Touch &&\n        window.console\n    ) {\n        // This promise library consumes exceptions thrown in handlers so\n        // they can be handled by a subsequent promise.  The rejected\n        // promises get added to this array when they are created, and\n        // removed when they are handled.\n        console.log(\"Should be empty:\", errors);\n    }\n    errorsDisplayed = true;\n}\n```\n\nWhy not just check for the presence of console.log and displayErrors if there is an actual error?\nThe above is being called every time one rejects a promise which is not an error per se.\n\nApart from that.... I still don't understand why reject is being called twice. That smells like bug #148 to me. :)\n. right now, in safari 5.1.7. \nin nodejs v0.8.6, I don't get this error.\n. ok, I'll try to isolate the issue.\n. no problems, so far it has been a pleasure to use, just this little annoyance. :) \n. There you have it.\n\n``` javascript\nvar depends = [\n    'q',\n    'jQuery/jquery-1.8.2.min'\n];\n\nrequire(depends,function(Q){\n\n    function test(call) {\n        var deferred = Q.defer();\n\n        $.ajax(call)\n            .done(function(result) { deferred.resolve(result) })\n            .fail(function(error) { deferred.reject(error) });\n\n        return deferred.promise;\n    }   \n\n    test(\"something\")\n    .then(function(res) { console.log(\"ok:\",res) },\n        function(err) { console.log(\"err:\", err) } );\n});\n```\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"Cache-control\" content=\"no-cache\">\n    <title>Should be empty</title>\n</head>\n\n<body>\n    <script data-main=\"js/should_be_empty\" src=\"js/require.js\"></script>\n</body>\n```\n. Sorry, I missed the part about a self contained version.\n\n``` html\n<!DOCTYPE html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Should be empty</title>\n</head>\n\n<body>\n    <h1>Should be empty</h1>\n    <div></div>\n\n    <script src=\"https://raw.github.com/kriskowal/q/master/q.min.js\"></script>\n    <script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"></script>\n    <script>\n    var e = document.getElementsByTagName(\"div\")[0];\n\n    function test(call) {\n            var deferred = Q.defer();\n\n            $.ajax(call)\n                .done(function(result) { deferred.resolve(result) })\n                .fail(function(error) { deferred.reject(error) });\n\n            return deferred.promise;\n        }   \n\n        test(\"something\")\n        .then(function(res) { e.innerHTML = JSON.stringify(res) },\n            function(err) { e.innerHTML = JSON.stringify(err) } );\n    </script>\n</body>\n```\n\n...or without jquery/ajax stuff.\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"Cache-control\" content=\"no-cache\">\n    <title>Should be empty</title>\n</head>\n\n<body>\n    <h1>Should be empty</h1>\n    <div></div>\n\n    <script src=\"https://raw.github.com/kriskowal/q/master/q.min.js\"></script>\n    <script>\n    var e = document.getElementsByTagName(\"div\")[0];\n\n    function test(call) {\n            var deferred = Q.defer();\n\n            deferred.reject(\"rejected \" + call);\n\n            return deferred.promise;\n        }   \n\n        test(\"something\")\n        .then(function(res) { e.innerHTML = JSON.stringify(res) },\n            function(err) { e.innerHTML = JSON.stringify(err) } );\n    </script>\n</body>\n```\n. same with FireFox 17.x, Omniweb 5.11.1, Chrome 23.0.1271.97...\nHowever in Chrome Canary it seems to work.\n. I can see that the rejection is pushed twice into the rejections array in the reject method. \nWhich means that reject() is being called two times where this snippet lies.\n\n```\n...\n   displayErrors();\n   rejections.push(rejection);\n   errors.push(exception);\n...\n```\n\nAfter a little more debugging:\nFirst it is called by this function\n\n```\n  deferred.reject = function (exception) {\n        become(reject(exception));\n    };\n```\n\nLater it is called again by this function\n\n```\n\"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                var at = array_indexOf(rejections, this);\n                if (at !== -1) {\n                    errors.splice(at, 1);\n                    rejections.splice(at, 1);\n                }\n            }\n            return rejected ? rejected(exception) : reject(exception);\n        }\n```\n\nit seems like the above function is actually being called twice. \nFirst when `rejected` is `undefined` and later when it is set to a function. \n\nWhich in turn gets called twiced by promise.promiseDispatch function at Line 481 with the following arguments: \n\n```\npromiseDispatch resolve=(undefined) op=(when) args=(Array[2])\n```\n\nand again by \n\n```\npromiseDispatch resolve=(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }) op=(when) args=(Array[1])\n```\n\noh my... this gets complicated.\n\n```\nq.js:640reject called by: function (exception) {\n        become(reject(exception));\n    }\nq.js:629Should be empty: [\nObject\n]\nq.js:484promiseDispatch caller: function () {\n                value.promiseDispatch.apply(value, pending);\n            }\nq.js:652rejected: undefined\nq.js:640reject called by: function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                var at = array_indexOf(rejections, this);\n                if (at !== -1) {\n                    errors.splice(at, 1);\n                    rejections.splice(at, 1);\n                }\n            }\n            console.log(\"rejected:\", rejected);\n            return rejected ? rejected(exception) : reject(exception);\n        }\nq.js:484promiseDispatch caller: function () {\n                value.promiseDispatch.apply(value, pending);\n            }\nq.js:652rejected: function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n            console.log(\"asdfds\");\n            deferred.resolve(_rejected(exception));\n        }\n```\n. I don't understand the dance with displayErrors.\nWhy have a errorDisplayed flag and why care about touch devices and so on ?\n\n```\nvar errorsDisplayed;\nfunction displayErrors() {\n    if (\n        !errorsDisplayed &&\n        typeof window !== \"undefined\" &&\n        !window.Touch &&\n        window.console\n    ) {\n        // This promise library consumes exceptions thrown in handlers so\n        // they can be handled by a subsequent promise.  The rejected\n        // promises get added to this array when they are created, and\n        // removed when they are handled.\n        console.log(\"Should be empty:\", errors);\n    }\n    errorsDisplayed = true;\n}\n```\n\nWhy not just check for the presence of console.log and displayErrors if there is an actual error?\nThe above is being called every time one rejects a promise which is not an error per se.\n\nApart from that.... I still don't understand why reject is being called twice. That smells like bug #148 to me. :)\n. ",
    "pcottle": "Any progress on this? Sorry to revive a month-old thread, but the line\n\n```\nconsole.log(\"Should be empty\", errors)\n```\n\nreally just seems like a sanity check from the author. I get this almost every time I call `.done()` on a promise chain. Why not just check for the length of errors and then log if it's non-zero?\n\nI'm just trying to clean up my console output :D\n. Woah this is cool! Would love to see it merged\n. Any progress on this? Sorry to revive a month-old thread, but the line\n\n```\nconsole.log(\"Should be empty\", errors)\n```\n\nreally just seems like a sanity check from the author. I get this almost every time I call `.done()` on a promise chain. Why not just check for the length of errors and then log if it's non-zero?\n\nI'm just trying to clean up my console output :D\n. Woah this is cool! Would love to see it merged\n. ",
    "walski": "That would be appreciated! :+1:\n. That would be appreciated! :+1:\n. ",
    "jamespacileo": "I'm getting the same error with WinJS\n. Invalid. My bad. Should spend more verifying next time! Thanks Domenic.\n. Mmmh the result isn't mapped to the source anyway\n\n![stack trace 2](https://f.cloud.github.com/assets/608868/755576/02d1ec14-e5b6-11e2-89b6-b61c11f92cc1.JPG)\n\nNot sure if anything can be conjured up, don't have much knowledge on the matter. Thought I would write this up just in case. What do you think?\n. Thanks for the help. Unfortunately none of those work with Browserify out of the box. Looks very promising, maybe I could fork one.\n\nI reckon that I could plug one of these into the error callbacks Q offers in the config. Thanks!\n. I'm getting the same error with WinJS\n. Invalid. My bad. Should spend more verifying next time! Thanks Domenic.\n. Mmmh the result isn't mapped to the source anyway\n\n![stack trace 2](https://f.cloud.github.com/assets/608868/755576/02d1ec14-e5b6-11e2-89b6-b61c11f92cc1.JPG)\n\nNot sure if anything can be conjured up, don't have much knowledge on the matter. Thought I would write this up just in case. What do you think?\n. Thanks for the help. Unfortunately none of those work with Browserify out of the box. Looks very promising, maybe I could fork one.\n\nI reckon that I could plug one of these into the error callbacks Q offers in the config. Thanks!\n. ",
    "SLaks": "Alternatively, can you think of any better solutions for the underlying problem?\n\nFor example, \n\n``` js\ngetEmail(...)\n    .then(function(email) {\n        return Q.deepResolve({\n            email: email,\n            user: getUserInfo(email)  //promise\n        });\n    });\n```\n\nMaybe I'll add a `deepResolve()` method to my [Qx library](https://github.com/SLaks/Qx).\n. Should it go in Q itself or in Qx?\n. It looks like QQ already has it.\n\nhttps://github.com/kriskowal/qq/blob/master/qq.js#L215\n. I just realized that there is a much simpler solution to the original problem:\n\n``` js\ngetEmail(...)\n    .then(function(email) {\n        return Q.all([ email, getUserInfo(email) ]);\n    }).spread(function(email, user) {\n        ...\n    });\n```\n. This happens because `fallback()` (https://github.com/kriskowal/q/blob/master/q.js#L788) doesn't remove the previous rejection from `unhandledRejections`.\n. Fixed by #290 \n. Alternatively, can you think of any better solutions for the underlying problem?\n\nFor example, \n\n``` js\ngetEmail(...)\n    .then(function(email) {\n        return Q.deepResolve({\n            email: email,\n            user: getUserInfo(email)  //promise\n        });\n    });\n```\n\nMaybe I'll add a `deepResolve()` method to my [Qx library](https://github.com/SLaks/Qx).\n. Should it go in Q itself or in Qx?\n. It looks like QQ already has it.\n\nhttps://github.com/kriskowal/qq/blob/master/qq.js#L215\n. I just realized that there is a much simpler solution to the original problem:\n\n``` js\ngetEmail(...)\n    .then(function(email) {\n        return Q.all([ email, getUserInfo(email) ]);\n    }).spread(function(email, user) {\n        ...\n    });\n```\n. This happens because `fallback()` (https://github.com/kriskowal/q/blob/master/q.js#L788) doesn't remove the previous rejection from `unhandledRejections`.\n. Fixed by #290 \n. ",
    "azproduction": "@kriskowal we can use getters for not so popular Promise methods such as reject, notify and bind them to the context only when we need it + fallback for old js-engines. http://jsperf.com/auto-bind-using-getter\n. @kriskowal we can use getters for not so popular Promise methods such as reject, notify and bind them to the context only when we need it + fallback for old js-engines. http://jsperf.com/auto-bind-using-getter\n. ",
    "jergason": "I agree. What is the justification for having a separate file when there is already an established convention for project description files?\n. Sorry for derailing. I was just curious about the reasoning behind it.\n. I agree. What is the justification for having a separate file when there is already an established convention for project description files?\n. Sorry for derailing. I was just curious about the reasoning behind it.\n. ",
    "timaschew": "> Agreed, I'm happy to discuss elsewhere.\n\nwhere?\n\nI think maintaining multiple package managers shouldn't be a problem with one of these tools: https://github.com/ianstormtaylor/bump or \nhttps://github.com/jprichardson/tin or\nhttps://github.com/cimi/semver-sync\n\n@ForbesLindesay do you still maintain microjs/q? because the last commit is a year ago\n. > Agreed, I'm happy to discuss elsewhere.\n\nwhere?\n\nI think maintaining multiple package managers shouldn't be a problem with one of these tools: https://github.com/ianstormtaylor/bump or \nhttps://github.com/jprichardson/tin or\nhttps://github.com/cimi/semver-sync\n\n@ForbesLindesay do you still maintain microjs/q? because the last commit is a year ago\n. ",
    "mike-spainhower": "You might think about adding this back once this patch https://codereview.chromium.org/135903014/ makes its way to Chrome and node.js stable releases.  (Original issue marked fixed https://code.google.com/p/v8/issues/detail?id=1858)\n. /cc @reiz\n. Yes, but it is kind of a bummer to break semver so completely.  Is it unacceptable to use e.g., \n\n``` js\nsemver.inc('2.0.0-unstable.0', 'pre', 'unstable')\n// 2.0.0 -> 2.0.0-unstable.0\n// 2.0.1 -> 2.0.0-unstable.1\n// 2.0.2 -> 2.0.0-unstable.2\n// 2.0.3 -> 2.0.0-unstable.3\n```\n\nor\n\n``` js\nsemver.inc('2.0.0-unstable', 'prepatch', 'unstable')\n// 2.0.0 -> 2.0.0-unstable.0\n// 2.0.1 -> 2.0.1-unstable.0\n// 2.0.2 -> 2.0.2-unstable.0\n// 2.0.3 -> 2.0.3-unstable.0\n```\n. You might think about adding this back once this patch https://codereview.chromium.org/135903014/ makes its way to Chrome and node.js stable releases.  (Original issue marked fixed https://code.google.com/p/v8/issues/detail?id=1858)\n. /cc @reiz\n. Yes, but it is kind of a bummer to break semver so completely.  Is it unacceptable to use e.g., \n\n``` js\nsemver.inc('2.0.0-unstable.0', 'pre', 'unstable')\n// 2.0.0 -> 2.0.0-unstable.0\n// 2.0.1 -> 2.0.0-unstable.1\n// 2.0.2 -> 2.0.0-unstable.2\n// 2.0.3 -> 2.0.0-unstable.3\n```\n\nor\n\n``` js\nsemver.inc('2.0.0-unstable', 'prepatch', 'unstable')\n// 2.0.0 -> 2.0.0-unstable.0\n// 2.0.1 -> 2.0.1-unstable.0\n// 2.0.2 -> 2.0.2-unstable.0\n// 2.0.3 -> 2.0.3-unstable.0\n```\n. ",
    "jcolebrand": "I didn't do a pull request because I see this as more of a discussion, and less of a \"fix\".\n\nI'll read up on the spread source part when I get home, but I'm specifically thinking of use in a \"then\"\n. Arrrrgh, I figured it was supposed to be there. idk. I'll try again later.\n. Thanks, sorry. \n. I didn't do a pull request because I see this as more of a discussion, and less of a \"fix\".\n\nI'll read up on the spread source part when I get home, but I'm specifically thinking of use in a \"then\"\n. Arrrrgh, I figured it was supposed to be there. idk. I'll try again later.\n. Thanks, sorry. \n. ",
    "Redsandro": "Thank  you and sorry for getting back so late.\nYour answer is excellent **ForbesLindesay**. \n\nThe project I was working on has already evolved beyond this issue. Nevertheless, I've been trying to recreate the scenario as per your request, but I cannot get it to work. You must be right, and I've probably made a mistake in my initial scenario. `==` in stead of `===` or something that caused the value to be globally available to the function, misleading me. Idk.\n\nOr I was right but I cannot figure out exactly what I did. Probably not, but I like to keep the idea alive for my personal feelings and stuff. :P\n\nAnyway, much thanks for providing the proper code. It clarifies things.\n. Extra question though, while trying to recreate the scenario, I find that I miss the thrown errors with stacktrace. These are eaten by `Q`, which is what we want for the end user. But is it possible switch to developer mode or something, to get the crashes, errors and stacktraces in the console in stead of triggering the error clause in the `Q` contract?\n\n``` javascript\nvar freeStuff = {};\nfreeStuff.freeBeer(20);\n```\n\n``` cmd\nTypeError: Object #<Object> has no method 'freeBeer'\nat here and here\nat there and there\nat so and so\n```\n. Thanks. \n\nI didn't know we need to wrap a `throw` in a `setTimeout`. This is always, or only in `then()`, or only in the error parameter of `then()`?\n. Thank you! I appreciate the elaborate example. :)\n. I am probably using one of your examples wrong, but when I use this one:\n\n``` javascript\n.then(function(value2) {\n    return Q.nfcall(funcWithCallback, value1, value2);\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n\nin this way (let's call this **solution 1** for reference):\n\n``` javascript\n.then(function(value2) {\n    return q.nfcall(mysql.client.query, query, [lang_code, autocomplete]);\n})\n.then(function(err, results, fields) {\n    if (err) {\n        throw err;\n    }\n    // Have a party\n})\n.done();\n```\n\nI get\n\n``` bash\n/var/www/node/node_modules/q/q.js:1327\n                throw error;\n                      ^\nTypeError: Object #<Object> has no method '_implyConnect'\n    at /var/www/node/node_modules/mysql/lib/Connection.js:88:8\nFrom previous event:\n    at /var/www/node/node_modules/q/q.js:1062:16\n    at /var/www/node/includes/router.js:274:14\n    at /var/www/node/node_modules/q/q.js:860:30\n```\n\nWhat did I do wrong?\n. Normal usage is\n\n``` javascript\nmysql.client.query(query, [lang_code, autocomplete], function(err, results, fields) {\n    if (err) {\n        throw err;\n    }\n    // Have a party\n});\n```\n. I receive the exact same error, not sure how to use this properly.\n\nNot with your or this **solution 1** either:\n\n```\nreturn q.nfcall(mysql.client.query.bind(mysql.query, query, [lang_code, autocomplete]));\n```\n\neither, as I am trying to apply this documentation about your suggestion: https://developer.mozilla.org/ru/docs/JavaScript/Reference/Global_Objects/Function/bind\n. Same error on (Let's call this **solution 2**):\n\n``` javascript\nvar doQuery = q.nfbind(mysql.client.query);\nreturn doQuery(query, [lang_code, autocomplete]);\n```\n. Yes, that one ( **solution 2** ) works! \n\n**Solution 1** also works! I must have done something stupid. Perhaps not restarting node after the bind.\nI am very sorry, and you are right about the bind. Thank you.\n. This  `done()` business is indeed nice. I should have known because it is in the docs: _Ending a promise chain makes sure that, if an error doesn\u2019t get handled before the end, it will get rethrown and reported._ In my opinion, this line should be marked by boldness and fireworks. :)\n\nIn other news, even though the previous `mysql.client` example worked in the end, I cannot seem to plug a `callback` with parameters into a callback-wanting-function. I've read this page again and again, and I am still not the professional that my mother tell my grandmother I am.\n\nI have a 9 line example, but in stead of explaining I added comments and an example func+callback so it reads like a novel:\n\n``` javascript\nq.fcall(function() {\n    // This function creates val01\n    var val01 = 'something';\n    return val01;\n})\n.then(function(val01) {\n    // funcNeedsCB needs val01    // works\n    // funcNeedsCB creates val02    // works\n    // funcNeedsCB calls callback with val01 and val02    // problem\n\n    //return q.nfcall(tools.funcNeedsCB.bind(tools), val01); // does not work, why not?\n    return q.nfbind(tools.funcNeedsCB.bind(tools), val01);\n})\n.then(function(val01, val02) {\n    // someCallbackFunc needs to be inserted into funcNeedsCB as callback\n    // someCallbackFunc needs val01 and val02, but these are specified in funcNeedsCB's callback call\n\n    //return q.fcall(tools.someCallbackFunc.bind(tools)); // test\n    //q.fcall(tools.someCallbackFunc.bind(tools)); // test\n    tools.someCallbackFunc(val01, val02); // Does not work because val01 = func and val02 = undefined\n});\n//.done();\n\n// e.g.\ntools = {\n    funcNeedsCB         : function(val01, callback) {\n        var val02 = 'anything';\n        callback(val01, val02); // AKA someCallbackFunc\n    },\n\n    someCallbackFunc    : function(val01, val02) {\n        // Build a fire with val01 and val02\n    }\n}\n```\n\nCan you see where I am going wrong again?\n\n---\n\nAlso, is there a rule when or when not to use `bind()`?\nSince I seem to need to bind _every_ method I use like so:\n\n``` javascript\nvar doQuery = q.nfbind(mysql.client.query.bind(mysql.client));\n```\n\nBut the docs provide this example:\n\n``` javascript\nvar readFile = Q.nfbind(FS.readFile);\n```\n\nand not:\n\n``` javascript\nvar readFile = Q.nfbind(FS.readFile.bind(FS));\n```\n\nIs this because the scope is automatically one parent up which is the same as the root of the callee?\n. Wow, turns out I have _always_ misunderstood this difference between functions and this-requiring methods. Providing `this` is usually within my frame of my intuition. It was never a problem. It seems I have discovered where intuition ends and actual thinking begins. \n\nI am still unsure because calling the method directly doesn't require `bind()`ing `this`.\nI know I have to pay attention to that. Thanks for pointing it out.\n. Awesome example. I know and use that first thing, extensively for crying out loud. I just never knew about this `bind` stuff, I just pass it all the toys `function` needs. And I blindly assumed `mysql.client.query` did the same.\n\nSo I can remove the `bind` in example #issuecomment-13517187 and it works if I change `funcNeedsCB` to return a `deferred`, call it directly (no `bind` or `call`) and work on that in stead of using a callback, but I wonder if I can't just plug in a callback in the next `then`.\n\nI am sorry, I know you mentioned using callbacks should be considered `legacy`, but I see me writing all these wrappers and things.. if the next `then` would just be the callback that is plugged into the previous `then`, it would be a syntactic sugar storm.\n. Thanks for the example. As for `Q.nfinvoke`, isn't that what `Q.nfbind` is supposed to do?\n(I guess not otherwise my example would work, but maybe I should prepend a `null` in the call arguments first because the first one should be an error..)\n\nAnd by `Q.nfinvoke` you mean `Q.ninvoke` (without the f) of is `Q.nfinvoke` (with f) just not in the API reference yet?\n\nBtw, the code example in the API @ https://github.com/kriskowal/q/wiki/API-Reference for `Q.ninvoke` is accidentally the same as `Q.npost`. Copy-paste-typo I think. :)\n. Sorry to get back at this method vs. function again. But since we need to `bind()` the method ourselves, what is effectively the difference between `nfapply` and `npost`?\n. Yes I was looking at the [API](https://github.com/kriskowal/q/wiki/API-Reference); it looks like `npost` is `nfapply` with `bind` internally. It confused me because if that's all it feels intuitively like this would be `nmapply` (no typo) but maybe I simply need to read up on javascript terminology, and find out why you `apply` to a `function` but `post` to a `method`.\n. Ah yes. Perhaps there could be a `q.nmcall()` to complement `q.nfcall()` in a similar way that `q.npost` complements `q.nfapply`. \n\nThen no one would ever have to explain the binding \u00e0 la\n`q.nfcall(mysql.client.query.bind(mysql.client), query, [lang_code, autocomplete]);`\never again. ;)\n. Good idea? Bad idea?\n. Nice, thanks for fixing!\nJust to be sure: I can delete this branch now, right?\n. This is happening to all promises, not just the once created by `q.nfcall`. I first encountered this trying to get an array from `promise.allResolved()`. I get a promise, even in the `valueOf` that promise. I can traverse the array inside the promise chain (`then()`), but then the array items are promises for which I cannot reach their values.\n\nOnce a starship is returned as a promise, there is no escape from the chain. We are trying to reach our home world, which lies outside the chain. Please show us how to correctly change our heading. We are desperate for food and supplies.\n. I now realize that a promise that not is fulfilled yet cannot reveal it's value, but I am wondering if the `valueOf()` shouldn't be `undefined` in this case.\n. Hmm.. this is true. Back when things took time in my node script, I was getting used to being able to use `valueOf()` so that I forgot to check that this is actually documented in the API wiki.\n\nI guess in stead of checking for `undefined` I can do something like `if (myPromise.valueOf().constructor && myPromise.valueOf().constructor.name == 'Promise')` for now, and start converting all such occurances in my code to a callback-stype wrapper functions to pass along promised values.\n. Thank you.\n. I agree that this could be improved upon, but in my own prosecution, one might argue that in an ideal promised land, values won't ever have to be evaluated like this. \n\nEither way, I like that this is being debated. :)\n. One thing though about events in stead of promises is that breakpoint debugging is a great way to examine long storylines of code. But the value of a promise in an entire chain cannot be followed in a similar fashion this way, because the value won't be known until a few ticks later.\n\nAny hints on how to do something similar in promiseland?\n. Yes I need `allResolved`, I cannot be sure all promises get fulfilled, some might be rejected and I need to continue with the fulfilled ones.\n\nNice one. Is this filter a javascript function extended as Q prototype? As in, is it chainable?\n\n```\nq.allResolved(arrayWithPromises)\n.filter(\n    function (promise) {\n        return promise.isFulfilled()\n    })\n.map(\n    function (promise) {\n        return promise.valueOf()\n    }\n)\n```\n. That is clever. I had to see the source code to understand it. `q.valueOf` is not exported statically, but it is exported as `q.nearer`. Nice.\n. Is there a pseudo-easy way to figure out where a promise was rejected?\n\nAlthough I run `Ubuntu 12.10` and `node v0.6.19` both locally and remote with the same code, this construction keeps tripping an error on the server while it works flawlessly on my local machine. It's such a tedious task to backtrace the reject.\n\n---\n\nAlso, while trying out oldskool debug messages, I found that [`promise.isPending()`](https://github.com/kriskowal/q/wiki/API-Reference#promiseispending) doesn't seem to work (on either machine): `TypeError: Object [object Promise] has no method 'isPending' at q.js:860:30`. At least not in the way I expected.\n\n---\n\nHere's some reference output, you can ignore this. Just in case code sais more than words.\n\nLocal:\n\n``` terminal\nDEBUG: Fullfilled boolean: true\nDEBUG: Rejected   boolean: false\nDEBUG: [object Promise],[object Promise],[object Promise]\nDEBUG: [object Object]\nDEBUG: [object Object]\n```\n\nServer:\n\n``` terminal\nDEBUG: Fullfilled boolean: false\nDEBUG: Rejected   boolean: true\nDEBUG: [object Promise],[object Promise],[object Promise]\nDEBUG: [object Promise]\nDEBUG: [object Promise]\n```\n\nDebug code for reference purposes\n\n``` javascript\nvar myPromise = q.allResolved(promiseArray)\n.then(function (promiseArray) {\n    // THIS STEP IS FOR DEBUGGING ONLY\n    tools.debug('Fullfilled boolean: ' + promiseArray[0].isFulfilled());\n    tools.debug('Rejected   boolean: ' + promiseArray[0].isRejected());\n//  tools.debug('Pending    boolean: ' + promiseArray[0].isPending()); // Does not work\n    tools.debug(promiseArray);\n    var debug = promiseArray[0].valueOf(); // Breakpoint\n    tools.debug(debug);\n    tools.debug(debug.valueOf());\n    util.inspect(debug, true); // No output today?\n    return promiseArray;\n})\n.then() // etc\n```\n. Thanks! This will help to a certain extend.\n\nThe line number is not totally accurate but I can search for the thrown error in my code.\n\n```\nLine: 0\n```\n. Thank you. I misunderstood again. The example clarifies the facts.\n\n(Skip below, you replied at the same time.)\n\nOriginal message:\n\nI am trying to have different error handling for thrown errors further down the chain, but the `onFulfilled` is getting in my way. The spec doesn't explicitly mention that `onFulfilled` should execute after the first `onRejected`. The promise and me are in disagreement about whether or not this means the promise is allowed to trespass on fulfilled territory.\n. (edited above message)\n\nAh, I see how to get it to work how I assumed it did. Errors don't bubble, you have to rethrow them.\n(Just mentioning this for google, duckduckgo and other referencing purposes.)\n\n``` javascript\n.fail(function (err) {\n    console.log('I caught ya! :D');\n    throw err;\n})\n.then(function () {\n    console.log('Shouldn\\'t this step be skipped?');\n})\n.fail(etcetera)\n.done();\n```\n. Yeah, I mean like.. handled errors don't bubble between onRejected handlers like oldschool web2.0 handled mouseclicks still bubble; ignoring the onFulfilled handlers for a moment as if they are like axons covered in myelin. Or something. You are right.\n. Is there a way to cancel the bubble, end the chain, without breaking it in two?\n\nBecause even if an error is handled and the chain goes on, the promised data/request/file/anything will not be available, and all the consecutive ticks are more often than not futile without this data. Only cause more errors to handle.\n\n``` javascript\n// ...\n.fail(function (err) {\n    console.log('Some exception that should end the chain.');\n})\n.then(function () {\n    console.log('Chain should only go on if the above exception did not occur.');\n})\n.then() // etc\n```\n\nLike a conditional `done()`\n\n``` javascript\nQ.fcall(step1)\n.then(step2)\n.fail(okNeverMind).done() // Never mind the rest of the chain, but only when failed\n.then(step3)\n.then(step4)\n.then(stepFinal, handleStep3and4)\n.done();\n```\n\nMy current alternative looks like this:\n\n``` javascript\n/// stuff ...\n.fail(function (err) { // First handler\n    console.log('httpRequest without Data was just a probe for JSON headers.');\n    throw new Error('ignore');\n})\n.then() // blah\n.done(\n    function() {\n        // We are done.\n    }, function(err) {\n        if (err.message == 'ignore') return;\n        // Else handle real error\n    }\n)\n```\n. I have been editing my post without realizing you had replied already, but you got the gist.\n\nThe problem with your idea, I've been playing with that too, is that promises are a form of syntactic sugar. I am a big fan of syntactic sugar.\n\nImagine a longer chain:\n\n``` javascript\nfcall()\n.fail() // Handle initial errors and stop the chain\n.then()\n.then()\n.then()\n.fail() // Handle errors in the above three steps and stop the chain\n.then()\n.then()\n.then()\n.done() // Handle errors in the final steps\n```\n\nAdding the probe to all these functions kinda introduces syntactic \"salt\" and 'complicates' use of existing functions that also have use in non-promise routines.\n\nSilently bubbling the error so that it skips fulfilled-handlers seems like the better idea at the time, but it has me wondering if there should be a command like `breakPromise` or something that just stops the entire chain.\n\nIt's not spec, but also not crazy. It would be useful. Enhancement maybe.\n. Well my current code is kind of huge so I tried to illustrate it with pseudo-code, but I am trying to simplify the initial chain for sugar reasons. First only for _\"inversing the inversion of control\"_ (sync style for async code), but going a bit further now, it made me think: Either it's already possible or it's a great enhancement if it would be possible to break. It is compatible with the promise spec after all.\n\nFor example, one of the first steps is a promise for `JSON` data. But the node `server.request` fires an empty `onData` and `onEnd` event in certain cases because the client wants to check for a `JSON` accept header, for example when the client uses `jQuery`. The chain is nearly perfect, except for handling this (non)error or continuing otherwise. Further along the chain I have something similar when the promise reached a state where it's complemented with database data. In some rare cases it should stop because data is already written to `server.response`.\n. I think the answer to _\"can you break\"_ is _\"no\"_, and all I can do is suggest it would be a valuable function to add.\nWe both provided workarounds, so I am not sure if dumping more code will be useful. I feel that people don't usually appreciate dumping of code that is more than a few lines.\n\nBut if you think you might get additional ideas, I'll gladly show you the request I am working with now, right after it comes from the router.\n\nBy now people usually comment on my object notation style as not how it is supposed to be, but hey I'm a rebel.\n\nThe listening server is routed to onIncomingRequest.\n\n``` javascript\nmodule.exports = {\n\n\n    onIncomingRequest :     function(httpRequest, httpResponse) {\n\n        // Pass around one single object\n        var requestObj = {\n            req: httpRequest,\n            res: httpResponse\n        };\n\n        // Here is the chain. Start by reading the request\n        self.readJsonRequest(httpRequest, httpResponse).then(\n            function(data) {\n                // Store JSON in requestObj\n                requestObj.data = data;\n                return requestObj;\n            },\n            function(err) {\n                var msg = 'Ignoring request: '+ err.message;\n                util.debug(msg);\n                throw new Error('ignore');\n            }\n        )\n        .then(db.promises.request.handleRequest)\n        .then(db.promises.request.storeRequest)\n        .fail(db.promises.request.handleMissing) // Rethrow error\n        .then(db.promises.response.storeRequest)\n        .done(\n            function() {\n                // We are done.\n                //TODO: Do we need to do some sort of garbage collection?\n            },\n            function(err) {\n                if (err.message == 'ignore') return;\n\n                util.debug('error', 'Lookuop failed.', err.message); //TODO: Proper handler\n            }\n        );\n    },\n\n    // Private functions\n\n    readJsonRequest     : function(request, response) {\n\n        var data = '';\n        var promise = q.defer(); I am suggesting \n\n        request.on('data', function(chunk) {\n            data += chunk;\n        });\n\n        request.on('end', function() {\n\n            if (data) {\n                try {\n                    data = JSON.parse(data);\n                } catch (e) {\n                    promise.reject(new Error('Not JSON'));\n                }\n\n                promise.resolve(data);\n            }\n            else {\n                promise.reject(new Error('Empty request is a JSON handshake. Sending headers.'));\n                response.writeHead(200, {'Content-Type': 'application/json', 'Access-Control-Allow-Headers': 'Content-Type'});\n                response.end();\n            }\n        });\n        return promise.promise;\n    }\n};\nextend(exports, module.exports);\n```\n\n(Yes storeRequest is called twice, does a switch and an upsert, not important.)\n. Kinda boring right?\nNevermind, I'll stick to 'ignore' error messages for now.\n. In that case, I think I misunderstood you a few times, and I didn't realize until now. :(\n\nIf you mean what it was before I started playing with `deferred`, `async` and `q`, I can't show you literally because it is now mostly `q` and `async`. (Although I think I can replace `async` with `q`.)\n\nBut I can tell you, it was a big virtual noodle soup of events. I kept passing along an event emitter as the object bubbling through everything because it could emit events from everywhere. And I hooked what you'd concider the final `then()` to a listener in the first function. The promise chain has the benefit of not requiring this, because the scope of the enclosing function is available to all the anonymous functions in the chain.\n. Since the spec mentions:\n_3.2.6.3: If either `onFulfilled` or `onRejected` returns a promise (call it `returnedPromise`), `promise2` must assume the state of `returnedPromise`_\n\nI am assuming that this should in fact work and the mistake is in my own code. :/\n. Yes, the provided code was hypothetical. I tried minifying my code of biblic proportions to something that isn't unnecessarily fleshy, and now it doesn't break anymore. :( (or :) actually.)\n\nI still don't totally understand what the problem was. This time I started with `q.fcall(function(){return 'someValuesIGenerated'}).then(promiseReturningFunc)` in stead of `promiseReturningFunc().then()`a few times so I could skip a bunch of boring code.\n\nI'll leave it like this, because staring too long makes me feel like Sonic who lost a lot of rings. I will reopen this issue next time I have a dejavu and I'll make sure to provide working code with it.\n. I am not sure when I created this HEAD I am comparing with now, but it is possible that I foolishly returned a `promise` where I should have returned `promise.promise` in the case of `var promise = q.defer();`. This might be a good time to start calling my deferreds `deferred` in stead of `promise` which seemed to make more sense to me at the time.\n. I must add that I still find it hard to find the correct thrown error line number when a problem is caused by a rejection.\n\nI can `util.log()` the `error.stack` and/or manually add `done()` everywhere to make a hard crash, but sometimes it points to a line number completely (seemingly) irrelevant. E.g. three `then()` iterations after the one where a property of `undefined` cannot be accessed.\n\nIs there a typical trick to use when debugging longer chains with entire functions within steps apart from echoing `error.stack` and `promise.valueOf().exception` on every `onReject`?\n. @killdream Thanks! This sort of wrappery is exactly what I mean. I am just not sure about the reason for `identity`, but I will play around with it tomorrow. Does `nodejs` provide means of extending `require`d modules so that I can prototype this to promises?\n\n@kriskowal I understand, although I think this is very useful. If it's in the core, it will encourage people to take a bite of sammich that is separation of promiseflow and actual code magic and say 'mmm-mmm'.\n. No, I was raised atheist and was told not to listen to what churches write. So I never really took a look at the inventions of Alonzo Church.\n\nJ/k, never heard about Lambda Calculus combinators. I got to know anonymous functions as Lambda-style functions (in PHP) and that's it. Thanks for the explanation. \n\nI understand you disagree and you're probably right. In my personal opinion, having a complete solution adds so much value to a module, and I would not consider something bloat if it adds many possibilities (promise trees in stead of promise chains) with just a handful of code. I remember some other module that decided to include `prototype.js` one day. Adding ~170K for some functionality, that would be bloat in my book.\n\nJust my POV, I am perfectly happy adding it manually. :)\n\nBtw, if non-bloat, plain, slim and clean is really paramount, I still suggest changing core functions like `post`, `tickle` and `robot` to something more sensible like `mcall` `mapply` and `nmcall` as I suggested here: https://github.com/kriskowal/q/pull/235\nBecause I have to look them up in the documentation _all the time_.\n\n2 cents. :)\n. I am trying to put conditional functionality in a separate module `qtree` which extends Q and share it for people who are interested. But I cannot seem to extend the promise methods. Is this at all possible? Here, to illustrate what I am trying to do, I am importing this module in stead of Q:\n\n``` javascript\nvar q = require('q');\n\nmodule.exports = q;\n\nq.makePromise.prototype.if = function (testFunc, thenFunc, elseFunc, throwBool) {\n    return switchIf(this, testFunc, thenFunc, elseFunc, throwBool);\n};\n```\n\n``` cmd\n/var/test/qtree-test.js:93\n        .if(function(){return true}, function(val){return val;})\n     ^\nTypeError: Object [object Promise] has no method 'if'\n```\n\nI want to add some extra prototypes to promises in a separate module with a Q dependency.\n. Different approach, same problem:\n\n``` javascript\nObject.defineProperty(q.makePromise.prototype, 'if', {\n    enumerable  :   false,\n    value       :   function(testFunc, thenFunc, elseFunc, throwBool) {\n                        return switchIf(this, testFunc, thenFunc, elseFunc, throwBool);\n                    }\n});\n```\n\n``` cmd\nObject.defineProperty(q.makePromise.prototype, 'if', {\n       ^\nTypeError: Cannot define property:if, object is not extensible.\n```\n. I did a quick search for `preventExtensions` and `isExtensible` and didn't find any in `Q`, I thought it would be extensible by default. Either way, you're right, I don't have the latest version on my development server. Will fetch it and try again.\n. You are right, `0.9.4` is less stubborn! What sourcery is this? How does one change extensibility without using the letters `extens*` in code?\n\n(Also, `q.makePromise.prototype` and `Object.defineProperty(q.makePromise.prototype` both work. I don't know which is preferred or if I should care.)\n. In case anyone is interested, I put this small piece of code that adds the `if()` method to promises in a repo. I hope to expand on it in the future.\n\nhttps://github.com/Redsandro/qtree\n. I am trying to make promises [aware of their switched state](https://github.com/Redsandro/qtree#future-wishes), so I can have daisychained conditionals.\n\nIs it clever to extend `Q` internal functions (e.g. `when()`) with a wrapper function by overriding the prototype (e.g. `then()`)? Or is there a better (smarter) way to do this?\n\n(you can skip the rest, just some examples to show what I mean)\n\n---\n\nE.g. In order to do branch-aware promises:\n\n``` javascript\ngetPromise()\n.case('someValue')\n    .then(someBazBaz) // No break, continues with next case\n.case('otherValue')\n    .then(someBarBar)\n    .break() // Break, skips to esac()\n.default() // When no case is matched\n    .then(someFooBaz)\n.esac() // Promise no longer needs to be branch-aware.\n```\n\nI need to add a 'secret' property to promises to notify them to skip `then()`s under certain conditions, but I want to be as non-invasive as possible so every `Q` update won't break `qtree`.\n\nE.g. hypothetical code: `Q.when` is still used, but wrapped in `qtree.newWhen`:\n\n``` javascript\nq.makePromise.prototype.then = function (fulfilled, rejected, progressed) {\n    return newWhen(this, fulfilled, rejected, progressed);\n};\n\nnewWhen = function(promise, fulfilled, rejected, progressed) {\n    if (promise.secretProperty) // some wizardry TBD\n        return promise; // Ignore this then()\n    else\n        return q.when(promise, fulfilled, rejected, progressed);\n```\n. Ideally I'd like to wrap _all_ promise-accepting `Q` functions in one _single_ wrapper function. The wrapper would either execute/return the original function, or return the promise immediately. \n\nI'm not sure if that's possible in javascript. But OTOH, you have this clever `array_reduce` trick for batch-adding functions to a prototype. Maybe there is a clever hook type trick I can do for batch-wrapping?\n\n---\n\n**@killdream:** _Why_ do you think it's not a good idea? I think it's an excellent idea. I think your POV is too close to the promises as they are. Extend your frame of reference a bit and this will be awesome. You don't have to like it right away though. ;) It doesn't touch `Q` anyway. But before attempting it my way, I just like to verify if the clever Q people over here know of a better way to extend `Q` than I am about to try.\n\n_\"Because the promise chain provides such a nice overview of the order in which your code is executed, it is beneficial to be able to make promise trees in stead of promise chains.\"_ _\"The goal is to have more control over the flow of promises.\"_\n\nThe alternative you provided has no improvement over the  `if()` statement, except for semantics which contradict the functionality of your typical `case` statement. ( _Note:_ I am following `Bash` here because it uses a short and simple linear chain of commands like I am trying to implement. Javascript would call this a `switch` statement which encloses the `case` switches.)\n1. On first `case` statement, `promise` must remember he's in a case statement (i.e. be _branch-aware_) because: \n   - It must skip `then`s when `case` condition is not met;\n   - It must stop doing `case`s and skip the chain to `esac` when `break` is encountered;\n   - It must stop being branch-aware when `esac` is encountered. \n\nAnyway, daisychaining `if`s is also on my todo-list, but in order to do so, the question remains exactly the same because promises still need to be aware. \n. Not really. \n\n1) Promises already have states. 2) And having the (secret hidden helper) state of the promise defined by the previous `case` is the _definition_ of compositionality. 3) These states are not global.\n\n``` javascript\nvar foo = promise.then(baz)\nvar baz = doSomething(foo)\n// Same difference. The biggest showstoppers are the unknown functions `baz()` and `doSomething()`.\n```\n\nAs for the consequence of the missing `esac` statement - the unexpected effect this has on consecutive `then` statements is not weirder than executing `onFulfilled` callbacks after `onRejected` when the promise clearly cannot have the value expected by `onFulfilled`.\n\nI can best illustrate this by showing you the module when it's ready. The first lines before the <hr> break in my previous (edited) post illustrate the real technical question.\n. I often use [these if-switches I hacked together](https://github.com/Redsandro/qtree) based on **killdream** s suggestion. Our lives would be easier if we could create entire case-chains, but I am too stupid to implement those.\n\nI'd love to see these clever guys implement something like this in core, and although I disagree with most arguments against it, **kriskowal** has expressed an understandable wish to keep things simple and focused.\n. Just curious. Is this purely for minifying purposes?\n\nI was looking at this to see if it can help me write simpler code. But (at least in V8) it doesn't seem to improve.\n\n`someArray.map(someFunction);` or `array_map(someArray, someFunction);`\n\n`object.hasOwnProperty(key);` or `object_hasOwnProperty(object, key);`\n\nMaybe I'm using bad code examples for seeing greater benefit.\n\n-edit- \nI meant to ask this here but I accidentally followed the link to #181. \n. Don't necessarily need `uncurryThis` for that but it is pretty I give you that.\n\nHowever I was inspired to think this way (simpler code) by the comment in the (not too recent) source:\n\n```\n// There is no situation where this is necessary.\n// (...)\n// However, this does have the nice side-effect of reducing the size\n// of the code by reducing x.call() to merely x(), eliminating many\n// hard-to-minify characters.\n```\n\nSo I was wondering what other simplification tricks it could do that were relevant to my interests. :) \n. Well, the comments are still in the code ([210:216](https://github.com/kriskowal/q/blob/master/q.js#L210)) so I thought this kind of speculation is exactly what got it there in the first place. :)\n\nI was wrong, but you can see why I thought so.\n. That was an awfully quick reply. :)\n\nYou are right, it won't be caught that way. I guess MongoDB forgot a listener here, because the docs don't state listeners should be attached manually. I will dive into Mongo then. Thanks!\n. This turns out to be a `MongoDB` error indeed, and is fixed in recent versions. Attaching listeners to everything is recommended to prevent node from crashing.\n. Just putting this out here in case someone hits the same problem. Took me a while to figure out because of confusing docs.\n\nMongoDB docs are synchronous and often just return the results. But running in node, there's only an async function. `distinct()` **must** have a callback.\n\nSo in the light of `Q`, it's a perfect case for `nfcall` to attach the callback in a promise.\n\nIn this case:\n\n``` javascript\nreturn q.nfcall(col.distinct.bind(col), 'someField');\n```\n. Or - even better - using the brand new _experimental alias_ `nmcall()`:\n\n``` javascript\nreturn q.nmcall(col, 'distinct', 'someField');\n```\n. Not the kittens! :sob: \nThanks for explaining.\n\nAlthough in stead of babysitting, I would call the formatting trick _'syntactic sugar',_ and checking if argument is already an `Error` _'backwards compatibility'._\n\n`deferred.reject(new Error(util.format(string, var, var)));` versus `deferred.reject(string, var, var);`\n. This is true. Partially. :stuck_out_tongue_winking_eye:  \n\nBut if a 4 line addition can make an awesome library even more awesome, I feel like it's my responsibility to bring it up. :sparkles:\n\nBut hey I'll just require('kittens') on all script files of my app and call it a day. :)\n. Just in case I'm not smart enough, I can change `defer()`, but I cannot change `deferred.reject()` inside `defer()` from outside the `Q` module, am I wrong?\n\n```\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n```\n\nUnless of course I replace the entire function but that ain't cute anymore.\n. Wow the code around that has changed a lot. Is there (gonna be) a separate secure and non-secure version of Q or something?\n\nI like extensibility. So I probably like these developments. :)\n. Thanks. :)\n. > We will continue enjoying the m\\* methods for the duration of the version 1 release train.\n\nI noticed that `q.nmcall` is not a proper alias for `q.ninvoke`. The variadic arguments are not properly passed.\n\nE.g.:\n`return q.ninvoke(collection, 'find', query, options);` returns a proper cursor for MongoDB, where:\n`return q.nmcall(collection, 'find', query, options);` returns an empty cursor.\n\nI noticed this in a project running Q `0.9.4`.\n\n---\n\nI'll just convert my things to the recommended Q method names from now on. I'll take the fact that I have to visit the API in stead of intuitively knowing which method to use for granted. I still don't get the `invoke` preference. It is totally ambiguous. For example, you often learn about invoking functions (e.g. w3schools), yet with Q, invoking applies to methods.\n\nIs there a rationale? Maybe people like me just need a little leap of understanding and this suddenly makes sense.\n. Does that work?\n\nEither way, that's not syntactic sugar, that's wizardry.\n\nI propose:\n\n```\nlibrary (value)\ncommand (options)\ncommand (options)\ndone\n```\n\nYou (cleverly (if it works)) replace the original (annoying) function wrapper by a trick:\n\n```\nlibrary (value)\nstep (library command wizardry (library options))\nstep (library command wizardry (library options))\ndome\n```\n\nThe whole idea is to make this simple to read and write.\n. Is there a big difference between node.js and any other implementation of `Q`? Because your ideas seem relevant to my interests unless I'm missing something.\n. Is this a suggestion? Isn't this already possible?\n. Oh yeah I forgot, there is no `nmbind`. I forgot about those when drafting #235.\nIt's `nbind`.\n\nVery convenient indeed:\n\n```\nq(gzipped)\n.then(q.nbind(zlib.gunzip, zlib))\n.then(playWithUnzipped)\n```\n. Is there a similar one-line sugar possibility to pass extra arguments to the next step?\n\n`.then(q.something(function, arg1, arg2, arg3))`\n. Interesting. Are there API docs for this yet? Or [V2 in general](https://www.google.com/search?q=q+v2+api)?\nAm I correct that v2 API is slimmed down and not backwards compatible with V1?\n. Nice to know. I'll keep using V1 for now. Some of the Q-specific functions are just too awesome to miss (those bind, call, apply etc). Similarly, some people at random locations seem to want to punch me in the face for using Q because they claim a thing called 'bluebird' is a gazillion times faster.\n\nThe Q team is very knowledgeable as proven by many responses and the clever code imo, and I know nothing about this speed thing, but I thought maybe V2 might address some of these issues.\n\nAnyway, I don't notice any reason to want something faster anyway. Just saying, there are some folks out there. :)\n. Ah that was easy.\n\nI (wrongfully) assumed those two were equivalent, since for promise chaining the frontpage states that chaining inside or outside is similar: _You can chain promises either inside or outside handlers. The next two examples are equivalent._\n\nBut the nesting is different indeed. Thanks.\n. Makes sense, thanks :thumbsup: \n\nSince I'm all about sugar, how does this sound?\n\n`p.timeout(ms, message, [delayedStart])`\nWith `delayedStart` being an optional boolean that when set to `true` causes the the timer to start _after_ the incoming promise is fulfilled?\n\nIt preserves a flat queue, and is 100% compatible.\n\nI would provide an example to https://github.com/kriskowal/q/blob/v1/q.js#L1671 line 1671-1690 but I'm not sure how to add a `then()` to the promise if a boolean is set. The code is too clever for me to see how to construct that.\n. In the original case of `delayedStart = false` the timer would start at the beginning of the chain and stop when the promise passed to `timeout()` is fulfilled.\n\nWith `delayedStart = true` the timer would start when the promise passed to `timeout()` is fulfilled and stop at the end of the fulfilled chain.\n. You are correct. I haven't thought this through.\n\nMy heart goes out to beauty and sometimes that makes me forget that rules of logic can simply not be broken.\n. Thank  you and sorry for getting back so late.\nYour answer is excellent **ForbesLindesay**. \n\nThe project I was working on has already evolved beyond this issue. Nevertheless, I've been trying to recreate the scenario as per your request, but I cannot get it to work. You must be right, and I've probably made a mistake in my initial scenario. `==` in stead of `===` or something that caused the value to be globally available to the function, misleading me. Idk.\n\nOr I was right but I cannot figure out exactly what I did. Probably not, but I like to keep the idea alive for my personal feelings and stuff. :P\n\nAnyway, much thanks for providing the proper code. It clarifies things.\n. Extra question though, while trying to recreate the scenario, I find that I miss the thrown errors with stacktrace. These are eaten by `Q`, which is what we want for the end user. But is it possible switch to developer mode or something, to get the crashes, errors and stacktraces in the console in stead of triggering the error clause in the `Q` contract?\n\n``` javascript\nvar freeStuff = {};\nfreeStuff.freeBeer(20);\n```\n\n``` cmd\nTypeError: Object #<Object> has no method 'freeBeer'\nat here and here\nat there and there\nat so and so\n```\n. Thanks. \n\nI didn't know we need to wrap a `throw` in a `setTimeout`. This is always, or only in `then()`, or only in the error parameter of `then()`?\n. Thank you! I appreciate the elaborate example. :)\n. I am probably using one of your examples wrong, but when I use this one:\n\n``` javascript\n.then(function(value2) {\n    return Q.nfcall(funcWithCallback, value1, value2);\n})\n.then(function(dronesYouAreLookingFor){\n    // Have a party\n})\n.done();\n```\n\nin this way (let's call this **solution 1** for reference):\n\n``` javascript\n.then(function(value2) {\n    return q.nfcall(mysql.client.query, query, [lang_code, autocomplete]);\n})\n.then(function(err, results, fields) {\n    if (err) {\n        throw err;\n    }\n    // Have a party\n})\n.done();\n```\n\nI get\n\n``` bash\n/var/www/node/node_modules/q/q.js:1327\n                throw error;\n                      ^\nTypeError: Object #<Object> has no method '_implyConnect'\n    at /var/www/node/node_modules/mysql/lib/Connection.js:88:8\nFrom previous event:\n    at /var/www/node/node_modules/q/q.js:1062:16\n    at /var/www/node/includes/router.js:274:14\n    at /var/www/node/node_modules/q/q.js:860:30\n```\n\nWhat did I do wrong?\n. Normal usage is\n\n``` javascript\nmysql.client.query(query, [lang_code, autocomplete], function(err, results, fields) {\n    if (err) {\n        throw err;\n    }\n    // Have a party\n});\n```\n. I receive the exact same error, not sure how to use this properly.\n\nNot with your or this **solution 1** either:\n\n```\nreturn q.nfcall(mysql.client.query.bind(mysql.query, query, [lang_code, autocomplete]));\n```\n\neither, as I am trying to apply this documentation about your suggestion: https://developer.mozilla.org/ru/docs/JavaScript/Reference/Global_Objects/Function/bind\n. Same error on (Let's call this **solution 2**):\n\n``` javascript\nvar doQuery = q.nfbind(mysql.client.query);\nreturn doQuery(query, [lang_code, autocomplete]);\n```\n. Yes, that one ( **solution 2** ) works! \n\n**Solution 1** also works! I must have done something stupid. Perhaps not restarting node after the bind.\nI am very sorry, and you are right about the bind. Thank you.\n. This  `done()` business is indeed nice. I should have known because it is in the docs: _Ending a promise chain makes sure that, if an error doesn\u2019t get handled before the end, it will get rethrown and reported._ In my opinion, this line should be marked by boldness and fireworks. :)\n\nIn other news, even though the previous `mysql.client` example worked in the end, I cannot seem to plug a `callback` with parameters into a callback-wanting-function. I've read this page again and again, and I am still not the professional that my mother tell my grandmother I am.\n\nI have a 9 line example, but in stead of explaining I added comments and an example func+callback so it reads like a novel:\n\n``` javascript\nq.fcall(function() {\n    // This function creates val01\n    var val01 = 'something';\n    return val01;\n})\n.then(function(val01) {\n    // funcNeedsCB needs val01    // works\n    // funcNeedsCB creates val02    // works\n    // funcNeedsCB calls callback with val01 and val02    // problem\n\n    //return q.nfcall(tools.funcNeedsCB.bind(tools), val01); // does not work, why not?\n    return q.nfbind(tools.funcNeedsCB.bind(tools), val01);\n})\n.then(function(val01, val02) {\n    // someCallbackFunc needs to be inserted into funcNeedsCB as callback\n    // someCallbackFunc needs val01 and val02, but these are specified in funcNeedsCB's callback call\n\n    //return q.fcall(tools.someCallbackFunc.bind(tools)); // test\n    //q.fcall(tools.someCallbackFunc.bind(tools)); // test\n    tools.someCallbackFunc(val01, val02); // Does not work because val01 = func and val02 = undefined\n});\n//.done();\n\n// e.g.\ntools = {\n    funcNeedsCB         : function(val01, callback) {\n        var val02 = 'anything';\n        callback(val01, val02); // AKA someCallbackFunc\n    },\n\n    someCallbackFunc    : function(val01, val02) {\n        // Build a fire with val01 and val02\n    }\n}\n```\n\nCan you see where I am going wrong again?\n\n---\n\nAlso, is there a rule when or when not to use `bind()`?\nSince I seem to need to bind _every_ method I use like so:\n\n``` javascript\nvar doQuery = q.nfbind(mysql.client.query.bind(mysql.client));\n```\n\nBut the docs provide this example:\n\n``` javascript\nvar readFile = Q.nfbind(FS.readFile);\n```\n\nand not:\n\n``` javascript\nvar readFile = Q.nfbind(FS.readFile.bind(FS));\n```\n\nIs this because the scope is automatically one parent up which is the same as the root of the callee?\n. Wow, turns out I have _always_ misunderstood this difference between functions and this-requiring methods. Providing `this` is usually within my frame of my intuition. It was never a problem. It seems I have discovered where intuition ends and actual thinking begins. \n\nI am still unsure because calling the method directly doesn't require `bind()`ing `this`.\nI know I have to pay attention to that. Thanks for pointing it out.\n. Awesome example. I know and use that first thing, extensively for crying out loud. I just never knew about this `bind` stuff, I just pass it all the toys `function` needs. And I blindly assumed `mysql.client.query` did the same.\n\nSo I can remove the `bind` in example #issuecomment-13517187 and it works if I change `funcNeedsCB` to return a `deferred`, call it directly (no `bind` or `call`) and work on that in stead of using a callback, but I wonder if I can't just plug in a callback in the next `then`.\n\nI am sorry, I know you mentioned using callbacks should be considered `legacy`, but I see me writing all these wrappers and things.. if the next `then` would just be the callback that is plugged into the previous `then`, it would be a syntactic sugar storm.\n. Thanks for the example. As for `Q.nfinvoke`, isn't that what `Q.nfbind` is supposed to do?\n(I guess not otherwise my example would work, but maybe I should prepend a `null` in the call arguments first because the first one should be an error..)\n\nAnd by `Q.nfinvoke` you mean `Q.ninvoke` (without the f) of is `Q.nfinvoke` (with f) just not in the API reference yet?\n\nBtw, the code example in the API @ https://github.com/kriskowal/q/wiki/API-Reference for `Q.ninvoke` is accidentally the same as `Q.npost`. Copy-paste-typo I think. :)\n. Sorry to get back at this method vs. function again. But since we need to `bind()` the method ourselves, what is effectively the difference between `nfapply` and `npost`?\n. Yes I was looking at the [API](https://github.com/kriskowal/q/wiki/API-Reference); it looks like `npost` is `nfapply` with `bind` internally. It confused me because if that's all it feels intuitively like this would be `nmapply` (no typo) but maybe I simply need to read up on javascript terminology, and find out why you `apply` to a `function` but `post` to a `method`.\n. Ah yes. Perhaps there could be a `q.nmcall()` to complement `q.nfcall()` in a similar way that `q.npost` complements `q.nfapply`. \n\nThen no one would ever have to explain the binding \u00e0 la\n`q.nfcall(mysql.client.query.bind(mysql.client), query, [lang_code, autocomplete]);`\never again. ;)\n. Good idea? Bad idea?\n. Nice, thanks for fixing!\nJust to be sure: I can delete this branch now, right?\n. This is happening to all promises, not just the once created by `q.nfcall`. I first encountered this trying to get an array from `promise.allResolved()`. I get a promise, even in the `valueOf` that promise. I can traverse the array inside the promise chain (`then()`), but then the array items are promises for which I cannot reach their values.\n\nOnce a starship is returned as a promise, there is no escape from the chain. We are trying to reach our home world, which lies outside the chain. Please show us how to correctly change our heading. We are desperate for food and supplies.\n. I now realize that a promise that not is fulfilled yet cannot reveal it's value, but I am wondering if the `valueOf()` shouldn't be `undefined` in this case.\n. Hmm.. this is true. Back when things took time in my node script, I was getting used to being able to use `valueOf()` so that I forgot to check that this is actually documented in the API wiki.\n\nI guess in stead of checking for `undefined` I can do something like `if (myPromise.valueOf().constructor && myPromise.valueOf().constructor.name == 'Promise')` for now, and start converting all such occurances in my code to a callback-stype wrapper functions to pass along promised values.\n. Thank you.\n. I agree that this could be improved upon, but in my own prosecution, one might argue that in an ideal promised land, values won't ever have to be evaluated like this. \n\nEither way, I like that this is being debated. :)\n. One thing though about events in stead of promises is that breakpoint debugging is a great way to examine long storylines of code. But the value of a promise in an entire chain cannot be followed in a similar fashion this way, because the value won't be known until a few ticks later.\n\nAny hints on how to do something similar in promiseland?\n. Yes I need `allResolved`, I cannot be sure all promises get fulfilled, some might be rejected and I need to continue with the fulfilled ones.\n\nNice one. Is this filter a javascript function extended as Q prototype? As in, is it chainable?\n\n```\nq.allResolved(arrayWithPromises)\n.filter(\n    function (promise) {\n        return promise.isFulfilled()\n    })\n.map(\n    function (promise) {\n        return promise.valueOf()\n    }\n)\n```\n. That is clever. I had to see the source code to understand it. `q.valueOf` is not exported statically, but it is exported as `q.nearer`. Nice.\n. Is there a pseudo-easy way to figure out where a promise was rejected?\n\nAlthough I run `Ubuntu 12.10` and `node v0.6.19` both locally and remote with the same code, this construction keeps tripping an error on the server while it works flawlessly on my local machine. It's such a tedious task to backtrace the reject.\n\n---\n\nAlso, while trying out oldskool debug messages, I found that [`promise.isPending()`](https://github.com/kriskowal/q/wiki/API-Reference#promiseispending) doesn't seem to work (on either machine): `TypeError: Object [object Promise] has no method 'isPending' at q.js:860:30`. At least not in the way I expected.\n\n---\n\nHere's some reference output, you can ignore this. Just in case code sais more than words.\n\nLocal:\n\n``` terminal\nDEBUG: Fullfilled boolean: true\nDEBUG: Rejected   boolean: false\nDEBUG: [object Promise],[object Promise],[object Promise]\nDEBUG: [object Object]\nDEBUG: [object Object]\n```\n\nServer:\n\n``` terminal\nDEBUG: Fullfilled boolean: false\nDEBUG: Rejected   boolean: true\nDEBUG: [object Promise],[object Promise],[object Promise]\nDEBUG: [object Promise]\nDEBUG: [object Promise]\n```\n\nDebug code for reference purposes\n\n``` javascript\nvar myPromise = q.allResolved(promiseArray)\n.then(function (promiseArray) {\n    // THIS STEP IS FOR DEBUGGING ONLY\n    tools.debug('Fullfilled boolean: ' + promiseArray[0].isFulfilled());\n    tools.debug('Rejected   boolean: ' + promiseArray[0].isRejected());\n//  tools.debug('Pending    boolean: ' + promiseArray[0].isPending()); // Does not work\n    tools.debug(promiseArray);\n    var debug = promiseArray[0].valueOf(); // Breakpoint\n    tools.debug(debug);\n    tools.debug(debug.valueOf());\n    util.inspect(debug, true); // No output today?\n    return promiseArray;\n})\n.then() // etc\n```\n. Thanks! This will help to a certain extend.\n\nThe line number is not totally accurate but I can search for the thrown error in my code.\n\n```\nLine: 0\n```\n. Thank you. I misunderstood again. The example clarifies the facts.\n\n(Skip below, you replied at the same time.)\n\nOriginal message:\n\nI am trying to have different error handling for thrown errors further down the chain, but the `onFulfilled` is getting in my way. The spec doesn't explicitly mention that `onFulfilled` should execute after the first `onRejected`. The promise and me are in disagreement about whether or not this means the promise is allowed to trespass on fulfilled territory.\n. (edited above message)\n\nAh, I see how to get it to work how I assumed it did. Errors don't bubble, you have to rethrow them.\n(Just mentioning this for google, duckduckgo and other referencing purposes.)\n\n``` javascript\n.fail(function (err) {\n    console.log('I caught ya! :D');\n    throw err;\n})\n.then(function () {\n    console.log('Shouldn\\'t this step be skipped?');\n})\n.fail(etcetera)\n.done();\n```\n. Yeah, I mean like.. handled errors don't bubble between onRejected handlers like oldschool web2.0 handled mouseclicks still bubble; ignoring the onFulfilled handlers for a moment as if they are like axons covered in myelin. Or something. You are right.\n. Is there a way to cancel the bubble, end the chain, without breaking it in two?\n\nBecause even if an error is handled and the chain goes on, the promised data/request/file/anything will not be available, and all the consecutive ticks are more often than not futile without this data. Only cause more errors to handle.\n\n``` javascript\n// ...\n.fail(function (err) {\n    console.log('Some exception that should end the chain.');\n})\n.then(function () {\n    console.log('Chain should only go on if the above exception did not occur.');\n})\n.then() // etc\n```\n\nLike a conditional `done()`\n\n``` javascript\nQ.fcall(step1)\n.then(step2)\n.fail(okNeverMind).done() // Never mind the rest of the chain, but only when failed\n.then(step3)\n.then(step4)\n.then(stepFinal, handleStep3and4)\n.done();\n```\n\nMy current alternative looks like this:\n\n``` javascript\n/// stuff ...\n.fail(function (err) { // First handler\n    console.log('httpRequest without Data was just a probe for JSON headers.');\n    throw new Error('ignore');\n})\n.then() // blah\n.done(\n    function() {\n        // We are done.\n    }, function(err) {\n        if (err.message == 'ignore') return;\n        // Else handle real error\n    }\n)\n```\n. I have been editing my post without realizing you had replied already, but you got the gist.\n\nThe problem with your idea, I've been playing with that too, is that promises are a form of syntactic sugar. I am a big fan of syntactic sugar.\n\nImagine a longer chain:\n\n``` javascript\nfcall()\n.fail() // Handle initial errors and stop the chain\n.then()\n.then()\n.then()\n.fail() // Handle errors in the above three steps and stop the chain\n.then()\n.then()\n.then()\n.done() // Handle errors in the final steps\n```\n\nAdding the probe to all these functions kinda introduces syntactic \"salt\" and 'complicates' use of existing functions that also have use in non-promise routines.\n\nSilently bubbling the error so that it skips fulfilled-handlers seems like the better idea at the time, but it has me wondering if there should be a command like `breakPromise` or something that just stops the entire chain.\n\nIt's not spec, but also not crazy. It would be useful. Enhancement maybe.\n. Well my current code is kind of huge so I tried to illustrate it with pseudo-code, but I am trying to simplify the initial chain for sugar reasons. First only for _\"inversing the inversion of control\"_ (sync style for async code), but going a bit further now, it made me think: Either it's already possible or it's a great enhancement if it would be possible to break. It is compatible with the promise spec after all.\n\nFor example, one of the first steps is a promise for `JSON` data. But the node `server.request` fires an empty `onData` and `onEnd` event in certain cases because the client wants to check for a `JSON` accept header, for example when the client uses `jQuery`. The chain is nearly perfect, except for handling this (non)error or continuing otherwise. Further along the chain I have something similar when the promise reached a state where it's complemented with database data. In some rare cases it should stop because data is already written to `server.response`.\n. I think the answer to _\"can you break\"_ is _\"no\"_, and all I can do is suggest it would be a valuable function to add.\nWe both provided workarounds, so I am not sure if dumping more code will be useful. I feel that people don't usually appreciate dumping of code that is more than a few lines.\n\nBut if you think you might get additional ideas, I'll gladly show you the request I am working with now, right after it comes from the router.\n\nBy now people usually comment on my object notation style as not how it is supposed to be, but hey I'm a rebel.\n\nThe listening server is routed to onIncomingRequest.\n\n``` javascript\nmodule.exports = {\n\n\n    onIncomingRequest :     function(httpRequest, httpResponse) {\n\n        // Pass around one single object\n        var requestObj = {\n            req: httpRequest,\n            res: httpResponse\n        };\n\n        // Here is the chain. Start by reading the request\n        self.readJsonRequest(httpRequest, httpResponse).then(\n            function(data) {\n                // Store JSON in requestObj\n                requestObj.data = data;\n                return requestObj;\n            },\n            function(err) {\n                var msg = 'Ignoring request: '+ err.message;\n                util.debug(msg);\n                throw new Error('ignore');\n            }\n        )\n        .then(db.promises.request.handleRequest)\n        .then(db.promises.request.storeRequest)\n        .fail(db.promises.request.handleMissing) // Rethrow error\n        .then(db.promises.response.storeRequest)\n        .done(\n            function() {\n                // We are done.\n                //TODO: Do we need to do some sort of garbage collection?\n            },\n            function(err) {\n                if (err.message == 'ignore') return;\n\n                util.debug('error', 'Lookuop failed.', err.message); //TODO: Proper handler\n            }\n        );\n    },\n\n    // Private functions\n\n    readJsonRequest     : function(request, response) {\n\n        var data = '';\n        var promise = q.defer(); I am suggesting \n\n        request.on('data', function(chunk) {\n            data += chunk;\n        });\n\n        request.on('end', function() {\n\n            if (data) {\n                try {\n                    data = JSON.parse(data);\n                } catch (e) {\n                    promise.reject(new Error('Not JSON'));\n                }\n\n                promise.resolve(data);\n            }\n            else {\n                promise.reject(new Error('Empty request is a JSON handshake. Sending headers.'));\n                response.writeHead(200, {'Content-Type': 'application/json', 'Access-Control-Allow-Headers': 'Content-Type'});\n                response.end();\n            }\n        });\n        return promise.promise;\n    }\n};\nextend(exports, module.exports);\n```\n\n(Yes storeRequest is called twice, does a switch and an upsert, not important.)\n. Kinda boring right?\nNevermind, I'll stick to 'ignore' error messages for now.\n. In that case, I think I misunderstood you a few times, and I didn't realize until now. :(\n\nIf you mean what it was before I started playing with `deferred`, `async` and `q`, I can't show you literally because it is now mostly `q` and `async`. (Although I think I can replace `async` with `q`.)\n\nBut I can tell you, it was a big virtual noodle soup of events. I kept passing along an event emitter as the object bubbling through everything because it could emit events from everywhere. And I hooked what you'd concider the final `then()` to a listener in the first function. The promise chain has the benefit of not requiring this, because the scope of the enclosing function is available to all the anonymous functions in the chain.\n. Since the spec mentions:\n_3.2.6.3: If either `onFulfilled` or `onRejected` returns a promise (call it `returnedPromise`), `promise2` must assume the state of `returnedPromise`_\n\nI am assuming that this should in fact work and the mistake is in my own code. :/\n. Yes, the provided code was hypothetical. I tried minifying my code of biblic proportions to something that isn't unnecessarily fleshy, and now it doesn't break anymore. :( (or :) actually.)\n\nI still don't totally understand what the problem was. This time I started with `q.fcall(function(){return 'someValuesIGenerated'}).then(promiseReturningFunc)` in stead of `promiseReturningFunc().then()`a few times so I could skip a bunch of boring code.\n\nI'll leave it like this, because staring too long makes me feel like Sonic who lost a lot of rings. I will reopen this issue next time I have a dejavu and I'll make sure to provide working code with it.\n. I am not sure when I created this HEAD I am comparing with now, but it is possible that I foolishly returned a `promise` where I should have returned `promise.promise` in the case of `var promise = q.defer();`. This might be a good time to start calling my deferreds `deferred` in stead of `promise` which seemed to make more sense to me at the time.\n. I must add that I still find it hard to find the correct thrown error line number when a problem is caused by a rejection.\n\nI can `util.log()` the `error.stack` and/or manually add `done()` everywhere to make a hard crash, but sometimes it points to a line number completely (seemingly) irrelevant. E.g. three `then()` iterations after the one where a property of `undefined` cannot be accessed.\n\nIs there a typical trick to use when debugging longer chains with entire functions within steps apart from echoing `error.stack` and `promise.valueOf().exception` on every `onReject`?\n. @killdream Thanks! This sort of wrappery is exactly what I mean. I am just not sure about the reason for `identity`, but I will play around with it tomorrow. Does `nodejs` provide means of extending `require`d modules so that I can prototype this to promises?\n\n@kriskowal I understand, although I think this is very useful. If it's in the core, it will encourage people to take a bite of sammich that is separation of promiseflow and actual code magic and say 'mmm-mmm'.\n. No, I was raised atheist and was told not to listen to what churches write. So I never really took a look at the inventions of Alonzo Church.\n\nJ/k, never heard about Lambda Calculus combinators. I got to know anonymous functions as Lambda-style functions (in PHP) and that's it. Thanks for the explanation. \n\nI understand you disagree and you're probably right. In my personal opinion, having a complete solution adds so much value to a module, and I would not consider something bloat if it adds many possibilities (promise trees in stead of promise chains) with just a handful of code. I remember some other module that decided to include `prototype.js` one day. Adding ~170K for some functionality, that would be bloat in my book.\n\nJust my POV, I am perfectly happy adding it manually. :)\n\nBtw, if non-bloat, plain, slim and clean is really paramount, I still suggest changing core functions like `post`, `tickle` and `robot` to something more sensible like `mcall` `mapply` and `nmcall` as I suggested here: https://github.com/kriskowal/q/pull/235\nBecause I have to look them up in the documentation _all the time_.\n\n2 cents. :)\n. I am trying to put conditional functionality in a separate module `qtree` which extends Q and share it for people who are interested. But I cannot seem to extend the promise methods. Is this at all possible? Here, to illustrate what I am trying to do, I am importing this module in stead of Q:\n\n``` javascript\nvar q = require('q');\n\nmodule.exports = q;\n\nq.makePromise.prototype.if = function (testFunc, thenFunc, elseFunc, throwBool) {\n    return switchIf(this, testFunc, thenFunc, elseFunc, throwBool);\n};\n```\n\n``` cmd\n/var/test/qtree-test.js:93\n        .if(function(){return true}, function(val){return val;})\n     ^\nTypeError: Object [object Promise] has no method 'if'\n```\n\nI want to add some extra prototypes to promises in a separate module with a Q dependency.\n. Different approach, same problem:\n\n``` javascript\nObject.defineProperty(q.makePromise.prototype, 'if', {\n    enumerable  :   false,\n    value       :   function(testFunc, thenFunc, elseFunc, throwBool) {\n                        return switchIf(this, testFunc, thenFunc, elseFunc, throwBool);\n                    }\n});\n```\n\n``` cmd\nObject.defineProperty(q.makePromise.prototype, 'if', {\n       ^\nTypeError: Cannot define property:if, object is not extensible.\n```\n. I did a quick search for `preventExtensions` and `isExtensible` and didn't find any in `Q`, I thought it would be extensible by default. Either way, you're right, I don't have the latest version on my development server. Will fetch it and try again.\n. You are right, `0.9.4` is less stubborn! What sourcery is this? How does one change extensibility without using the letters `extens*` in code?\n\n(Also, `q.makePromise.prototype` and `Object.defineProperty(q.makePromise.prototype` both work. I don't know which is preferred or if I should care.)\n. In case anyone is interested, I put this small piece of code that adds the `if()` method to promises in a repo. I hope to expand on it in the future.\n\nhttps://github.com/Redsandro/qtree\n. I am trying to make promises [aware of their switched state](https://github.com/Redsandro/qtree#future-wishes), so I can have daisychained conditionals.\n\nIs it clever to extend `Q` internal functions (e.g. `when()`) with a wrapper function by overriding the prototype (e.g. `then()`)? Or is there a better (smarter) way to do this?\n\n(you can skip the rest, just some examples to show what I mean)\n\n---\n\nE.g. In order to do branch-aware promises:\n\n``` javascript\ngetPromise()\n.case('someValue')\n    .then(someBazBaz) // No break, continues with next case\n.case('otherValue')\n    .then(someBarBar)\n    .break() // Break, skips to esac()\n.default() // When no case is matched\n    .then(someFooBaz)\n.esac() // Promise no longer needs to be branch-aware.\n```\n\nI need to add a 'secret' property to promises to notify them to skip `then()`s under certain conditions, but I want to be as non-invasive as possible so every `Q` update won't break `qtree`.\n\nE.g. hypothetical code: `Q.when` is still used, but wrapped in `qtree.newWhen`:\n\n``` javascript\nq.makePromise.prototype.then = function (fulfilled, rejected, progressed) {\n    return newWhen(this, fulfilled, rejected, progressed);\n};\n\nnewWhen = function(promise, fulfilled, rejected, progressed) {\n    if (promise.secretProperty) // some wizardry TBD\n        return promise; // Ignore this then()\n    else\n        return q.when(promise, fulfilled, rejected, progressed);\n```\n. Ideally I'd like to wrap _all_ promise-accepting `Q` functions in one _single_ wrapper function. The wrapper would either execute/return the original function, or return the promise immediately. \n\nI'm not sure if that's possible in javascript. But OTOH, you have this clever `array_reduce` trick for batch-adding functions to a prototype. Maybe there is a clever hook type trick I can do for batch-wrapping?\n\n---\n\n**@killdream:** _Why_ do you think it's not a good idea? I think it's an excellent idea. I think your POV is too close to the promises as they are. Extend your frame of reference a bit and this will be awesome. You don't have to like it right away though. ;) It doesn't touch `Q` anyway. But before attempting it my way, I just like to verify if the clever Q people over here know of a better way to extend `Q` than I am about to try.\n\n_\"Because the promise chain provides such a nice overview of the order in which your code is executed, it is beneficial to be able to make promise trees in stead of promise chains.\"_ _\"The goal is to have more control over the flow of promises.\"_\n\nThe alternative you provided has no improvement over the  `if()` statement, except for semantics which contradict the functionality of your typical `case` statement. ( _Note:_ I am following `Bash` here because it uses a short and simple linear chain of commands like I am trying to implement. Javascript would call this a `switch` statement which encloses the `case` switches.)\n1. On first `case` statement, `promise` must remember he's in a case statement (i.e. be _branch-aware_) because: \n   - It must skip `then`s when `case` condition is not met;\n   - It must stop doing `case`s and skip the chain to `esac` when `break` is encountered;\n   - It must stop being branch-aware when `esac` is encountered. \n\nAnyway, daisychaining `if`s is also on my todo-list, but in order to do so, the question remains exactly the same because promises still need to be aware. \n. Not really. \n\n1) Promises already have states. 2) And having the (secret hidden helper) state of the promise defined by the previous `case` is the _definition_ of compositionality. 3) These states are not global.\n\n``` javascript\nvar foo = promise.then(baz)\nvar baz = doSomething(foo)\n// Same difference. The biggest showstoppers are the unknown functions `baz()` and `doSomething()`.\n```\n\nAs for the consequence of the missing `esac` statement - the unexpected effect this has on consecutive `then` statements is not weirder than executing `onFulfilled` callbacks after `onRejected` when the promise clearly cannot have the value expected by `onFulfilled`.\n\nI can best illustrate this by showing you the module when it's ready. The first lines before the <hr> break in my previous (edited) post illustrate the real technical question.\n. I often use [these if-switches I hacked together](https://github.com/Redsandro/qtree) based on **killdream** s suggestion. Our lives would be easier if we could create entire case-chains, but I am too stupid to implement those.\n\nI'd love to see these clever guys implement something like this in core, and although I disagree with most arguments against it, **kriskowal** has expressed an understandable wish to keep things simple and focused.\n. Just curious. Is this purely for minifying purposes?\n\nI was looking at this to see if it can help me write simpler code. But (at least in V8) it doesn't seem to improve.\n\n`someArray.map(someFunction);` or `array_map(someArray, someFunction);`\n\n`object.hasOwnProperty(key);` or `object_hasOwnProperty(object, key);`\n\nMaybe I'm using bad code examples for seeing greater benefit.\n\n-edit- \nI meant to ask this here but I accidentally followed the link to #181. \n. Don't necessarily need `uncurryThis` for that but it is pretty I give you that.\n\nHowever I was inspired to think this way (simpler code) by the comment in the (not too recent) source:\n\n```\n// There is no situation where this is necessary.\n// (...)\n// However, this does have the nice side-effect of reducing the size\n// of the code by reducing x.call() to merely x(), eliminating many\n// hard-to-minify characters.\n```\n\nSo I was wondering what other simplification tricks it could do that were relevant to my interests. :) \n. Well, the comments are still in the code ([210:216](https://github.com/kriskowal/q/blob/master/q.js#L210)) so I thought this kind of speculation is exactly what got it there in the first place. :)\n\nI was wrong, but you can see why I thought so.\n. That was an awfully quick reply. :)\n\nYou are right, it won't be caught that way. I guess MongoDB forgot a listener here, because the docs don't state listeners should be attached manually. I will dive into Mongo then. Thanks!\n. This turns out to be a `MongoDB` error indeed, and is fixed in recent versions. Attaching listeners to everything is recommended to prevent node from crashing.\n. Just putting this out here in case someone hits the same problem. Took me a while to figure out because of confusing docs.\n\nMongoDB docs are synchronous and often just return the results. But running in node, there's only an async function. `distinct()` **must** have a callback.\n\nSo in the light of `Q`, it's a perfect case for `nfcall` to attach the callback in a promise.\n\nIn this case:\n\n``` javascript\nreturn q.nfcall(col.distinct.bind(col), 'someField');\n```\n. Or - even better - using the brand new _experimental alias_ `nmcall()`:\n\n``` javascript\nreturn q.nmcall(col, 'distinct', 'someField');\n```\n. Not the kittens! :sob: \nThanks for explaining.\n\nAlthough in stead of babysitting, I would call the formatting trick _'syntactic sugar',_ and checking if argument is already an `Error` _'backwards compatibility'._\n\n`deferred.reject(new Error(util.format(string, var, var)));` versus `deferred.reject(string, var, var);`\n. This is true. Partially. :stuck_out_tongue_winking_eye:  \n\nBut if a 4 line addition can make an awesome library even more awesome, I feel like it's my responsibility to bring it up. :sparkles:\n\nBut hey I'll just require('kittens') on all script files of my app and call it a day. :)\n. Just in case I'm not smart enough, I can change `defer()`, but I cannot change `deferred.reject()` inside `defer()` from outside the `Q` module, am I wrong?\n\n```\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n```\n\nUnless of course I replace the entire function but that ain't cute anymore.\n. Wow the code around that has changed a lot. Is there (gonna be) a separate secure and non-secure version of Q or something?\n\nI like extensibility. So I probably like these developments. :)\n. Thanks. :)\n. > We will continue enjoying the m\\* methods for the duration of the version 1 release train.\n\nI noticed that `q.nmcall` is not a proper alias for `q.ninvoke`. The variadic arguments are not properly passed.\n\nE.g.:\n`return q.ninvoke(collection, 'find', query, options);` returns a proper cursor for MongoDB, where:\n`return q.nmcall(collection, 'find', query, options);` returns an empty cursor.\n\nI noticed this in a project running Q `0.9.4`.\n\n---\n\nI'll just convert my things to the recommended Q method names from now on. I'll take the fact that I have to visit the API in stead of intuitively knowing which method to use for granted. I still don't get the `invoke` preference. It is totally ambiguous. For example, you often learn about invoking functions (e.g. w3schools), yet with Q, invoking applies to methods.\n\nIs there a rationale? Maybe people like me just need a little leap of understanding and this suddenly makes sense.\n. Does that work?\n\nEither way, that's not syntactic sugar, that's wizardry.\n\nI propose:\n\n```\nlibrary (value)\ncommand (options)\ncommand (options)\ndone\n```\n\nYou (cleverly (if it works)) replace the original (annoying) function wrapper by a trick:\n\n```\nlibrary (value)\nstep (library command wizardry (library options))\nstep (library command wizardry (library options))\ndome\n```\n\nThe whole idea is to make this simple to read and write.\n. Is there a big difference between node.js and any other implementation of `Q`? Because your ideas seem relevant to my interests unless I'm missing something.\n. Is this a suggestion? Isn't this already possible?\n. Oh yeah I forgot, there is no `nmbind`. I forgot about those when drafting #235.\nIt's `nbind`.\n\nVery convenient indeed:\n\n```\nq(gzipped)\n.then(q.nbind(zlib.gunzip, zlib))\n.then(playWithUnzipped)\n```\n. Is there a similar one-line sugar possibility to pass extra arguments to the next step?\n\n`.then(q.something(function, arg1, arg2, arg3))`\n. Interesting. Are there API docs for this yet? Or [V2 in general](https://www.google.com/search?q=q+v2+api)?\nAm I correct that v2 API is slimmed down and not backwards compatible with V1?\n. Nice to know. I'll keep using V1 for now. Some of the Q-specific functions are just too awesome to miss (those bind, call, apply etc). Similarly, some people at random locations seem to want to punch me in the face for using Q because they claim a thing called 'bluebird' is a gazillion times faster.\n\nThe Q team is very knowledgeable as proven by many responses and the clever code imo, and I know nothing about this speed thing, but I thought maybe V2 might address some of these issues.\n\nAnyway, I don't notice any reason to want something faster anyway. Just saying, there are some folks out there. :)\n. Ah that was easy.\n\nI (wrongfully) assumed those two were equivalent, since for promise chaining the frontpage states that chaining inside or outside is similar: _You can chain promises either inside or outside handlers. The next two examples are equivalent._\n\nBut the nesting is different indeed. Thanks.\n. Makes sense, thanks :thumbsup: \n\nSince I'm all about sugar, how does this sound?\n\n`p.timeout(ms, message, [delayedStart])`\nWith `delayedStart` being an optional boolean that when set to `true` causes the the timer to start _after_ the incoming promise is fulfilled?\n\nIt preserves a flat queue, and is 100% compatible.\n\nI would provide an example to https://github.com/kriskowal/q/blob/v1/q.js#L1671 line 1671-1690 but I'm not sure how to add a `then()` to the promise if a boolean is set. The code is too clever for me to see how to construct that.\n. In the original case of `delayedStart = false` the timer would start at the beginning of the chain and stop when the promise passed to `timeout()` is fulfilled.\n\nWith `delayedStart = true` the timer would start when the promise passed to `timeout()` is fulfilled and stop at the end of the fulfilled chain.\n. You are correct. I haven't thought this through.\n\nMy heart goes out to beauty and sometimes that makes me forget that rules of logic can simply not be broken.\n. ",
    "kuno": "@domenic \n\nAs showing in the example code, I determining the results based on the argument that passed to the callback of `exec` function. \n\nIf the first argument is valued to be true, then I assumed that the execution of the command was failed.\n. @domenic \nThanks for you reply. For your question, in my case, `runAlotOfCommands` is a public api that exposed to other developers.\n\nSo it is their job to judge fulfilled for rejected.\n. @domenic \n\nAs showing in the example code, I determining the results based on the argument that passed to the callback of `exec` function. \n\nIf the first argument is valued to be true, then I assumed that the execution of the command was failed.\n. @domenic \nThanks for you reply. For your question, in my case, `runAlotOfCommands` is a public api that exposed to other developers.\n\nSo it is their job to judge fulfilled for rejected.\n. ",
    "danielmoore": "Hm, I see how that would be very effective. One caveat I neglected to mention earlier is that sometimes one of the steps is `undefined` (hence the `else return args;`). The idea of the larger component is that the user-code can configure a bunch of steps (actually via an object literal) and then they get executed in the correct semantic order.\n\nI totally understand if this is something unique to my situation; I just thought I'd share something that helped me out.\n. As promised:\n\n``` js\nQ\n  .allResolved([{ then: function(ok, notOk){ setTimeout(ok, 100); } } ])\n  .then(function(promises) { console.log('Should be 1:', promises.filter(Q.isResolved).length); })\n  .done()\n```\n. Hm, I see how that would be very effective. One caveat I neglected to mention earlier is that sometimes one of the steps is `undefined` (hence the `else return args;`). The idea of the larger component is that the user-code can configure a bunch of steps (actually via an object literal) and then they get executed in the correct semantic order.\n\nI totally understand if this is something unique to my situation; I just thought I'd share something that helped me out.\n. As promised:\n\n``` js\nQ\n  .allResolved([{ then: function(ok, notOk){ setTimeout(ok, 100); } } ])\n  .then(function(promises) { console.log('Should be 1:', promises.filter(Q.isResolved).length); })\n  .done()\n```\n. ",
    "rkatic": "Here a performance test: http://jsperf.com/uncurrythis\n. It is not a small fix, and English is not my first language, so will leave this one to you guys ;)\n. Not sure what you mean, but the returned promise from callbacks will be used to forward the resolution...\n. If the promise is fulfilled then the `doneCallbacks` resolves, if rejected then `failCallbacks`. But still unsure what you mean..\n\nEDIT: I see now the plural :) I suspect it is an error in theirs documentation.\n. Where you found the `deferred.then( doneCallbacks, failCallbacks )` signature?\n. Yes, I see, but it is removed in 1.8 :)\n. No problem.\n. @kriskowal Nice one. I would probably add a hard limit on accumulating free nodes (1000?). However, in my opinion, the performance gain of this listQueue over a simple array is not too relevant specially considering the amount of the additional code required.\n. @kriskowal To effectively run the code path that reuses free nodes, I made each `pushAndShift` execute twice. Also the `shift` method was not correct - http://jsperf.com/list-vs-array-queue/3 \n. @kriskowal Not exactly. Chrome uses the \"hidden classes\" optimization and reusage is not too relevant for him, but you should notice an improvement on Firefox.\n. @domenic \"hidden classes\" has nothing with JS constructors - it's an optimization technique internal to V8 to optimize property accessing and it operates on object literals in the same way.\n. @domenic In my experience, object literals performs better. Maybe they do some additional optimization with constructors, but calling constructors (like any other function) has a penalty on it's own, specially on other browsers where none of those optimizations are applied.\nHowever, I could be wrong. Try and we will see :)\n. I made some additional [tests](http://jsperf.com/qegfraerfrecregrs/2), and seems that node reusage have no benefits.\nI think we can conclude that the slowness of the current solution is caused by adding/deleting node properties.\nTherefore, I am closing this pull-req, to open another with new changes.\n. It shouldn't. I use a preventive `postMessage/setTimeout` to handle remaining tasks even if one throws.\n. @domenic I added a comment that should clarify the approach. Feel free to suggest an better one.\n. Here a performance test: http://jsperf.com/wqgrecrereffrre/3\n. To put in a better perspective, in test http://jsperf.com/wqgrecrereffrre/4 I also added the list optimization alone ([pull191](/kriskowal/q/pull/191)).\n. @domenic That one will fail on IE 6 **and 7**. It does not support `try finally` without `catch`.\n. I would like to point out that while this approach do minimize latency of \"ticks\" in case of none thrown exceptions, it also can increase latency of tasks after a thrown exception. In case we wont to be less \"optimistic\", we can preemptively request _n_ ticks, where _n <= m_ and _m_ is the number of tasks.\nWith my last updates, I adopt an \"rather-optimistic\" approach, where _n <= 2_.\nThis could be further adjusted.\n. With the last change, I think, I resolved the problem of the introduced latency on multiple thrown exceptions. :8ball:  (is this the proper use of 8ball?) \n. Ignore my last comment. Unfortunately the only way to completely eliminate the increased latency after thrown exceptions, is to make an tick request per task ( _n >= m_ ). I created a new branch with such \"pessimistic\" approach. Implementation is even simpler (https://github.com/rkatic/q/compare/more-nextTick), with no apparent drop in performances (http://jsperf.com/wqgrecrereffrre/7).\nNow, if we can expect tasks to throw exceptions only occasionally (mainly during debugging), then the current \"optimistic\" approach should be probably fine, otherwise, I don't see why we shouldn't adopt the \"pessimistic\" one.\n. After some given thoughts, I come to the conclusion that the assumption, that uncaught exceptions will be rare in production, is too dangerous. It's not hard to imagine a progress listener start throwing exceptions with high frequency, considerably delaying resolutions of many promises.\nHowever, the \"pessimistic\" approach, although with still good performances, would produce mostly wasted `postMessage/setTimeout` calls.\nTherefore, I made a change that \"amortizes\" both, tick requests, and latency after thrown exceptions.\n. @domenic The problem that a naive \"tick-reusage\" solution has, is that in cases of thrown exceptions, subsequent tick is requested **much** later and **sequentially**. This is a problem, because tasks are queued, and all subsequent tasks after thrown exceptions will wait for the newly requested tick. My solution amortizes such costs.\nTake for example this [test](http://jsperf.com/reqgfdefs/2), where on 100 tasks, every second throws. While the \"naive\" solution with the \"catch re-tick\" approach will sequentially request 50 ticks, producing an _O(t n)_ delay, the amortized solution produces an _O(t log n)_ delay.\nI hope I was clear enough, beside my bad-ish English. Please, feel free to ask for more clarifications.\n\n_t_: tick delay (~3ms on Firefox, 0-1ms on Chrome, ...)\n_n_: number of uncaught exceptions\n. I'm glad I could help, however, I would like to point out that the amortization algorithm is mostly relevant when the tick delay is significant, and that in future, if the usage of `setTimeout` will be removed, the simpler \"catch re-tick\" solution could be probably adopted.\n\nI am actually wondering if we could avoid the `setTimeout` fallback even now, and if we can not, could we at least use the `image.onerror` technique in not IE browsers.\n. Made a [test](http://jsperf.com/qgrfefwt3tr4wrw4f), and seems that this change would have no benefits in performance, so I am closing this one.\n. I am not 100% sure, but I am guessing that the reason for bad performance results is the high number of promise methods that turns-off \"class optimizations\" (like \"hidden classes\").\n. Actually, I am talking about methods that **are** in prototype. Not that I am aware that prototype size could influence constructor performances, but that actually have sense...\n. Can I ask what are the reasons for \"heating\" `deferred.fulfill`? Normalli I am for reducing API-s, but this one seams useful with no additional implementational costs..\n. Please see my [comment](https://github.com/kriskowal/q/pull/195#issuecomment-13452061) with included test, that \"explains\" the motivation for #195.\n. Yea, but it's _additional_ delay in case of thrown exceptions, not total. I fixed the description.\n. Even if in theory it should give better performances, it is probably good to have some tests before merging.\nCould do some tests in next days.\n\nProbably the only downside of this solution is that, in cases of serious computations, exceptions can show up with significant delay. Also, in some situations (error monitoring?), it could be importation to have exceptions in sync...\n. I don't think the order of reported exceptions would be altered. However, imagine debugging some code that is stuck in a recursion that prevents a real tick to end. In that case, no errors will show up, even if there are.\n\nEdited for clarity.\n. The simplicity of this solution is attractive indeed. However, because of already mentioned issues that it would enable during debugging, it is a no-go, in my opinion. I'm trying to come with a variation that would resolve those issues, but it seems impossible to do that without introducing significant complexity.\nAre you ok with closing this for now?\n. Is perhaps `model` a thenable? Have you tried to replace `deferred.resolve` with `deferred.fulfill`?\n. A resolved value is a resolved value, and it should be propagated as such. Returned values form callbacks, in other hand, should be recursively resolved. Otherwise Q is broken if resolved value is also a thenable.\n. Ok, I will use the _fulfilled_ word then...\nNo, in this way Q does not support thenable fulfilled values regardless if its `then` works properly or not.\n. >  it's impossible for a thenable to have a legitimate fulfillment value that is a thenable\n\nWhy not?! Why you are not willing to distinguish already fulfilled/rejected values from returned values/promises from callbacks?\n. The distinction that I am talking about doesn't go against Promise/A+.\nCheck my \"experiment\" lib that makes such distinction: https://github.com/rkatic/p\n. I am not buying this. Also I have not time to read all your discussions about. If you can point me out the reason of such drastic decision, I will be grateful. \n. Thanks for your effort @domenic. I am a lazy bastard. However, I still don't see why your arguments should be sound. When the `onFulfilled(value)` is called, `value` should be considered fulfilled, even if thenable. The intention is clear here to me.\n. > And my argument is that value should never be a thenable.\n\nWell, then my question is what is your argument for your argument :)\n. I guess I am really missing something, because for now, I only see circular reasoning here. I hope a sleep will help.\n. You lost me on [1] :) Too meta for you? Not to me, for now at least.\nThe #205 I hoped was for `Q.fulfill`, but not for `deferred.fulfill` too.\n[3] is correct iff you **always** have to distinguish between promises and fufilled values.\nBut again, I guess I am the one missing something, so will not expect other explanations for now.\n. Now that I had my needed dose of rest, I have mixed feelings about this.\n\nI can agree that not allowing thenable fufilled values makes the usage more \"natural\" in some cases, eliminating a subtle but sometimes important distinction to the user - user don't have to bother to return `Q.fulfill(value)` instead of simply returning the value, even when the nature of the value is unclear.\n\nHowever, as mentioned by @kriskowal, it can be an too strong assumption that other promise implementations will never have thenable fulfilled values. Also, I am not sure that we can even consider this an edge case.\nImagine an ajax function that returns a thenable xhr. Since the xhr object stores various results on itself, it is also a logical candidate for the fulfilled value too. In fact, having promises that fulfills with itself could be considered a handy (anti)pattern (note that in such cases it is not that important to have a `Q.fulfill`).\nHowever, I could be wrong here too, since I am relatively new on using promises in general. \n. Per discussion at #205, I suppose this one can be closed.\n. Actually, since #205 is rejected, and acknowledging that fulfilled values can be thenables, this issue seams more relevant then before.\nI also added a test for `timeout` that shows how such values are currently not propagated, but resolved, removing the effect of eventual `return Q.fulfill(fakeThenable)`.\nI renamed this issue to better describe both problems.\n. @domenic Both tests that I added do not currently pass. Not completely sure what you mean with \"not a cyclic promise chain\", but the second added test should not be one of those.\n. Are you ok with removing changes regarding coercing? Would it make this pull-request more acceptable?\n. Because of the recursive assimilation algorithm in Promises/A+ 1.1, preventing resolution to stuck in every situations is not simple, if not impossible (depends on how badly the thenable `then` behave). I think that only thenables fulfilled with itself should be eventually supported. Anything more would require an array to detect cycles (ignoring cases of very bad `then`s), and/or stopping assimilation on a fixed \"max-assimilation-recursion\".\n. Are you fine with `Q.isPromise(Q.nonPromise(5)) === true`?\n. @domenic That's not how functions are normally named.\n. What about `Q.settled`? But, what about `Q.reject` then? What about `Q.fulfill(ed)With` and `Q.reject(ed)With`? They are something more \"verbose\", and even more clearer on intent.\n. @keithamus I didn't test it, but what you are looking for is probably something like:\n\n``` javascript\nQ.makePromise.prototype.and = function (promise) {\n    var self = this;\n    promise = Q.when(promise, function (value) {\n        return Q.when(self, function (values) {\n            if (!self._createdByAnd_) {\n                return [values, value];\n            }\n            values = values.slice();\n            values.push(value);\n            return values;\n        });\n     });\n     promise._createdByAnd_ = true;\n     return promise;\n};\n```\n\nHowever, I am not a fan of this, specially because on using it it can be easily unclear which promises are \"included\" in a particular \"all\" promise.\n. I wrote that in hurry and I am not sure why I used \"add\" instead of \"and\", but I certainly prefer the last one, so i fixed my code..\n. Why not using `then` instead?\n. So you don't know whether deferred will be resolved with array or single value, but it seems you are certain that a single value can not be an array. Seems you have a special agreement with the producer, that you are perfectly able to fulfill using `then`. Instead, you are asking to change `spread` to make it not spread when value is not an array. But how about array-like objects then (arguments, DOMList, ...)?\n. https://github.com/promises-aplus/promises-spec/issues/60\n. > then could be used as a generic for handling the Value a type, in a way it would call the right function to handle Just a if the value is not tagged, or Q.spread if the value is tagged.\n\nHave you considered how this would scale using `Q.all` and others?\n. Try with last version of node.js. I think they fixed a related issue lately.\n. Seems it is still unfixed (if node is to blame): https://github.com/joyent/node/issues/5108\n. Your first version can be changed to avoid the useage of `Q.all`:\n\n``` js\nrepeat = 5;\nspeeds = [];\n\nvar done = Q();\nfor (var i = 0; i < repeat; ++i) {\n    done = done.then(function (speed) {\n        if (speed !== undefined) {\n            speeds.push(speed);\n        }\n        return testspeed(url);\n    });\n}\ndone.then(function () {\n    console.log(speeds);\n});\n```\n\nYour second version is running `testspeed` in parallel.\nA promise is only a holder for a wanted value, and it doesn't have control on how or when it is fulfilled.\n. I created a [gist](https://gist.github.com/rkatic/5309285) that you may find helpful.\n. I am not sure if a long promise chain is expected to eventually exceed the\ncall stack, but functions in the gist should not cause the stack to\noverflow (no long promise chains).\n\n--Robert\nOn Apr 4, 2013 3:10 PM, \"Hans-Peter Gygax\" notifications@github.com wrote:\n\n> Thank you Robert, these look quite useful. But I do not see how they would\n> avoid the problem that I'm having ? (a problem that is not caused by Q\n> actually, but most probably by a limitation of V8)\n> -- Jean-Pierre\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/254#issuecomment-15896051\n> .\n. How about using `process.nextTick` as a tick-requester for the internal task-queue?\n. I remember that there where no significant differences in speed between `process.nextTick` alone, and `process.nextTick` with internal queue. Unfortunately, with node 0.10, even the second one is probably not safe in cases of thrown exceptions (the amortization algorithm will exponentially increase the number of tick requests).\nAlso, even if `setImmediate` should be something \"slower\" then `process.nextTick`, and using it with the internal queue would probably give better performances, it's still used as a hook-function for custom \"next-turn\" implementations.\nIn conclusion, at this moment, this fix is good as it is. When and if an alternative \"next-turn-hook\" will be exposed, it could be preferable to use `setImmediate` (and `process.nextTick`) with the internal queue.\n. Have you tested it with NodeJS 0.10 with cases of many uncaught exceptions? I am travelling and unable to test it for myself right now.\n. I still have no time for this (next week I will), but I am pretty sure that this will not work in all cases, unless #217 is applied.\n\n@ForbesLindesay I would not recommend to use a separate `next-tick` library - it would bring even more issues.\nAlso, having an own solutions, enables us to have maximum control over it, making it more performant (for instance, I have new ideas how to avoid unnecessary \"next-turns\" that I would like to experiment).\n. @ForbesLindesay In that case, I have no objections, but it should be primarily for Q, since there is probably no an always optimal solution for all promise libraries.\n. I ran locally unit tests with this change in NodeJs 0.10, and realized that even if there are not reported errors, those do not complete.\nRunning `jasmine-node --captureExceptions spec`, a \"progress\" related error message is shown. I think this confirms my strong suspicion that current queue implementation does not eliminate recursive `nextTick` calls.\nIf `process.nextTick` is really needed, then we probably have to adopt #217 first.\n. Will come back on this ASAP :) - in next 12 hours...\n\n--Robert\nOn Jun 4, 2013 5:35 AM, \"Domenic Denicola\" notifications@github.com wrote:\n\n> I do not believe that we catch exceptions before nextTick in all cases.\n> Quick scan shows nodeify in particular.\n> \n> Sure, but we could put the burden on nodeify instead of on asap(hahahahaha).\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/269#issuecomment-18887396\n> .\n. I am going to prepare a new PR in next hours, that will be based on #217 and that will maximize priority of nextTick (and console.error when existent, but not sure yet).\n\n> Let\u2019s spin off a `next-turn` or `asap`...\n\nI am not aware of a related `asap` package (not found in npm or github), so I am not able to comment it.\nIf you are pointing to my `next-turn`, it is still in experimental phase and it is not tested yet.\n\n> I do not believe that we catch exceptions before nextTick in all cases. Quick scan shows `nodeify` in particular.\n\nI would add progress listeners and any other external `Q.nextTick(fn)` usage to the list.\n\nHope to have something well tested before @domenic starts his Q-issies-triage :)\n. Ok, after searching for a good and performant solution that would adopt #217 and that would not corrupt debugging, I only came with some significant compromises - nothing ideal.\n\nAt the end, I realized that the change with this PR is actually not that bad!\nEven if in theory current queue is not immune to nextTick recursion, it should be quite safe in practice. Considering that `process.maxTickDepth == 1000`, thanks to the amortization algorithm, there can be almost 4^1000 uncaught exceptions per event loop with no problems.\n\nUnfortunately, there is still a failure with a unit test. I thought it was related to progress listeners (damn to line wrapping on the line number), but it's actually about node domains (\"should be caught by the domain\" at line 2119). This problem also persisted after applying other solutions that involved the queue. Not sure if this is a bug in NodeJS. If it is not, to keep the support for node domains, we could be forced to avoid queuing tasks entirely in NodeJS and to adopt a solution with controlled recursions (something similar to the solution in `next-turn`). \nWill investigate this further tomorrow.\nHave to go sleep now.\n. Actually, since current amortization algorithm will almost never require more ticks then the number of pending tasks, it will produce recursion much faster then I stated in my last comment. However, it is probably irrelevant, since a NodeJS process should die (soon) after first uncaught exception (?).\n\nStill not sure how to resolve the issue with node domains. Is it relevant at all? I have no experience on using them, perhaps because NodeJS is relatively new to me...\n. I will take a look on this from Monday. For now I have two main suspects: 1) a minifier that makes some wrong assumptions when queuedTasks is incremented (unlikely); 2) a problematic custom implementation of setTimeout (some multithreading issues). However, I am not familiar with Rhino and showing the respective code would certainly help.\n. If you prefer to \"outsource\", I guess I could start a \"nextTick\" project that will be based on the Q's one and will be maintained in future mainly for Q's needs. \n. I would like to suggest to also move long-stack-traces in a separate package. I am sure other libraries too would find it useful.\n\nRegarding a nextTick package, please inform me what your intentions are when you decide something, so I can start contributing on the chosen project or to start a new one.\n. I like both (already pushed in P), but I am a little uncomfortable with `allSettled` fulfilled with a fresh array, while `all` replaces values of the input array. Are there particular reasons for such inconsistency?\n. > One thing we have going for us is that no-one is likely to notice either way.\n\nI suppose you are right. I thought that the current behavior of `all` was well known. It seems I never learn how others are way less sensible on inconsistency then me... ;)\n. @kriskowal I am aware you all value consistency, and I was primarily referring to your statement that others will unlikely notice such inconsistency (that existed with `allResolved` too), which could be an argument to keep this change as it is, especially if there would be some GC issues...\n. I am not sure if changing the `all` behavior would break some users code, but its a possibility. Making `allSettled` to behave like `all` (until version 1.0 at least) seems the most safe thing to do for now.\n\nAlso, it seems @kriskowal is worried about some issues (would like to know more about that) on always fulfilling with fresh arrays.\nHowever, if fresh arrays are still wonted in most of cases, then a second optional argument could be added to `all/allSettled`.\n\n``` js\nQ.all = function (promises, results) {\n  results = results || [];\n  ...\n};\n...\nQ.allSettled = function (promises, results) {\n  ...\n  promises = array_map(promises, ...);\n  return all(promises, results || promises); // no new array here\n}\n```\n\nIn any case I think it is a good idea to explicitly mention if fresh arrays are created or not.\n. It's unclear to me too what @kriskowal intends by \"my proposal\". More then proposing a single solution, I was more putting some reasoning on some possibilities. If there is a proposal in my previous comment, then it would be something like:\n1. Make `allSettled` replace values of the input array (like `all`).\n2. Consider to fulfill with fresh arrays in Q v1.0\n   1. If \"fresh arrays\" are chosen, then consider to add a second argument to allow array reusage.\n\n> Maybe that first line is supposed to be `results = results || promises`\n\nI considered this too (\"reuse input\" as the default behavior), but at the end you can achieve something similar with `Q.all(array.slice())` without messing with alternative function signatures.\n. @kriskowal I am ok with first option too, but would probably wait with it until version 2.0 for two reasons:\n1. `all(promises)` will fulfill with a fresh array - could break users code (unlikely, but still possible)\n2. `arrayOfArray.map(Q.all)` could break, and would probably require an more complex check (`var output = opt_outputs && opt_outputs === Object(opt_outputs) ? opt_outputs : [];`).\n\n[2] can be a concern in v1.0 too, but probably not as important as in 0.9.\n. @kriskowal it sounds reasonable to me.\n. I realized that `allSettled` should not change the input array :(\n\n``` js\nvar promise1 = Q.all([1, 2, 3]);\n\nvar promise2 = Q.allSettled( promise1 );\n\nsetTimeout(function() {\n    promise1.then(function (values) {\n        alert(values[0] === 1); // values[0] is {\"fulfilled\", value: 1}, not 1!!!\n    });\n}, 10);\n```\n\nWhile `allResolved` would probably not break the original array content, \u02d9allSettled` would!\n\nIf this is right, then I suppose we have to opt for solution 1, or to push this change as it is, regardless of some inconsistency.\n. It seems to me that also `all` should fulfill with fresh array by default.\n\nConsider this example:\n\n``` js\nvar promises = Q([ Q(1), Q(2), Q(3) ]);\n\n// implicit `all` call\npromises.spread(function (one, two, three) {\n  assert( one === 1 ); // => true\n});\n\npromises.then(function (promises) {\n  assert(Q.isPromise(promises[0]); // => false (it's 1)\n});\n```\n\nNote how without the spread part, the last assert would return `true`.\n. In P I am fulfilling with fresh arrays now, and instead of adding a second argument, I am exposing \"low level\" variants:\n\n``` js\n// uses first argument only\nP.all(values) // => eventually fulfills with a fresh array\nP.allSettled(values) // => eventually fulfills with a fresh array\n\n// both arguments are required\nP.all._(inputArray, outputArray) // => eventually fulfills with outputArray\nP.allSettled._(inputArray, outputArray) // => eventually fulfills with outputArray\n```\n\nhttps://github.com/rkatic/p/blob/3a42d8ea56bcef97de6f74379a893d663af53eab/p.js#L340-L400\n. What about my three two comments?\n\nEDITED: three, not two.\n. So you two discussed this issue further? Ok then, I guess. ..\n\n--Robert\nOn May 18, 2013 7:58 PM, \"Domenic Denicola\" notifications@github.com\nwrote:\n\n> I'm happy to go whichever way @kriskowal https://github.com/kriskowalprefers.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/286#issuecomment-18105321\n> .\n. I mentioned an issue with `allSettled` changing the input array in a [comment above](https://github.com/kriskowal/q/pull/286#issuecomment-17770444) that I think is particularly important.\n. @Lacrymology note that in your example, an exception thrown by `handler`, will not be logged/thrown.\n\n``` js\npromise2 = promise\n  .then(handler)\n  .fail(logAndThrow);  // this is better\n```\n\nAlso, you probably don't want an error to be logged multiple times, so you want log/throw it **after** \"bubbling\".\n\n``` js\npromise\n  .then(handler)\n  .done(null, logAndThrow);  // this is even better\n```\n\nIf you want log/throw every \"uncaught\" rejection, then you can:\n\n``` js\nQ.onerror = logAndThrow;\n...\npromise\n  .done(handler);\n```\n. Yea, I realized that, but not immediately. I deleted the inline comment few seconds after posting it, hoping it will not show up so fast. :P\n. In regard of the ASAP package, it's probably better if it is a @kriskowal's project mainly for \"logistic\" reasons. In any case I will be happy to contribute to it.\n. @arikon Can you provide a simple use case that shows the issue?\n. Also, if you are going to test `q.umd.js`, you will have to trigger `grunt browserify` with the `pretest` script. To avoid building during development (and to forget to do that), it could be better to import a fake CommonJS implementation before importing sources.\n. There is also `Q.onerror`. Exposing options with methods would also make possible to eventually introduce some logic on enabling/disabling actions, specially useful once such options have to be propagated across other modules in future.\n. > I\u2019m going to leave this open. There is a chance that an overload like this will fall into our lap with all being overloaded for \"iterables\".\n\nIt was too much magic already (array-likes vs. maps). Now with \"iterables\" in addition, it would be too messy.\n\nSupporting \"iterables\" it becomes \"trivial\" for users to do something like:\n\n``` js\nfunction props(obj) {\n    var keys = Object.keys(obj);\n    var length = keys.length;\n    var index = 0;\n    return {\n        next: function() {\n            if (index < length) {\n                var key = keys[index++];\n                return {value: obj[key], index: key, done: false};\n            } else {\n                return {done: true};\n            }\n        }\n    };\n}\n\nQ.all(props({\n    boo: getBoo(),\n    foo: getFoo()\n}))\n.then(function(result) {\n    return result.boo + result.foo;\n});\n```\n\nEDITED: When sleepy, I am capable of huge mistakes.\n. The problem with exposing an `Q.allProperties`, regardless of how it is named, is that it would also demand a `Q.allSettledProperties`, `Q.redceProperties`, and others, which, if added would significantly inflate the API surface.\nThe `props` function, on the other hand, will work in combination with all `all/map/reduce` functions.\n\nThe only problem is that `all` always returns an array (?). However, I think that this should be considered a separate issue, since even with iterables, sometimes, it can be more useful to return something else then an array.\n. Perhaps a possible solution to the output type, is to attach it to the iterator (via the `props` function for example).\n\n``` js\nfunction props(obj, output) {\n    var keys = Object.keys(obj);\n    var length = keys.length;\n    var index = 0;\n    return {\n        output: output || obj,\n        next: function() {\n            if (index < length) {\n                var key = keys[index++];\n                return {value: obj[key], index: key, done: false};\n            } else {\n                return {done: true};\n            }\n        }\n    };\n}\n\nQ.all = function (iterable) {\n    ...\n    var output = iterable.output || [];\n    ...\n};\n```\n\nEDITED: attach output to the iterator, not to the iterations.\nEDITED 2: by default, output is now the input object\n. So, how about exposing `props` as `Q.itearateProperties` instead?\n. Why `[index, value]` instead of `{index, value}` tuples, or even better `{value, index, done}`?\n. I agree that this would probably introduce much more issues then needed.\n+1 for caution.\n. @kriskowal What happened? It's not in the `master` (any more.)\n. Looks good now. Thanks.\n. It would probably help to know which version of node.js and Q you are using.\nI could be wrong, but I suspect that those issues are easily avoidable by upgrading to node.js 0.10, or to latest Q.\n. @domenic what about using `filterStackString` to make such stack string more useful? Also \"Error\" from the first line seems inappropriate. \n\nEDITED: if it is not possible to use long stack traces here, it seems better to not generate a stack at all.\n. Regarding ASAP. Version 1.0.0 lacks of one or more fixes that where introduced in Q later. Would wait for version 1.0.1.\n. Interesting. Not able to investigate now, but I'm wondering if it's because of the missing `Array.prototype.push`. Is it defined?\n. Here a performance test: http://jsperf.com/uncurrythis\n. It is not a small fix, and English is not my first language, so will leave this one to you guys ;)\n. Not sure what you mean, but the returned promise from callbacks will be used to forward the resolution...\n. If the promise is fulfilled then the `doneCallbacks` resolves, if rejected then `failCallbacks`. But still unsure what you mean..\n\nEDIT: I see now the plural :) I suspect it is an error in theirs documentation.\n. Where you found the `deferred.then( doneCallbacks, failCallbacks )` signature?\n. Yes, I see, but it is removed in 1.8 :)\n. No problem.\n. @kriskowal Nice one. I would probably add a hard limit on accumulating free nodes (1000?). However, in my opinion, the performance gain of this listQueue over a simple array is not too relevant specially considering the amount of the additional code required.\n. @kriskowal To effectively run the code path that reuses free nodes, I made each `pushAndShift` execute twice. Also the `shift` method was not correct - http://jsperf.com/list-vs-array-queue/3 \n. @kriskowal Not exactly. Chrome uses the \"hidden classes\" optimization and reusage is not too relevant for him, but you should notice an improvement on Firefox.\n. @domenic \"hidden classes\" has nothing with JS constructors - it's an optimization technique internal to V8 to optimize property accessing and it operates on object literals in the same way.\n. @domenic In my experience, object literals performs better. Maybe they do some additional optimization with constructors, but calling constructors (like any other function) has a penalty on it's own, specially on other browsers where none of those optimizations are applied.\nHowever, I could be wrong. Try and we will see :)\n. I made some additional [tests](http://jsperf.com/qegfraerfrecregrs/2), and seems that node reusage have no benefits.\nI think we can conclude that the slowness of the current solution is caused by adding/deleting node properties.\nTherefore, I am closing this pull-req, to open another with new changes.\n. It shouldn't. I use a preventive `postMessage/setTimeout` to handle remaining tasks even if one throws.\n. @domenic I added a comment that should clarify the approach. Feel free to suggest an better one.\n. Here a performance test: http://jsperf.com/wqgrecrereffrre/3\n. To put in a better perspective, in test http://jsperf.com/wqgrecrereffrre/4 I also added the list optimization alone ([pull191](/kriskowal/q/pull/191)).\n. @domenic That one will fail on IE 6 **and 7**. It does not support `try finally` without `catch`.\n. I would like to point out that while this approach do minimize latency of \"ticks\" in case of none thrown exceptions, it also can increase latency of tasks after a thrown exception. In case we wont to be less \"optimistic\", we can preemptively request _n_ ticks, where _n <= m_ and _m_ is the number of tasks.\nWith my last updates, I adopt an \"rather-optimistic\" approach, where _n <= 2_.\nThis could be further adjusted.\n. With the last change, I think, I resolved the problem of the introduced latency on multiple thrown exceptions. :8ball:  (is this the proper use of 8ball?) \n. Ignore my last comment. Unfortunately the only way to completely eliminate the increased latency after thrown exceptions, is to make an tick request per task ( _n >= m_ ). I created a new branch with such \"pessimistic\" approach. Implementation is even simpler (https://github.com/rkatic/q/compare/more-nextTick), with no apparent drop in performances (http://jsperf.com/wqgrecrereffrre/7).\nNow, if we can expect tasks to throw exceptions only occasionally (mainly during debugging), then the current \"optimistic\" approach should be probably fine, otherwise, I don't see why we shouldn't adopt the \"pessimistic\" one.\n. After some given thoughts, I come to the conclusion that the assumption, that uncaught exceptions will be rare in production, is too dangerous. It's not hard to imagine a progress listener start throwing exceptions with high frequency, considerably delaying resolutions of many promises.\nHowever, the \"pessimistic\" approach, although with still good performances, would produce mostly wasted `postMessage/setTimeout` calls.\nTherefore, I made a change that \"amortizes\" both, tick requests, and latency after thrown exceptions.\n. @domenic The problem that a naive \"tick-reusage\" solution has, is that in cases of thrown exceptions, subsequent tick is requested **much** later and **sequentially**. This is a problem, because tasks are queued, and all subsequent tasks after thrown exceptions will wait for the newly requested tick. My solution amortizes such costs.\nTake for example this [test](http://jsperf.com/reqgfdefs/2), where on 100 tasks, every second throws. While the \"naive\" solution with the \"catch re-tick\" approach will sequentially request 50 ticks, producing an _O(t n)_ delay, the amortized solution produces an _O(t log n)_ delay.\nI hope I was clear enough, beside my bad-ish English. Please, feel free to ask for more clarifications.\n\n_t_: tick delay (~3ms on Firefox, 0-1ms on Chrome, ...)\n_n_: number of uncaught exceptions\n. I'm glad I could help, however, I would like to point out that the amortization algorithm is mostly relevant when the tick delay is significant, and that in future, if the usage of `setTimeout` will be removed, the simpler \"catch re-tick\" solution could be probably adopted.\n\nI am actually wondering if we could avoid the `setTimeout` fallback even now, and if we can not, could we at least use the `image.onerror` technique in not IE browsers.\n. Made a [test](http://jsperf.com/qgrfefwt3tr4wrw4f), and seems that this change would have no benefits in performance, so I am closing this one.\n. I am not 100% sure, but I am guessing that the reason for bad performance results is the high number of promise methods that turns-off \"class optimizations\" (like \"hidden classes\").\n. Actually, I am talking about methods that **are** in prototype. Not that I am aware that prototype size could influence constructor performances, but that actually have sense...\n. Can I ask what are the reasons for \"heating\" `deferred.fulfill`? Normalli I am for reducing API-s, but this one seams useful with no additional implementational costs..\n. Please see my [comment](https://github.com/kriskowal/q/pull/195#issuecomment-13452061) with included test, that \"explains\" the motivation for #195.\n. Yea, but it's _additional_ delay in case of thrown exceptions, not total. I fixed the description.\n. Even if in theory it should give better performances, it is probably good to have some tests before merging.\nCould do some tests in next days.\n\nProbably the only downside of this solution is that, in cases of serious computations, exceptions can show up with significant delay. Also, in some situations (error monitoring?), it could be importation to have exceptions in sync...\n. I don't think the order of reported exceptions would be altered. However, imagine debugging some code that is stuck in a recursion that prevents a real tick to end. In that case, no errors will show up, even if there are.\n\nEdited for clarity.\n. The simplicity of this solution is attractive indeed. However, because of already mentioned issues that it would enable during debugging, it is a no-go, in my opinion. I'm trying to come with a variation that would resolve those issues, but it seems impossible to do that without introducing significant complexity.\nAre you ok with closing this for now?\n. Is perhaps `model` a thenable? Have you tried to replace `deferred.resolve` with `deferred.fulfill`?\n. A resolved value is a resolved value, and it should be propagated as such. Returned values form callbacks, in other hand, should be recursively resolved. Otherwise Q is broken if resolved value is also a thenable.\n. Ok, I will use the _fulfilled_ word then...\nNo, in this way Q does not support thenable fulfilled values regardless if its `then` works properly or not.\n. >  it's impossible for a thenable to have a legitimate fulfillment value that is a thenable\n\nWhy not?! Why you are not willing to distinguish already fulfilled/rejected values from returned values/promises from callbacks?\n. The distinction that I am talking about doesn't go against Promise/A+.\nCheck my \"experiment\" lib that makes such distinction: https://github.com/rkatic/p\n. I am not buying this. Also I have not time to read all your discussions about. If you can point me out the reason of such drastic decision, I will be grateful. \n. Thanks for your effort @domenic. I am a lazy bastard. However, I still don't see why your arguments should be sound. When the `onFulfilled(value)` is called, `value` should be considered fulfilled, even if thenable. The intention is clear here to me.\n. > And my argument is that value should never be a thenable.\n\nWell, then my question is what is your argument for your argument :)\n. I guess I am really missing something, because for now, I only see circular reasoning here. I hope a sleep will help.\n. You lost me on [1] :) Too meta for you? Not to me, for now at least.\nThe #205 I hoped was for `Q.fulfill`, but not for `deferred.fulfill` too.\n[3] is correct iff you **always** have to distinguish between promises and fufilled values.\nBut again, I guess I am the one missing something, so will not expect other explanations for now.\n. Now that I had my needed dose of rest, I have mixed feelings about this.\n\nI can agree that not allowing thenable fufilled values makes the usage more \"natural\" in some cases, eliminating a subtle but sometimes important distinction to the user - user don't have to bother to return `Q.fulfill(value)` instead of simply returning the value, even when the nature of the value is unclear.\n\nHowever, as mentioned by @kriskowal, it can be an too strong assumption that other promise implementations will never have thenable fulfilled values. Also, I am not sure that we can even consider this an edge case.\nImagine an ajax function that returns a thenable xhr. Since the xhr object stores various results on itself, it is also a logical candidate for the fulfilled value too. In fact, having promises that fulfills with itself could be considered a handy (anti)pattern (note that in such cases it is not that important to have a `Q.fulfill`).\nHowever, I could be wrong here too, since I am relatively new on using promises in general. \n. Per discussion at #205, I suppose this one can be closed.\n. Actually, since #205 is rejected, and acknowledging that fulfilled values can be thenables, this issue seams more relevant then before.\nI also added a test for `timeout` that shows how such values are currently not propagated, but resolved, removing the effect of eventual `return Q.fulfill(fakeThenable)`.\nI renamed this issue to better describe both problems.\n. @domenic Both tests that I added do not currently pass. Not completely sure what you mean with \"not a cyclic promise chain\", but the second added test should not be one of those.\n. Are you ok with removing changes regarding coercing? Would it make this pull-request more acceptable?\n. Because of the recursive assimilation algorithm in Promises/A+ 1.1, preventing resolution to stuck in every situations is not simple, if not impossible (depends on how badly the thenable `then` behave). I think that only thenables fulfilled with itself should be eventually supported. Anything more would require an array to detect cycles (ignoring cases of very bad `then`s), and/or stopping assimilation on a fixed \"max-assimilation-recursion\".\n. Are you fine with `Q.isPromise(Q.nonPromise(5)) === true`?\n. @domenic That's not how functions are normally named.\n. What about `Q.settled`? But, what about `Q.reject` then? What about `Q.fulfill(ed)With` and `Q.reject(ed)With`? They are something more \"verbose\", and even more clearer on intent.\n. @keithamus I didn't test it, but what you are looking for is probably something like:\n\n``` javascript\nQ.makePromise.prototype.and = function (promise) {\n    var self = this;\n    promise = Q.when(promise, function (value) {\n        return Q.when(self, function (values) {\n            if (!self._createdByAnd_) {\n                return [values, value];\n            }\n            values = values.slice();\n            values.push(value);\n            return values;\n        });\n     });\n     promise._createdByAnd_ = true;\n     return promise;\n};\n```\n\nHowever, I am not a fan of this, specially because on using it it can be easily unclear which promises are \"included\" in a particular \"all\" promise.\n. I wrote that in hurry and I am not sure why I used \"add\" instead of \"and\", but I certainly prefer the last one, so i fixed my code..\n. Why not using `then` instead?\n. So you don't know whether deferred will be resolved with array or single value, but it seems you are certain that a single value can not be an array. Seems you have a special agreement with the producer, that you are perfectly able to fulfill using `then`. Instead, you are asking to change `spread` to make it not spread when value is not an array. But how about array-like objects then (arguments, DOMList, ...)?\n. https://github.com/promises-aplus/promises-spec/issues/60\n. > then could be used as a generic for handling the Value a type, in a way it would call the right function to handle Just a if the value is not tagged, or Q.spread if the value is tagged.\n\nHave you considered how this would scale using `Q.all` and others?\n. Try with last version of node.js. I think they fixed a related issue lately.\n. Seems it is still unfixed (if node is to blame): https://github.com/joyent/node/issues/5108\n. Your first version can be changed to avoid the useage of `Q.all`:\n\n``` js\nrepeat = 5;\nspeeds = [];\n\nvar done = Q();\nfor (var i = 0; i < repeat; ++i) {\n    done = done.then(function (speed) {\n        if (speed !== undefined) {\n            speeds.push(speed);\n        }\n        return testspeed(url);\n    });\n}\ndone.then(function () {\n    console.log(speeds);\n});\n```\n\nYour second version is running `testspeed` in parallel.\nA promise is only a holder for a wanted value, and it doesn't have control on how or when it is fulfilled.\n. I created a [gist](https://gist.github.com/rkatic/5309285) that you may find helpful.\n. I am not sure if a long promise chain is expected to eventually exceed the\ncall stack, but functions in the gist should not cause the stack to\noverflow (no long promise chains).\n\n--Robert\nOn Apr 4, 2013 3:10 PM, \"Hans-Peter Gygax\" notifications@github.com wrote:\n\n> Thank you Robert, these look quite useful. But I do not see how they would\n> avoid the problem that I'm having ? (a problem that is not caused by Q\n> actually, but most probably by a limitation of V8)\n> -- Jean-Pierre\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/254#issuecomment-15896051\n> .\n. How about using `process.nextTick` as a tick-requester for the internal task-queue?\n. I remember that there where no significant differences in speed between `process.nextTick` alone, and `process.nextTick` with internal queue. Unfortunately, with node 0.10, even the second one is probably not safe in cases of thrown exceptions (the amortization algorithm will exponentially increase the number of tick requests).\nAlso, even if `setImmediate` should be something \"slower\" then `process.nextTick`, and using it with the internal queue would probably give better performances, it's still used as a hook-function for custom \"next-turn\" implementations.\nIn conclusion, at this moment, this fix is good as it is. When and if an alternative \"next-turn-hook\" will be exposed, it could be preferable to use `setImmediate` (and `process.nextTick`) with the internal queue.\n. Have you tested it with NodeJS 0.10 with cases of many uncaught exceptions? I am travelling and unable to test it for myself right now.\n. I still have no time for this (next week I will), but I am pretty sure that this will not work in all cases, unless #217 is applied.\n\n@ForbesLindesay I would not recommend to use a separate `next-tick` library - it would bring even more issues.\nAlso, having an own solutions, enables us to have maximum control over it, making it more performant (for instance, I have new ideas how to avoid unnecessary \"next-turns\" that I would like to experiment).\n. @ForbesLindesay In that case, I have no objections, but it should be primarily for Q, since there is probably no an always optimal solution for all promise libraries.\n. I ran locally unit tests with this change in NodeJs 0.10, and realized that even if there are not reported errors, those do not complete.\nRunning `jasmine-node --captureExceptions spec`, a \"progress\" related error message is shown. I think this confirms my strong suspicion that current queue implementation does not eliminate recursive `nextTick` calls.\nIf `process.nextTick` is really needed, then we probably have to adopt #217 first.\n. Will come back on this ASAP :) - in next 12 hours...\n\n--Robert\nOn Jun 4, 2013 5:35 AM, \"Domenic Denicola\" notifications@github.com wrote:\n\n> I do not believe that we catch exceptions before nextTick in all cases.\n> Quick scan shows nodeify in particular.\n> \n> Sure, but we could put the burden on nodeify instead of on asap(hahahahaha).\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/269#issuecomment-18887396\n> .\n. I am going to prepare a new PR in next hours, that will be based on #217 and that will maximize priority of nextTick (and console.error when existent, but not sure yet).\n\n> Let\u2019s spin off a `next-turn` or `asap`...\n\nI am not aware of a related `asap` package (not found in npm or github), so I am not able to comment it.\nIf you are pointing to my `next-turn`, it is still in experimental phase and it is not tested yet.\n\n> I do not believe that we catch exceptions before nextTick in all cases. Quick scan shows `nodeify` in particular.\n\nI would add progress listeners and any other external `Q.nextTick(fn)` usage to the list.\n\nHope to have something well tested before @domenic starts his Q-issies-triage :)\n. Ok, after searching for a good and performant solution that would adopt #217 and that would not corrupt debugging, I only came with some significant compromises - nothing ideal.\n\nAt the end, I realized that the change with this PR is actually not that bad!\nEven if in theory current queue is not immune to nextTick recursion, it should be quite safe in practice. Considering that `process.maxTickDepth == 1000`, thanks to the amortization algorithm, there can be almost 4^1000 uncaught exceptions per event loop with no problems.\n\nUnfortunately, there is still a failure with a unit test. I thought it was related to progress listeners (damn to line wrapping on the line number), but it's actually about node domains (\"should be caught by the domain\" at line 2119). This problem also persisted after applying other solutions that involved the queue. Not sure if this is a bug in NodeJS. If it is not, to keep the support for node domains, we could be forced to avoid queuing tasks entirely in NodeJS and to adopt a solution with controlled recursions (something similar to the solution in `next-turn`). \nWill investigate this further tomorrow.\nHave to go sleep now.\n. Actually, since current amortization algorithm will almost never require more ticks then the number of pending tasks, it will produce recursion much faster then I stated in my last comment. However, it is probably irrelevant, since a NodeJS process should die (soon) after first uncaught exception (?).\n\nStill not sure how to resolve the issue with node domains. Is it relevant at all? I have no experience on using them, perhaps because NodeJS is relatively new to me...\n. I will take a look on this from Monday. For now I have two main suspects: 1) a minifier that makes some wrong assumptions when queuedTasks is incremented (unlikely); 2) a problematic custom implementation of setTimeout (some multithreading issues). However, I am not familiar with Rhino and showing the respective code would certainly help.\n. If you prefer to \"outsource\", I guess I could start a \"nextTick\" project that will be based on the Q's one and will be maintained in future mainly for Q's needs. \n. I would like to suggest to also move long-stack-traces in a separate package. I am sure other libraries too would find it useful.\n\nRegarding a nextTick package, please inform me what your intentions are when you decide something, so I can start contributing on the chosen project or to start a new one.\n. I like both (already pushed in P), but I am a little uncomfortable with `allSettled` fulfilled with a fresh array, while `all` replaces values of the input array. Are there particular reasons for such inconsistency?\n. > One thing we have going for us is that no-one is likely to notice either way.\n\nI suppose you are right. I thought that the current behavior of `all` was well known. It seems I never learn how others are way less sensible on inconsistency then me... ;)\n. @kriskowal I am aware you all value consistency, and I was primarily referring to your statement that others will unlikely notice such inconsistency (that existed with `allResolved` too), which could be an argument to keep this change as it is, especially if there would be some GC issues...\n. I am not sure if changing the `all` behavior would break some users code, but its a possibility. Making `allSettled` to behave like `all` (until version 1.0 at least) seems the most safe thing to do for now.\n\nAlso, it seems @kriskowal is worried about some issues (would like to know more about that) on always fulfilling with fresh arrays.\nHowever, if fresh arrays are still wonted in most of cases, then a second optional argument could be added to `all/allSettled`.\n\n``` js\nQ.all = function (promises, results) {\n  results = results || [];\n  ...\n};\n...\nQ.allSettled = function (promises, results) {\n  ...\n  promises = array_map(promises, ...);\n  return all(promises, results || promises); // no new array here\n}\n```\n\nIn any case I think it is a good idea to explicitly mention if fresh arrays are created or not.\n. It's unclear to me too what @kriskowal intends by \"my proposal\". More then proposing a single solution, I was more putting some reasoning on some possibilities. If there is a proposal in my previous comment, then it would be something like:\n1. Make `allSettled` replace values of the input array (like `all`).\n2. Consider to fulfill with fresh arrays in Q v1.0\n   1. If \"fresh arrays\" are chosen, then consider to add a second argument to allow array reusage.\n\n> Maybe that first line is supposed to be `results = results || promises`\n\nI considered this too (\"reuse input\" as the default behavior), but at the end you can achieve something similar with `Q.all(array.slice())` without messing with alternative function signatures.\n. @kriskowal I am ok with first option too, but would probably wait with it until version 2.0 for two reasons:\n1. `all(promises)` will fulfill with a fresh array - could break users code (unlikely, but still possible)\n2. `arrayOfArray.map(Q.all)` could break, and would probably require an more complex check (`var output = opt_outputs && opt_outputs === Object(opt_outputs) ? opt_outputs : [];`).\n\n[2] can be a concern in v1.0 too, but probably not as important as in 0.9.\n. @kriskowal it sounds reasonable to me.\n. I realized that `allSettled` should not change the input array :(\n\n``` js\nvar promise1 = Q.all([1, 2, 3]);\n\nvar promise2 = Q.allSettled( promise1 );\n\nsetTimeout(function() {\n    promise1.then(function (values) {\n        alert(values[0] === 1); // values[0] is {\"fulfilled\", value: 1}, not 1!!!\n    });\n}, 10);\n```\n\nWhile `allResolved` would probably not break the original array content, \u02d9allSettled` would!\n\nIf this is right, then I suppose we have to opt for solution 1, or to push this change as it is, regardless of some inconsistency.\n. It seems to me that also `all` should fulfill with fresh array by default.\n\nConsider this example:\n\n``` js\nvar promises = Q([ Q(1), Q(2), Q(3) ]);\n\n// implicit `all` call\npromises.spread(function (one, two, three) {\n  assert( one === 1 ); // => true\n});\n\npromises.then(function (promises) {\n  assert(Q.isPromise(promises[0]); // => false (it's 1)\n});\n```\n\nNote how without the spread part, the last assert would return `true`.\n. In P I am fulfilling with fresh arrays now, and instead of adding a second argument, I am exposing \"low level\" variants:\n\n``` js\n// uses first argument only\nP.all(values) // => eventually fulfills with a fresh array\nP.allSettled(values) // => eventually fulfills with a fresh array\n\n// both arguments are required\nP.all._(inputArray, outputArray) // => eventually fulfills with outputArray\nP.allSettled._(inputArray, outputArray) // => eventually fulfills with outputArray\n```\n\nhttps://github.com/rkatic/p/blob/3a42d8ea56bcef97de6f74379a893d663af53eab/p.js#L340-L400\n. What about my three two comments?\n\nEDITED: three, not two.\n. So you two discussed this issue further? Ok then, I guess. ..\n\n--Robert\nOn May 18, 2013 7:58 PM, \"Domenic Denicola\" notifications@github.com\nwrote:\n\n> I'm happy to go whichever way @kriskowal https://github.com/kriskowalprefers.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/286#issuecomment-18105321\n> .\n. I mentioned an issue with `allSettled` changing the input array in a [comment above](https://github.com/kriskowal/q/pull/286#issuecomment-17770444) that I think is particularly important.\n. @Lacrymology note that in your example, an exception thrown by `handler`, will not be logged/thrown.\n\n``` js\npromise2 = promise\n  .then(handler)\n  .fail(logAndThrow);  // this is better\n```\n\nAlso, you probably don't want an error to be logged multiple times, so you want log/throw it **after** \"bubbling\".\n\n``` js\npromise\n  .then(handler)\n  .done(null, logAndThrow);  // this is even better\n```\n\nIf you want log/throw every \"uncaught\" rejection, then you can:\n\n``` js\nQ.onerror = logAndThrow;\n...\npromise\n  .done(handler);\n```\n. Yea, I realized that, but not immediately. I deleted the inline comment few seconds after posting it, hoping it will not show up so fast. :P\n. In regard of the ASAP package, it's probably better if it is a @kriskowal's project mainly for \"logistic\" reasons. In any case I will be happy to contribute to it.\n. @arikon Can you provide a simple use case that shows the issue?\n. Also, if you are going to test `q.umd.js`, you will have to trigger `grunt browserify` with the `pretest` script. To avoid building during development (and to forget to do that), it could be better to import a fake CommonJS implementation before importing sources.\n. There is also `Q.onerror`. Exposing options with methods would also make possible to eventually introduce some logic on enabling/disabling actions, specially useful once such options have to be propagated across other modules in future.\n. > I\u2019m going to leave this open. There is a chance that an overload like this will fall into our lap with all being overloaded for \"iterables\".\n\nIt was too much magic already (array-likes vs. maps). Now with \"iterables\" in addition, it would be too messy.\n\nSupporting \"iterables\" it becomes \"trivial\" for users to do something like:\n\n``` js\nfunction props(obj) {\n    var keys = Object.keys(obj);\n    var length = keys.length;\n    var index = 0;\n    return {\n        next: function() {\n            if (index < length) {\n                var key = keys[index++];\n                return {value: obj[key], index: key, done: false};\n            } else {\n                return {done: true};\n            }\n        }\n    };\n}\n\nQ.all(props({\n    boo: getBoo(),\n    foo: getFoo()\n}))\n.then(function(result) {\n    return result.boo + result.foo;\n});\n```\n\nEDITED: When sleepy, I am capable of huge mistakes.\n. The problem with exposing an `Q.allProperties`, regardless of how it is named, is that it would also demand a `Q.allSettledProperties`, `Q.redceProperties`, and others, which, if added would significantly inflate the API surface.\nThe `props` function, on the other hand, will work in combination with all `all/map/reduce` functions.\n\nThe only problem is that `all` always returns an array (?). However, I think that this should be considered a separate issue, since even with iterables, sometimes, it can be more useful to return something else then an array.\n. Perhaps a possible solution to the output type, is to attach it to the iterator (via the `props` function for example).\n\n``` js\nfunction props(obj, output) {\n    var keys = Object.keys(obj);\n    var length = keys.length;\n    var index = 0;\n    return {\n        output: output || obj,\n        next: function() {\n            if (index < length) {\n                var key = keys[index++];\n                return {value: obj[key], index: key, done: false};\n            } else {\n                return {done: true};\n            }\n        }\n    };\n}\n\nQ.all = function (iterable) {\n    ...\n    var output = iterable.output || [];\n    ...\n};\n```\n\nEDITED: attach output to the iterator, not to the iterations.\nEDITED 2: by default, output is now the input object\n. So, how about exposing `props` as `Q.itearateProperties` instead?\n. Why `[index, value]` instead of `{index, value}` tuples, or even better `{value, index, done}`?\n. I agree that this would probably introduce much more issues then needed.\n+1 for caution.\n. @kriskowal What happened? It's not in the `master` (any more.)\n. Looks good now. Thanks.\n. It would probably help to know which version of node.js and Q you are using.\nI could be wrong, but I suspect that those issues are easily avoidable by upgrading to node.js 0.10, or to latest Q.\n. @domenic what about using `filterStackString` to make such stack string more useful? Also \"Error\" from the first line seems inappropriate. \n\nEDITED: if it is not possible to use long stack traces here, it seems better to not generate a stack at all.\n. Regarding ASAP. Version 1.0.0 lacks of one or more fixes that where introduced in Q later. Would wait for version 1.0.1.\n. Interesting. Not able to investigate now, but I'm wondering if it's because of the missing `Array.prototype.push`. Is it defined?\n. ",
    "cowwoc": "I believe the only way to mix q.js and JQuery 1.8+ is using `Q.defer()`. Am I wrong?\n\nIf this is the case, you can pretty much eliminate the Wiki page and replace it with a short note to that effect.\n. Perhaps now is a good time to compare to:\n\nhttp://thanpol.as/javascript/promises-a-performance-hits-you-should-be-aware-of/\nhttps://github.com/cujojs/promise-perf-tests#test-results\nhttps://github.com/medikoo/deferred#performance\n\nAre we seeing the same relative numbers on our end? By all accounts this makes Q look slower than the competition by over an order of magnitude (which I find surprising in light of the changes in 0.9.7, but I re-ran the first test and the results still hold).\n. Hi Domenic,\n\nThat's fair. I think it would be useful to provide a concise summary of the aforementioned problems alongside our own benchmarks. I'm hoping that will get the ball rolling towards more objective benchmarks, as one vendor corrects the other's problems.\n\nI'm glad to see that Q is instituting its own benchmark as it'll push us in the right direction. You can't improve what you can't measure, right? :)\n. My mistake. I noticed that q.js defined Array.reduce() and incorrectly assumed that you were defining a new method. I see now that this is part of the JS standard. In light of that, I agree that you don't need to add it to the API specification. Thanks for the clarification :)\n. To clarify, I read the main documentation first, saw sequences, then flipped through the API documentation and was surprised to see the method missing. So like I said, I'd be fine if you leave the documentation as-is. Your call.\n. Yes please :)\n. Holy smokes batman! :) Love it. Does this belong in the aforementioned documentation? Or somewhere else?\n. Will do. There is one outstanding question though. Looking at http://api.jquery.com/jQuery.ajax/ they declare `then()` as follows:\n\n```\njqXHR.then(function( data, textStatus, jqXHR ) {}, function( jqXHR, textStatus, errorThrown ) {});\n```\n\nDoesn't this imply that Q's `then()` will get different arguments for success and failure? Meaning, I cannot simply `then(function(xhr)` because the argument might not be xhr.\n. On second glance, I think I misunderstood. `Q()` invokes `Q.coerce()` which will invoke `jQuery.then(deferred.resolve, referred.reject, deferred.notify)`. Now, `jQuery` invokes `then(function( data, textStatus, jqXHR ) {}, function( jqXHR, textStatus, errorThrown ) {});` which means that `referred.resolve` will get `data` and `referred.reject` will get `jqXHR`.\n\nThe only time you need to store `xhr` is if you need it in the success handler. I'll edit the Wiki accordingly.\n. I've updated the wiki. Please let me know if I screwed anything up ;)\n. Very nice. Thank you!\n. The `complete()` use-case doesn't work as I expected. The goal was to pass `xhr` to `Q.then()` regardless of whether `jQuery.ajax()` succeeded or failed. As you can see, I invoked `resolve(xhr)` for both success and failure case, but the problem is that `xhr` is Promise-like, so `coerce()` gets called which invokes `xhr.then()` which results in `promise.resolve()` getting invoked on success and `promise.reject()` on failure. In other words, the cases get split up into success and failure in spite of the fact I try to unify them.\n\nIs there some way for me to tell `Q` to treat `xhr` as a value without trying to resolve it further? I know I can try removing the `then()` method (as an ugly hack) but I'm wondering if there is a better way.\n. > With upcoming promises in the language, the promise system would not coerce a value to a promise unless you use `then`\n\nHow does this differ from the current behavior? By the looks of it, this is the exact same test you do in `isPromiseAlike`.\n\n>  These promises also have a flatMap which is like then, but would do what you need if you played nicely with it.\n\nI would encourage you to push for an explicit method for this use-case instead of making users jump through hoops. Either tell users to `delete foo.then` (which sounds like a hack to me) or allow them to `resolve(Q.literal(xhr))` in which case the underlying system needs to check for literals and avoid resolving their nested values.\n\nI concede that this is an edge case, but it is similar to the need for an escape mechanism in Strings (for slashes and other reserved characters). We need to be able to pass Promises as literals or even literals of literals.\n. I forgot to mention, I'm using version 0.9.7.\n. Looks like this is caused by https://code.google.com/p/chromium/issues/detail?id=249575\n. I ended up doing something a bit fancier:\n\n```\nfunction throwUnhandledError(error)\n{\n    \"use strict\";\n    setTimeout(function()\n    {\n        var stack = printStackTrace({e: error, guess: true}).join(\"\\n\");\n        throw new Error(error.message + \"\\n\" + stack);\n    }, 0);\n}\n```\n\nwhere `printStackTrace` is defined by https://github.com/eriwen/javascript-stacktrace. Anyway, I'm closing this issue because Q.js is not at fault.\n. I think @toymachiner62 might be right. I am also seeing the wrong stacktrace with the value set to `true`. Reopening.\n. Actually sorry no. I originally closed this issue because https://code.google.com/p/chromium/issues/detail?id=249575 was causing Chrome to display the same stack-trace even if Q changed it. I don't remember if I actually checked whether Q changed the value of `stack`, but even if it had it wouldn't have made a difference (that much I did verify).\n\n@toymachiner62, what browser are you using?\n. @toymachiner62 That doesn't necessarily mean `Q` is at fault. You need to examine the value of `exception.stack` with this feature on/off. Is it the same? It could very well be that `exception.stack` is being modified but the routine rendering the exception does not re-read this value (as Chrome does).\n. @toymachiner62 When a `Promise` throws an exception, catch it and print the stacktrace as follows:\n\n```\ncatch(function(exception)\n{\n  console.log(exception.stack);\n});\n```\n\nThis value should change when `Q.longStackSupport` is enabled/disabled.\n. > It's probable that your browser or IDE is not displaying the value of exception.stack, but instead some kind of internal, hidden stack value that is not user-modifiable. Unfortunately there's nothing Q can do about modifying that one...\n\n@domenic We can do better. In https://github.com/kriskowal/q/blob/v1/q.js#L134 you can check for offending browsers (e.g. Chrome) and in such a case do the following:\n\n```\n    var message = error.message + \"\\n\" + printStackTrace(\n    {\n        e: error,\n        guess: true\n    }).join(\"\\n\");\n    console.error(message);\n```\n\nwhere `printStackTrace` is defined by https://github.com/stacktracejs/stacktrace.js. In other words, instead of relying on Chrome to print the updated stack-trace, we do it ourselves.\n\nI do this in my own code, and it works fine. Whenever Google decides to finally fix https://code.google.com/p/chromium/issues/detail?id=249575 you can remove this workaround.\n. According to http://stackoverflow.com/a/20972210/14731 we might be able to do even better. We should be able to register `onerror`, then use the `error` parameter to print the exception stack-trace using the above method. If the `error` parameter is null then return `false` to allow the default handler to kick in.\n\nIn light of this, perhaps it is best to handle this outside of `q.js` and simply add a note from the documentation to this description.\n. The code sniplet I pasted was incomplete. Something _does_ catch the error after logging `0.1` but more to the point, note that Q logs the warning **before** the handler for `0.1` is invoked. That by itself indicates a bug.\n. @kriskowal \n\nI assume there is some existing discussion about what \"consoles failing to update\" means? If so, please send us a link to read.\n\nThe feature itself is great, so if you can make it work then please do. As for Ember/Montage, it sounds like they require a lot more heavy lifting to integrate into our projects than q.js. I'm not looking for a framework, just a library.\n. @kriskowal Just a thought, but couldn't you do the following instead?\n1. Q registers a default failure handler which prints out this warning.\n2. Error handlers registered by the users get inserted before Q's handler.\n\nThis way, you don't need to update consoles. The warning message is only ever printed out if there is a problem.\n. Are there any known open bug reports against Chrome and other browsers for these issues?\n\nPS: I agree with the author of http://www.bennadel.com/blog/2408-Chrome-Dev-Tools-Live-Update-In-The-JavaScript-Console-Is-Confusing.htm ... It's not clear that \"Live Update\" is all that great for console output. It sounds to me like we need some event to be fired before an object is garbage collected or something so we can check its state then and append to the log if needed. The whole idea of \"updating\" a log seems wrong to me as well.\n. And according to http://stackoverflow.com/a/8249333/14731 this functionality was removed.\n\nKris, are you referring to this same Chrome feature or are we talking about something else?\n. I would suggest disabling the feature by default (in v1 and v2) while you experiment with making it more reliable. Users who are interested could enable the relevant flag.\n. @kriskowal Just to make sure I understood correctly:\n1. I want to invoke some code in a form's \"submit\" event handler and that event handler requires me to return a boolean synchronously.\n2. However, the method that I need to invoke returns a Promise (it doesn't expose a synchronous equivalent).\n3. You're saying it is technically impossible to make this work in Q 1.0 but that in Q 2.0 I will be able to somehow yield to Q's event loop inside the form event handler, and return synchronously from its event handler as I am asking?\n. @HarryPehkonen \n\nOriginally I was thinking of something like http://jsfiddle.net/clickthelink/Uwcuz/1/\n\nI was thinking that you needed to wait for the `$.ajax()` call to complete before returning from the submit event handler (otherwise the user could mess up the form in mid-transmission). But, upon further consideration:\n1. If you're firing an AJAX request, the event handler should always return false.\n2. You don't need to actually \"block\" the submit handler until the AJAX call completes. You could disable the form elements, return false from the handler, process the AJAX call asynchronously, and restore the form elements when the operation completes.\n\nIn short, I think @kriskowal was right: we don't need this functionality for this particular use-case.\n. I believe the only way to mix q.js and JQuery 1.8+ is using `Q.defer()`. Am I wrong?\n\nIf this is the case, you can pretty much eliminate the Wiki page and replace it with a short note to that effect.\n. Perhaps now is a good time to compare to:\n\nhttp://thanpol.as/javascript/promises-a-performance-hits-you-should-be-aware-of/\nhttps://github.com/cujojs/promise-perf-tests#test-results\nhttps://github.com/medikoo/deferred#performance\n\nAre we seeing the same relative numbers on our end? By all accounts this makes Q look slower than the competition by over an order of magnitude (which I find surprising in light of the changes in 0.9.7, but I re-ran the first test and the results still hold).\n. Hi Domenic,\n\nThat's fair. I think it would be useful to provide a concise summary of the aforementioned problems alongside our own benchmarks. I'm hoping that will get the ball rolling towards more objective benchmarks, as one vendor corrects the other's problems.\n\nI'm glad to see that Q is instituting its own benchmark as it'll push us in the right direction. You can't improve what you can't measure, right? :)\n. My mistake. I noticed that q.js defined Array.reduce() and incorrectly assumed that you were defining a new method. I see now that this is part of the JS standard. In light of that, I agree that you don't need to add it to the API specification. Thanks for the clarification :)\n. To clarify, I read the main documentation first, saw sequences, then flipped through the API documentation and was surprised to see the method missing. So like I said, I'd be fine if you leave the documentation as-is. Your call.\n. Yes please :)\n. Holy smokes batman! :) Love it. Does this belong in the aforementioned documentation? Or somewhere else?\n. Will do. There is one outstanding question though. Looking at http://api.jquery.com/jQuery.ajax/ they declare `then()` as follows:\n\n```\njqXHR.then(function( data, textStatus, jqXHR ) {}, function( jqXHR, textStatus, errorThrown ) {});\n```\n\nDoesn't this imply that Q's `then()` will get different arguments for success and failure? Meaning, I cannot simply `then(function(xhr)` because the argument might not be xhr.\n. On second glance, I think I misunderstood. `Q()` invokes `Q.coerce()` which will invoke `jQuery.then(deferred.resolve, referred.reject, deferred.notify)`. Now, `jQuery` invokes `then(function( data, textStatus, jqXHR ) {}, function( jqXHR, textStatus, errorThrown ) {});` which means that `referred.resolve` will get `data` and `referred.reject` will get `jqXHR`.\n\nThe only time you need to store `xhr` is if you need it in the success handler. I'll edit the Wiki accordingly.\n. I've updated the wiki. Please let me know if I screwed anything up ;)\n. Very nice. Thank you!\n. The `complete()` use-case doesn't work as I expected. The goal was to pass `xhr` to `Q.then()` regardless of whether `jQuery.ajax()` succeeded or failed. As you can see, I invoked `resolve(xhr)` for both success and failure case, but the problem is that `xhr` is Promise-like, so `coerce()` gets called which invokes `xhr.then()` which results in `promise.resolve()` getting invoked on success and `promise.reject()` on failure. In other words, the cases get split up into success and failure in spite of the fact I try to unify them.\n\nIs there some way for me to tell `Q` to treat `xhr` as a value without trying to resolve it further? I know I can try removing the `then()` method (as an ugly hack) but I'm wondering if there is a better way.\n. > With upcoming promises in the language, the promise system would not coerce a value to a promise unless you use `then`\n\nHow does this differ from the current behavior? By the looks of it, this is the exact same test you do in `isPromiseAlike`.\n\n>  These promises also have a flatMap which is like then, but would do what you need if you played nicely with it.\n\nI would encourage you to push for an explicit method for this use-case instead of making users jump through hoops. Either tell users to `delete foo.then` (which sounds like a hack to me) or allow them to `resolve(Q.literal(xhr))` in which case the underlying system needs to check for literals and avoid resolving their nested values.\n\nI concede that this is an edge case, but it is similar to the need for an escape mechanism in Strings (for slashes and other reserved characters). We need to be able to pass Promises as literals or even literals of literals.\n. I forgot to mention, I'm using version 0.9.7.\n. Looks like this is caused by https://code.google.com/p/chromium/issues/detail?id=249575\n. I ended up doing something a bit fancier:\n\n```\nfunction throwUnhandledError(error)\n{\n    \"use strict\";\n    setTimeout(function()\n    {\n        var stack = printStackTrace({e: error, guess: true}).join(\"\\n\");\n        throw new Error(error.message + \"\\n\" + stack);\n    }, 0);\n}\n```\n\nwhere `printStackTrace` is defined by https://github.com/eriwen/javascript-stacktrace. Anyway, I'm closing this issue because Q.js is not at fault.\n. I think @toymachiner62 might be right. I am also seeing the wrong stacktrace with the value set to `true`. Reopening.\n. Actually sorry no. I originally closed this issue because https://code.google.com/p/chromium/issues/detail?id=249575 was causing Chrome to display the same stack-trace even if Q changed it. I don't remember if I actually checked whether Q changed the value of `stack`, but even if it had it wouldn't have made a difference (that much I did verify).\n\n@toymachiner62, what browser are you using?\n. @toymachiner62 That doesn't necessarily mean `Q` is at fault. You need to examine the value of `exception.stack` with this feature on/off. Is it the same? It could very well be that `exception.stack` is being modified but the routine rendering the exception does not re-read this value (as Chrome does).\n. @toymachiner62 When a `Promise` throws an exception, catch it and print the stacktrace as follows:\n\n```\ncatch(function(exception)\n{\n  console.log(exception.stack);\n});\n```\n\nThis value should change when `Q.longStackSupport` is enabled/disabled.\n. > It's probable that your browser or IDE is not displaying the value of exception.stack, but instead some kind of internal, hidden stack value that is not user-modifiable. Unfortunately there's nothing Q can do about modifying that one...\n\n@domenic We can do better. In https://github.com/kriskowal/q/blob/v1/q.js#L134 you can check for offending browsers (e.g. Chrome) and in such a case do the following:\n\n```\n    var message = error.message + \"\\n\" + printStackTrace(\n    {\n        e: error,\n        guess: true\n    }).join(\"\\n\");\n    console.error(message);\n```\n\nwhere `printStackTrace` is defined by https://github.com/stacktracejs/stacktrace.js. In other words, instead of relying on Chrome to print the updated stack-trace, we do it ourselves.\n\nI do this in my own code, and it works fine. Whenever Google decides to finally fix https://code.google.com/p/chromium/issues/detail?id=249575 you can remove this workaround.\n. According to http://stackoverflow.com/a/20972210/14731 we might be able to do even better. We should be able to register `onerror`, then use the `error` parameter to print the exception stack-trace using the above method. If the `error` parameter is null then return `false` to allow the default handler to kick in.\n\nIn light of this, perhaps it is best to handle this outside of `q.js` and simply add a note from the documentation to this description.\n. The code sniplet I pasted was incomplete. Something _does_ catch the error after logging `0.1` but more to the point, note that Q logs the warning **before** the handler for `0.1` is invoked. That by itself indicates a bug.\n. @kriskowal \n\nI assume there is some existing discussion about what \"consoles failing to update\" means? If so, please send us a link to read.\n\nThe feature itself is great, so if you can make it work then please do. As for Ember/Montage, it sounds like they require a lot more heavy lifting to integrate into our projects than q.js. I'm not looking for a framework, just a library.\n. @kriskowal Just a thought, but couldn't you do the following instead?\n1. Q registers a default failure handler which prints out this warning.\n2. Error handlers registered by the users get inserted before Q's handler.\n\nThis way, you don't need to update consoles. The warning message is only ever printed out if there is a problem.\n. Are there any known open bug reports against Chrome and other browsers for these issues?\n\nPS: I agree with the author of http://www.bennadel.com/blog/2408-Chrome-Dev-Tools-Live-Update-In-The-JavaScript-Console-Is-Confusing.htm ... It's not clear that \"Live Update\" is all that great for console output. It sounds to me like we need some event to be fired before an object is garbage collected or something so we can check its state then and append to the log if needed. The whole idea of \"updating\" a log seems wrong to me as well.\n. And according to http://stackoverflow.com/a/8249333/14731 this functionality was removed.\n\nKris, are you referring to this same Chrome feature or are we talking about something else?\n. I would suggest disabling the feature by default (in v1 and v2) while you experiment with making it more reliable. Users who are interested could enable the relevant flag.\n. @kriskowal Just to make sure I understood correctly:\n1. I want to invoke some code in a form's \"submit\" event handler and that event handler requires me to return a boolean synchronously.\n2. However, the method that I need to invoke returns a Promise (it doesn't expose a synchronous equivalent).\n3. You're saying it is technically impossible to make this work in Q 1.0 but that in Q 2.0 I will be able to somehow yield to Q's event loop inside the form event handler, and return synchronously from its event handler as I am asking?\n. @HarryPehkonen \n\nOriginally I was thinking of something like http://jsfiddle.net/clickthelink/Uwcuz/1/\n\nI was thinking that you needed to wait for the `$.ajax()` call to complete before returning from the submit event handler (otherwise the user could mess up the form in mid-transmission). But, upon further consideration:\n1. If you're firing an AJAX request, the event handler should always return false.\n2. You don't need to actually \"block\" the submit handler until the AJAX call completes. You could disable the form elements, return false from the handler, process the AJAX call asynchronously, and restore the form elements when the operation completes.\n\nIn short, I think @kriskowal was right: we don't need this functionality for this particular use-case.\n. ",
    "iamwilhelm": "I'ved edited the sample above and converted it from coffeescript to javascript.\n. Ahh, I see. I hadn't seen an example or something noting that progress MUST come before then(). It makes sense with the explanation above. I think progress in promises make sense. It's just that all the examples and documentation concentrates on then() and fail() error handling, where fail can be followed by then. In addition, the order of the arguments in then(onSuccess, onError, onProgress) implied that I could tack on an onProgress at the end of a then.\n\nI'm not sure you can change the method signature without breaking everyone code, but I can edit the documentation to make this nuance a lot clearer, if you'd like.\n. @kriskowal That's fine. I think as long as the documentation is clear about using the syntax sugar, progress() before then(), it's all good.\n. @kriskowal /me nods\n\n@domenic Ack. Thanks for the clarification. I looked at your sample code much closer, and I get what you're saying now (Correct me if I'm wrong). The notifications are getting fired before the progress handler's getting attached. So if each iteration is too quick, the notification gets fired before progress() has a chance to attach and report.\n\nIs there a way to guarantee that all handlers are attached before I start executing the work inside the function squares()?\n. Should I also call `Q.nextTick(deferred.notify)` also? And if I use nextTick(), it doesn't seem like there's a way to control what arguments get passed to it. How would I control what the resolved value is if I use nextTick()? (Sorry for all the questions. Promise to submit it back as documentation)\n. @ForbesLindesay Thanks.\n\nRight. It's two issues:\n\n1) if you fire `deferred.notify()` before the `progress` callback is attached, you won't see the `progress` callback execute\n2) if you fire `deferred.resolve()` before all the notifications are able to fire, even if `progress` callback is attached, you won't see the `progress` callback execute.\n\nWhy is nextTick() not called inside of `resolve` and `notify`?\n. I'ved edited the sample above and converted it from coffeescript to javascript.\n. Ahh, I see. I hadn't seen an example or something noting that progress MUST come before then(). It makes sense with the explanation above. I think progress in promises make sense. It's just that all the examples and documentation concentrates on then() and fail() error handling, where fail can be followed by then. In addition, the order of the arguments in then(onSuccess, onError, onProgress) implied that I could tack on an onProgress at the end of a then.\n\nI'm not sure you can change the method signature without breaking everyone code, but I can edit the documentation to make this nuance a lot clearer, if you'd like.\n. @kriskowal That's fine. I think as long as the documentation is clear about using the syntax sugar, progress() before then(), it's all good.\n. @kriskowal /me nods\n\n@domenic Ack. Thanks for the clarification. I looked at your sample code much closer, and I get what you're saying now (Correct me if I'm wrong). The notifications are getting fired before the progress handler's getting attached. So if each iteration is too quick, the notification gets fired before progress() has a chance to attach and report.\n\nIs there a way to guarantee that all handlers are attached before I start executing the work inside the function squares()?\n. Should I also call `Q.nextTick(deferred.notify)` also? And if I use nextTick(), it doesn't seem like there's a way to control what arguments get passed to it. How would I control what the resolved value is if I use nextTick()? (Sorry for all the questions. Promise to submit it back as documentation)\n. @ForbesLindesay Thanks.\n\nRight. It's two issues:\n\n1) if you fire `deferred.notify()` before the `progress` callback is attached, you won't see the `progress` callback execute\n2) if you fire `deferred.resolve()` before all the notifications are able to fire, even if `progress` callback is attached, you won't see the `progress` callback execute.\n\nWhy is nextTick() not called inside of `resolve` and `notify`?\n. ",
    "francoisfrisch": "Thanks @rkatic !\n. speed seems on par with #195 in this test http://jsperf.com/q-retick\n. I think returning is misleading in this case. You want `nodeback #1` to be guaranteed to be called before `#2` but what has in fact happened is that the chain has been forked since it uses `nextTick` to call the `nodeback`.\nThe return is the promise that the `nodeback` has been scheduled not that it has been executed.\n I believe., the fact that one is happening before the other is an implementation detail of nextTick.\n. @ThomasBurleson Are just trying to save yourself having to write the following?\n\n``` javascript\nmongoQuery.execute( db, collectionName).then(callback )\n```\n. Thanks @rkatic !\n. speed seems on par with #195 in this test http://jsperf.com/q-retick\n. I think returning is misleading in this case. You want `nodeback #1` to be guaranteed to be called before `#2` but what has in fact happened is that the chain has been forked since it uses `nextTick` to call the `nodeback`.\nThe return is the promise that the `nodeback` has been scheduled not that it has been executed.\n I believe., the fact that one is happening before the other is an implementation detail of nextTick.\n. @ThomasBurleson Are just trying to save yourself having to write the following?\n\n``` javascript\nmongoQuery.execute( db, collectionName).then(callback )\n```\n. ",
    "tebriel": "Could you give me an example of tests that are now broken in the migration from 1.0.28 to 1.1.0? It was my intention to keep backwards compatibility. I can have these things fixed by the end of the week. The reference error in 1.2.0 is fixed and 1.2.1 is now published in NPM. I'm forking q and will set up a travis-ci to mirror what you're doing.\n\n1.2.1 seems to pass all your tests for Node 0.8: https://travis-ci.org/tebriel/q\n1.2.1 seems to pass all your tests for Node 0.6, with the exception of a list of...exceptions due to promises.\n\nI do see these, so I don't know if that's a jasmine-node issue or not.\n\n```\n493Unhandled rejected promise (no stack): {}\n494Unhandled rejected promise (no stack): {}\n495Unhandled rejected promise (no stack): {}\n496Unhandled rejected promise (no stack): {}\n497Unhandled rejected promise (no stack): {}\n498Unhandled rejected promise (no stack): {}\n499Unhandled rejected promise (no stack): {}\n500Unhandled rejected promise (no stack): {}\n501Unhandled rejected promise (no stack): {}\n502Unhandled rejected promise (no stack): {}\n503Unhandled rejected promise (no stack): {}\n504Unhandled rejected promise (no stack): {}\n505Unhandled rejected promise (no stack): {}\n```\n. Oop, hold that thought, my apologies. I forgot to update the package.json. Re-pushing, I'll see what travis says in a second.\n. Okay, yeah, fixed the ref, domains are still broken. Looking into it now.\n. Found the [issue](https://github.com/mhevery/jasmine-node/commit/6bf80d4752e5017be711f64fc3d2fb07e98b645b)\n\nReverted this change, it's now a command line flag, as this broke current functionality.\nYou can see the passing Q tests for Node 0.8 [here](https://travis-ci.org/tebriel/q/jobs/4572424)\n\njasmine-node 1.2.2 is now on NPM and addresses both of the issues.\n. @domenic Glad to get that back up and running. I just took over development on jasmine-node. Sorry for the pain. My intention to never be backwards incompatible, if possible. If there's some things you guys would like/ideas you have to make what you're doing easier please drop an issue on the project. Thanks.\n. Could you give me an example of tests that are now broken in the migration from 1.0.28 to 1.1.0? It was my intention to keep backwards compatibility. I can have these things fixed by the end of the week. The reference error in 1.2.0 is fixed and 1.2.1 is now published in NPM. I'm forking q and will set up a travis-ci to mirror what you're doing.\n\n1.2.1 seems to pass all your tests for Node 0.8: https://travis-ci.org/tebriel/q\n1.2.1 seems to pass all your tests for Node 0.6, with the exception of a list of...exceptions due to promises.\n\nI do see these, so I don't know if that's a jasmine-node issue or not.\n\n```\n493Unhandled rejected promise (no stack): {}\n494Unhandled rejected promise (no stack): {}\n495Unhandled rejected promise (no stack): {}\n496Unhandled rejected promise (no stack): {}\n497Unhandled rejected promise (no stack): {}\n498Unhandled rejected promise (no stack): {}\n499Unhandled rejected promise (no stack): {}\n500Unhandled rejected promise (no stack): {}\n501Unhandled rejected promise (no stack): {}\n502Unhandled rejected promise (no stack): {}\n503Unhandled rejected promise (no stack): {}\n504Unhandled rejected promise (no stack): {}\n505Unhandled rejected promise (no stack): {}\n```\n. Oop, hold that thought, my apologies. I forgot to update the package.json. Re-pushing, I'll see what travis says in a second.\n. Okay, yeah, fixed the ref, domains are still broken. Looking into it now.\n. Found the [issue](https://github.com/mhevery/jasmine-node/commit/6bf80d4752e5017be711f64fc3d2fb07e98b645b)\n\nReverted this change, it's now a command line flag, as this broke current functionality.\nYou can see the passing Q tests for Node 0.8 [here](https://travis-ci.org/tebriel/q/jobs/4572424)\n\njasmine-node 1.2.2 is now on NPM and addresses both of the issues.\n. @domenic Glad to get that back up and running. I just took over development on jasmine-node. Sorry for the pain. My intention to never be backwards incompatible, if possible. If there's some things you guys would like/ideas you have to make what you're doing easier please drop an issue on the project. Thanks.\n. ",
    "pudgeball": "From looking through the commits this has not been worked on.  I'm wondering if this is something that will make it into any version of Q?  I had a couple situations in my code where this was an issue that I worked around in the cleanest way that I could, but it's definitely not my ideal.\n. @kriskowal Sorry, I re-read the ticket and I realized that this isn't what I thought it was.  Sorry about that and my delayed response.\n. From looking through the commits this has not been worked on.  I'm wondering if this is something that will make it into any version of Q?  I had a couple situations in my code where this was an issue that I worked around in the cleanest way that I could, but it's definitely not my ideal.\n. @kriskowal Sorry, I re-read the ticket and I realized that this isn't what I thought it was.  Sorry about that and my delayed response.\n. ",
    "jamielinux": "Awesome, thanks very much! :)\n. Awesome, thanks very much! :)\n. ",
    "jokeyrhyme": "@domenic actually, (from your example) nbind looks more like JavaScript's Function.prototype.call (or apply). That makes it slightly more consistent with the language itself. Obviously, I'm happy with whatever works. :)\n\nI've read somewhere that you guys were working on new names for the Node functions to make them more verbose. Should you be aiming for consistency here? Or would this be an opportunity to release something with the new naming scheme?\n. You mention that the minified version becomes out of sync sometimes in #250 .\n\nThere's brief discussion of a build system in #280 which might help avoid this in future.\n\nIf you're interested, I could knock together a Pull Request implementing a move to GruntJS with for builds and tests...\n. @domenic actually, (from your example) nbind looks more like JavaScript's Function.prototype.call (or apply). That makes it slightly more consistent with the language itself. Obviously, I'm happy with whatever works. :)\n\nI've read somewhere that you guys were working on new names for the Node functions to make them more verbose. Should you be aiming for consistency here? Or would this be an opportunity to release something with the new naming scheme?\n. You mention that the minified version becomes out of sync sometimes in #250 .\n\nThere's brief discussion of a build system in #280 which might help avoid this in future.\n\nIf you're interested, I could knock together a Pull Request implementing a move to GruntJS with for builds and tests...\n. ",
    "ryanramage": "Looking the q package.json this pull request is unnecessary for jam. Jam already uses the main, and dependencies from the root of package.json. @lyxsus did you try publishing to jam without a jam section?\n. Looking the q package.json this pull request is unnecessary for jam. Jam already uses the main, and dependencies from the root of package.json. @lyxsus did you try publishing to jam without a jam section?\n. ",
    "vitalets": "thanks a lot! Now I get it.\nmaybe add it to docs, as by examples for  `nfcall/ninvoke` they looked nearly identical for me as newbie of q \n\n```\nreturn Q.nfcall(FS.readFile, \"foo.txt\", \"utf-8\");\nreturn Q.ninvoke(FS, \"readFile\", \"foo.txt\", \"utf-8\");\n```\n. thanks a lot! Now I get it.\nmaybe add it to docs, as by examples for  `nfcall/ninvoke` they looked nearly identical for me as newbie of q \n\n```\nreturn Q.nfcall(FS.readFile, \"foo.txt\", \"utf-8\");\nreturn Q.ninvoke(FS, \"readFile\", \"foo.txt\", \"utf-8\");\n```\n. ",
    "Skalman": "Alright. I find the documentation quite confusing. I'll see if I can explain how to use it also in the non-static form.\n. I was trying to do something like this (pseudo-code):\n\n``` javascript\nwhen f1\nthen f2 f3 // simultaneously\nthen f4 // when both f2 and f3 have been resolved\n```\n\nI was assuming that `all` would be used for `f2` and `f3`, but apparently I was wrong. What's the shortest way to do the above?\n. Ok, thanks. To me it felt natural to use `all` directly. :-)\n. Alright. I find the documentation quite confusing. I'll see if I can explain how to use it also in the non-static form.\n. I was trying to do something like this (pseudo-code):\n\n``` javascript\nwhen f1\nthen f2 f3 // simultaneously\nthen f4 // when both f2 and f3 have been resolved\n```\n\nI was assuming that `all` would be used for `f2` and `f3`, but apparently I was wrong. What's the shortest way to do the above?\n. Ok, thanks. To me it felt natural to use `all` directly. :-)\n. ",
    "Weblors": "Why was this closed when this was never resolved?\n. Why was this closed when this was never resolved?\n. ",
    "erights": "Domenic & Kris,\n\nPlease help me fill in\nhttp://wiki.ecmascript.org/doku.php?id=strawman:promises\n\nOn Mon, Jun 3, 2013 at 8:45 PM, Domenic Denicola\nnotifications@github.comwrote:\n\n> Note that Future.when seems to have gone away, replaced by Future.every,\n> so that reason is no longer there.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/215#issuecomment-18887606\n> .\n\n## \n\nText by me above is hereby placed in the public domain\n\n  Cheers,\n  --MarkM\n. Leaner, yes!\n. It looks like we'll be settling on a variant of AP2 (see http://wiki.ecmascript.org/lib/exe/fetch.php?id=strawman%3Apromises&media=strawman:promisesvsmonads2.pdf ). But don't change Q or Promises/A+ yet. This should all be decided at the end-of-July TC39 meeting.\n\nWhen we have a decent draft of this AP2 variant, I'll post a pointer here and on Promises/A+ and invite comments.\n. @kriskowal yup, thanks!\n\nSee https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/debug.js for something similar for synchronous stack traces.\n. Hi @domenic, the array_reduce thing seems too heavy for something this simple, so I just converted to a for(;;) loop. \n. I'll try. But I make no, uh, promises about when I'll get to it. If I\nhaven't after a reasonable time, please don't block on me.\n\nOn Wed, May 8, 2013 at 1:15 PM, Kris Kowal notifications@github.com wrote:\n\n> I actually am wondering whether I might beg a code review from @erightshttps://github.com/erights.\n> Is this consistent with the direction of the language? Is this mature?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/288#issuecomment-17630900\n> .\n\n## \n\nText by me above is hereby placed in the public domain\n\n  Cheers,\n  --MarkM\n. +1\n. At the .then-level, which is the level Q and Promises/A+ operate at (in contrast to the lower .flatMap-level of the full AP2 proposal on es-discuss), we still don't need to distinguish AP2's adoption from acceptance, so I would avoid the term \"accepted\". Rather, if promise p is resolved to promise q, then p follows q. The question is, how to describe the state where p is resolved to a non-promise v, where we don't yet even know whether v will be considered thenable. In this case, at the AP2 .flatMap-level p can only accept v, since only promises can be adopted. Nevertheless, at our .then-level, I think the right concept to extend is \"following\" as in p follows v. So a promise can follow anything. But once p.then happens, in a later turn we further resolve p according to v's state and behavior.\n\nAs Domenic says, as long as v might be a thenable, \"fulfilled\" and \"rejected\" are no longer concrete states, but rather expository states to explain how p's behavior depends on v's.\n\nRegarding the Q-specific inspection methods, I doubt there is any perfect way to maintain compatibility with their old behavior. So let's start by asking: What are these used for? \n. What would happen if we withdrew all of these for a while and then added them, or something like them, back in as we encounter concrete use cases that need them?\n. This question clarified something for me regarding thenables and memoization. With apologies to Albert, I propose that \"Thenables should be assimilated as late as possible, but no later.\" Once p.then(v => .., e =>..) fires, from then on it remains fulfilled or rejected to whatever it provided as the callback argument. In particular, if v later becomes a thenable, this will not affect the behavior of p itself. A later p.then will still report p as fulfilled with v itself. Or, with apologies to post-Albert, observing p's settlement (by being invoked as a callback by p.then) causes the collapse of p's assimilation function.\n. I asked my cat and she says \"well, yes and no.\"\n. We have discussed .any before. The problem is that the name suggests that it is a dual of .all, but is not. The main thing I like about .race is that the name alerts you to its semantics being racier -- more timing dependent -- than most of our other abstractions. I also think the name more clearly suggests its meaning and what to use it for.\n. > naming things, why is it so hard.\n\nBecause of malnymitis\n. See also http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.race\n. @ndkrempel writes\n\n> ... explains why yield Q.all([...]) is needed so much ...\n\nIs it? I don't know one way or the other and would appreciate any evidence. Thanks.\n\nWhat about existing languages with await, like C#? Do they have any equivalent to an await all? If not, does their manual pattern equivalent to our \"yield Q.all([...])\" appear a lot? What fraction of all await statements?\n. @ndkrempel \n\"yield Q.all([x])\" would have as its value a promise for a singleton array containing the promised value of x, which  is very different than \"yield x\". So I don't understand your shorthand suggestion.\n. What would you do with the array of resolved promises typically anyway? I would guess, pattern match it against an array pattern of variable definitions. In ES6:\n\n```\nconst [a, b, c] = yield Q.all([op1(), op2(), op3()]);\n```\n\nIf we're thinking about ES7 sugared syntax, \"await all\" still leaves the variables distant from their initializing expressions. How about\n\n```\nawait const a = op1(), b = op2(), c = op3();\n```\n\n?\n. const [v1, v2, v3] =  yield Q.all([op1(), op2(), op3()]);\n\nIsn't\n. Given the numbers, i do not like the proposed change. The implicit cast is consistent with other promise patterns. Switching behaviors on an array test isn't, and is surprising.\n. That would make it a thenable\n\nOn Thu, Dec 5, 2013 at 9:40 AM, Domenic Denicola\nnotifications@github.comwrote:\n\n> I think it should be renamed Q.then personally :)\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/446#issuecomment-29919425\n> .\n\n## \n\nText by me above is hereby placed in the public domain\n\n  Cheers,\n  --MarkM\n. Yes. My old TC39 draft proposal: http://wiki.ecmascript.org/doku.php?id=strawman:concurrency\nTyler's old Waterken Q API: http://waterken.sourceforge.net/web_send/#API\n\nAnd yes, Q is mnemonic for \"queue\" used as a verb. Most of the API queues things.\n. In looking for those, I also came across https://github.com/kriskowal/q/wiki/Coming-from-Waterken%E2%80%99s-Ref-Send which is interesting.\n. Domenic & Kris,\n\nPlease help me fill in\nhttp://wiki.ecmascript.org/doku.php?id=strawman:promises\n\nOn Mon, Jun 3, 2013 at 8:45 PM, Domenic Denicola\nnotifications@github.comwrote:\n\n> Note that Future.when seems to have gone away, replaced by Future.every,\n> so that reason is no longer there.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/215#issuecomment-18887606\n> .\n\n## \n\nText by me above is hereby placed in the public domain\n\n  Cheers,\n  --MarkM\n. Leaner, yes!\n. It looks like we'll be settling on a variant of AP2 (see http://wiki.ecmascript.org/lib/exe/fetch.php?id=strawman%3Apromises&media=strawman:promisesvsmonads2.pdf ). But don't change Q or Promises/A+ yet. This should all be decided at the end-of-July TC39 meeting.\n\nWhen we have a decent draft of this AP2 variant, I'll post a pointer here and on Promises/A+ and invite comments.\n. @kriskowal yup, thanks!\n\nSee https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/debug.js for something similar for synchronous stack traces.\n. Hi @domenic, the array_reduce thing seems too heavy for something this simple, so I just converted to a for(;;) loop. \n. I'll try. But I make no, uh, promises about when I'll get to it. If I\nhaven't after a reasonable time, please don't block on me.\n\nOn Wed, May 8, 2013 at 1:15 PM, Kris Kowal notifications@github.com wrote:\n\n> I actually am wondering whether I might beg a code review from @erightshttps://github.com/erights.\n> Is this consistent with the direction of the language? Is this mature?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/288#issuecomment-17630900\n> .\n\n## \n\nText by me above is hereby placed in the public domain\n\n  Cheers,\n  --MarkM\n. +1\n. At the .then-level, which is the level Q and Promises/A+ operate at (in contrast to the lower .flatMap-level of the full AP2 proposal on es-discuss), we still don't need to distinguish AP2's adoption from acceptance, so I would avoid the term \"accepted\". Rather, if promise p is resolved to promise q, then p follows q. The question is, how to describe the state where p is resolved to a non-promise v, where we don't yet even know whether v will be considered thenable. In this case, at the AP2 .flatMap-level p can only accept v, since only promises can be adopted. Nevertheless, at our .then-level, I think the right concept to extend is \"following\" as in p follows v. So a promise can follow anything. But once p.then happens, in a later turn we further resolve p according to v's state and behavior.\n\nAs Domenic says, as long as v might be a thenable, \"fulfilled\" and \"rejected\" are no longer concrete states, but rather expository states to explain how p's behavior depends on v's.\n\nRegarding the Q-specific inspection methods, I doubt there is any perfect way to maintain compatibility with their old behavior. So let's start by asking: What are these used for? \n. What would happen if we withdrew all of these for a while and then added them, or something like them, back in as we encounter concrete use cases that need them?\n. This question clarified something for me regarding thenables and memoization. With apologies to Albert, I propose that \"Thenables should be assimilated as late as possible, but no later.\" Once p.then(v => .., e =>..) fires, from then on it remains fulfilled or rejected to whatever it provided as the callback argument. In particular, if v later becomes a thenable, this will not affect the behavior of p itself. A later p.then will still report p as fulfilled with v itself. Or, with apologies to post-Albert, observing p's settlement (by being invoked as a callback by p.then) causes the collapse of p's assimilation function.\n. I asked my cat and she says \"well, yes and no.\"\n. We have discussed .any before. The problem is that the name suggests that it is a dual of .all, but is not. The main thing I like about .race is that the name alerts you to its semantics being racier -- more timing dependent -- than most of our other abstractions. I also think the name more clearly suggests its meaning and what to use it for.\n. > naming things, why is it so hard.\n\nBecause of malnymitis\n. See also http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.race\n. @ndkrempel writes\n\n> ... explains why yield Q.all([...]) is needed so much ...\n\nIs it? I don't know one way or the other and would appreciate any evidence. Thanks.\n\nWhat about existing languages with await, like C#? Do they have any equivalent to an await all? If not, does their manual pattern equivalent to our \"yield Q.all([...])\" appear a lot? What fraction of all await statements?\n. @ndkrempel \n\"yield Q.all([x])\" would have as its value a promise for a singleton array containing the promised value of x, which  is very different than \"yield x\". So I don't understand your shorthand suggestion.\n. What would you do with the array of resolved promises typically anyway? I would guess, pattern match it against an array pattern of variable definitions. In ES6:\n\n```\nconst [a, b, c] = yield Q.all([op1(), op2(), op3()]);\n```\n\nIf we're thinking about ES7 sugared syntax, \"await all\" still leaves the variables distant from their initializing expressions. How about\n\n```\nawait const a = op1(), b = op2(), c = op3();\n```\n\n?\n. const [v1, v2, v3] =  yield Q.all([op1(), op2(), op3()]);\n\nIsn't\n. Given the numbers, i do not like the proposed change. The implicit cast is consistent with other promise patterns. Switching behaviors on an array test isn't, and is surprising.\n. That would make it a thenable\n\nOn Thu, Dec 5, 2013 at 9:40 AM, Domenic Denicola\nnotifications@github.comwrote:\n\n> I think it should be renamed Q.then personally :)\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/446#issuecomment-29919425\n> .\n\n## \n\nText by me above is hereby placed in the public domain\n\n  Cheers,\n  --MarkM\n. Yes. My old TC39 draft proposal: http://wiki.ecmascript.org/doku.php?id=strawman:concurrency\nTyler's old Waterken Q API: http://waterken.sourceforge.net/web_send/#API\n\nAnd yes, Q is mnemonic for \"queue\" used as a verb. Most of the API queues things.\n. In looking for those, I also came across https://github.com/kriskowal/q/wiki/Coming-from-Waterken%E2%80%99s-Ref-Send which is interesting.\n. ",
    "mgcrea": "It looks like the `mongoose` direct save is not working correctly. So it probably does come from there.\n. It looks like the `mongoose` direct save is not working correctly. So it probably does come from there.\n. ",
    "mj1856": "Understood.  I'll be happy to maintain a nuget package for you.  Question - where should I pull the \"official\" version from, and what/where are your version numbers?  Thanks.\n. Thanks.  Done. https://nuget.org/packages/q\nCongrats on your shiny new single-letter nuget package.\n\nIs there a feed or list I can subscribe to for updates?  I suppose I can just watch for changes to package.json on github.  I will maintain it as you push new releases.\n\nDo you want the nuspec (package definition file) in your repo? I can send it in a pull req.\n\nCheers!\n. Just in case you didn't know already - The main users of NuGet are Visual Studio developers.  You might not be thinking about us that much during your dev lifecycle, but there is a big push recently towards \"SPA\" style javascript applications.  There's also a lot of cross-over now with VS and node.js folks.\n\nI actually discovered Q from it's use with [Durandal](http://durandaljs.com/) in John Papa's new [Hot Towel](http://www.johnpapa.net/hottowel/) template. I believe this stems from [this thread](https://github.com/BlueSpire/Durandal/issues/55).  Q was the only third-party library in the template that didn't source from nuget.\n\nLike any good package manager, the advantage of nuget is that as updates to Q come out, those that have the package reference can find out about it easier and update their project seamlessly.\n. @jmbertoncelli - I've updated nuget with v 1.1.1.\n. Looks like Bower just pulls the git tags from the repo.\n\nI think the issue is that Bower assumes [semver](http://semver.org/) guideline that pre-release versions are labeled, such as `2.0.0-beta`, and Q doesn't do that.\n. FYI, [for nuget](https://www.nuget.org/packages/Q), I tagged the 2.x versions with `-experimental`.  A nuget user would have to use the `-pre` flag to pull down a prerelease version.  I think to address this issue, it might make sense to re-tag the github repo similarly.\n. Understood.  I'll be happy to maintain a nuget package for you.  Question - where should I pull the \"official\" version from, and what/where are your version numbers?  Thanks.\n. Thanks.  Done. https://nuget.org/packages/q\nCongrats on your shiny new single-letter nuget package.\n\nIs there a feed or list I can subscribe to for updates?  I suppose I can just watch for changes to package.json on github.  I will maintain it as you push new releases.\n\nDo you want the nuspec (package definition file) in your repo? I can send it in a pull req.\n\nCheers!\n. Just in case you didn't know already - The main users of NuGet are Visual Studio developers.  You might not be thinking about us that much during your dev lifecycle, but there is a big push recently towards \"SPA\" style javascript applications.  There's also a lot of cross-over now with VS and node.js folks.\n\nI actually discovered Q from it's use with [Durandal](http://durandaljs.com/) in John Papa's new [Hot Towel](http://www.johnpapa.net/hottowel/) template. I believe this stems from [this thread](https://github.com/BlueSpire/Durandal/issues/55).  Q was the only third-party library in the template that didn't source from nuget.\n\nLike any good package manager, the advantage of nuget is that as updates to Q come out, those that have the package reference can find out about it easier and update their project seamlessly.\n. @jmbertoncelli - I've updated nuget with v 1.1.1.\n. Looks like Bower just pulls the git tags from the repo.\n\nI think the issue is that Bower assumes [semver](http://semver.org/) guideline that pre-release versions are labeled, such as `2.0.0-beta`, and Q doesn't do that.\n. FYI, [for nuget](https://www.nuget.org/packages/Q), I tagged the 2.x versions with `-experimental`.  A nuget user would have to use the `-pre` flag to pull down a prerelease version.  I think to address this issue, it might make sense to re-tag the github repo similarly.\n. ",
    "benjamn": "Great! Thanks for the speedy review and merge.\n. Great! Thanks for the speedy review and merge.\n. ",
    "mbriggs": "Those would all be awesome. I was thinking functions that take callbacks as their last argument, if they call the callback it resolves the promise, if they throw an exception it rejects (although there are a bunch of cases where return false rejects, but that is less consistent). That would cover 99% of client side 3rd party libs. The built-in ones may require more specific wrappers\n. Those would all be awesome. I was thinking functions that take callbacks as their last argument, if they call the callback it resolves the promise, if they throw an exception it rejects (although there are a bunch of cases where return false rejects, but that is less consistent). That would cover 99% of client side 3rd party libs. The built-in ones may require more specific wrappers\n. ",
    "itsnotvalid": "But with NF\\* granted first tier support in Q, would it be sensible to make a `q-node` as well?\n. But with NF\\* granted first tier support in Q, would it be sensible to make a `q-node` as well?\n. ",
    "ELLIOTTCABLE": "Just a single, lonely, little example \u2026 but I ran into this problem with Node's `readline`:\n\n``` coffeescript\n_ = Q.nfcall(read.question, \"What's your name? \")\n_.then (name) ->\n   console.log \"name: #{name}\"\n_.fail (error) ->\n   console.log \"error: #{error}\"\n```\n\nThis'll print `\"error: Elliott\"`, because the _first argument_ to `readline.question()`'s callback is the user-input; there's no `error` argument.\n. Just a single, lonely, little example \u2026 but I ran into this problem with Node's `readline`:\n\n``` coffeescript\n_ = Q.nfcall(read.question, \"What's your name? \")\n_.then (name) ->\n   console.log \"name: #{name}\"\n_.fail (error) ->\n   console.log \"error: #{error}\"\n```\n\nThis'll print `\"error: Elliott\"`, because the _first argument_ to `readline.question()`'s callback is the user-input; there's no `error` argument.\n. ",
    "omares": "Changed according to your feedback. Do i/Should i build and commit the minified versions and add them to the pr?\n. Just for better planning, how high are the changes this will be merged?\n. Changed according to your feedback. Do i/Should i build and commit the minified versions and add them to the pr?\n. Just for better planning, how high are the changes this will be merged?\n. ",
    "craigyk": "OK, I think I got it working with:\n\n``` coffeescript\n\nchain = (msecs,start,...calls) ->\n    start = q.fcall(start).timeout(msecs)\n    for call in calls\n        start = start.spread timeout msecs, call\n    start\n\ntimeout = (msecs,call) ->\n    (...args) ->\n        (q.fcall call, ...args).timeout msecs\n```\n. OK, I think I got it working with:\n\n``` coffeescript\n\nchain = (msecs,start,...calls) ->\n    start = q.fcall(start).timeout(msecs)\n    for call in calls\n        start = start.spread timeout msecs, call\n    start\n\ntimeout = (msecs,call) ->\n    (...args) ->\n        (q.fcall call, ...args).timeout msecs\n```\n. ",
    "abrkn": "I'm fine with using something on top of Q to keep the core tight. Speaking of which, why does Q.spread exists? Will definitely check out Qx! LINQ is amazing.\n. I'm fine with using something on top of Q to keep the core tight. Speaking of which, why does Q.spread exists? Will definitely check out Qx! LINQ is amazing.\n. ",
    "keithamus": "@rkatic your function works perfectly with my demo :smile: \n\nMy main interest in using the add is with integration into an API that doesn't expose Q. I want all functions inside my  API to be chain-able, both serially and in parallel.\n\nI also think this could be a very useful addition overall to Q. If you're passing around a promise between functions it's very useful to be able to add something to execute in parallel, which you cannot do with Q.all\n. @rkatic your function works perfectly with my demo :smile: \n\nMy main interest in using the add is with integration into an API that doesn't expose Q. I want all functions inside my  API to be chain-able, both serially and in parallel.\n\nI also think this could be a very useful addition overall to Q. If you're passing around a promise between functions it's very useful to be able to add something to execute in parallel, which you cannot do with Q.all\n. ",
    "scf2k": "@domenic no, it's not node dependant.\n. @domenic no, it's not node dependant.\n. ",
    "mikerobe": "This also causes spurious unhandled rejects:\n\n``` coffee\nq = require 'q'\ndefer = q.defer()\npromise = defer.promise\npromise.fail (err) ->\n  console.log err\n\n# removing this fin makes it work properly\npromise.fin ->\n  console.log 'fin'\ndefer.reject(new Error())\n```\n\nIt may be a good idea to roll back the feature on the main releases until it's been thought out a little better (to avoid wrong and confusing errors)\n. @domenic :) that's a good one\n. This also causes spurious unhandled rejects:\n\n``` coffee\nq = require 'q'\ndefer = q.defer()\npromise = defer.promise\npromise.fail (err) ->\n  console.log err\n\n# removing this fin makes it work properly\npromise.fin ->\n  console.log 'fin'\ndefer.reject(new Error())\n```\n\nIt may be a good idea to roll back the feature on the main releases until it's been thought out a little better (to avoid wrong and confusing errors)\n. @domenic :) that's a good one\n. ",
    "tsgautier": "This is easily reproducible:\n\nput this in a file called test.js:\n\n``` javascript\nvar q = require('q');\n\nvar deferred = q.defer();\ndeferred.promise.then(function(e) { console.log(\"then\", e); });\ndeferred.promise.fail(function(e) { console.log(e); });\ndeferred.reject('rejected');\n```\n\nrun it:\n\n$ node test\n\nrejected\nUnhandled rejected promise (no stack): rejected\n. Thanks for the comments.   Here is my revised implementation.  I think this synchronously waits for the 10,000 chains to be created.  The result I get from this was approximately:\n\ntook 11248 ms average  889.0469416785206 macro TPS 4445.234708392603 micro TPS\n\nThere is no more pause so I think you were correct on that count.\n\n``` javascript\n\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var chain, count, doit, finish, i, max, q, setupChain, start, _i;\n\n  q = require('q');\n\n  count = 0;\n\n  max = 10000;\n\n  start = new Date().getTime();\n\n  finish = function() {\n    var elapsed, end;\n\n    end = new Date().getTime();\n    elapsed = end - start;\n    return console.log(\"took \" + elapsed + \" ms average \", count / (elapsed / 1000), \"macro TPS\", 5 * count / (elapsed / 1000), \"micro TPS\");\n  };\n\n  chain = function(p, val) {\n    return p.then(function() {\n      return val;\n    });\n  };\n\n  setupChain = function() {\n    var i, original, p, _i;\n\n    original = q.defer();\n    p = original.promise;\n    for (i = _i = 1; _i <= 5; i = ++_i) {\n      p = chain(p, i);\n    }\n    original.resolve('foo');\n    return p;\n  };\n\n  doit = function() {\n    return setupChain().then(function() {\n      if (++count >= max) {\n        return finish();\n      }\n    });\n  };\n\n  for (i = _i = 1; 1 <= max ? _i <= max : _i >= max; i = 1 <= max ? ++_i : --_i) {\n    doit();\n  }\n\n}).call(this);\n```\n. I think maybe this demonstration is more concise.  \n\n$ took 2763 ms average  3619.2544335866814 TPS\n\n``` javascript\n\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var count, doit, finish, i, max, q, start, _i;\n\n  q = require('q');\n\n  count = 0;\n\n  max = 10000;\n\n  start = new Date().getTime();\n\n  finish = function() {\n    var elapsed, end;\n\n    end = new Date().getTime();\n    elapsed = end - start;\n    return console.log(\"took \" + elapsed + \" ms average \", count / (elapsed / 1000), \"TPS\");\n  };\n\n  doit = function() {\n    return q.when('value').then(function() {\n      if (++count >= max) {\n        return finish();\n      }\n    });\n  };\n\n  for (i = _i = 1; 1 <= max ? _i <= max : _i >= max; i = 1 <= max ? ++_i : --_i) {\n    doit();\n  }\n\n}).call(this);\n```\n. By a small, amount, maybe.  By 1 or 2 orders of magnitude? No I don't agree.\n\nHere is some async code that demonstrates expected in-memory performance\n\ntook 6 ms average  1666666.6666666667 TPS\n\n``` javascript\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var count, doit, events, finish, i, max, obj, start, _i;\n\n  events = require('events');\n\n  count = 0;\n\n  max = 10000;\n\n  start = new Date().getTime();\n\n  finish = function() {\n    var elapsed, end;\n\n    end = new Date().getTime();\n    elapsed = end - start;\n    return console.log(\"took \" + elapsed + \" ms average \", count / (elapsed / 1000), \"TPS\");\n  };\n\n  obj = new events.EventEmitter();\n\n  obj.on('test', function() {\n    if (++count >= max) {\n      return finish();\n    }\n  });\n\n  doit = function() {\n    return obj.emit('test');\n  };\n\n  for (i = _i = 1; 1 <= max ? _i <= max : _i >= max; i = 1 <= max ? ++_i : --_i) {\n    doit();\n  }\n\n}).call(this);\n```\n. I was in the middle of updating my mistake, I accidentally had the coffeescript version in my buffer, and was adding the javascript version.  I'm pretty sure I'm not the one being rude.\n. How about this?\n\ntook 14 ms average  714285.7142857143 TPS\n\n``` javascript\n\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var count, doit, events, finish, i, max, obj, start, _i;\n\n  events = require('events');\n\n  count = 0;\n\n  max = 10000;\n\n  start = new Date().getTime();\n\n  finish = function() {\n    var elapsed, end;\n\n    end = new Date().getTime();\n    elapsed = end - start;\n    return console.log(\"took \" + elapsed + \" ms average \", count / (elapsed / 1000), \"TPS\");\n  };\n\n  obj = new events.EventEmitter();\n\n  doit = function() {\n    return setTimeout(function() {\n      if (++count >= max) {\n        return finish();\n      }\n    }, 0);\n  };\n\n  for (i = _i = 1; 1 <= max ? _i <= max : _i >= max; i = 1 <= max ? ++_i : --_i) {\n    doit();\n  }\n\n}).call(this);\n```\n. That's what I did in my first example.  But then I simplified it to just using when/then and see the same timing.  Note that these last two examples aren't using q - I was just trying to write some async code that is performing the same # of operations to measure it's performance.\n\nKeep in mind I am well aware that micro-benchmarks are always dangerous and one should be immediately skeptical - I get that. \n\nBut - I think I get what you are saying - my simulation of chained promises isn't very good.  Nonetheless, let's focus on the simple case, it seems to exhibit similar characteristics, so it doesn't seem to require a chain.\n. Right, let's focus on just running a bunch of promises in parallel as in this code where I am running q.when/then in parallel and timing the total time it takes for all the parallel events to resolve.  The code below, in a micro-benchmark over 10k parallel ops, took ~3s to complete.\n\n``` javascript\ndoit = function() {\n    return q.when('value').then(function() {\n      if (++count >= max) {\n        return finish();\n      }\n    });\n  };\n```\n. I think it's better if we don't worry about the chain of promises.  While that simulates my actual use case more accurately, after several iterations of different tests on this thread it seems clear that just a simple benchmark of n asynchronous callbacks or n q resolves will also show similar behavior, and is easier to understand in a micro-benchmark scenario.  And I think writing just a simple loop of n async callbacks or n q resolves is easier to understand and examine.\n. This is easily reproducible:\n\nput this in a file called test.js:\n\n``` javascript\nvar q = require('q');\n\nvar deferred = q.defer();\ndeferred.promise.then(function(e) { console.log(\"then\", e); });\ndeferred.promise.fail(function(e) { console.log(e); });\ndeferred.reject('rejected');\n```\n\nrun it:\n\n$ node test\n\nrejected\nUnhandled rejected promise (no stack): rejected\n. Thanks for the comments.   Here is my revised implementation.  I think this synchronously waits for the 10,000 chains to be created.  The result I get from this was approximately:\n\ntook 11248 ms average  889.0469416785206 macro TPS 4445.234708392603 micro TPS\n\nThere is no more pause so I think you were correct on that count.\n\n``` javascript\n\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var chain, count, doit, finish, i, max, q, setupChain, start, _i;\n\n  q = require('q');\n\n  count = 0;\n\n  max = 10000;\n\n  start = new Date().getTime();\n\n  finish = function() {\n    var elapsed, end;\n\n    end = new Date().getTime();\n    elapsed = end - start;\n    return console.log(\"took \" + elapsed + \" ms average \", count / (elapsed / 1000), \"macro TPS\", 5 * count / (elapsed / 1000), \"micro TPS\");\n  };\n\n  chain = function(p, val) {\n    return p.then(function() {\n      return val;\n    });\n  };\n\n  setupChain = function() {\n    var i, original, p, _i;\n\n    original = q.defer();\n    p = original.promise;\n    for (i = _i = 1; _i <= 5; i = ++_i) {\n      p = chain(p, i);\n    }\n    original.resolve('foo');\n    return p;\n  };\n\n  doit = function() {\n    return setupChain().then(function() {\n      if (++count >= max) {\n        return finish();\n      }\n    });\n  };\n\n  for (i = _i = 1; 1 <= max ? _i <= max : _i >= max; i = 1 <= max ? ++_i : --_i) {\n    doit();\n  }\n\n}).call(this);\n```\n. I think maybe this demonstration is more concise.  \n\n$ took 2763 ms average  3619.2544335866814 TPS\n\n``` javascript\n\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var count, doit, finish, i, max, q, start, _i;\n\n  q = require('q');\n\n  count = 0;\n\n  max = 10000;\n\n  start = new Date().getTime();\n\n  finish = function() {\n    var elapsed, end;\n\n    end = new Date().getTime();\n    elapsed = end - start;\n    return console.log(\"took \" + elapsed + \" ms average \", count / (elapsed / 1000), \"TPS\");\n  };\n\n  doit = function() {\n    return q.when('value').then(function() {\n      if (++count >= max) {\n        return finish();\n      }\n    });\n  };\n\n  for (i = _i = 1; 1 <= max ? _i <= max : _i >= max; i = 1 <= max ? ++_i : --_i) {\n    doit();\n  }\n\n}).call(this);\n```\n. By a small, amount, maybe.  By 1 or 2 orders of magnitude? No I don't agree.\n\nHere is some async code that demonstrates expected in-memory performance\n\ntook 6 ms average  1666666.6666666667 TPS\n\n``` javascript\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var count, doit, events, finish, i, max, obj, start, _i;\n\n  events = require('events');\n\n  count = 0;\n\n  max = 10000;\n\n  start = new Date().getTime();\n\n  finish = function() {\n    var elapsed, end;\n\n    end = new Date().getTime();\n    elapsed = end - start;\n    return console.log(\"took \" + elapsed + \" ms average \", count / (elapsed / 1000), \"TPS\");\n  };\n\n  obj = new events.EventEmitter();\n\n  obj.on('test', function() {\n    if (++count >= max) {\n      return finish();\n    }\n  });\n\n  doit = function() {\n    return obj.emit('test');\n  };\n\n  for (i = _i = 1; 1 <= max ? _i <= max : _i >= max; i = 1 <= max ? ++_i : --_i) {\n    doit();\n  }\n\n}).call(this);\n```\n. I was in the middle of updating my mistake, I accidentally had the coffeescript version in my buffer, and was adding the javascript version.  I'm pretty sure I'm not the one being rude.\n. How about this?\n\ntook 14 ms average  714285.7142857143 TPS\n\n``` javascript\n\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var count, doit, events, finish, i, max, obj, start, _i;\n\n  events = require('events');\n\n  count = 0;\n\n  max = 10000;\n\n  start = new Date().getTime();\n\n  finish = function() {\n    var elapsed, end;\n\n    end = new Date().getTime();\n    elapsed = end - start;\n    return console.log(\"took \" + elapsed + \" ms average \", count / (elapsed / 1000), \"TPS\");\n  };\n\n  obj = new events.EventEmitter();\n\n  doit = function() {\n    return setTimeout(function() {\n      if (++count >= max) {\n        return finish();\n      }\n    }, 0);\n  };\n\n  for (i = _i = 1; 1 <= max ? _i <= max : _i >= max; i = 1 <= max ? ++_i : --_i) {\n    doit();\n  }\n\n}).call(this);\n```\n. That's what I did in my first example.  But then I simplified it to just using when/then and see the same timing.  Note that these last two examples aren't using q - I was just trying to write some async code that is performing the same # of operations to measure it's performance.\n\nKeep in mind I am well aware that micro-benchmarks are always dangerous and one should be immediately skeptical - I get that. \n\nBut - I think I get what you are saying - my simulation of chained promises isn't very good.  Nonetheless, let's focus on the simple case, it seems to exhibit similar characteristics, so it doesn't seem to require a chain.\n. Right, let's focus on just running a bunch of promises in parallel as in this code where I am running q.when/then in parallel and timing the total time it takes for all the parallel events to resolve.  The code below, in a micro-benchmark over 10k parallel ops, took ~3s to complete.\n\n``` javascript\ndoit = function() {\n    return q.when('value').then(function() {\n      if (++count >= max) {\n        return finish();\n      }\n    });\n  };\n```\n. I think it's better if we don't worry about the chain of promises.  While that simulates my actual use case more accurately, after several iterations of different tests on this thread it seems clear that just a simple benchmark of n asynchronous callbacks or n q resolves will also show similar behavior, and is easier to understand in a micro-benchmark scenario.  And I think writing just a simple loop of n async callbacks or n q resolves is easier to understand and examine.\n. ",
    "debug-ito": "This issue seems reproducible in Web browsers since the test at\nhttps://rawgithub.com/kriskowal/q/master/spec/q-spec.html\nemits the following error message to the console.\n\n   [Q] Unhandled rejection reasons (should be empty): []\n\nI tried Firefox 20.0 and Chromium 25.0.1364.160 (both on Ubuntu 12.04), and both of them emit the message.\n. This issue seems reproducible in Web browsers since the test at\nhttps://rawgithub.com/kriskowal/q/master/spec/q-spec.html\nemits the following error message to the console.\n\n   [Q] Unhandled rejection reasons (should be empty): []\n\nI tried Firefox 20.0 and Chromium 25.0.1364.160 (both on Ubuntu 12.04), and both of them emit the message.\n. ",
    "satazor": "I've also encountered this bug, but it doesn't happen every time when running the same code multiple times.\nIs there any way to disable this feature? I would prefer to disable it until this bug got fixed.\n. I've also encountered this bug, but it doesn't happen every time when running the same code multiple times.\nIs there any way to disable this feature? I would prefer to disable it until this bug got fixed.\n. ",
    "Myztiq": "It would be nice to be able to disable this tracking via a configuration, or set a max size/count for the array to prevent memory being consumed on a production machine. Especially if that production machine does not \"crash\" or get restarted on a regular basis.\n. Thanks @domenic, I missed that issue.\n. Technically yes you can. Things get a little hairy in my experience when doing so.\n\nYou essentially augment the returned promise object:\n\n``` javascript\nvar deferred = Q.defer()\ndeferred.promise.method1 = function(){\n  return deferred.promise.invoke('method1')\n}\ndeferred.promise.method2 = function(){\n  return deferred.promise.invoke('method2')\n}\n```\n\nThe cleaner and easier route would just be to go with\n\n``` javascript\nobj.invoke('method1').invoke('method2').invoke('method3')\n```\n\nThe downside being it will end up passing in the response from method1 into method2 I believe.\n. It would be nice to be able to disable this tracking via a configuration, or set a max size/count for the array to prevent memory being consumed on a production machine. Especially if that production machine does not \"crash\" or get restarted on a regular basis.\n. Thanks @domenic, I missed that issue.\n. Technically yes you can. Things get a little hairy in my experience when doing so.\n\nYou essentially augment the returned promise object:\n\n``` javascript\nvar deferred = Q.defer()\ndeferred.promise.method1 = function(){\n  return deferred.promise.invoke('method1')\n}\ndeferred.promise.method2 = function(){\n  return deferred.promise.invoke('method2')\n}\n```\n\nThe cleaner and easier route would just be to go with\n\n``` javascript\nobj.invoke('method1').invoke('method2').invoke('method3')\n```\n\nThe downside being it will end up passing in the response from method1 into method2 I believe.\n. ",
    "TrevorBurnham": "I'm wondering why this was closed... surely it's a bug that attaching additional success handlers to a promise causes additional entries to be added to `unhandledReasons`/`unhandledExceptions`? Here's a test case:\n\n```\ndeferred = Q.defer();\ndeferred.reject(new Error('foo'));\ndeferred.promise.fail(function() {\n  console.log(Q.getUnhandledReasons().length);  // 0\n});\ndeferred.promise.then(function() {  /* ... */ });\ndeferred.promise.fail(function() {\n  console.log(Q.getUnhandledReasons().length);  // 1\n});\n```\n\nIt's perfectly valid to attach success handlers to a promise separately from failure handlers, and should not complicate debugging. N'est pas?\n. Yes, I was just realizing that. Not a bug, but a conceptual choice. Thanks for taking the time to clarify.\n. I'm wondering why this was closed... surely it's a bug that attaching additional success handlers to a promise causes additional entries to be added to `unhandledReasons`/`unhandledExceptions`? Here's a test case:\n\n```\ndeferred = Q.defer();\ndeferred.reject(new Error('foo'));\ndeferred.promise.fail(function() {\n  console.log(Q.getUnhandledReasons().length);  // 0\n});\ndeferred.promise.then(function() {  /* ... */ });\ndeferred.promise.fail(function() {\n  console.log(Q.getUnhandledReasons().length);  // 1\n});\n```\n\nIt's perfectly valid to attach success handlers to a promise separately from failure handlers, and should not complicate debugging. N'est pas?\n. Yes, I was just realizing that. Not a bug, but a conceptual choice. Thanks for taking the time to clarify.\n. ",
    "whitecolor": "Can I use .fail() to handle rejection or it is not appropriate? Just in other promise implementations I've seen done to handle resolve and .fail to handle reject.\n. To handle resolve I'm supposed to use .then. I not fully understand the role of .done? What is the difference between last .then(callback) and done(callback) and why I should need to use done?\n. I've got it, done is called alway, and also should be called in the end to make exeptions visible. thanks! )\n. Because I don't know whether deferred will be resolved with array or single value. I have a library of methods that in different cases should resolve different results, some times there should be one value and some times more than one. A consumer code it self will deal with it. But in the code of the methods I now should do:\n\n<pre>deferred.resolve([someValue]) </pre> - not a big deal but, I think it could be handled to allow just deferred.resolve(someValue) and then be handled by spread.\nAlso I'm not sure why not make it possible to do:\n<pre>deferred.resolve(value1, value2, value2)</pre>\n\nand consume it with then\n\n<pre>deferred.promise.then(funciton(value1, value2, value3))</pre>\n\nWithout using arrays at all, that would eliminate the need of spread for such cases.\n. Ok, that may be a reason not to change spread, and use it only with arrays, but then it would be nice to be able to do like that:\n\n<pre>deferred.resolve(value1, value2, value2)</pre>\n\nand consume it with then\n\n<pre>deferred.promise.then(funciton(value1, value2, value3){\n// consume value1, value2, value3, \n// now only value1 will be avaliable, \n// value2 and valu3 will be undefined\n})</pre>\n. Ok, that is a good point to make it like that:\n\n<pre>\npromise.relove(1,2,3) // if it would construct array [1,2, 3] and pass it further\n</pre>\n. Yes I guess that my problem is solved, thanks!\n. @killdream ok, thanks!\n. No It is the same Uploader, I just replaced ytUplader with Uploader,\n\nTo get the results I just replace the code with for cycle with the code with forEach and it fails to produce promises, no other changes.\n. Yes, thanks. I'm very inattentive. Closed.\n. Can I use .fail() to handle rejection or it is not appropriate? Just in other promise implementations I've seen done to handle resolve and .fail to handle reject.\n. To handle resolve I'm supposed to use .then. I not fully understand the role of .done? What is the difference between last .then(callback) and done(callback) and why I should need to use done?\n. I've got it, done is called alway, and also should be called in the end to make exeptions visible. thanks! )\n. Because I don't know whether deferred will be resolved with array or single value. I have a library of methods that in different cases should resolve different results, some times there should be one value and some times more than one. A consumer code it self will deal with it. But in the code of the methods I now should do:\n\n<pre>deferred.resolve([someValue]) </pre> - not a big deal but, I think it could be handled to allow just deferred.resolve(someValue) and then be handled by spread.\nAlso I'm not sure why not make it possible to do:\n<pre>deferred.resolve(value1, value2, value2)</pre>\n\nand consume it with then\n\n<pre>deferred.promise.then(funciton(value1, value2, value3))</pre>\n\nWithout using arrays at all, that would eliminate the need of spread for such cases.\n. Ok, that may be a reason not to change spread, and use it only with arrays, but then it would be nice to be able to do like that:\n\n<pre>deferred.resolve(value1, value2, value2)</pre>\n\nand consume it with then\n\n<pre>deferred.promise.then(funciton(value1, value2, value3){\n// consume value1, value2, value3, \n// now only value1 will be avaliable, \n// value2 and valu3 will be undefined\n})</pre>\n. Ok, that is a good point to make it like that:\n\n<pre>\npromise.relove(1,2,3) // if it would construct array [1,2, 3] and pass it further\n</pre>\n. Yes I guess that my problem is solved, thanks!\n. @killdream ok, thanks!\n. No It is the same Uploader, I just replaced ytUplader with Uploader,\n\nTo get the results I just replace the code with for cycle with the code with forEach and it fails to produce promises, no other changes.\n. Yes, thanks. I'm very inattentive. Closed.\n. ",
    "robotlolita": "What if `resolve` accepted a specially tagged Object that marked the value it encodes as variadic? In that way, the producer could decide how the value should be treated: as a single value, or as a list of values. And the consumer wouldn't need to worry about it.\n\nSay:\n\n``` haskell\ntype Value a :: Just a | Spread a\n```\n\nThen, people would could just tag the return value:\n\n``` js\ndeferred.resolve(1, 2, 3) // => Just [1, 2, 3]\n\ndeferred.resolve(Q.spreading(1, 2, 3)) // => Spread [1, 2, 3]\n```\n\nIn this way, `then` could be used as a generic for handling the `Value a` type, in a way it would call the right function to handle `Just a` if the value is not tagged, or `Q.spread` if the value is tagged. It does add an additional burden on the producer for tagging the return values, but it gives the consumer a better interface, since it doesn't need to know the internals of a particular promised function.\n\n``` js\ndeferred.resolve(1, 2, 3)\n        .promise.then(function(a){ return a }) // [1, 2, 3]\n\ndeferred.resolve(Q.spreading(1, 2, 3))\n        .promise.then(function(a, b, c){\n                        return a + b + c }) // => 6\n```\n. @domenic after giving it some more thought, I don't think it's a good idea to do it like this at all. It kills compositionality because JS isn't typed and you can only emulate these things with run-time tags, all of which changes the semantics of the object they're encoding in some way (until have standardised `__proto__`, so we can subclass these things). It also kills interoperability with other Promises/a+ libraries, because now they're getting an alien object in the `then` method, which leads to inconsistent behaviours and misses the point of having a spec entirely in the first place ;3\n. @kriskowal since Promises/A+ are fully compatible, ain't Q already fully \"extensible\" by providing only a small core? If I write something that computes promises in parallel or computes them sequentially, I don't necessarily have to put that on the Q object: they could live as separate functions in separate modules:\n\nBasically, this means that the following should just work, for any Promises/A+ implementation:\n\n``` js\nvar parallel = require('promises-aplus/parallel')\nparallel([qPromise, jqueryThenable, whenPromise]).then(...)\n```\n\nThis is the approach I'm taking with my implementation ([Pinky](https://github.com/killdream/pinky)). The core library only provides a means of creating promises, with an additional module for composing promises and another module for lifting functions to work with promises.\n\nAs a bonus point, if you make the combinator modules parametric, you don't need to tie it to a specific promise implementation \u2014 just like the Promises/A+ spec tests. This would provide even more benefits for other promise implementations, without the user having to deal with duplicated code if they're using combinators that depend on a different promise implementation. OTOH this makes consumers have to deal with the instantiation of the modules themselves:\n\n``` js\nvar parallel = require('promises-aplus/parallel')({ adapter })\n```\n\nHowever, Q could provide the users with a easier way of requiring these. For example, if there is a common adapter pattern, we could just pass an object that exposes a `promiseAdapter` key or something.\n\n``` js\nvar parallel = require('promises-aplus/parallel')(Q)\n```\n. Is that CoffeeScript?\n\nFrom this snippet, the `console.log` instruction and the computing of the elapsed times don't seem to use promises at all. Promises/A+ (which Q is an implementation of), resolves all promises `.then` methods asynchronously, so, in your example, logging and other stuff would happen before the promises are resolved \u2014 which would explain the \"huge pause\" at the end (those things are still scheduled to happen at some later time).\n. Here's a proper test case for this. It executes 100 parallel computations asynchronously, where each computation is made up of 5 sequential asynchronous operations. Q is faster because my callback version is na\u00efve and each asynchronous operation is executed in the next event loop, whereas in Q this is optimised internally.\n\n**correction**: Q is only faster on Firefox. In Chromium the callback version is faster.\n\nhttp://jsperf.com/callbacks-vs-promises-a\n. @whitecolor If you want to automatically convert your OO interfaces to Promise-yielding interfaces, you can implement `chain()` and `value()` rather easily. (Sorry for the \"non-Q idiomatic code\", I'm not that familiar with all the stuff in the library)\n\n``` js\n// Helpers for sane prototype OO programming\nfunction extend(a, b) {\n  return Object.keys(b).forEach(function(k){ a[k] = b[k] })\n}\nfunction derive(proto, mixin) {\n  return extend(Object.create(proto), mixin)\n}\nfunction map(o, f) {\n  return Object.keys(o).reduce(function(r, k) { r[k] = f(r[k]) }, {})\n}\n\n// Makes an object's interface \"chainable\", automatically using promises\nfunction pchain(o) {\n  return derive(promise(o), map(o, promisify)))\n}\n\n// Lifts a regular method into a promise-accepting method.\n// This will grab a promise for a result, chain the method to the promise,\n// then return a new augmented promise\nfunction promisify(method) {\n  return function() {\n    var args = [].slice.call(arguments)\n    var self = this\n    return pchain(this.then(function(){ return self[method].apply(self, args) }))\n  }\n}\n```\n\nNow you get to write your \"fluent interface\" style and deal with promise's `then` methods easily:\n\n``` js\nvar data = pchain(turtle())\n  .asyncMove(x, y)\n  .asyncPenColour('black')\n  .asyncMove(x + 10, y + 10)\n  .asyncStroke()\n\n// Now `data` is a promise for whatever `asyncStroke` returns, and all actions are executed in order.\n```\n. @fschwiet just complementing what @wychi said. You get the results you get because:\n\n1) Q.fcall(fn) will just invoke `fn` right away, and return a promise for its results.\n2) `Promise.then` is always resolved in the next event-loop.\n\nSo, this means that your example will be translated to this:\n- Print `a`, and return a promise for `undefined`\n- Print `b`, and return a promise for `undefined`\n- Schedule the execution of a function for the next event loop, return a promise\n- Print `e` and return a promise for `undefined`\n- Execute the `then` method of `promiseLog(\"a\")`\n- Execute the `then` method of `promiseLog(\"b\")`\n- Invoke the previously scheduled function.\n- Print `c`, return a promise for `undefined`\n- Print `d`, return a promise for `undefined`\n- Execute the `then` method of `promiseLog(\"c\")`\n- Execute the `then` method of `promiseLog(\"d\")`\n- Execute the `then` method of `promiseLog(\"e\")`\n. @Redsandro you can have a simple combinator for this in a separate library, this doesn't need to be in Q core:\n\n``` js\nfunction pif(promise, test, consequent, alternate) {\n  return promise.then(function(value) {\n    return test(value)? consequent(value) : alternate(value)\n  })\n}\n\nfunction identity(a){ return a }\n\nfunction when(promise, test, f) {\n  return pif(promise, test, f, identity)\n}\n\nfunction unless(promise, test, f) {\n  return pif(promise, test, identity, f)\n}\n```\n\nThen use it:\n\n``` js\npif(promise, isZero, doX, doY)\nwhen(promise, isZero, doX)\nunless(promise, isZero, doY)\n```\n. @Redsandro JS itself is a very dynamic language, you can change the shape of any object at all. Again, I disagree this should be in Q-core, since it's easy to provide a generic module with this particular feature that would work for any Promises/A+ implementation.\n\nI assume you're not familiar with Lambda Calculus combinators? `Identity` is a core combinator that just returns its argument, without doing anything to it. It's useful for composing things where you don't want to apply any transformation on the value, but the operation still expects you to provide a function. In this case, `pif` always takes two functions, `consequent`, which is ran if the predicate passes, and `alternate`, which is ran if it isn't. Since `when` and `unless` are just concerned about applying transformations in the promised value in one of the cases, `identity` fits perfectly as the \"look, just keep the value as-is\" function :3\n. I don't think that's a good idea at all. Just use something like:\n\n``` js\npromise\n  .case('foo', doBar)\n  .case('baz', compose(doBaz, doBar))\n  .case('qux', doSomethingElse)\n```\n. It's a bad idea because it breaks compositionality and introduces mutable global state, which are two things we've been trying to avoid throughout all the story of programming.\n\nAs an example:\n\n``` js\nvar foo = promise.case('foo').then(baz)\nvar baz = doSomething(foo)\n// now `foo` is not just a value, it has state, and state is evil,\n// and breaks compositionality, thus you can't pass\n// it around as easily as you would be able to\n// if your promises are pure, sweet and simple values.\n```\n. It is a nice abstract way of applying transformations when you have no idea of the amount of functions you'll be calling. Brofist uses a similar function to run all the hooks that have been defined before and after a test case/suite sequentially - see https://github.com/brofistjs/brofist/blob/master/lib/suite.js#L60\n\nI'm not sure it's something that comes up too often, though. So there's the drawback of having something that might be rarely used in Q-core, which I'm not sure it's a good idea.\n. @AaronO there's no `Q.reduce`, that's your everyday `Array.prototype.reduce` function, You can do this sort of abstraction because promises are just regular values :3\n. What if `resolve` accepted a specially tagged Object that marked the value it encodes as variadic? In that way, the producer could decide how the value should be treated: as a single value, or as a list of values. And the consumer wouldn't need to worry about it.\n\nSay:\n\n``` haskell\ntype Value a :: Just a | Spread a\n```\n\nThen, people would could just tag the return value:\n\n``` js\ndeferred.resolve(1, 2, 3) // => Just [1, 2, 3]\n\ndeferred.resolve(Q.spreading(1, 2, 3)) // => Spread [1, 2, 3]\n```\n\nIn this way, `then` could be used as a generic for handling the `Value a` type, in a way it would call the right function to handle `Just a` if the value is not tagged, or `Q.spread` if the value is tagged. It does add an additional burden on the producer for tagging the return values, but it gives the consumer a better interface, since it doesn't need to know the internals of a particular promised function.\n\n``` js\ndeferred.resolve(1, 2, 3)\n        .promise.then(function(a){ return a }) // [1, 2, 3]\n\ndeferred.resolve(Q.spreading(1, 2, 3))\n        .promise.then(function(a, b, c){\n                        return a + b + c }) // => 6\n```\n. @domenic after giving it some more thought, I don't think it's a good idea to do it like this at all. It kills compositionality because JS isn't typed and you can only emulate these things with run-time tags, all of which changes the semantics of the object they're encoding in some way (until have standardised `__proto__`, so we can subclass these things). It also kills interoperability with other Promises/a+ libraries, because now they're getting an alien object in the `then` method, which leads to inconsistent behaviours and misses the point of having a spec entirely in the first place ;3\n. @kriskowal since Promises/A+ are fully compatible, ain't Q already fully \"extensible\" by providing only a small core? If I write something that computes promises in parallel or computes them sequentially, I don't necessarily have to put that on the Q object: they could live as separate functions in separate modules:\n\nBasically, this means that the following should just work, for any Promises/A+ implementation:\n\n``` js\nvar parallel = require('promises-aplus/parallel')\nparallel([qPromise, jqueryThenable, whenPromise]).then(...)\n```\n\nThis is the approach I'm taking with my implementation ([Pinky](https://github.com/killdream/pinky)). The core library only provides a means of creating promises, with an additional module for composing promises and another module for lifting functions to work with promises.\n\nAs a bonus point, if you make the combinator modules parametric, you don't need to tie it to a specific promise implementation \u2014 just like the Promises/A+ spec tests. This would provide even more benefits for other promise implementations, without the user having to deal with duplicated code if they're using combinators that depend on a different promise implementation. OTOH this makes consumers have to deal with the instantiation of the modules themselves:\n\n``` js\nvar parallel = require('promises-aplus/parallel')({ adapter })\n```\n\nHowever, Q could provide the users with a easier way of requiring these. For example, if there is a common adapter pattern, we could just pass an object that exposes a `promiseAdapter` key or something.\n\n``` js\nvar parallel = require('promises-aplus/parallel')(Q)\n```\n. Is that CoffeeScript?\n\nFrom this snippet, the `console.log` instruction and the computing of the elapsed times don't seem to use promises at all. Promises/A+ (which Q is an implementation of), resolves all promises `.then` methods asynchronously, so, in your example, logging and other stuff would happen before the promises are resolved \u2014 which would explain the \"huge pause\" at the end (those things are still scheduled to happen at some later time).\n. Here's a proper test case for this. It executes 100 parallel computations asynchronously, where each computation is made up of 5 sequential asynchronous operations. Q is faster because my callback version is na\u00efve and each asynchronous operation is executed in the next event loop, whereas in Q this is optimised internally.\n\n**correction**: Q is only faster on Firefox. In Chromium the callback version is faster.\n\nhttp://jsperf.com/callbacks-vs-promises-a\n. @whitecolor If you want to automatically convert your OO interfaces to Promise-yielding interfaces, you can implement `chain()` and `value()` rather easily. (Sorry for the \"non-Q idiomatic code\", I'm not that familiar with all the stuff in the library)\n\n``` js\n// Helpers for sane prototype OO programming\nfunction extend(a, b) {\n  return Object.keys(b).forEach(function(k){ a[k] = b[k] })\n}\nfunction derive(proto, mixin) {\n  return extend(Object.create(proto), mixin)\n}\nfunction map(o, f) {\n  return Object.keys(o).reduce(function(r, k) { r[k] = f(r[k]) }, {})\n}\n\n// Makes an object's interface \"chainable\", automatically using promises\nfunction pchain(o) {\n  return derive(promise(o), map(o, promisify)))\n}\n\n// Lifts a regular method into a promise-accepting method.\n// This will grab a promise for a result, chain the method to the promise,\n// then return a new augmented promise\nfunction promisify(method) {\n  return function() {\n    var args = [].slice.call(arguments)\n    var self = this\n    return pchain(this.then(function(){ return self[method].apply(self, args) }))\n  }\n}\n```\n\nNow you get to write your \"fluent interface\" style and deal with promise's `then` methods easily:\n\n``` js\nvar data = pchain(turtle())\n  .asyncMove(x, y)\n  .asyncPenColour('black')\n  .asyncMove(x + 10, y + 10)\n  .asyncStroke()\n\n// Now `data` is a promise for whatever `asyncStroke` returns, and all actions are executed in order.\n```\n. @fschwiet just complementing what @wychi said. You get the results you get because:\n\n1) Q.fcall(fn) will just invoke `fn` right away, and return a promise for its results.\n2) `Promise.then` is always resolved in the next event-loop.\n\nSo, this means that your example will be translated to this:\n- Print `a`, and return a promise for `undefined`\n- Print `b`, and return a promise for `undefined`\n- Schedule the execution of a function for the next event loop, return a promise\n- Print `e` and return a promise for `undefined`\n- Execute the `then` method of `promiseLog(\"a\")`\n- Execute the `then` method of `promiseLog(\"b\")`\n- Invoke the previously scheduled function.\n- Print `c`, return a promise for `undefined`\n- Print `d`, return a promise for `undefined`\n- Execute the `then` method of `promiseLog(\"c\")`\n- Execute the `then` method of `promiseLog(\"d\")`\n- Execute the `then` method of `promiseLog(\"e\")`\n. @Redsandro you can have a simple combinator for this in a separate library, this doesn't need to be in Q core:\n\n``` js\nfunction pif(promise, test, consequent, alternate) {\n  return promise.then(function(value) {\n    return test(value)? consequent(value) : alternate(value)\n  })\n}\n\nfunction identity(a){ return a }\n\nfunction when(promise, test, f) {\n  return pif(promise, test, f, identity)\n}\n\nfunction unless(promise, test, f) {\n  return pif(promise, test, identity, f)\n}\n```\n\nThen use it:\n\n``` js\npif(promise, isZero, doX, doY)\nwhen(promise, isZero, doX)\nunless(promise, isZero, doY)\n```\n. @Redsandro JS itself is a very dynamic language, you can change the shape of any object at all. Again, I disagree this should be in Q-core, since it's easy to provide a generic module with this particular feature that would work for any Promises/A+ implementation.\n\nI assume you're not familiar with Lambda Calculus combinators? `Identity` is a core combinator that just returns its argument, without doing anything to it. It's useful for composing things where you don't want to apply any transformation on the value, but the operation still expects you to provide a function. In this case, `pif` always takes two functions, `consequent`, which is ran if the predicate passes, and `alternate`, which is ran if it isn't. Since `when` and `unless` are just concerned about applying transformations in the promised value in one of the cases, `identity` fits perfectly as the \"look, just keep the value as-is\" function :3\n. I don't think that's a good idea at all. Just use something like:\n\n``` js\npromise\n  .case('foo', doBar)\n  .case('baz', compose(doBaz, doBar))\n  .case('qux', doSomethingElse)\n```\n. It's a bad idea because it breaks compositionality and introduces mutable global state, which are two things we've been trying to avoid throughout all the story of programming.\n\nAs an example:\n\n``` js\nvar foo = promise.case('foo').then(baz)\nvar baz = doSomething(foo)\n// now `foo` is not just a value, it has state, and state is evil,\n// and breaks compositionality, thus you can't pass\n// it around as easily as you would be able to\n// if your promises are pure, sweet and simple values.\n```\n. It is a nice abstract way of applying transformations when you have no idea of the amount of functions you'll be calling. Brofist uses a similar function to run all the hooks that have been defined before and after a test case/suite sequentially - see https://github.com/brofistjs/brofist/blob/master/lib/suite.js#L60\n\nI'm not sure it's something that comes up too often, though. So there's the drawback of having something that might be rarely used in Q-core, which I'm not sure it's a good idea.\n. @AaronO there's no `Q.reduce`, that's your everyday `Array.prototype.reduce` function, You can do this sort of abstraction because promises are just regular values :3\n. ",
    "AndrewGaspar": "Makes sense. Thanks for the explanation!\n. Makes sense. Thanks for the explanation!\n. ",
    "realyze": "Well, strange thing is that this happens even if I use describe.only and run a suite of 6 tests (it still complains about setting 11 listeners). No idea why it sets 11 listeners there. Also, shouldn't the listener be unset when the test ends? I tried requiring sandboxed-module in an beforeEach block and it did not affect this issue.\n. Hm, unfortunately no, I'm on v0.10.1 which is the newest one. But thanks anyways.\n. Well, strange thing is that this happens even if I use describe.only and run a suite of 6 tests (it still complains about setting 11 listeners). No idea why it sets 11 listeners there. Also, shouldn't the listener be unset when the test ends? I tried requiring sandboxed-module in an beforeEach block and it did not affect this issue.\n. Hm, unfortunately no, I'm on v0.10.1 which is the newest one. But thanks anyways.\n. ",
    "fyddaben": "i have same problem..still look for answer\n. i have same problem..still look for answer\n. ",
    "wardbell": "Glad you\u2019re on this, Domenic. I had the same question in mind. I love making it easy to create jsFiddles with that get Q.js from a CDN but I don\u2019t control the way he does it. Wish one could designate \u201cthe latest\u201d version and let people just link to that. \n. No problem. I'll think of something else\n. Glad you\u2019re on this, Domenic. I had the same question in mind. I love making it easy to create jsFiddles with that get Q.js from a CDN but I don\u2019t control the way he does it. Wish one could designate \u201cthe latest\u201d version and let people just link to that. \n. No problem. I'll think of something else\n. ",
    "sukima": "http://cdnjs.cloudflare.com/ajax/libs/q.js/0.9.2/q.js works but http://cdnjs.cloudflare.com/ajax/libs/q.js/0.9.7/q.js does not. This solution will not work not just for the README but in that future versions do not exist. Bummer.\n. http://cdnjs.cloudflare.com/ajax/libs/q.js/0.9.2/q.js works but http://cdnjs.cloudflare.com/ajax/libs/q.js/0.9.7/q.js does not. This solution will not work not just for the README but in that future versions do not exist. Bummer.\n. ",
    "stefek99": "Quick question...\n\nhttps://cdnjs.com/libraries/q.js\n\nhttps://cdnjs.cloudflare.com/ajax/libs/q.js/2.0.3/q.js\n\n`var WeakMap = require(\"weak-map\");`\n\nDoesn't work in my browser....\n. Quick question...\n\nhttps://cdnjs.com/libraries/q.js\n\nhttps://cdnjs.cloudflare.com/ajax/libs/q.js/2.0.3/q.js\n\n`var WeakMap = require(\"weak-map\");`\n\nDoesn't work in my browser....\n. ",
    "thirdreplicator": "Thanks so much for the clarification.  The destructuring will do it for me.  BTW, I love this library.  Thanks so much to you guys for making it.  Lodash and Q are my two favorite JS libraries.\n. Thanks so much for the clarification.  The destructuring will do it for me.  BTW, I love this library.  Thanks so much to you guys for making it.  Lodash and Q are my two favorite JS libraries.\n. ",
    "Stuk": "+1\nWill be useful in conjunction with a beforeunload warning in the browser\n\nIt would also be nice if it returned whether there were any unhandled rejections, so then a decision could be made on whether to show a beforeunload dialog, but I see that the release doesn't know anything about the behaviour it's triggering.\n. Could you be more explicit about what you mean by \"operator modules\"?\n. +1\nWill be useful in conjunction with a beforeunload warning in the browser\n\nIt would also be nice if it returned whether there were any unhandled rejections, so then a decision could be made on whether to show a beforeunload dialog, but I see that the release doesn't know anything about the behaviour it's triggering.\n. Could you be more explicit about what you mean by \"operator modules\"?\n. ",
    "curvedmark": "Actually, the real need is to be able to specify how many promises are allowed to run in parallel. Maybe .all() could receive one more argument?\n. Ah, your version is much better, thanks.\n\nMy understanding of promises was completely wrong in the second version, but what I actually mean is this:\n\n```\nrepeat = 5;\n\nvar tests = [];\nfor (var i = 0; i < repeat; ++i) {\n    tests.push(testspeed.bind(undefined, url));\n}\n\nQ.series(tests).then(function (speeds) {\n    console.log(speeds);\n});\n```\n\nWhen given an array of promise-generating functions, `Q.serial(array)` should fulfill promises serially. `Q.serial` is actually a specialized version of `Q.parallel(array, count)`, which should fulfill at most `count` promises in parallel.\n\nThis could potentially be useful, for example, when testing multiple servers, or requesting multiple files with xhr.\n\nHere is my initial stab at it:\n\n```\nQ.parallel = function (funcs, count) {\n    var length = funcs.length;\n    if (!length) {\n        return Q([]);\n    }\n\n    if (count == null) {\n        count = Infinity;\n    }\n\n    count = Math.max(count, 1);\n    count = Math.min(count, funcs.length);\n\n    var promises = [];\n    var values = [];\n    for (var i = 0; i < count; ++i) {\n        var promise = funcs[i]();\n        promise = promise.then(next(i));\n        promises.push(promise);\n    }\n\n    return Q.all(promises).then(function () {\n        return values;\n    });\n\n    function next(i) {\n        return function (value) {\n            if (i == null) {\n                i = count++;\n            }\n\n            if (i < length) {\n                values[i] = value;\n            }\n\n            if (count < length) {\n                return funcs[count]().then(next())\n            }\n        }\n    }\n};\n```\n. Actually, the real need is to be able to specify how many promises are allowed to run in parallel. Maybe .all() could receive one more argument?\n. Ah, your version is much better, thanks.\n\nMy understanding of promises was completely wrong in the second version, but what I actually mean is this:\n\n```\nrepeat = 5;\n\nvar tests = [];\nfor (var i = 0; i < repeat; ++i) {\n    tests.push(testspeed.bind(undefined, url));\n}\n\nQ.series(tests).then(function (speeds) {\n    console.log(speeds);\n});\n```\n\nWhen given an array of promise-generating functions, `Q.serial(array)` should fulfill promises serially. `Q.serial` is actually a specialized version of `Q.parallel(array, count)`, which should fulfill at most `count` promises in parallel.\n\nThis could potentially be useful, for example, when testing multiple servers, or requesting multiple files with xhr.\n\nHere is my initial stab at it:\n\n```\nQ.parallel = function (funcs, count) {\n    var length = funcs.length;\n    if (!length) {\n        return Q([]);\n    }\n\n    if (count == null) {\n        count = Infinity;\n    }\n\n    count = Math.max(count, 1);\n    count = Math.min(count, funcs.length);\n\n    var promises = [];\n    var values = [];\n    for (var i = 0; i < count; ++i) {\n        var promise = funcs[i]();\n        promise = promise.then(next(i));\n        promises.push(promise);\n    }\n\n    return Q.all(promises).then(function () {\n        return values;\n    });\n\n    function next(i) {\n        return function (value) {\n            if (i == null) {\n                i = count++;\n            }\n\n            if (i < length) {\n                values[i] = value;\n            }\n\n            if (count < length) {\n                return funcs[count]().then(next())\n            }\n        }\n    }\n};\n```\n. ",
    "nikcorg": "Wow. That was quick. Thanks! \n. Wow. That was quick. Thanks! \n. ",
    "chrisballinger": "@domenic Is there a toggle for this already?\n. @domenic Is there a toggle for this already?\n. ",
    "mattrobenolt": "I would like to suggest using a different property for a different type of stacktrace. :)\n\nTechnically, the err.stack does a lot of magic with the CallSite API, so in general, that could affect many things that utilize that.\n\nFor reference: https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n. I would like to suggest using a different property for a different type of stacktrace. :)\n\nTechnically, the err.stack does a lot of magic with the CallSite API, so in general, that could affect many things that utilize that.\n\nFor reference: https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n. ",
    "JPGygax68": "Thank you Robert, these look quite useful. But I do not see how they would avoid the problem that I'm having ? (a problem that is not caused by Q actually, but most probably by a limitation of V8)\n-- Jean-Pierre\n. Ah, I think I see the difference now. I should be able to apply this to my code using bind(). Thanks again, I'll report back the results here.\n. @reconbot I'm using 0.10.2. I just read issue #259, which explains what happened with my code. I think the issue will be resolved soon, so no worries. I'll leave the issue open for now to report success or failure as soon as an official fix or patch becomess available.\n. Thank you Robert, these look quite useful. But I do not see how they would avoid the problem that I'm having ? (a problem that is not caused by Q actually, but most probably by a limitation of V8)\n-- Jean-Pierre\n. Ah, I think I see the difference now. I should be able to apply this to my code using bind(). Thanks again, I'll report back the results here.\n. @reconbot I'm using 0.10.2. I just read issue #259, which explains what happened with my code. I think the issue will be resolved soon, so no worries. I'll leave the issue open for now to report success or failure as soon as an official fix or patch becomess available.\n. ",
    "reconbot": "@JPGygax68 what version of node are you using?\n. @JPGygax68 what version of node are you using?\n. ",
    "ravi": "Trivial question w.r.t naming: if the deferred.reject() has state \"rejected\", then shouldn't deferred.resolve() have state \"resolved\" and not \"fulfilled\"? (assuming I am reading this all correctly).\n. Until a fix is in, will this do?\n\n``` javascript\n// assume for the sake of example: f1 returns first\nQ.all( [ f1(), f2() ] )\n.then\n(\n    function f1win() {  }, // f1win() returns a promise\n    function f1fail() { },\n)\n.then\n(\n    null,\n    function catchall_fail(err)\n    {\n        // don't know what failed unless 'err' has some info\n        // but at least there will not be any unhandled rejections\n    }\n)\n.done();\n```\n. I was afraid I will have to walk the array. Okay, thank you.\n. @domenic that's neat, but am I reading it right: with your change, can I use Q.getUnhandledReasons() in one of the following then()s? \n. Ah, thanks for the clarification. So, with this patch, I can avoid (turn off) Q reporting an unhandled reject, but I cannot really catch/process second and further rejects generated by Q.all() calls.\n. Thank you Kris.\n. Trivial question w.r.t naming: if the deferred.reject() has state \"rejected\", then shouldn't deferred.resolve() have state \"resolved\" and not \"fulfilled\"? (assuming I am reading this all correctly).\n. Until a fix is in, will this do?\n\n``` javascript\n// assume for the sake of example: f1 returns first\nQ.all( [ f1(), f2() ] )\n.then\n(\n    function f1win() {  }, // f1win() returns a promise\n    function f1fail() { },\n)\n.then\n(\n    null,\n    function catchall_fail(err)\n    {\n        // don't know what failed unless 'err' has some info\n        // but at least there will not be any unhandled rejections\n    }\n)\n.done();\n```\n. I was afraid I will have to walk the array. Okay, thank you.\n. @domenic that's neat, but am I reading it right: with your change, can I use Q.getUnhandledReasons() in one of the following then()s? \n. Ah, thanks for the clarification. So, with this patch, I can avoid (turn off) Q reporting an unhandled reject, but I cannot really catch/process second and further rejects generated by Q.all() calls.\n. Thank you Kris.\n. ",
    "wizardwerdna": "That works fine, Essentially, when the first item comes, push it to the stack and nextTick a handler that runs callback and any new callbacks stacked up as a result until the stack is empty again, returning.  Its not unlike using a trampoline to avoid tail-recursion.  Of course, this might take unbounded time, and care should be taken to avoid starving the event loop.  \n\nThere are a number of other solutions, but I am not familiar enough with Q's codebase to make recommendations.  setImmediate works for sure, but you pay the price of nextTick v. setImmediate.  With the private queue, you have some additional cost of managing the trampoline.  This is one of those code-and-measure problems, I suppose, but my first thought was to get Q back onto the \"it just works\" stage.\n. One last thing about the nextTick handler, you must manage a race condition that deals with the case where the handler has popped the last item off the stack, so that the last callback doesn't trigger off a new handler until the first has returned.\n. I am going back and forth until I have the time to build a meaningful test scaffold to compare.  Here is a [gist for the plugin equivalent for nextTick](https://gist.github.com/wizardwerdna/5328792) I referred to earlier. The enqueue function, when substituted everywhere in the program for nextTick will assure that nextTick will be used and never nested more than once, retaining the sequencing semantics.  I have no idea whether it is better/faster or even correct, but it was a quick and interesting hack.\n\nI'd love any thoughts you might have.\n. That works fine, Essentially, when the first item comes, push it to the stack and nextTick a handler that runs callback and any new callbacks stacked up as a result until the stack is empty again, returning.  Its not unlike using a trampoline to avoid tail-recursion.  Of course, this might take unbounded time, and care should be taken to avoid starving the event loop.  \n\nThere are a number of other solutions, but I am not familiar enough with Q's codebase to make recommendations.  setImmediate works for sure, but you pay the price of nextTick v. setImmediate.  With the private queue, you have some additional cost of managing the trampoline.  This is one of those code-and-measure problems, I suppose, but my first thought was to get Q back onto the \"it just works\" stage.\n. One last thing about the nextTick handler, you must manage a race condition that deals with the case where the handler has popped the last item off the stack, so that the last callback doesn't trigger off a new handler until the first has returned.\n. I am going back and forth until I have the time to build a meaningful test scaffold to compare.  Here is a [gist for the plugin equivalent for nextTick](https://gist.github.com/wizardwerdna/5328792) I referred to earlier. The enqueue function, when substituted everywhere in the program for nextTick will assure that nextTick will be used and never nested more than once, retaining the sequencing semantics.  I have no idea whether it is better/faster or even correct, but it was a quick and interesting hack.\n\nI'd love any thoughts you might have.\n. ",
    "tgriesser": "For node, at least, would it make sense to default `longStack` based on a specified environment variable (e.g. `process.env.NODE_ENV`) if it's not explicitly set? Otherwise (correct me if I'm wrong here) if you're consuming `q` as part of a library, you'd need to tell the user to set this property themselves, as you wouldn't want to mess with any default setting they may have specified if they're using `q` elsewhere in their application, but you'd probably want to make sure it was turned off in production for performance.\n. For node, at least, would it make sense to default `longStack` based on a specified environment variable (e.g. `process.env.NODE_ENV`) if it's not explicitly set? Otherwise (correct me if I'm wrong here) if you're consuming `q` as part of a library, you'd need to tell the user to set this property themselves, as you wouldn't want to mess with any default setting they may have specified if they're using `q` elsewhere in their application, but you'd probably want to make sure it was turned off in production for performance.\n. ",
    "pelicanorojo": "Great! I am using q with mocha and phantomjs, and also in my application in parallel load synchronization.\n. Great! I am using q with mocha and phantomjs, and also in my application in parallel load synchronization.\n. ",
    "kitcambridge": "The problem is that the `onResolved` handler (in this case, `loadBody`) is called on the subsequent tick\u2014so the first `data` event has already been triggered. You'll want to have the `httpGet` function handle the body collection.\n. `Q.allNamed`?\n. @theduderog Yep, that's intentional\u2014Promises/A+ mandates [async resolution](http://promisesaplus.com/#notes) (see note 4.1), so they're not compatible with the legacy streams interface. If you're using Node 0.10, though, you can use `streams2`:\n\n``` javascript\nvar onConnectionDeferred = q.defer();\n\n//Let observers know that connection has been established\n//Observers should be guaranteed that their callbacks will be executed before any 'data' events are dispatched\nvar req = http.request(options, function(res) {\n  onConnectionDeferred.resolve(res);\n\n  res.on('readable', function() {\n    var chunk = res.read();\n    if (!chunk)\n      return;\n\n    console.log('BODY: ' + chunk);\n  });\n});\n\nonConnectionDeferred.promise.then(function (res) {\n  // Set some state here that must be set before 'data' events are processed\n});\n```\n\nThis will buffer incoming data until you are ready to consume it.\n. Check out [`.done()`](https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-onprogress).\n. I think this is by design\u2014promises are meant to parallel synchronous code, and a function can't return, throw, or `yield` multiple values. The closest it can come is returning an array of values.\n\n**Edit**: Ninja'd by @domenic.\n. No worries. It can be tricky, especially if you're coming from an implementation that supports multiple fulfillment or rejection values (like jQuery's `Deferred`s).\n. Is this in Node?\n. Node's `console.log` function uses [`util.inspect`](http://nodejs.org/api/util.html#util_util_inspect_object_options) to serialize objects, which will delegate to an object's `inspect` method if defined. Try it out:\n\n``` js\nvar p = { 'inspect': function(){ return 'Hello, world!'; } };\nconsole.log(p);\n// => Hello, world!\n```\n\nQ does define a [`Promise#inspect`](https://github.com/kriskowal/q/blob/master/q.js#L531-535) method, but it returns an object, not a string\u2014try running `console.log(x.inspect())`. `util.inspect` then implicitly coerces that object to a string (i.e., `String(x.inspect()) == '[object Object]'`).\n. @domenic Nice! I was going to suggest adding `Promise#toJSON` as a kludgy workaround, but the fix in joyent/node@66280de133a56964641a08291b06fc0e5ca2b4e1 makes it unnecessary.\n. I think you're looking for `#nodeify()`.\n. It looks like Sequelize already [supports promises](https://github.com/sequelize/sequelize/blob/master/lib/emitters/custom-event-emitter.js#L138-148). What happens if you run this?\n\n``` js\ndb.transaction.then(function transactionFulfilled(t) {\n  console.log(\"got transaction\");\n});\n```\n. This was discussed before in #440\u2026it came down to avoiding overloading.\n. `$.Deferred#promise()` is a function\u2014your example runs correctly if you change line 14 to `return deferred.promise()`.\n. Yup, you can write either `return result` or `return result.promise()`\u2014but not `return result.promise`. From the link:\n\n``` js\nfunction foo() {\n    var result = $.Deferred();\n    result.resolve(10);\n    return result; // or\n    return result.promise();\n}\n```\n. Or `Object.prototype.toString.call(process) == '[object process]'`...\n. The problem is that the `onResolved` handler (in this case, `loadBody`) is called on the subsequent tick\u2014so the first `data` event has already been triggered. You'll want to have the `httpGet` function handle the body collection.\n. `Q.allNamed`?\n. @theduderog Yep, that's intentional\u2014Promises/A+ mandates [async resolution](http://promisesaplus.com/#notes) (see note 4.1), so they're not compatible with the legacy streams interface. If you're using Node 0.10, though, you can use `streams2`:\n\n``` javascript\nvar onConnectionDeferred = q.defer();\n\n//Let observers know that connection has been established\n//Observers should be guaranteed that their callbacks will be executed before any 'data' events are dispatched\nvar req = http.request(options, function(res) {\n  onConnectionDeferred.resolve(res);\n\n  res.on('readable', function() {\n    var chunk = res.read();\n    if (!chunk)\n      return;\n\n    console.log('BODY: ' + chunk);\n  });\n});\n\nonConnectionDeferred.promise.then(function (res) {\n  // Set some state here that must be set before 'data' events are processed\n});\n```\n\nThis will buffer incoming data until you are ready to consume it.\n. Check out [`.done()`](https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-onprogress).\n. I think this is by design\u2014promises are meant to parallel synchronous code, and a function can't return, throw, or `yield` multiple values. The closest it can come is returning an array of values.\n\n**Edit**: Ninja'd by @domenic.\n. No worries. It can be tricky, especially if you're coming from an implementation that supports multiple fulfillment or rejection values (like jQuery's `Deferred`s).\n. Is this in Node?\n. Node's `console.log` function uses [`util.inspect`](http://nodejs.org/api/util.html#util_util_inspect_object_options) to serialize objects, which will delegate to an object's `inspect` method if defined. Try it out:\n\n``` js\nvar p = { 'inspect': function(){ return 'Hello, world!'; } };\nconsole.log(p);\n// => Hello, world!\n```\n\nQ does define a [`Promise#inspect`](https://github.com/kriskowal/q/blob/master/q.js#L531-535) method, but it returns an object, not a string\u2014try running `console.log(x.inspect())`. `util.inspect` then implicitly coerces that object to a string (i.e., `String(x.inspect()) == '[object Object]'`).\n. @domenic Nice! I was going to suggest adding `Promise#toJSON` as a kludgy workaround, but the fix in joyent/node@66280de133a56964641a08291b06fc0e5ca2b4e1 makes it unnecessary.\n. I think you're looking for `#nodeify()`.\n. It looks like Sequelize already [supports promises](https://github.com/sequelize/sequelize/blob/master/lib/emitters/custom-event-emitter.js#L138-148). What happens if you run this?\n\n``` js\ndb.transaction.then(function transactionFulfilled(t) {\n  console.log(\"got transaction\");\n});\n```\n. This was discussed before in #440\u2026it came down to avoiding overloading.\n. `$.Deferred#promise()` is a function\u2014your example runs correctly if you change line 14 to `return deferred.promise()`.\n. Yup, you can write either `return result` or `return result.promise()`\u2014but not `return result.promise`. From the link:\n\n``` js\nfunction foo() {\n    var result = $.Deferred();\n    result.resolve(10);\n    return result; // or\n    return result.promise();\n}\n```\n. Or `Object.prototype.toString.call(process) == '[object process]'`...\n. ",
    "stefanpoeter": "And how would you do it with async tests.\n\n```\nit('Should test something', function (done) {\n\n    var req = someRequest,\n          mock = sinon.mock(response),\n          stub = sinon.stub(stubObject, 'method');\n\n      stub.withArgs('foo').returns(Q.resolve(5));\n\n      mock.expects('bar').once().withArgs(200);\n\n      request(req, response);\n\n      mock.verify();\n});\n```\n\nWhen could I call done()?\n. The problem is, that once I return the promise the resolve and reject callbacks are not getting called directly. When I put a \n\n```\nprocess.nextTick(function () {\n    mock.verify();\n    done();\n});\n```\n\nat the end of the test it works for unchained promisses. Basically I think testing promisses wrapped in no-promisse-structured functions is a bit tricky. What do you think?\n. And how would you do it with async tests.\n\n```\nit('Should test something', function (done) {\n\n    var req = someRequest,\n          mock = sinon.mock(response),\n          stub = sinon.stub(stubObject, 'method');\n\n      stub.withArgs('foo').returns(Q.resolve(5));\n\n      mock.expects('bar').once().withArgs(200);\n\n      request(req, response);\n\n      mock.verify();\n});\n```\n\nWhen could I call done()?\n. The problem is, that once I return the promise the resolve and reject callbacks are not getting called directly. When I put a \n\n```\nprocess.nextTick(function () {\n    mock.verify();\n    done();\n});\n```\n\nat the end of the test it works for unchained promisses. Basically I think testing promisses wrapped in no-promisse-structured functions is a bit tricky. What do you think?\n. ",
    "badunk": "sure, I can get to that tonight\n. Yikes..looks like a firebug bug with async + breakpoints (https://code.google.com/p/fbug/issues/detail?id=1830).  I cannot reproduce the behavior w/ a test - q works as expected in the situation I posed.  The same test in chrome passes.\n\nBasically, the bug is that time doesn't freeze during breakpoints in firebug.  Any code placed in setTimeout for a duration past the time you've set a breakpoint for does not execute.  For example:\n\n``` javascript\nsetTimeout(function(){\n    console.log('should show after 5 seconds'); // does not necessarily show if breakpoint duration is > 5 sec\n}, 5000);\nconsole.log('set your breakpoint here);\n```\n\nNot a q issue, thanks for the quick response though :)\n. sure, I can get to that tonight\n. Yikes..looks like a firebug bug with async + breakpoints (https://code.google.com/p/fbug/issues/detail?id=1830).  I cannot reproduce the behavior w/ a test - q works as expected in the situation I posed.  The same test in chrome passes.\n\nBasically, the bug is that time doesn't freeze during breakpoints in firebug.  Any code placed in setTimeout for a duration past the time you've set a breakpoint for does not execute.  For example:\n\n``` javascript\nsetTimeout(function(){\n    console.log('should show after 5 seconds'); // does not necessarily show if breakpoint duration is > 5 sec\n}, 5000);\nconsole.log('set your breakpoint here);\n```\n\nNot a q issue, thanks for the quick response though :)\n. ",
    "blalor": "On Apr 20, 2013, at 10:24 PM, Robert Kati\u0107 notifications@github.com wrote:\n\n> I will take a look on this from Monday. For now I have two main suspects: 1) a minifier that makes some wrong assumptions when queuedTasks is incremented (unlikely); 2) a problematic custom implementation of setTimeout (some multithreading issues). However, I am not familiar with Rhino and showing the respective code would certainly help.\n\nI'm not using the minified version.  I have tried a couple of different setTimeout versions (both thread-based, unfortunately; one with java.util.Timer, one with with a new Thread and Thread.sleep) and both have consistently had problems around this task queue.  I do strongly suspect a threading issue, however the exceptions I'm seeing happen so frequently in this spot that I thought it worth mentioning.  Don't spend much time on this; I just thought maybe more experienced eyes might see something obvious.  I'll see if I can come up with a test case.  I've abandoned the Jasmine JUnit runner I was using because of this problem, but I don't blame Q.\n. On Apr 20, 2013, at 10:24 PM, Robert Kati\u0107 notifications@github.com wrote:\n\n> I will take a look on this from Monday. For now I have two main suspects: 1) a minifier that makes some wrong assumptions when queuedTasks is incremented (unlikely); 2) a problematic custom implementation of setTimeout (some multithreading issues). However, I am not familiar with Rhino and showing the respective code would certainly help.\n\nI'm not using the minified version.  I have tried a couple of different setTimeout versions (both thread-based, unfortunately; one with java.util.Timer, one with with a new Thread and Thread.sleep) and both have consistently had problems around this task queue.  I do strongly suspect a threading issue, however the exceptions I'm seeing happen so frequently in this spot that I thought it worth mentioning.  Don't spend much time on this; I just thought maybe more experienced eyes might see something obvious.  I'll see if I can come up with a test case.  I've abandoned the Jasmine JUnit runner I was using because of this problem, but I don't blame Q.\n. ",
    "jwagner": "@domenic http://jsfiddle.net/t22MN/\nResults in:\n\n```\n[Q] Unhandled rejection reasons (should be empty): [] \n```\n\nFails in Chrome 28/dev, works in Firefox 20.\n. Sorry, I wasn't very clear about this.\n\nIn Chrome 27 and 28 I get the following output using kriskowal/q:\n\n```\n[Q] Unhandled rejection reasons (should be empty): [] \n```\n\n(It seems to make a deep copy of the objects in console.warn)\n\nAfter your change (https://rawgithub.com/domenic/q/master/q.js) I get\n\n```\n[Q] Unhandled rejection reasons (should be empty): [\"random reason\"] \n```\n\nWhich is what I expect. :+1: \n\nIn Firefox 20 I get:\n\n```\n[10:57:23.282] [Q] Unhandled rejection reasons (should be empty): [\"random reason\"]\n```\n\nIn Firefox nightly I get:\n\n```\n[10:55:05.027] \"[Q] Unhandled rejection reasons (should be empty):\" [object Proxy]\n```\n\nAnd for some reason I can't inspect the Proxy. But I guess this is just a work in progress in Firefox.\n. @domenic http://jsfiddle.net/t22MN/\nResults in:\n\n```\n[Q] Unhandled rejection reasons (should be empty): [] \n```\n\nFails in Chrome 28/dev, works in Firefox 20.\n. Sorry, I wasn't very clear about this.\n\nIn Chrome 27 and 28 I get the following output using kriskowal/q:\n\n```\n[Q] Unhandled rejection reasons (should be empty): [] \n```\n\n(It seems to make a deep copy of the objects in console.warn)\n\nAfter your change (https://rawgithub.com/domenic/q/master/q.js) I get\n\n```\n[Q] Unhandled rejection reasons (should be empty): [\"random reason\"] \n```\n\nWhich is what I expect. :+1: \n\nIn Firefox 20 I get:\n\n```\n[10:57:23.282] [Q] Unhandled rejection reasons (should be empty): [\"random reason\"]\n```\n\nIn Firefox nightly I get:\n\n```\n[10:55:05.027] \"[Q] Unhandled rejection reasons (should be empty):\" [object Proxy]\n```\n\nAnd for some reason I can't inspect the Proxy. But I guess this is just a work in progress in Firefox.\n. ",
    "AlexGalays": "I would find it nice if all the nodeJS related code was optional too...  Many developers still use Js only in the browser :)\n. I would find it nice if all the nodeJS related code was optional too...  Many developers still use Js only in the browser :)\n. ",
    "lfac-pt": "@kriskowal That sounds really interesting! Extensible how?\n. @kriskowal That is exactly the kind of thing that would be really useful to me right now. My current approach to achieve that kind of functionality is to create a normal promise and then add some methods to it, which is very lame.\n. Awesome!\n\nBTW, the primitive non-objects prototype change edge-case was a very good catch. You, Sir, are a Pro!\n. A link at the top of readme to the reference would be very good indeed (and convenient for me).\n. On the top one you have `Uploader.retrieveVideoState` and on the other `ytUploader.retrieveVideoState`, ins't the typo the reason why it's failing?\n\nAlso, if are not using the resulting promise for anything, the last `.then` could be replaced with `.done` and with that unhanded exceptions would be printed on the console.\n. @kriskowal That sounds really interesting! Extensible how?\n. @kriskowal That is exactly the kind of thing that would be really useful to me right now. My current approach to achieve that kind of functionality is to create a normal promise and then add some methods to it, which is very lame.\n. Awesome!\n\nBTW, the primitive non-objects prototype change edge-case was a very good catch. You, Sir, are a Pro!\n. A link at the top of readme to the reference would be very good indeed (and convenient for me).\n. On the top one you have `Uploader.retrieveVideoState` and on the other `ytUploader.retrieveVideoState`, ins't the typo the reason why it's failing?\n\nAlso, if are not using the resulting promise for anything, the last `.then` could be replaced with `.done` and with that unhanded exceptions would be printed on the console.\n. ",
    "bernii": "Sure thing. I did setup most of the things so basically you should only merge commit and replace my keys/username.\n\nHere is detailed info:\n1. You should have created Open Sauce account. Go to your account page at https://saucelabs.com/account and copy your _ACCESS KEY_ (lower left corner)\n3. Encrypt your Sauce Labs username and access key with **travis** tool (detailed info here: http://about.travis-ci.org/docs/user/encryption-keys/):\n3a. travis encrypt SAUCE_USERNAME=your-username\n3b. travis encrypt SAUCE_ACCESS_KEY=sauce-access-key \n4. Replace keys that I've provided (in .travis.yml) with the ones you generated  https://github.com/bernii/q/blob/master/.travis.yml \n5. Your're ready, you should be able to run **grunt test** to check if everything works.\n6. You should also edit README.md (https://raw.github.com/bernii/q/master/README.md) and replace _(https://saucelabs.com/buildstatus/berni_q)](https://saucelabs.com/u/berni_q)_ with your username there. \n7. When you push you should see that Travis CI is running browser tests against Sauce.\n\nSome extra info here: https://saucelabs.com/opensource/travis but you don't need it ;-)\n. @kriskowal might this be connected to today issues with npm? I saw a lot of people complaining that npm is failing today. I just did a successful `npm install` on my machine inside the project dir.\n. Sure thing. I did setup most of the things so basically you should only merge commit and replace my keys/username.\n\nHere is detailed info:\n1. You should have created Open Sauce account. Go to your account page at https://saucelabs.com/account and copy your _ACCESS KEY_ (lower left corner)\n3. Encrypt your Sauce Labs username and access key with **travis** tool (detailed info here: http://about.travis-ci.org/docs/user/encryption-keys/):\n3a. travis encrypt SAUCE_USERNAME=your-username\n3b. travis encrypt SAUCE_ACCESS_KEY=sauce-access-key \n4. Replace keys that I've provided (in .travis.yml) with the ones you generated  https://github.com/bernii/q/blob/master/.travis.yml \n5. Your're ready, you should be able to run **grunt test** to check if everything works.\n6. You should also edit README.md (https://raw.github.com/bernii/q/master/README.md) and replace _(https://saucelabs.com/buildstatus/berni_q)](https://saucelabs.com/u/berni_q)_ with your username there. \n7. When you push you should see that Travis CI is running browser tests against Sauce.\n\nSome extra info here: https://saucelabs.com/opensource/travis but you don't need it ;-)\n. @kriskowal might this be connected to today issues with npm? I saw a lot of people complaining that npm is failing today. I just did a successful `npm install` on my machine inside the project dir.\n. ",
    "necolas": "Fortunately you don't have to do anything specific to provide basic Bower support. It's already there. However, for all the people already installing q with Bower, the use of ignores would be beneficial. Are you still strongly opposed to catering to client-side package managers? If you have any feedback you'd like to share with those of us working on Bower, please let me know :).  Thanks\n. Fortunately you don't have to do anything specific to provide basic Bower support. It's already there. However, for all the people already installing q with Bower, the use of ignores would be beneficial. Are you still strongly opposed to catering to client-side package managers? If you have any feedback you'd like to share with those of us working on Bower, please let me know :).  Thanks\n. ",
    "loveencounterflow": "that's good news! could i easily patch / configure q right now to opt-out? not sure whether i'd obtain meaningful stacktraces with other tools when using promises, but i'm going to use q and want to have colorized stacktraces with source excerpts. the thing is that q makes it impossible for me to use `process.on 'uncaughtException'`, so my callback function never gets called (btw isn't that a bug in itself? those errors are not 'handled' just because they are 'expanded'...\n. ok i stand corrected. created a gist for this one: https://gist.github.com/loveencounterflow/5536720 . it is https://github.com/veged/coa after all who does something... not sure what. the stacktrace you get from test_2() with longjohn activated (so here i was wrong: that part did work) has so many mentions of q high up in the trace, i thought it must be q. now i have to hunt down why longjohn can do its work but my own event handler never gets called. it's a mystery.\n. that's good news! could i easily patch / configure q right now to opt-out? not sure whether i'd obtain meaningful stacktraces with other tools when using promises, but i'm going to use q and want to have colorized stacktraces with source excerpts. the thing is that q makes it impossible for me to use `process.on 'uncaughtException'`, so my callback function never gets called (btw isn't that a bug in itself? those errors are not 'handled' just because they are 'expanded'...\n. ok i stand corrected. created a gist for this one: https://gist.github.com/loveencounterflow/5536720 . it is https://github.com/veged/coa after all who does something... not sure what. the stacktrace you get from test_2() with longjohn activated (so here i was wrong: that part did work) has so many mentions of q high up in the trace, i thought it must be q. now i have to hunt down why longjohn can do its work but my own event handler never gets called. it's a mystery.\n. ",
    "wingo": "I tested this with FireFox and the js-1.7 directory.  For ES6 I tested with a fresh Chrome build, hacked to use bleeding_edge v8, run with --harmony.\n. It almost goes without stating, but not quite, so just to mention I'm happy to make any changes you suggest.  I'm not really familiar with Q and am actually quite a bad JS programmer ;) so it's likely I didn't do things quite right.\n\nWill take a look in the euro-morning.  Cheers.\n. I tested this with FireFox and the js-1.7 directory.  For ES6 I tested with a fresh Chrome build, hacked to use bleeding_edge v8, run with --harmony.\n. It almost goes without stating, but not quite, so just to mention I'm happy to make any changes you suggest.  I'm not really familiar with Q and am actually quite a bad JS programmer ;) so it's likely I didn't do things quite right.\n\nWill take a look in the euro-morning.  Cheers.\n. ",
    "aaylward": "adding a .done() will fix your problem\n\nQ = require('q');\ndef = Q.defer();\ndef.promise.then(function(val) { assert(false) }).done();\ndef.resolve(1);\n. @domenic you type fast!\n. `promiseMeSomething` should return a promise.\n. Well, your example results in a TypeError because your `promiseMeSomething` doesn't return a promise (or at least a then-able).\n\n```\nTypeError: Object some,results has no method 'then'\n```\n\nThe examples should be as simple as possible, but not simpler.\n. It might make sense to include a small section in the tutorial for jQuery users though. Something like:\n\n```\nfunction promiseMeContent() {\n   return Q(jQuery.get('/some/sweet/content'));\n}\n```\n. That'll do it.\n. @kriskowal my pleasure. This is quite a cool library you have here!\n. Where did you find your version of Q? I just did a fresh install from npm, and it's working fine here.\n\nA possible source of confusion may be that even if `deferred.promise` is a promise, the value of `console.log(deferred.promise)` is `undefined`. Could this be related to your issue?\n. With node 0.10.7 and Q 0.9.6:\n\n``` javascript\n> var promise = require('q').defer().promise\nundefined\n> promise.then\n[Function]\n```\n\nEverything appears to be working correctly. What happens when you do this?\n. adding a .done() will fix your problem\n\nQ = require('q');\ndef = Q.defer();\ndef.promise.then(function(val) { assert(false) }).done();\ndef.resolve(1);\n. @domenic you type fast!\n. `promiseMeSomething` should return a promise.\n. Well, your example results in a TypeError because your `promiseMeSomething` doesn't return a promise (or at least a then-able).\n\n```\nTypeError: Object some,results has no method 'then'\n```\n\nThe examples should be as simple as possible, but not simpler.\n. It might make sense to include a small section in the tutorial for jQuery users though. Something like:\n\n```\nfunction promiseMeContent() {\n   return Q(jQuery.get('/some/sweet/content'));\n}\n```\n. That'll do it.\n. @kriskowal my pleasure. This is quite a cool library you have here!\n. Where did you find your version of Q? I just did a fresh install from npm, and it's working fine here.\n\nA possible source of confusion may be that even if `deferred.promise` is a promise, the value of `console.log(deferred.promise)` is `undefined`. Could this be related to your issue?\n. With node 0.10.7 and Q 0.9.6:\n\n``` javascript\n> var promise = require('q').defer().promise\nundefined\n> promise.then\n[Function]\n```\n\nEverything appears to be working correctly. What happens when you do this?\n. ",
    "Lacrymology": "fantastic, thank you for the fast response!\n. If I wanted to handle an error somehow (say logging) and then let it keep bubbling, should I do something like this, right?\n\n```\npromise.then(handler, function(error) {\n    console.error(error);\n    throw error;\n})\n```\n. We have code using promises that was **very** poorly designed, we didn't understand promises correctly yet, and it's all very intrincate, you can see it here https://github.com/inaes-tic/melted-node/blob/master/melted-node.js\n\nYou can see two different promises are created and the handlers used to resolve or fail the one returned to the caller. I'm trying to create a single deferred and pass it around and resolve or reject it as suitable\n. is there a mailing list or something where I can ask about usage details?\n. fantastic, thank you for the fast response!\n. If I wanted to handle an error somehow (say logging) and then let it keep bubbling, should I do something like this, right?\n\n```\npromise.then(handler, function(error) {\n    console.error(error);\n    throw error;\n})\n```\n. We have code using promises that was **very** poorly designed, we didn't understand promises correctly yet, and it's all very intrincate, you can see it here https://github.com/inaes-tic/melted-node/blob/master/melted-node.js\n\nYou can see two different promises are created and the handlers used to resolve or fail the one returned to the caller. I'm trying to create a single deferred and pass it around and resolve or reject it as suitable\n. is there a mailing list or something where I can ask about usage details?\n. ",
    "Constellation": "Thanks :)\n. Yeah, right.\nThis is the logic checking current JS engine supports ES6 generator.\n\nOn Sun, May 19, 2013 at 2:34 AM, Domenic Denicola\nnotifications@github.comwrote:\n\n> Thanks, merged as 1c024d5https://github.com/kriskowal/q/commit/1c024d5721f3179e76051ea71ce3851e8feb0a0a\n> .\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/293#issuecomment-18104957\n> .\n\n## \n\nRegards,\nYusuke Suzuki\n. Thanks :)\n. Yeah, right.\nThis is the logic checking current JS engine supports ES6 generator.\n\nOn Sun, May 19, 2013 at 2:34 AM, Domenic Denicola\nnotifications@github.comwrote:\n\n> Thanks, merged as 1c024d5https://github.com/kriskowal/q/commit/1c024d5721f3179e76051ea71ce3851e8feb0a0a\n> .\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/pull/293#issuecomment-18104957\n> .\n\n## \n\nRegards,\nYusuke Suzuki\n. ",
    "fresheneesz": "I think I second this. The reference is very good. The readme here is less so. The reference needs a link at the _top_ of the page, and most of the tutorial stuff should be split off into a separate page as well (like on the wiki). The readme should contain some starter information - enough to be able to easily understand the reference. Everything else needs to go somewhere else.\n. So, in the last day or so, I created a pretty full featured core async library. The concepts in the library are based on Q and fibers/future, though I didn't reuse any of Q's code. I don't want to reinvent all the wheels, but this is one that seemed like needed it. I'd appreciate any feedback.\n\nhttps://github.com/fresheneesz/nodejsUtils/blob/master/asyncFuture.js\nTests: https://github.com/fresheneesz/nodejsUtils/blob/master/tests/asyncFuturesTest.js\n. So btw, I take back what I said about timeout. Timeout (or some way to cancel the future callback) seems like a pretty basic feature to me now. Do you have any interest in reviewing my work at all?\n. Thanks kris, thats a really helpful document. After reading through it, I don't think it mentioned any corner cases i've missed - tho I'm not doing anything related to arbitrary message passing. Two of the major difference in my implementation is that the promise and deferred is merged (forgoing tho not disabling, the ability to distinguish \"authority\"), and a promise can't be resolved more than once (doing so will throw an error). Since a promise can't be resolved twice, the problems solved by reducing \"authority\" are moot - hijacking the promise means you create a bug that needs to be fixed, not a silent error. \n\nI would have used Q, by the way, were I able to resolve promises with full authority. Because I couldn't, it made it much harder to develop the API I wanted with Q.\n. I think I second this. The reference is very good. The readme here is less so. The reference needs a link at the _top_ of the page, and most of the tutorial stuff should be split off into a separate page as well (like on the wiki). The readme should contain some starter information - enough to be able to easily understand the reference. Everything else needs to go somewhere else.\n. So, in the last day or so, I created a pretty full featured core async library. The concepts in the library are based on Q and fibers/future, though I didn't reuse any of Q's code. I don't want to reinvent all the wheels, but this is one that seemed like needed it. I'd appreciate any feedback.\n\nhttps://github.com/fresheneesz/nodejsUtils/blob/master/asyncFuture.js\nTests: https://github.com/fresheneesz/nodejsUtils/blob/master/tests/asyncFuturesTest.js\n. So btw, I take back what I said about timeout. Timeout (or some way to cancel the future callback) seems like a pretty basic feature to me now. Do you have any interest in reviewing my work at all?\n. Thanks kris, thats a really helpful document. After reading through it, I don't think it mentioned any corner cases i've missed - tho I'm not doing anything related to arbitrary message passing. Two of the major difference in my implementation is that the promise and deferred is merged (forgoing tho not disabling, the ability to distinguish \"authority\"), and a promise can't be resolved more than once (doing so will throw an error). Since a promise can't be resolved twice, the problems solved by reducing \"authority\" are moot - hijacking the promise means you create a bug that needs to be fixed, not a silent error. \n\nI would have used Q, by the way, were I able to resolve promises with full authority. Because I couldn't, it made it much harder to develop the API I wanted with Q.\n. ",
    "sobotklp": "We've been using q@0.8.2 for a moderately large API (~800 reqs/sec) with persistent websocket connections. Upon upgrading to q@0.9.4, we noticed a ~400% increase in CPU use as well as leaking memory. Aside from using Q.fcall() instead of Q.call(), there were no changes to the way we're using Q promises. Unfortunately, we couldn't find a fix for those issues other than reverting to the older version of q.\n. @domenic cool thanks! :) I'll give that a try.\n. We've been using q@0.8.2 for a moderately large API (~800 reqs/sec) with persistent websocket connections. Upon upgrading to q@0.9.4, we noticed a ~400% increase in CPU use as well as leaking memory. Aside from using Q.fcall() instead of Q.call(), there were no changes to the way we're using Q promises. Unfortunately, we couldn't find a fix for those issues other than reverting to the older version of q.\n. @domenic cool thanks! :) I'll give that a try.\n. ",
    "wavded": "Another potential typo thing that may be an issue, shouldn't:\n\n``` js\npromises.push[ytUploader.retrieveVideoState({videoId: video.videoId})]\n```\n\nBe:\n\n``` js\npromises.push(ytUploader.retrieveVideoState({videoId: video.videoId}))\n```\n. Happens to us all, glad you are back up and :running: \n. @gavreh valueOf was deprecated in, I believe, v0.9.5, you can now call `promise.inspect()` which returns an object that has `value` as one of its properties if a value is known and it wasn't rejected, more info at: https://github.com/kriskowal/q/wiki/API-Reference#promiseinspect\n. +1 - nice example @ForbesLindesay !\n. AFAIK, @guyonroche this is the intended behavior, you sound like you are looking for the `any` method.  I was just reading about this over in the Bluebird issue tracker: https://github.com/petkaantonov/bluebird/issues/55\n\nA comment of note that differentiates the behaviors: https://github.com/petkaantonov/bluebird/issues/55#issuecomment-31200242\n. ahh, thx.. wondered if there was a correlation with gtor repo.\n. Another potential typo thing that may be an issue, shouldn't:\n\n``` js\npromises.push[ytUploader.retrieveVideoState({videoId: video.videoId})]\n```\n\nBe:\n\n``` js\npromises.push(ytUploader.retrieveVideoState({videoId: video.videoId}))\n```\n. Happens to us all, glad you are back up and :running: \n. @gavreh valueOf was deprecated in, I believe, v0.9.5, you can now call `promise.inspect()` which returns an object that has `value` as one of its properties if a value is known and it wasn't rejected, more info at: https://github.com/kriskowal/q/wiki/API-Reference#promiseinspect\n. +1 - nice example @ForbesLindesay !\n. AFAIK, @guyonroche this is the intended behavior, you sound like you are looking for the `any` method.  I was just reading about this over in the Bluebird issue tracker: https://github.com/petkaantonov/bluebird/issues/55\n\nA comment of note that differentiates the behaviors: https://github.com/petkaantonov/bluebird/issues/55#issuecomment-31200242\n. ahh, thx.. wondered if there was a correlation with gtor repo.\n. ",
    "wychi": "A little modification.\nIt works as you expected.\n\n``` javascript\nvar Q = require(\"q\");\n\nfunction promiseLog(message) {\n    return function() {\n        return Q.fcall(function() {\n            console.log(message);\n        });\n    }\n}\n\npromiseLog(\"a\")()\n.then(promiseLog(\"b\"))\n.then(function() {\n    return promiseLog(\"c\")()\n              .then(promiseLog(\"d\"));\n})\n.then(promiseLog(\"e\"));\n```\n. A little modification.\nIt works as you expected.\n\n``` javascript\nvar Q = require(\"q\");\n\nfunction promiseLog(message) {\n    return function() {\n        return Q.fcall(function() {\n            console.log(message);\n        });\n    }\n}\n\npromiseLog(\"a\")()\n.then(promiseLog(\"b\"))\n.then(function() {\n    return promiseLog(\"c\")()\n              .then(promiseLog(\"d\"));\n})\n.then(promiseLog(\"e\"));\n```\n. ",
    "fschwiet": "Thanks for the help everyone, it does make sense now.\n. Thanks for the help everyone, it does make sense now.\n. ",
    "prajwalkman": "Oh that damn ruby map confusion.\n. Oh that damn ruby map confusion.\n. ",
    "jlongster": "Oh man, I didn't realize I wasn't watching this repo so I didn't see any of your comments. I think github should show notifications for PRs opened by you...\n\nThis has been merged, so I assume that you cleaned up the code afterwards? Do you want me to write any more tests?\n. Yeah, I can see why you would be hesitant about it. I would argue that generators themselves are a lot of \"magic\", and this is a tiny extension that doesn't add much more. Using generators, assuming that `yield x` transforms to `Q.resolve(x)` is the same exact magic. Adding just a few more transformations make them immensely more useful, and we just a need a small list that describes the available transformations. @domenic, in your above example, I would say that if it doesn't match a few special types of objects, that it simply defaults to `Q.resolve`.\n\nI'm not extremely passionate about it though, since this doesn't concern APIs or composability, but just app-level code, and it would be pretty easy to do this in another library if a lot of people really find it useful.\n. > Particularly, all will become suitable for generically waiting either for an \"iterable\" of promises to all be fulfilled, or pass non-iterables through. That\u2019ll cover arrays, generators, iterators, and promise queues, and pass everything else through.\n\nThat's very cool. So `Q.all` is similar too `Q.spawn` for generators, except it doesn't imply `done()` at the end. Is this how my above code would look?\n\n``` js\nQ.spawn(function*() {\n    var ids = [1, 2, 3];\n    var transactions = yield Q.map(ids, function(id) { return Q.all(getTransaction(id)); });\n\n    // ...\n});\n```\n\nIt's still unfortunate that I have to wrap any calls to generators with `Q.all`, but it's not that bad.\n. > I\u2019m running into much broader problems with this effort in general.\n\nIt'd be neat if you had a short example that shows those problems, for us that don't have as much context on what's going on. It looks highly interesting, and it'd be sad if it's too hard! But I trust your caution.\n. Oh man, I didn't realize I wasn't watching this repo so I didn't see any of your comments. I think github should show notifications for PRs opened by you...\n\nThis has been merged, so I assume that you cleaned up the code afterwards? Do you want me to write any more tests?\n. Yeah, I can see why you would be hesitant about it. I would argue that generators themselves are a lot of \"magic\", and this is a tiny extension that doesn't add much more. Using generators, assuming that `yield x` transforms to `Q.resolve(x)` is the same exact magic. Adding just a few more transformations make them immensely more useful, and we just a need a small list that describes the available transformations. @domenic, in your above example, I would say that if it doesn't match a few special types of objects, that it simply defaults to `Q.resolve`.\n\nI'm not extremely passionate about it though, since this doesn't concern APIs or composability, but just app-level code, and it would be pretty easy to do this in another library if a lot of people really find it useful.\n. > Particularly, all will become suitable for generically waiting either for an \"iterable\" of promises to all be fulfilled, or pass non-iterables through. That\u2019ll cover arrays, generators, iterators, and promise queues, and pass everything else through.\n\nThat's very cool. So `Q.all` is similar too `Q.spawn` for generators, except it doesn't imply `done()` at the end. Is this how my above code would look?\n\n``` js\nQ.spawn(function*() {\n    var ids = [1, 2, 3];\n    var transactions = yield Q.map(ids, function(id) { return Q.all(getTransaction(id)); });\n\n    // ...\n});\n```\n\nIt's still unfortunate that I have to wrap any calls to generators with `Q.all`, but it's not that bad.\n. > I\u2019m running into much broader problems with this effort in general.\n\nIt'd be neat if you had a short example that shows those problems, for us that don't have as much context on what's going on. It looks highly interesting, and it'd be sad if it's too hard! But I trust your caution.\n. ",
    "AndersDJohnson": "Yes, this was somewhat specific to my application, but I feel like this should be easier in general. I do prefer your proposed `allSettled` from #257; are there plans to release that?\n\nI don't think your example solves the issue. See [this JSFiddle](http://jsfiddle.net/gh/gist/library/pure/5692454/). It still short-circuits to the `rejected` callback if any of the promises fail. Also, testing `\"exception\" in b.valueOf()` would fail when the promise resolves to a primitive type like an `int`, since the `in` operator is invalid there. I'm using `hasOwnProperty('exception')` instead in my latest approach.\n\nI'm might close this pull request, as I've since found a cleaner solution that works for me for now:\n\n``` js\nfunction valuesOr (promises, defaultValues) {\n  return promises.map(function (promise, index) {\n    var value = promise.valueOf();\n    return (value.hasOwnProperty('exception')) ? defaultValues[index] : value;\n  });\n}\n\nQ.allResolved([\n  Q.resolve(10),\n  Q.reject(new Error('oops')),\n  Q.resolve(20)\n]).then(function (promises) {\n  var results = valuesOr(promises,  ['default a', 'default b', 'default c']);\n  console.log(results);\n});\n```\n. Yes, this was somewhat specific to my application, but I feel like this should be easier in general. I do prefer your proposed `allSettled` from #257; are there plans to release that?\n\nI don't think your example solves the issue. See [this JSFiddle](http://jsfiddle.net/gh/gist/library/pure/5692454/). It still short-circuits to the `rejected` callback if any of the promises fail. Also, testing `\"exception\" in b.valueOf()` would fail when the promise resolves to a primitive type like an `int`, since the `in` operator is invalid there. I'm using `hasOwnProperty('exception')` instead in my latest approach.\n\nI'm might close this pull request, as I've since found a cleaner solution that works for me for now:\n\n``` js\nfunction valuesOr (promises, defaultValues) {\n  return promises.map(function (promise, index) {\n    var value = promise.valueOf();\n    return (value.hasOwnProperty('exception')) ? defaultValues[index] : value;\n  });\n}\n\nQ.allResolved([\n  Q.resolve(10),\n  Q.reject(new Error('oops')),\n  Q.resolve(20)\n]).then(function (promises) {\n  var results = valuesOr(promises,  ['default a', 'default b', 'default c']);\n  console.log(results);\n});\n```\n. ",
    "sowdri": "This functionality would really be useful as part of core. It looks like a basic functionality that i run into often. \n. This functionality would really be useful as part of core. It looks like a basic functionality that i run into often. \n. ",
    "jdalton": "\\o/ \n. \\o/ \n. ",
    "mpj": "Hi, I was wondering what the status is of this? We were debating what promise library to use at Spotify, and this one came up https://github.com/petkaantonov/bluebird/tree/master/benchmark, which made bluebird look (what I think is) unnecessarily good. \n. Hi, I was wondering what the status is of this? We were debating what promise library to use at Spotify, and this one came up https://github.com/petkaantonov/bluebird/tree/master/benchmark, which made bluebird look (what I think is) unnecessarily good. \n. ",
    "jugglinmike": "I can't find any documentation collecting all the DOMRequest-producing APIs; the best I can do is [a search results page for \"DOMRequest\" in the b2g18 source](http://mxr.mozilla.org/mozilla-b2g18/search?string=DOMRequest). I think this makes your point pretty well--there isn't much of a standard here. If this method has a home, it's probably in [the Gaia project](https://github.com/mozilla-b2g/gaia). In the mean time, I think I'll make a new personal rule to avoid issuing pull requests before 10AM... Thanks for your review, all the same!\n. I can't find any documentation collecting all the DOMRequest-producing APIs; the best I can do is [a search results page for \"DOMRequest\" in the b2g18 source](http://mxr.mozilla.org/mozilla-b2g18/search?string=DOMRequest). I think this makes your point pretty well--there isn't much of a standard here. If this method has a home, it's probably in [the Gaia project](https://github.com/mozilla-b2g/gaia). In the mean time, I think I'll make a new personal rule to avoid issuing pull requests before 10AM... Thanks for your review, all the same!\n. ",
    "busticated": "hmm... weird... guess [cdnjs.com](http://cdnjs.com) has something mixed up :-/\n\nhere's what I ran in to: http://jsfiddle.net/4FRBc/1/ (open console, note the error);\n\nhere's the lib i pulled in:\nhttp://cdnjs.cloudflare.com/ajax/libs/q.js/0.9.2/q.min.js\n. hmm... weird... guess [cdnjs.com](http://cdnjs.com) has something mixed up :-/\n\nhere's what I ran in to: http://jsfiddle.net/4FRBc/1/ (open console, note the error);\n\nhere's the lib i pulled in:\nhttp://cdnjs.cloudflare.com/ajax/libs/q.js/0.9.2/q.min.js\n. ",
    "pnommensen": "Hello, we've added this library to the jsDelivr CDN https://github.com/jsdelivr/jsdelivr. \n\nWould it be possible to include an official q.min.js file in the release so our project can automatically update this file on the CDN when new versions are released? https://github.com/jsdelivr/jsdelivr#auto-updating\n. Hello, we've added this library to the jsDelivr CDN https://github.com/jsdelivr/jsdelivr. \n\nWould it be possible to include an official q.min.js file in the release so our project can automatically update this file on the CDN when new versions are released? https://github.com/jsdelivr/jsdelivr#auto-updating\n. ",
    "aleclofabbro": "ok, i won't dig ;)\nthanks!\n. ok, i won't dig ;)\nthanks!\n. ",
    "myndzi": "Thanks, that makes enough sense :)\n. Thanks, that makes enough sense :)\n. ",
    "nicco": "Thanks!\n. Thanks!\n. ",
    "wmertens": "I agree as well :)\n\nNew semantics, all tests pass, minified. \n. LGTM, in that I can't see this doing harm, but I don't understand how it works :) Maybe there should be a comment regarding how maintaining the counter helps for this feature?\n. Looks great, thanks!!\n. @domenic @kriskowal could you push a new version to npm?. I agree as well :)\n\nNew semantics, all tests pass, minified. \n. LGTM, in that I can't see this doing harm, but I don't understand how it works :) Maybe there should be a comment regarding how maintaining the counter helps for this feature?\n. Looks great, thanks!!\n. @domenic @kriskowal could you push a new version to npm?. ",
    "macnibblet": "@kriskowal Ah thanks! \n. @kriskowal Ah thanks! \n. ",
    "AaronO": "@kriskowal Thanks for pointing that out.\n\nI somehow missed, the Q.reduce function ... So that pretty much suits my needs.\n\n(Using Q.all and Q.reduce to control workflow, replacing async.parallel and async.waterfall)\n. @killdream Yep sorry, you're right. I mistyped what I thought, I meant Array.prototype.reduce.\n\nI find promises really useful, and a few friends wanting to switch over to using Q, wanted to be able to define their workflow in a more function style than p.then(f1).then(f2) ...\n\nI'll provide them with the alternative using reduce and Q.when.\n\nThanks for the pointers and your good work on Q.\n. @kriskowal Thanks for pointing that out.\n\nI somehow missed, the Q.reduce function ... So that pretty much suits my needs.\n\n(Using Q.all and Q.reduce to control workflow, replacing async.parallel and async.waterfall)\n. @killdream Yep sorry, you're right. I mistyped what I thought, I meant Array.prototype.reduce.\n\nI find promises really useful, and a few friends wanting to switch over to using Q, wanted to be able to define their workflow in a more function style than p.then(f1).then(f2) ...\n\nI'll provide them with the alternative using reduce and Q.when.\n\nThanks for the pointers and your good work on Q.\n. ",
    "danieldkim": "Well, let's assume step1 and step2 are third-party library functions that we can't modify.  I know I can write wrappers around them that return promises, as I did with the example above that uses deferred's to do that.  But I don't want to have to do all of that -- it would be nice if I could just call use a utility function that does the adaptation/conversion for me.  The code sample at the at top of the README suggests that I can use `Q.fcall()` to do that, but I can't.  I can, however, use `Q.nfcall()` to do that for node-style functions (though not quite as nicely as simply as that code sample suggests).\n. @domenic that works for me though, again, it would be nice if it (or something) did work the way the current text suggests :).  although I understand that you can't make the same assumptions about the adapted function that you can when using `Q.nfcall` so this may not be so straightforward.\n\nbtw, what prompted this was I was playing around with the [phantomjs](https://github.com/sgentle/phantomjs-node) node module, specifically the [code sample in their README](https://github.com/sgentle/phantomjs-node/blob/ba26b70e31adf957656248b5ed14576eca956ed8/README.markdown), and I was trying to flatten that pyramid using Q.  the phantomjs functions take callbacks -- but not node-style callbacks with an error as the first argument -- so this mapped directly to the code sample that's currently at the top of the README and so I tried to follow the example and it didn't work.  so clarifying the README would at least avoid another newbie opening the same issue in github.\n. Well, let's assume step1 and step2 are third-party library functions that we can't modify.  I know I can write wrappers around them that return promises, as I did with the example above that uses deferred's to do that.  But I don't want to have to do all of that -- it would be nice if I could just call use a utility function that does the adaptation/conversion for me.  The code sample at the at top of the README suggests that I can use `Q.fcall()` to do that, but I can't.  I can, however, use `Q.nfcall()` to do that for node-style functions (though not quite as nicely as simply as that code sample suggests).\n. @domenic that works for me though, again, it would be nice if it (or something) did work the way the current text suggests :).  although I understand that you can't make the same assumptions about the adapted function that you can when using `Q.nfcall` so this may not be so straightforward.\n\nbtw, what prompted this was I was playing around with the [phantomjs](https://github.com/sgentle/phantomjs-node) node module, specifically the [code sample in their README](https://github.com/sgentle/phantomjs-node/blob/ba26b70e31adf957656248b5ed14576eca956ed8/README.markdown), and I was trying to flatten that pyramid using Q.  the phantomjs functions take callbacks -- but not node-style callbacks with an error as the first argument -- so this mapped directly to the code sample that's currently at the top of the README and so I tried to follow the example and it didn't work.  so clarifying the README would at least avoid another newbie opening the same issue in github.\n. ",
    "bencates": "Okay, aggregation is probably not the best approach, but it seems wrong to just drop valid output on the floor.  Perhaps instead it should emit something like `[0, \"33%\"], [1, \"33%\"], [0, \"67%\"], [0, \"100%\"], [2, \"33%\"], [1, \"67%\"], [2, \"67%\"], [1, \"100%\"], [2, \"100%\"]`.\n\nAs best I can tell the only way to preserve that data is to hide the `Q.all` call behind a new `Q.defer()` and explicitly reemit any notifications, like so:\n\n``` javascript\n(function () {\n  var d = Q.defer();\n  Q.all([\n    promise1.progress(d.notify),\n    promise2.progress(d.notify)\n    // etc...\n  ]).then(d.resolve, d.reject);\n  return d.promise;\n})();\n```\n\nIt seems like a lot of boilerplate.  Am I missing something?\n. Okay, aggregation is probably not the best approach, but it seems wrong to just drop valid output on the floor.  Perhaps instead it should emit something like `[0, \"33%\"], [1, \"33%\"], [0, \"67%\"], [0, \"100%\"], [2, \"33%\"], [1, \"67%\"], [2, \"67%\"], [1, \"100%\"], [2, \"100%\"]`.\n\nAs best I can tell the only way to preserve that data is to hide the `Q.all` call behind a new `Q.defer()` and explicitly reemit any notifications, like so:\n\n``` javascript\n(function () {\n  var d = Q.defer();\n  Q.all([\n    promise1.progress(d.notify),\n    promise2.progress(d.notify)\n    // etc...\n  ]).then(d.resolve, d.reject);\n  return d.promise;\n})();\n```\n\nIt seems like a lot of boilerplate.  Am I missing something?\n. ",
    "TimDaub": "![NOOOOOOOOOOOOOOOOOOOOOOOOOO](http://nontoxicrevolution.org/wp-content/uploads/2015/05/no-gif1.gif)\n\nI'm trying to abort the hashing of a number of files and I'm using Q's promises to handle the async part.\nSo since this is never going to work in 1.0, I guess its not possible to stop the execution of a promise from the outside or is it?\n. ![NOOOOOOOOOOOOOOOOOOOOOOOOOO](http://nontoxicrevolution.org/wp-content/uploads/2015/05/no-gif1.gif)\n\nI'm trying to abort the hashing of a number of files and I'm using Q's promises to handle the async part.\nSo since this is never going to work in 1.0, I guess its not possible to stop the execution of a promise from the outside or is it?\n. ",
    "theduderog": "@kitcambridge Thank you for the explanation.  To me, that seems like a bad choice for the standard.  I'm guessing that it based on a concern that too many handlers will get called before control is returned.\n\nRegarding streams2, the readable callback may still get invoked before the promise callback, right?\n. @domenic Thank you\n. @kitcambridge Thank you for the explanation.  To me, that seems like a bad choice for the standard.  I'm guessing that it based on a concern that too many handlers will get called before control is returned.\n\nRegarding streams2, the readable callback may still get invoked before the promise callback, right?\n. @domenic Thank you\n. ",
    "gavinr": "@wavded You're right - we're using valueOf in our code (I didn't think we were). Thanks for the info!\n. @wavded You're right - we're using valueOf in our code (I didn't think we were). Thanks for the info!\n. ",
    "kevinsimper": "Wouldn't it make the example more complex?\n\nI think it would be a good idea making another example after, where you should the little more advanced code.\n. I changed the commit (did I do it right?).\n. Wouldn't it make the example more complex?\n\nI think it would be a good idea making another example after, where you should the little more advanced code.\n. I changed the commit (did I do it right?).\n. ",
    "parauchf": "Happy to help if I can, but I haven't looked at the code much.  Will take a\nlook tonight.\n\nOn Wed, Jul 17, 2013 at 12:43 PM, Domenic Denicola <notifications@github.com\n\n> wrote:\n> \n> Gah, nice catch! Why is this such an easy mistake for us to make... Seems\n> like every all/allSettled implementation I've seen for any promise library\n> always has this bugfix in their commit history.\n> \n> Pull request welcome if you want all the fame and glory for yourself.\n> Should be a pretty quick one :). Otherwise we will fix it ASAP.\n> \n> @kriskowal I'm feeling another 0.9 point release coming on...\n> \n> ---\n> \n> From: Peter Rauchfussmailto:notifications@github.com\n> Sent: \u00fd7/\u00fd17/\u00fd2013 12:32\n> To: kriskowal/qmailto:q@noreply.github.com\n> Subject: [q] Q.allSettled hangs when passed an empty array (#345)\n> \n> e.g. the below never returns;\n> \n> noReturn = function(){\n> return Q.allSettled([]);\n> };\n> \n> whereas the equivalent with Q.all() returns immediately:\n> \n> noReturn = function(){\n> return Q.all([]);\n> };\n> \n> \u2014\n> Reply to this email directly or view it on GitHub<\n> https://github.com/kriskowal/q/issues/345>.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/345#issuecomment-21126462\n> .\n. Happy to help if I can, but I haven't looked at the code much.  Will take a\nlook tonight.\n\nOn Wed, Jul 17, 2013 at 12:43 PM, Domenic Denicola <notifications@github.com\n\n> wrote:\n> \n> Gah, nice catch! Why is this such an easy mistake for us to make... Seems\n> like every all/allSettled implementation I've seen for any promise library\n> always has this bugfix in their commit history.\n> \n> Pull request welcome if you want all the fame and glory for yourself.\n> Should be a pretty quick one :). Otherwise we will fix it ASAP.\n> \n> @kriskowal I'm feeling another 0.9 point release coming on...\n> \n> ---\n> \n> From: Peter Rauchfussmailto:notifications@github.com\n> Sent: \u00fd7/\u00fd17/\u00fd2013 12:32\n> To: kriskowal/qmailto:q@noreply.github.com\n> Subject: [q] Q.allSettled hangs when passed an empty array (#345)\n> \n> e.g. the below never returns;\n> \n> noReturn = function(){\n> return Q.allSettled([]);\n> };\n> \n> whereas the equivalent with Q.all() returns immediately:\n> \n> noReturn = function(){\n> return Q.all([]);\n> };\n> \n> \u2014\n> Reply to this email directly or view it on GitHub<\n> https://github.com/kriskowal/q/issues/345>.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/345#issuecomment-21126462\n> .\n. ",
    "stefanpenner": "@domenic, @tildeio gracefully covers these costs. As to what they are I can look into it for you, remind me tomorrow on IM.\n. naming things, why is it so hard.\n. @domenic, @tildeio gracefully covers these costs. As to what they are I can look into it for you, remind me tomorrow on IM.\n. naming things, why is it so hard.\n. ",
    "fivetanley": "@domenic You can encrypt it for this repository  by using the `-r` (repository) option with the travis gem:\n\n`travis encrypt -r kriskowal/q --add AWS_BLAH=foo`\n\nedit: that may be the issue, I can't remember travis implementation details. But I have used the above for ember projects and it has worked.\n. @domenic You can encrypt it for this repository  by using the `-r` (repository) option with the travis gem:\n\n`travis encrypt -r kriskowal/q --add AWS_BLAH=foo`\n\nedit: that may be the issue, I can't remember travis implementation details. But I have used the above for ember projects and it has worked.\n. ",
    "ChandrasekharPo-Kore": "Appreciate for all the comments and time. Just  a consideration.\n\nIs it not a good idea to modify the comments around uncurryThis to reflect this security caveat?\n\nbind.bind does more than what uncurryThis provides. It really does protect against downstream modifications.\nIn this regards the following comment is misleading.\n\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n. Appreciate for all the comments and time. Just  a consideration.\n\nIs it not a good idea to modify the comments around uncurryThis to reflect this security caveat?\n\nbind.bind does more than what uncurryThis provides. It really does protect against downstream modifications.\nIn this regards the following comment is misleading.\n\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n. ",
    "alFReD-NSH": "Well I'm afraid somewhere I might FORGET to handle the errors. That case I don't really want the error to be silent.\n. The thing is that \"Unhandled errors\" is not really helpful without the stack trace. How about calling `Q.onerror` or `Q.onUnhandledError` with the error?\n. Just to add what I'm saying, this is like node not providing 'uncaughtException' event and just logging errors.\n. Well I'm afraid somewhere I might FORGET to handle the errors. That case I don't really want the error to be silent.\n. The thing is that \"Unhandled errors\" is not really helpful without the stack trace. How about calling `Q.onerror` or `Q.onUnhandledError` with the error?\n. Just to add what I'm saying, this is like node not providing 'uncaughtException' event and just logging errors.\n. ",
    "Rolilink": "Ok I am new to promises, so i didnt know that. I will pass an object to the resolve function, thanks for the fast answer.\n. Ok I am new to promises, so i didnt know that. I will pass an object to the resolve function, thanks for the fast answer.\n. ",
    "neverfox": "Interestingly, when I isolated a find and save procedure in its own script, both in ICS and Q versions, I get the same memory footprint, so something else must be going on when it's in the context of the whole app. I would still appreciate any input or suggestions.\n. Closing until I can repeat problem consistently.\n. Interestingly, when I isolated a find and save procedure in its own script, both in ICS and Q versions, I get the same memory footprint, so something else must be going on when it's in the context of the whole app. I would still appreciate any input or suggestions.\n. Closing until I can repeat problem consistently.\n. ",
    "azhang": "yes\n. Oh, that makes sense. Thanks so much!\n. yes\n. Oh, that makes sense. Thanks so much!\n. ",
    "peernohell": "thank.\nI have absolutly miss the point.\nI have wrap every call of qecho in a function and it's work perfectly :)\n. thank.\nI have absolutly miss the point.\nI have wrap every call of qecho in a function and it's work perfectly :)\n. ",
    "magalhas": "How to use this with node inspector?\n. Are there any plans for it? Is a PR welcome?\n. How to use this with node inspector?\n. Are there any plans for it? Is a PR welcome?\n. ",
    "surr-name": "Yes, it looks like it was some old revision of '0.9.6'. Now it works.\n. I am so sorry! I've checked it again \u2014 it was fully my bug. Looks like I was too sleepy, when I \"have found\" it. Sorry for wasting your time.\n. Yes, it looks like it was some old revision of '0.9.6'. Now it works.\n. I am so sorry! I've checked it again \u2014 it was fully my bug. Looks like I was too sleepy, when I \"have found\" it. Sorry for wasting your time.\n. ",
    "SET001": "Can some one explain why `Q.all( [] )` shall never be resolved or rejeced? In my case I have an array of initialisers and something should be done after all initialisers would finish it's jobs. So I can just do \n\n`Q.all(this.initializers).then(() => {`\n\nand that something would run even if there are no any initialisers.\n\nNow, that `all` does not resolve on empty array, I should move my post-init code to separate funciton and do something like this:\n\n```\n    if (this.initializers.length){\n        Q.all(this.initializers).then(() => {\n            this._run(controller);\n        })\n    } else {\n        this._run(controller);\n    }\n```\n. you mean it should be resolved?\n. I may not understand you.\n\nHere is a test case I made\n\n```\n    beforeEach(function(){\n        foo = {\n            controller: function(){}\n        };\n        spyOn(foo, 'controller').and.callThrough();\n    });\n\n    fit('should resolve empty promises array', function(){\n        Q.all([]).then(\n            foo.controller,\n            foo.controller\n        );\n        expect(foo.controller).toHaveBeenCalled();\n    });\n```\n\nand it always fails - not rejected and not resolved. Is it supposed behavior?\n. Can some one explain why `Q.all( [] )` shall never be resolved or rejeced? In my case I have an array of initialisers and something should be done after all initialisers would finish it's jobs. So I can just do \n\n`Q.all(this.initializers).then(() => {`\n\nand that something would run even if there are no any initialisers.\n\nNow, that `all` does not resolve on empty array, I should move my post-init code to separate funciton and do something like this:\n\n```\n    if (this.initializers.length){\n        Q.all(this.initializers).then(() => {\n            this._run(controller);\n        })\n    } else {\n        this._run(controller);\n    }\n```\n. you mean it should be resolved?\n. I may not understand you.\n\nHere is a test case I made\n\n```\n    beforeEach(function(){\n        foo = {\n            controller: function(){}\n        };\n        spyOn(foo, 'controller').and.callThrough();\n    });\n\n    fit('should resolve empty promises array', function(){\n        Q.all([]).then(\n            foo.controller,\n            foo.controller\n        );\n        expect(foo.controller).toHaveBeenCalled();\n    });\n```\n\nand it always fails - not rejected and not resolved. Is it supposed behavior?\n. ",
    "bestander": "I am sort of late for the discussion but :-1: from me.\n\nI use q with bower in a large website which has deployment and minification scripts.\nBut how should I learn which minifier with which parameters should I compress the lib?\nIs mangle or dead code elimination allowed?\nI think most of website owners don't need to care about this and it can/should be done by the lib owner.\n. I found https://github.com/karol-f/q-bower maintained by another person and outdated.\nRemoval of q.min.js causes fragmentation IMHO\n. I am sort of late for the discussion but :-1: from me.\n\nI use q with bower in a large website which has deployment and minification scripts.\nBut how should I learn which minifier with which parameters should I compress the lib?\nIs mangle or dead code elimination allowed?\nI think most of website owners don't need to care about this and it can/should be done by the lib owner.\n. I found https://github.com/karol-f/q-bower maintained by another person and outdated.\nRemoval of q.min.js causes fragmentation IMHO\n. ",
    "nicovalencia": "Actually seems to be partially broken in 0.9.5 as well.\n. That was just my example, I'm actually inspecting the object with node debug. Create a deferred in 0.9.4, 0.9.5, and 0.9.6 and when you inspect it's promise object you see different behavior. I'm not at my dev machine now, but I may have been running edge Node, or at least 11+, so I'll try it out on a stable .10 version when I get back.\n. Actually seems to be partially broken in 0.9.5 as well.\n. That was just my example, I'm actually inspecting the object with node debug. Create a deferred in 0.9.4, 0.9.5, and 0.9.6 and when you inspect it's promise object you see different behavior. I'm not at my dev machine now, but I may have been running edge Node, or at least 11+, so I'll try it out on a stable .10 version when I get back.\n. ",
    "VRMink": "I spent the best part of an hour being confused about this too. Maybe we could change the toString on the object to return something meaningfull instead of undefined?\n. I spent the best part of an hour being confused about this too. Maybe we could change the toString on the object to return something meaningfull instead of undefined?\n. ",
    "Bartvds": "Well, the samples I pasted from the readme and edited here in the comment box.\n\nBut the issue is real enough, I have it in my project, like so:\n\n```\nreturn Q.nfcall(request.get, opts).then(function(res) {\n    res = res[0];\n    if (res.statusCode === 200) {\n        // etc ...\n```\n. Aah, right, makes sense. \n\nIt was a snippet using request.js and it does indeed return multiple non-error parameters (a result object and the body content). I never use the separate body content and never considered this.\n\nThanks for pointing this out though.\n. :+1: nice :)\n\nNote, I'm cool with closing this issue at your convenience.\n. Oh, now I feel silly for now having spotted that. (The Q docs are great, it's just so much info to absorb)\n. Ok, thanks for the info.\n\nI see how overloading it could be confusing, so let's not think about that, but apparently the use case is real, with so many people asking for it. I hope you reconsider adding a new method like the `allNamed` or `allProperties`. \n\nWhere it would end? That is for you to decide: if deep looping gives problem, then just don't deep-loop? Instead only use one shallow level, just plain-n-simple name-promise mapping, just when you use Q.all() with an array, but with named keys so ordering and amount do not matter. \n\nAnd it would enumerate by design, so whatever is enumerable would be checked: it is for you to decide if you allow properties from the prototypes. Since the goal is simple name/value-mapping I'd go for simple objects with own properties.\n\nI see you mention \"`spread` covers this nicely\" but this is not true, as using spread still depends on the total amount of elements and their order. It is impossible to create a variadic method for a changing set of promises.\n. Well, the samples I pasted from the readme and edited here in the comment box.\n\nBut the issue is real enough, I have it in my project, like so:\n\n```\nreturn Q.nfcall(request.get, opts).then(function(res) {\n    res = res[0];\n    if (res.statusCode === 200) {\n        // etc ...\n```\n. Aah, right, makes sense. \n\nIt was a snippet using request.js and it does indeed return multiple non-error parameters (a result object and the body content). I never use the separate body content and never considered this.\n\nThanks for pointing this out though.\n. :+1: nice :)\n\nNote, I'm cool with closing this issue at your convenience.\n. Oh, now I feel silly for now having spotted that. (The Q docs are great, it's just so much info to absorb)\n. Ok, thanks for the info.\n\nI see how overloading it could be confusing, so let's not think about that, but apparently the use case is real, with so many people asking for it. I hope you reconsider adding a new method like the `allNamed` or `allProperties`. \n\nWhere it would end? That is for you to decide: if deep looping gives problem, then just don't deep-loop? Instead only use one shallow level, just plain-n-simple name-promise mapping, just when you use Q.all() with an array, but with named keys so ordering and amount do not matter. \n\nAnd it would enumerate by design, so whatever is enumerable would be checked: it is for you to decide if you allow properties from the prototypes. Since the goal is simple name/value-mapping I'd go for simple objects with own properties.\n\nI see you mention \"`spread` covers this nicely\" but this is not true, as using spread still depends on the total amount of elements and their order. It is impossible to create a variadic method for a changing set of promises.\n. ",
    "CodersBrothers": "Never is enough information for the people can use easy your work. A responsable developer make a good code and a good documentation and videos. All other are lazy.\n. Never is enough information for the people can use easy your work. A responsable developer make a good code and a good documentation and videos. All other are lazy.\n. ",
    "peutetre": "you should write something like\n\n```\nQ.delay(2000).then(function () { return Q.delay(3000); }).then(...);\n```\n. you should write something like\n\n```\nQ.delay(2000).then(function () { return Q.delay(3000); }).then(...);\n```\n. ",
    "polidore": "That works.  Why does it matter? Doesn't Q.delay return a promise anyway?  \n. Oh, nevermind. So out of context with this stuff forgetting basics. So then wants a function, not a promise. Thanks!\n. That works.  Why does it matter? Doesn't Q.delay return a promise anyway?  \n. Oh, nevermind. So out of context with this stuff forgetting basics. So then wants a function, not a promise. Thanks!\n. ",
    "sachinbhatnagar": "Thanks for the prompt replies. Here's my code and I'm still not sure what I'm doing wrong. I'm using express.\n\n``` js\napp.get('/test', function(req, res){\n    var httpQ = function (opts) {\n        var deferred = q.defer();\n        http.get(opts, deferred.resolve);\n        return deferred.promise;\n         };\n    var getData = httpQ('http://www.sachinbhatnagar.com'); // Only this way its working\n    //var getData = q(http).ninvoke('get','http://www.sachinbhatnagar.com');  // This did not work.\n    //var getData = q.nfcall(http.get.bind(http), 'big.txt', 'utf-8'); // This did not work\n    getData.then(function(response, done){\n        // Pass Response Data to Stream Writer Function\n        onData(response,'newoutfile.txt');\n    }, function(err){\n        console.log(\"There was an error\");\n    })\n})\nfunction onData(response,filename){\n    var writeStream = fs.createWriteStream(filename);\n    response.setEncoding('utf8')\n    response.on('data', function(chunk){\n        writeStream.write(chunk);\n    });\n\n    response.on('end', function(){\n        writeStream.end();\n        console.log('JOB DONE');\n    })\n}\n```\n\nNot sure what I'm doing wrong here. \n. Hey thanks Domenic. The code i pasted here was a part of a bigger script, so I posted only what was causing issues. \n\nSo, for functions which do not follow the standard node style callback, the way out would be to use the Q.defer() method ? Is that correct ?\n. Thanks a ton for your help Domenic. And thanks again for the tip regarding the self contained example thingy. I'm not very active on forums and git and its only when all experiments fail do I resort to asking questions. Will keep this point in mind. :)\n\nApologies for the trouble :)\n. Thanks for the prompt replies. Here's my code and I'm still not sure what I'm doing wrong. I'm using express.\n\n``` js\napp.get('/test', function(req, res){\n    var httpQ = function (opts) {\n        var deferred = q.defer();\n        http.get(opts, deferred.resolve);\n        return deferred.promise;\n         };\n    var getData = httpQ('http://www.sachinbhatnagar.com'); // Only this way its working\n    //var getData = q(http).ninvoke('get','http://www.sachinbhatnagar.com');  // This did not work.\n    //var getData = q.nfcall(http.get.bind(http), 'big.txt', 'utf-8'); // This did not work\n    getData.then(function(response, done){\n        // Pass Response Data to Stream Writer Function\n        onData(response,'newoutfile.txt');\n    }, function(err){\n        console.log(\"There was an error\");\n    })\n})\nfunction onData(response,filename){\n    var writeStream = fs.createWriteStream(filename);\n    response.setEncoding('utf8')\n    response.on('data', function(chunk){\n        writeStream.write(chunk);\n    });\n\n    response.on('end', function(){\n        writeStream.end();\n        console.log('JOB DONE');\n    })\n}\n```\n\nNot sure what I'm doing wrong here. \n. Hey thanks Domenic. The code i pasted here was a part of a bigger script, so I posted only what was causing issues. \n\nSo, for functions which do not follow the standard node style callback, the way out would be to use the Q.defer() method ? Is that correct ?\n. Thanks a ton for your help Domenic. And thanks again for the tip regarding the self contained example thingy. I'm not very active on forums and git and its only when all experiments fail do I resort to asking questions. Will keep this point in mind. :)\n\nApologies for the trouble :)\n. ",
    "jeffwhelpley": "Hmm, ok, that makes sense. I guess in looking at my code the issue is that I don't have the chain going all the way up. I will just focus on doing that and it will achieve the same goal (i.e. putting the error handler one place). Thanks!\n. Ah, I was not aware. That would definitely solve my problem.\n. Hmm, ok, that makes sense. I guess in looking at my code the issue is that I don't have the chain going all the way up. I will just focus on doing that and it will achieve the same goal (i.e. putting the error handler one place). Thanks!\n. Ah, I was not aware. That would definitely solve my problem.\n. ",
    "dtudury": "ah, cool, thanks for that.  experimenting with Q is the one place I've needed to pass a logging function (and I experiment inside node).  at first it bothered me that passing console.log around worked\u2026 but I got over it :)\n\nI'll add a `var log = function(){console.log.apply(console, arguments);};` line to my future experiments\n\nwould a Q.log method be useful to people other than me? I think it'd be roughly `Q.log = function(){console.log.apply(console, arguments); return arguments};`.  I'm happy to contribute it (I'm also happy not to if you think adding an extra method is bloat; in general, I'd agree. I'd rather the modules I include be as simple as possible)\n. also (as we're all humans here\u2026),\n\ngreat job on Q!  it took me a while to come around, but having used it on a couple of modules recently: I can't imagine not using it on future projects. it's what garbage collection is to java; it's what comprehensions are to python; it's what popcorn is to the microwave.  so many more elegant solutions open up when you start requiring Q.  thank you!\n. thanks Domenic, I'm glad I tried contributing, I'd have blissfully misused Q for weeks before realizing any of these mistakes without your comments\n. kk, figured it unlikely to have been an oversight.  I'm new to promises and trying to grock some of the subtleties.  some familiarity with functional programming and chainable libraries (like jquery) helped at the start but may be hindering me now :)  if I make progress I'll try to contribute examples that would clarify for people with similar misunderstandings.\n\nthanks for the replies!\n. ah, cool, thanks for that.  experimenting with Q is the one place I've needed to pass a logging function (and I experiment inside node).  at first it bothered me that passing console.log around worked\u2026 but I got over it :)\n\nI'll add a `var log = function(){console.log.apply(console, arguments);};` line to my future experiments\n\nwould a Q.log method be useful to people other than me? I think it'd be roughly `Q.log = function(){console.log.apply(console, arguments); return arguments};`.  I'm happy to contribute it (I'm also happy not to if you think adding an extra method is bloat; in general, I'd agree. I'd rather the modules I include be as simple as possible)\n. also (as we're all humans here\u2026),\n\ngreat job on Q!  it took me a while to come around, but having used it on a couple of modules recently: I can't imagine not using it on future projects. it's what garbage collection is to java; it's what comprehensions are to python; it's what popcorn is to the microwave.  so many more elegant solutions open up when you start requiring Q.  thank you!\n. thanks Domenic, I'm glad I tried contributing, I'd have blissfully misused Q for weeks before realizing any of these mistakes without your comments\n. kk, figured it unlikely to have been an oversight.  I'm new to promises and trying to grock some of the subtleties.  some familiarity with functional programming and chainable libraries (like jquery) helped at the start but may be hindering me now :)  if I make progress I'll try to contribute examples that would clarify for people with similar misunderstandings.\n\nthanks for the replies!\n. ",
    "DannyMoerkerke": "Upgrade to v0.11.7 did the trick, thanx!\n. Upgrade to v0.11.7 did the trick, thanx!\n. ",
    "brycejacobs": "@kriskowal 0.9.6 does in fact work correctly on node 0.11.2. Will try to merge #366 and see what happens.\n\n@domenic Already thought of that, we are just stuck on 0.11.2 with node-gyp not working on 0.11.3 or above.\n. @kriskowal Seems that merging #366 makes no difference, still getting the same errors.\n. @kriskowal 0.9.6 does in fact work correctly on node 0.11.2. Will try to merge #366 and see what happens.\n\n@domenic Already thought of that, we are just stuck on 0.11.2 with node-gyp not working on 0.11.3 or above.\n. @kriskowal Seems that merging #366 makes no difference, still getting the same errors.\n. ",
    "kamituel": "`Q.spawn()` - I missed this. Thank you!\n. `Q.spawn()` - I missed this. Thank you!\n. ",
    "dbkaplun": "Thank you!\n. Thank you!\n. ",
    "zaggino": "I'm quite lost what kind of note should I put there :-)\n. :+1: \n. Sure. Thanks.\n. I'm quite lost what kind of note should I put there :-)\n. :+1: \n. Sure. Thanks.\n. ",
    "asaf": "Thanks for the clarification,\n\nFor simple (and IMO common cases), it may make sense to give each promise some weight and calculate the progress based on that when it comes to combining multiple promises.\n\nYes, documenting some of the possible strategies (even specifically the example you've mentioned above) in the frontpage doc will probably be valuable for others.\n\nThanks!\n. Thanks for the clarification,\n\nFor simple (and IMO common cases), it may make sense to give each promise some weight and calculate the progress based on that when it comes to combining multiple promises.\n\nYes, documenting some of the possible strategies (even specifically the example you've mentioned above) in the frontpage doc will probably be valuable for others.\n\nThanks!\n. ",
    "danielecr": "Thank you for clarification.\n\nfrom #465 \n\n```\ngetPromise().then(function(result){\nvar mydeferred = this.deferred;\nmydeferred.notify('this step is done);\nreturn secondPromise();\n});\n```\n\nshould be writen\n\n```\nvar myfirst = getPromise().then(function(result){\nmyfirst.notify('step 1');\n// ... code\nreturn secondPromise();\n}).done();\n```\n\nor such, please add this too to the next doc review, I am new to promise pattern, and it is not very clean how to code these things.\nI could be added a documentation section and a reference to this issue for adding cases.\n. Thank you for clarification.\n\nfrom #465 \n\n```\ngetPromise().then(function(result){\nvar mydeferred = this.deferred;\nmydeferred.notify('this step is done);\nreturn secondPromise();\n});\n```\n\nshould be writen\n\n```\nvar myfirst = getPromise().then(function(result){\nmyfirst.notify('step 1');\n// ... code\nreturn secondPromise();\n}).done();\n```\n\nor such, please add this too to the next doc review, I am new to promise pattern, and it is not very clean how to code these things.\nI could be added a documentation section and a reference to this issue for adding cases.\n. ",
    "plaa": "postMessage also suffers from the same bug:  http://sampo.kapsi.fi/setImmediate/testPostMessage.html\n\nSeems like there\u2019s no fully functional zero-time timeout on IE10.\n. It looks like we might have a winner.  http://sampo.kapsi.fi/setImmediate/testOnReadyStateChange.html\n\nOn WP8 the two functions are called alternately, on IE10 desktop only runOnReadyStateChange is ever called.  It seems runOnReadyStateChange is called at the end of the current tick, so IE never reaches the next tick to run the setTimeout callback.\n. postMessage also suffers from the same bug:  http://sampo.kapsi.fi/setImmediate/testPostMessage.html\n\nSeems like there\u2019s no fully functional zero-time timeout on IE10.\n. It looks like we might have a winner.  http://sampo.kapsi.fi/setImmediate/testOnReadyStateChange.html\n\nOn WP8 the two functions are called alternately, on IE10 desktop only runOnReadyStateChange is ever called.  It seems runOnReadyStateChange is called at the end of the current tick, so IE never reaches the next tick to run the setTimeout callback.\n. ",
    "ohgyun": "ah. you're right.\nIf so, we should change the description in the README file.\nhttps://github.com/kriskowal/q#tests\n. ah. you're right.\nIf so, we should change the description in the README file.\nhttps://github.com/kriskowal/q#tests\n. ",
    "STRd6": "An alternative possibility would be for the methods to return the promise rather than the deferred, which looking at it now was more of what I intended. My primary goal to be to allow something like:\n\n```\nreturn Deferred().resolve(\"Radical\")\n```\n\nWhere that return value is a promise-like thing.\n\nWhat I'm really after is a standalone `Deferred` constructor that is compatible with the other libraries out there.\n. @kriskowal Thanks for the explanation.\n\nIn my ideal world I'd be able to `require('deferred')` and gain access to a single constructor that can be used to create and fulfill promises rather than have to know about `Q.defer` and `Q.Promise`. Also ideally, for me anyway, would be for promises to be a subset of deferreds for compatibility with jQuery etc.\n\nThanks again for taking the time, I appreciate the work you've put into this library.\n. An alternative possibility would be for the methods to return the promise rather than the deferred, which looking at it now was more of what I intended. My primary goal to be to allow something like:\n\n```\nreturn Deferred().resolve(\"Radical\")\n```\n\nWhere that return value is a promise-like thing.\n\nWhat I'm really after is a standalone `Deferred` constructor that is compatible with the other libraries out there.\n. @kriskowal Thanks for the explanation.\n\nIn my ideal world I'd be able to `require('deferred')` and gain access to a single constructor that can be used to create and fulfill promises rather than have to know about `Q.defer` and `Q.Promise`. Also ideally, for me anyway, would be for promises to be a subset of deferreds for compatibility with jQuery etc.\n\nThanks again for taking the time, I appreciate the work you've put into this library.\n. ",
    "simonzack": "+1 to the `any` and `anySettled` proposal, I think this makes the most sense.\n. `race` and `any` behave differently: `any` only settles when all promises in the array are rejected, but `race` settles when any are rejected (the documentation seems to be wrong here, it says \"first of an array of promises to become fulfilled\" which I think should be \"first of an array of promises to become settled\"). I think `race` behaves the same as my `anySettled` function, but `any` can be useful too in many cases.\n\nA recent use-case of mine was firing two different ajax requests at the same time to retrieve the same file data, and responding when either of the reads succeeded or all failed.\n\nI can rename this to anything you like if you find it useful.\n. Would `.some(2)` mean any of 2 promises being fulfilled? What would be a use case for that?\n. +1 to the `any` and `anySettled` proposal, I think this makes the most sense.\n. `race` and `any` behave differently: `any` only settles when all promises in the array are rejected, but `race` settles when any are rejected (the documentation seems to be wrong here, it says \"first of an array of promises to become fulfilled\" which I think should be \"first of an array of promises to become settled\"). I think `race` behaves the same as my `anySettled` function, but `any` can be useful too in many cases.\n\nA recent use-case of mine was firing two different ajax requests at the same time to retrieve the same file data, and responding when either of the reads succeeded or all failed.\n\nI can rename this to anything you like if you find it useful.\n. Would `.some(2)` mean any of 2 promises being fulfilled? What would be a use case for that?\n. ",
    "bergus": "@kriskowal \n\n> There is a relatively new API, `Q.race([promise1, promise2, promise3])`, but it may not have been documented yet. We\u2019ll track that with this ticket.\n\nIt seems `race` is still not documented on the wiki page. Can you reopen?\n. +1. Nobody needs a promise that resolves to `undefined`.\n. That's just crazy code :-)\nIt's not a bug however imo, because it's not a circular promise - rather it's a circular thenable (that is no more thenable when it resolves, urghh). [Promises/A+](https://github.com/promises-aplus/promises-spec) don't mandate their detection.\nWe might want to update Promises/A+, though.\n. @kriskowal \n\n> There is a relatively new API, `Q.race([promise1, promise2, promise3])`, but it may not have been documented yet. We\u2019ll track that with this ticket.\n\nIt seems `race` is still not documented on the wiki page. Can you reopen?\n. +1. Nobody needs a promise that resolves to `undefined`.\n. That's just crazy code :-)\nIt's not a bug however imo, because it's not a circular promise - rather it's a circular thenable (that is no more thenable when it resolves, urghh). [Promises/A+](https://github.com/promises-aplus/promises-spec) don't mandate their detection.\nWe might want to update Promises/A+, though.\n. ",
    "axefrog": "That makes sense, and thanks for the explanation.\n. That makes sense, and thanks for the explanation.\n. ",
    "frosas": "Given that https://github.com/kriskowal/q/pull/404 requires a `npm install`\nmaybe it's better to simply change the README.\n. What is `window.Touch` being used for exactly?\n\nAnd what really concerns me, isn't polluting the console with misleading messages worse than showing nothing by default? I would be happy to see this enabled by default, but how to know live console updates are supported?\n\nI can split the commits in two PRs to discuss them separately.\n. I've tried a little more \"scientific\" approach testing the behavior under distinct browsers and this is what I've found ([fiddle](http://jsfiddle.net/frosas/ejSCm/2/)):\n\n``` js\nwindow.Touch = undefined // Make it work on Chrome\n\nQ.reject(\"Handled\").catch(function() {})\n\nvar promise = Q.reject(\"Handled after a while\")\nsetTimeout(function() { promise.catch(function() {}) }, 1000)\n\nQ.reject(\"Unhandled\")\n\n/*\n\n# Expected result\n\n    [Q] Unhandled rejection reasons (should be empty): [\"(no stack) Unhandled\"] \n\n# Result in Chrome\n\n    [Q] Unhandled rejection reasons (should be empty): [\"(no stack) Handled\"] \n\n# Result in Firefox\n\n    [Q] Unhandled rejection reasons (should be empty): [\"(no stack) Handled after a while\", \"(no stack) Unhandled\"]\n\n# Result in Safari\n\n    [Q] Unhandled rejection reasons (should be empty): [\"(no stack) Handled after a while\", \"(no stack) Unhandled\"]\n\n*/\n```\n- It seems Chrome is not updating the array at all\n- I don't know if it's a reasonable case but rejected promises being catched in a later tick are not removed from the console\n. Given that https://github.com/kriskowal/q/pull/404 requires a `npm install`\nmaybe it's better to simply change the README.\n. What is `window.Touch` being used for exactly?\n\nAnd what really concerns me, isn't polluting the console with misleading messages worse than showing nothing by default? I would be happy to see this enabled by default, but how to know live console updates are supported?\n\nI can split the commits in two PRs to discuss them separately.\n. I've tried a little more \"scientific\" approach testing the behavior under distinct browsers and this is what I've found ([fiddle](http://jsfiddle.net/frosas/ejSCm/2/)):\n\n``` js\nwindow.Touch = undefined // Make it work on Chrome\n\nQ.reject(\"Handled\").catch(function() {})\n\nvar promise = Q.reject(\"Handled after a while\")\nsetTimeout(function() { promise.catch(function() {}) }, 1000)\n\nQ.reject(\"Unhandled\")\n\n/*\n\n# Expected result\n\n    [Q] Unhandled rejection reasons (should be empty): [\"(no stack) Unhandled\"] \n\n# Result in Chrome\n\n    [Q] Unhandled rejection reasons (should be empty): [\"(no stack) Handled\"] \n\n# Result in Firefox\n\n    [Q] Unhandled rejection reasons (should be empty): [\"(no stack) Handled after a while\", \"(no stack) Unhandled\"]\n\n# Result in Safari\n\n    [Q] Unhandled rejection reasons (should be empty): [\"(no stack) Handled after a while\", \"(no stack) Unhandled\"]\n\n*/\n```\n- It seems Chrome is not updating the array at all\n- I don't know if it's a reasonable case but rejected promises being catched in a later tick are not removed from the console\n. ",
    "TheLudd": "Ahhh.... my misstake. Forgot to join my two promises in an array.\n. Ahhh.... my misstake. Forgot to join my two promises in an array.\n. ",
    "rafaelkaufmann": "Thank you! Closing issue now :+1: \n. Thank you! Closing issue now :+1: \n. ",
    "petkaantonov": "Note that `Math.random().toString(32).slice(2);` can result in a property name that's not a valid identifier. Adding such property to an object will turn the backing data structure into a hash table in V8. Just like `delete` does or `Object.freeze` did a few months ago. A simple fix is to add a valid identifier start character:\n\n``` js\nvar BRAND = \"b\" + Math.random().toString(32).slice(2);\n```\n\nNode code investigating a brand value that was generated:\n\n``` js\nvar BRAND_1 = \"31t4248\";\nvar BRAND_2 = \"b\" + \"31t4248\";\n\nvar o1 = {};\nvar o2 = {};\n\no1[BRAND_1] = 1;\no2[BRAND_2] = 2;\n\nconsole.log(%HasFastProperties(o1));\nconsole.log(%HasFastProperties(o2));\n```\n\n```\n$ node --allow-natives-syntax brand_test.js\nfalse\ntrue\n```\n. In jQuery code you are assigning the deferred to a local variable whereas in the Q code you assign it to object property.\n. What I am saying is that if\n\n``` js\nvar def = new $.Deferred();\nreturn def;\n```\n\nworks. Then:\n\n``` js\nvar def = Q.defer()\nreturn def.promise;\n```\n\nWill surely work too unless there is inequal code elsewhere as well. I don't understand how the jQuery can have 6 lines of blur and the Q code have no blur yet do the same thing for example.\n. One thing to check out is that Q doesn't create a new array so if at any time after calling Q.all, if you add items to the array, that might cause side effects.\n\nFor example here is simple case that reproduces your issue:\n\nhttp://jsfiddle.net/rKctx/1/\n\n<hr>\n\nYou can try for now something like `Q.all(this.postReserveActions.slice()).then`... as a workaround to see if it works.\n. You could write the stack instead of throwing the error:\n\n``` js\nQ.onerror = function (e) {\n    console.error(e.stack);\n    //If on node.js and want to also shutdown\n    //process.exit(-1);\n};\n```\n. It would be better to implement `.some` and then `.any` would just be `.some(1)`\n. No, `.some(2)` means that at least 2 promises must be fulfilled (So some(1) means 1 promise must be fulfilled I.E. `.any`). The result is the first 2 promises which fulfilled. If 2 promises cannot be fulfilled then it's rejected. See bluebird's [`Promise.some`](https://github.com/petkaantonov/bluebird/blob/master/API.md#promisesomearraydynamicpromise-values-int-count---promise) and CujoJS's [`when.some()`](https://github.com/cujojs/when/blob/master/docs/api.md#whensome)\n. This should do the same thing, all the queries will fire off at the same time\nbut call `displayResult` sequentially in-order.\n\n``` js\nfunction executeQueries(urls) {\n    return urls.map(executeQuery).map(function(query) {\n        return function() {\n            return query.then(displayResult, $.noop);\n        };\n    }).reduce(Q.when, Q());\n}\n\nfunction executeQuery(url) {\n    $.support.cors = true;\n    return Q($.ajax({\n        url: url,\n        type: \"GET\",\n        dataType: \"json\",\n        cache: false,\n        timeout: 5000\n    }));\n}\n```\n\nA good reason to even use promises over async etc is that you don't need the \"there's a function for that\" syndrome.\n. @domenic  Why would you convert everything to promise? I am pretty sure you can't `await` everything in C# and even more sure that yielding non-promise is a bug that you are making harder to find.\n. In such cases you can explicitly just `.cast`:\n\n`yield Q.cast(maybePromise)`\n. The promise constructor can do what deferreds can:\n\n``` js\nfunction getPromise() {\n    var deferred = {};\n    deferred.promise = new Promise(function(resolve, reject) {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n    });\n    deferred.resolve(10);\n    return deferred.promise;\n}\n```\n\nBut the same is easier using the constructor normally:\n\n``` js\nfunction getPromise() {\n    return new Promise(function(resolve) {\n        resolve(10);\n    });\n}\n```\n. It's progress itself that doesn't make any sense to use with promises\n. It's not borked, promsifyAll can wrap primitives and give good traces because there is no spec for promisifaction. Wrapping primitives thrown inside then handler is covered by the spec and doesn't allow changing the primitive in any way and so tracking it is impossible.\n. Yes, libraries that use callbacks and are then promisified work much better than libraries that use some other promise library. You can blame the spec :P\n\nIt is the construction of the wrapping error object that gives the stack trace so no.\n. How do you associate a stack trace with a primitive?\n. There is nothing to catch the error you throw after logging `0.1`?\n. @kriskowal Note that the heuristic should be 'no handlers attached by the start of second turn' (so _after_ queue has been completely flushed), not before as you say. So this way the only way to fool it is to use 3rd party asynchronous boundary in-between.\n. I don't get it, you are attaching the handler synchronously right away.\n. Afaik It returns undefined to defer people from writing code like this as it doesn't make any sense. \n. For performance and less code you should just do\n\n``` js\nvar downloadTwoFilesAsync = Q.async(function* (url1, url2) {\n    var contents1 = yield downloadFileAsync(url1);\n    var contents2 = yield downloadFileAsync(url2);\n    return contents1 + contents2;\n});\n```\n\n_(Also you are wasting perf in waiting for the other file to download before starting to download the second - a sadly common anti-pattern where you are losing all benefit of using asynchronity in the first place)_\n\nIn fact I do not see point of spawn method at all since one needs it once per whole application at most and can replace it with `Q.async(code)()` :P\n. Didn't realize you were using typescript... \n\n>  In fact, when you are using generators you accept that the generated code will be slower\n\nPromises and generators are actually the fastest way and have virtually no overhead over callbacks.  See https://github.com/petkaantonov/bluebird/blob/master/benchmark/stats/latest.md :\n\n``` js\nfile                                 time(ms)  memory(MB)\ncallbacks-baseline.js                     172       34.69\npromises-bluebird-generator.js            234       39.63\n```\n. At least in bluebird the overhead of using spawn like you do is not small but enormous - in that benchmark using spawn over async/coroutine will give result like 1000ms (5x slower).\n\nBut this is irrelevant as you are both using Q and TypeScript...\n\nThis has nothing to do with returning a promise (in fact spawn in bluebird returns a promise) the overhead is in creating the generator wrapper at runtime over and over again from scratch for each call. \n. haha @medikoo needs to see this\n. The mutation of the input is highly unexpected even for arrays and has caused subtle bugs before\n. Note that `Math.random().toString(32).slice(2);` can result in a property name that's not a valid identifier. Adding such property to an object will turn the backing data structure into a hash table in V8. Just like `delete` does or `Object.freeze` did a few months ago. A simple fix is to add a valid identifier start character:\n\n``` js\nvar BRAND = \"b\" + Math.random().toString(32).slice(2);\n```\n\nNode code investigating a brand value that was generated:\n\n``` js\nvar BRAND_1 = \"31t4248\";\nvar BRAND_2 = \"b\" + \"31t4248\";\n\nvar o1 = {};\nvar o2 = {};\n\no1[BRAND_1] = 1;\no2[BRAND_2] = 2;\n\nconsole.log(%HasFastProperties(o1));\nconsole.log(%HasFastProperties(o2));\n```\n\n```\n$ node --allow-natives-syntax brand_test.js\nfalse\ntrue\n```\n. In jQuery code you are assigning the deferred to a local variable whereas in the Q code you assign it to object property.\n. What I am saying is that if\n\n``` js\nvar def = new $.Deferred();\nreturn def;\n```\n\nworks. Then:\n\n``` js\nvar def = Q.defer()\nreturn def.promise;\n```\n\nWill surely work too unless there is inequal code elsewhere as well. I don't understand how the jQuery can have 6 lines of blur and the Q code have no blur yet do the same thing for example.\n. One thing to check out is that Q doesn't create a new array so if at any time after calling Q.all, if you add items to the array, that might cause side effects.\n\nFor example here is simple case that reproduces your issue:\n\nhttp://jsfiddle.net/rKctx/1/\n\n<hr>\n\nYou can try for now something like `Q.all(this.postReserveActions.slice()).then`... as a workaround to see if it works.\n. You could write the stack instead of throwing the error:\n\n``` js\nQ.onerror = function (e) {\n    console.error(e.stack);\n    //If on node.js and want to also shutdown\n    //process.exit(-1);\n};\n```\n. It would be better to implement `.some` and then `.any` would just be `.some(1)`\n. No, `.some(2)` means that at least 2 promises must be fulfilled (So some(1) means 1 promise must be fulfilled I.E. `.any`). The result is the first 2 promises which fulfilled. If 2 promises cannot be fulfilled then it's rejected. See bluebird's [`Promise.some`](https://github.com/petkaantonov/bluebird/blob/master/API.md#promisesomearraydynamicpromise-values-int-count---promise) and CujoJS's [`when.some()`](https://github.com/cujojs/when/blob/master/docs/api.md#whensome)\n. This should do the same thing, all the queries will fire off at the same time\nbut call `displayResult` sequentially in-order.\n\n``` js\nfunction executeQueries(urls) {\n    return urls.map(executeQuery).map(function(query) {\n        return function() {\n            return query.then(displayResult, $.noop);\n        };\n    }).reduce(Q.when, Q());\n}\n\nfunction executeQuery(url) {\n    $.support.cors = true;\n    return Q($.ajax({\n        url: url,\n        type: \"GET\",\n        dataType: \"json\",\n        cache: false,\n        timeout: 5000\n    }));\n}\n```\n\nA good reason to even use promises over async etc is that you don't need the \"there's a function for that\" syndrome.\n. @domenic  Why would you convert everything to promise? I am pretty sure you can't `await` everything in C# and even more sure that yielding non-promise is a bug that you are making harder to find.\n. In such cases you can explicitly just `.cast`:\n\n`yield Q.cast(maybePromise)`\n. The promise constructor can do what deferreds can:\n\n``` js\nfunction getPromise() {\n    var deferred = {};\n    deferred.promise = new Promise(function(resolve, reject) {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n    });\n    deferred.resolve(10);\n    return deferred.promise;\n}\n```\n\nBut the same is easier using the constructor normally:\n\n``` js\nfunction getPromise() {\n    return new Promise(function(resolve) {\n        resolve(10);\n    });\n}\n```\n. It's progress itself that doesn't make any sense to use with promises\n. It's not borked, promsifyAll can wrap primitives and give good traces because there is no spec for promisifaction. Wrapping primitives thrown inside then handler is covered by the spec and doesn't allow changing the primitive in any way and so tracking it is impossible.\n. Yes, libraries that use callbacks and are then promisified work much better than libraries that use some other promise library. You can blame the spec :P\n\nIt is the construction of the wrapping error object that gives the stack trace so no.\n. How do you associate a stack trace with a primitive?\n. There is nothing to catch the error you throw after logging `0.1`?\n. @kriskowal Note that the heuristic should be 'no handlers attached by the start of second turn' (so _after_ queue has been completely flushed), not before as you say. So this way the only way to fool it is to use 3rd party asynchronous boundary in-between.\n. I don't get it, you are attaching the handler synchronously right away.\n. Afaik It returns undefined to defer people from writing code like this as it doesn't make any sense. \n. For performance and less code you should just do\n\n``` js\nvar downloadTwoFilesAsync = Q.async(function* (url1, url2) {\n    var contents1 = yield downloadFileAsync(url1);\n    var contents2 = yield downloadFileAsync(url2);\n    return contents1 + contents2;\n});\n```\n\n_(Also you are wasting perf in waiting for the other file to download before starting to download the second - a sadly common anti-pattern where you are losing all benefit of using asynchronity in the first place)_\n\nIn fact I do not see point of spawn method at all since one needs it once per whole application at most and can replace it with `Q.async(code)()` :P\n. Didn't realize you were using typescript... \n\n>  In fact, when you are using generators you accept that the generated code will be slower\n\nPromises and generators are actually the fastest way and have virtually no overhead over callbacks.  See https://github.com/petkaantonov/bluebird/blob/master/benchmark/stats/latest.md :\n\n``` js\nfile                                 time(ms)  memory(MB)\ncallbacks-baseline.js                     172       34.69\npromises-bluebird-generator.js            234       39.63\n```\n. At least in bluebird the overhead of using spawn like you do is not small but enormous - in that benchmark using spawn over async/coroutine will give result like 1000ms (5x slower).\n\nBut this is irrelevant as you are both using Q and TypeScript...\n\nThis has nothing to do with returning a promise (in fact spawn in bluebird returns a promise) the overhead is in creating the generator wrapper at runtime over and over again from scratch for each call. \n. haha @medikoo needs to see this\n. The mutation of the input is highly unexpected even for arrays and has caused subtle bugs before\n. ",
    "i-love-code": "Core hits allSettled:\n![10-21-2013 11-21-04 am](https://f.cloud.github.com/assets/1737733/1374157/02687228-3a6d-11e3-9408-43fa9fdd5785.png)\n\nAfter user input, promise is resolved with a random value:\n![10-21-2013 11-21-23 am](https://f.cloud.github.com/assets/1737733/1374159/0967559e-3a6d-11e3-829b-2f09d5621924.png)\n\nThe core does _NOT_ continue into the then function of Q.allSettled. Upon further inspection, the promise state is fulfilled but still does not cause the then function to be called.\n![10-21-2013 11-21-57 am](https://f.cloud.github.com/assets/1737733/1374162/16ab8f04-3a6d-11e3-87b9-f8a0c5ae0eba.png)\n. No that's not possible. I've verified that there is only one promise added to the array prior to Q.all, and the array is not modified until we call the following statement where this.plugin.actionToResolve is the promise in the array passed into \"all\".\n\n![10-21-2013 11-21-23 am](https://f.cloud.github.com/assets/1737733/1375673/1228f7aa-3a86-11e3-8265-187120d07535.png)\n\nOne possibility I wanted to clear up is with the placement of the asynchronous action:\n![10-21-2013 10-57-38 am](https://f.cloud.github.com/assets/1737733/1375695/5d50f64c-3a86-11e3-973e-7d2857580f2d.png)\n\nDoes the promise need to be fulfilled inside the function that creates it, before the promise is returned, or can it happen later upon user input (picture 1, which is an event handler called on button click).\n\nIn my application, the core is completely separate from the plugin JS file and only is aware of the array of promises and the single promise inside it. The promise is pushed into the array in the pending state, and modified from the other JS file when the user input is completed.\n. I had to regrettably resort to using JQuery Deferreds. \n\nIt would appear the implementation is correct, as switching out the function that returns the promise:\n\n![10-21-2013 10-57-38 am](https://f.cloud.github.com/assets/1737733/1394907/c91f214a-3c30-11e3-80a4-d755be7da9f7.png)\n\nreplaced with:\n![10-23-2013 5-14-13 pm](https://f.cloud.github.com/assets/1737733/1394908/d1870a5a-3c30-11e3-8e0b-4b4cf4144dca.png)\n\n(Negligible code in the blue on image 2, unrelated JS)\n\nI have tried, but I cannot figure out why the Q.all promise is fulfilled (continues to then function) while promises in the array are still in the pending state, I would prefer to use Q over jQuery. This happens even with 1 promise in the array in the pending state.\n. Is that going to effect the outcome at all? I feel like I tried using the local variable with Q and it did not make a difference.\n. The way the promise was resolved was changed after I ran into the issues. This is the same exact code using Q.defer() as the above JQuery code. The result: The promise returned by Q.all is fulfilled before the promises in the array passed into Q.all are fulfilled.\n\nQ deferred creation:\n![10-23-2013 5-34-31 pm](https://f.cloud.github.com/assets/1737733/1395062/c0f2814e-3c33-11e3-8f61-51d214db2703.png)\n\nQ.all statement passed array of promises.\n![10-23-2013 5-34-44 pm](https://f.cloud.github.com/assets/1737733/1395063/c412f872-3c33-11e3-8ea3-abf5b6a8ec5a.png)\n\nPromise Array contains 1 pending promise\n![10-23-2013 5-35-04 pm](https://f.cloud.github.com/assets/1737733/1395065/c62034c2-3c33-11e3-9aaf-1cbd33edde4b.png)\n\nQ continues into successfully fulfilled promise function\n![10-23-2013 5-35-48 pm](https://f.cloud.github.com/assets/1737733/1395066/c92bb9b6-3c33-11e3-9e19-8283dafa4355.png)\n\nThe arguments shows the promise is still pending.\n![10-23-2013 5-35-35 pm](https://f.cloud.github.com/assets/1737733/1395067/cad9a00c-3c33-11e3-8512-8e3364a53a20.png)\n\nI have no explanation and for whatever reason cannot repeat the issue. Swapping out for JQuery deferreds works fine. I will work on isolating a similar situation tonight.\n\nNo blur added. No magic here.\n. The order in which the screenshots are given is the order in which the occur. There is only one item added to the array, and it is added prior to Q.all. \n\n> On Oct 23, 2013, at 6:14 PM, Petka Antonov notifications@github.com wrote:\n> \n> One thing to check out is that Q doesn't create a new array so if at any time after calling Q.all, if you add items to the array, that might cause side effects.\n> \n> For example here is simple case that reproduces your issue:\n> \n> http://jsfiddle.net/rKctx/1/\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Core hits allSettled:\n![10-21-2013 11-21-04 am](https://f.cloud.github.com/assets/1737733/1374157/02687228-3a6d-11e3-9408-43fa9fdd5785.png)\n\nAfter user input, promise is resolved with a random value:\n![10-21-2013 11-21-23 am](https://f.cloud.github.com/assets/1737733/1374159/0967559e-3a6d-11e3-829b-2f09d5621924.png)\n\nThe core does _NOT_ continue into the then function of Q.allSettled. Upon further inspection, the promise state is fulfilled but still does not cause the then function to be called.\n![10-21-2013 11-21-57 am](https://f.cloud.github.com/assets/1737733/1374162/16ab8f04-3a6d-11e3-87b9-f8a0c5ae0eba.png)\n. No that's not possible. I've verified that there is only one promise added to the array prior to Q.all, and the array is not modified until we call the following statement where this.plugin.actionToResolve is the promise in the array passed into \"all\".\n\n![10-21-2013 11-21-23 am](https://f.cloud.github.com/assets/1737733/1375673/1228f7aa-3a86-11e3-8265-187120d07535.png)\n\nOne possibility I wanted to clear up is with the placement of the asynchronous action:\n![10-21-2013 10-57-38 am](https://f.cloud.github.com/assets/1737733/1375695/5d50f64c-3a86-11e3-973e-7d2857580f2d.png)\n\nDoes the promise need to be fulfilled inside the function that creates it, before the promise is returned, or can it happen later upon user input (picture 1, which is an event handler called on button click).\n\nIn my application, the core is completely separate from the plugin JS file and only is aware of the array of promises and the single promise inside it. The promise is pushed into the array in the pending state, and modified from the other JS file when the user input is completed.\n. I had to regrettably resort to using JQuery Deferreds. \n\nIt would appear the implementation is correct, as switching out the function that returns the promise:\n\n![10-21-2013 10-57-38 am](https://f.cloud.github.com/assets/1737733/1394907/c91f214a-3c30-11e3-80a4-d755be7da9f7.png)\n\nreplaced with:\n![10-23-2013 5-14-13 pm](https://f.cloud.github.com/assets/1737733/1394908/d1870a5a-3c30-11e3-8e0b-4b4cf4144dca.png)\n\n(Negligible code in the blue on image 2, unrelated JS)\n\nI have tried, but I cannot figure out why the Q.all promise is fulfilled (continues to then function) while promises in the array are still in the pending state, I would prefer to use Q over jQuery. This happens even with 1 promise in the array in the pending state.\n. Is that going to effect the outcome at all? I feel like I tried using the local variable with Q and it did not make a difference.\n. The way the promise was resolved was changed after I ran into the issues. This is the same exact code using Q.defer() as the above JQuery code. The result: The promise returned by Q.all is fulfilled before the promises in the array passed into Q.all are fulfilled.\n\nQ deferred creation:\n![10-23-2013 5-34-31 pm](https://f.cloud.github.com/assets/1737733/1395062/c0f2814e-3c33-11e3-8f61-51d214db2703.png)\n\nQ.all statement passed array of promises.\n![10-23-2013 5-34-44 pm](https://f.cloud.github.com/assets/1737733/1395063/c412f872-3c33-11e3-8ea3-abf5b6a8ec5a.png)\n\nPromise Array contains 1 pending promise\n![10-23-2013 5-35-04 pm](https://f.cloud.github.com/assets/1737733/1395065/c62034c2-3c33-11e3-9aaf-1cbd33edde4b.png)\n\nQ continues into successfully fulfilled promise function\n![10-23-2013 5-35-48 pm](https://f.cloud.github.com/assets/1737733/1395066/c92bb9b6-3c33-11e3-9e19-8283dafa4355.png)\n\nThe arguments shows the promise is still pending.\n![10-23-2013 5-35-35 pm](https://f.cloud.github.com/assets/1737733/1395067/cad9a00c-3c33-11e3-8512-8e3364a53a20.png)\n\nI have no explanation and for whatever reason cannot repeat the issue. Swapping out for JQuery deferreds works fine. I will work on isolating a similar situation tonight.\n\nNo blur added. No magic here.\n. The order in which the screenshots are given is the order in which the occur. There is only one item added to the array, and it is added prior to Q.all. \n\n> On Oct 23, 2013, at 6:14 PM, Petka Antonov notifications@github.com wrote:\n> \n> One thing to check out is that Q doesn't create a new array so if at any time after calling Q.all, if you add items to the array, that might cause side effects.\n> \n> For example here is simple case that reproduces your issue:\n> \n> http://jsfiddle.net/rKctx/1/\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "pwmckenna": "Thanks! That's exactly what I was looking for. I'll make sure to rtfm next time :)\n. What your code is doing is the async equivalent of:\n\n``` js\ntry {\n  //whatever dtd does\n} catch (err) {\n    console.warn('NO');\n}\nthisMethodDoesntExist();\nconsole.warn('YES');\n```\n\n...hopefully this makes it a bit more obvious why you're not seeing the logging from the success handler. if you want the fail handler to catch errors in your success handler as well as the original promise, you'll want to move it to the end of the chain like so:\n\n``` coffee\ndfd.then(@success).catch(@fail)\n```\n\nIf you indeed only want to catch failures in the original code and are just a bit confused about the promise side of things, just move the 'YES' logging to the top of the success handler and it should start to make more sense.\n\nI have a write up about exactly this here: http://pwmckenna.com/2014/01/15/promises-in-production.html, specifically the section \"Trailing Exception Handlers\". \n. if you just want the exceptions to bubble up to the process level, then @taudep is right, just use `done` like so: `dfd.then(@success).done()`.\n\nIf Q treated errors and rejected promises differently, then you'd never be able to use promises with any external library that wasn't implemented using promises, because you'd have no way to capture the errors. By capturing them in a rejected promise it offers you the option of handling them, or letting them propagate the way you want what you desire using `.done()`. \n. slightly related...I've been trying to write a library that traces the resolution of large promise chains, and its impossible to hook most functions. ie, hooking Q itself is impossible, but would be rather simple if everything just referenced `module.exports.Q`. Does your reasonable/pull req statement apply to all the things?\n. alternatively use spread, though it works best when you're waiting for a known set of promises (as is the case in your example), rather than a dynamically generated array:\n\n``` js\nvar q = require('q');\nq.all([q('a'), q('b')]).spread(function (a, b) {\n// a === 'a'\n// b === 'b'\n});\n```\n. Defers resolved multiple times will forward the first value to the then callbacks. Why would you want to resolve a defer multiple times? Are you trying to do something asynchronous over and over, but not starting a second time until the first operation is complete?\n. Thanks! That's exactly what I was looking for. I'll make sure to rtfm next time :)\n. What your code is doing is the async equivalent of:\n\n``` js\ntry {\n  //whatever dtd does\n} catch (err) {\n    console.warn('NO');\n}\nthisMethodDoesntExist();\nconsole.warn('YES');\n```\n\n...hopefully this makes it a bit more obvious why you're not seeing the logging from the success handler. if you want the fail handler to catch errors in your success handler as well as the original promise, you'll want to move it to the end of the chain like so:\n\n``` coffee\ndfd.then(@success).catch(@fail)\n```\n\nIf you indeed only want to catch failures in the original code and are just a bit confused about the promise side of things, just move the 'YES' logging to the top of the success handler and it should start to make more sense.\n\nI have a write up about exactly this here: http://pwmckenna.com/2014/01/15/promises-in-production.html, specifically the section \"Trailing Exception Handlers\". \n. if you just want the exceptions to bubble up to the process level, then @taudep is right, just use `done` like so: `dfd.then(@success).done()`.\n\nIf Q treated errors and rejected promises differently, then you'd never be able to use promises with any external library that wasn't implemented using promises, because you'd have no way to capture the errors. By capturing them in a rejected promise it offers you the option of handling them, or letting them propagate the way you want what you desire using `.done()`. \n. slightly related...I've been trying to write a library that traces the resolution of large promise chains, and its impossible to hook most functions. ie, hooking Q itself is impossible, but would be rather simple if everything just referenced `module.exports.Q`. Does your reasonable/pull req statement apply to all the things?\n. alternatively use spread, though it works best when you're waiting for a known set of promises (as is the case in your example), rather than a dynamically generated array:\n\n``` js\nvar q = require('q');\nq.all([q('a'), q('b')]).spread(function (a, b) {\n// a === 'a'\n// b === 'b'\n});\n```\n. Defers resolved multiple times will forward the first value to the then callbacks. Why would you want to resolve a defer multiple times? Are you trying to do something asynchronous over and over, but not starting a second time until the first operation is complete?\n. ",
    "toymachiner62": "I'd like this to be reevaluated. I'm seeing the same results using web storm IDE. My stacktrace is the same whether I set `Q.longStackSupport = true` or not.\n. Not using a browser. Using [Web Storm](http://www.jetbrains.com/webstorm/) IDE. I'm using this q module in node and my web storm terminal is not showing the long stack support.\n. Same thing in a windows command prompt so it's not IDE related..\n. I'm not familiar with exception.stack. Can you elaborate on how I would use this to prove whether Q.longStackSupport is working or not?\n. I'm also seeing this same thing in the mac terminal. No long stack trace is shown.\n. I'd like this to be reevaluated. I'm seeing the same results using web storm IDE. My stacktrace is the same whether I set `Q.longStackSupport = true` or not.\n. Not using a browser. Using [Web Storm](http://www.jetbrains.com/webstorm/) IDE. I'm using this q module in node and my web storm terminal is not showing the long stack support.\n. Same thing in a windows command prompt so it's not IDE related..\n. I'm not familiar with exception.stack. Can you elaborate on how I would use this to prove whether Q.longStackSupport is working or not?\n. I'm also seeing this same thing in the mac terminal. No long stack trace is shown.\n. ",
    "gaboom": "I really can not explain, suddenly I have the same problem on the node console:\n\n```\ngab@Kamorka:~/src/nobe$ bash --version\nbash --version\nGNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2013 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n\nThis is free software; you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\ngab@Kamorka:~/src/nobe$ node --version\nnode --version\nv0.10.25\n```\n\nIf I use .catch() the received exception contains correct stack trace, it does change with the longStackSupport being turned on/off.\n\nHowever if I use done(), the only exception I receive, regardless of any option is:\n\n```\n/home/gab/src/nobe/node_modules/q/q.js:128\n                    throw e;\n```\n\nThis is really unhelpful and I fail to see yet what causes a different stack being shown. And what caused this change in behaviour?\n. I really can not explain, suddenly I have the same problem on the node console:\n\n```\ngab@Kamorka:~/src/nobe$ bash --version\nbash --version\nGNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2013 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n\nThis is free software; you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\ngab@Kamorka:~/src/nobe$ node --version\nnode --version\nv0.10.25\n```\n\nIf I use .catch() the received exception contains correct stack trace, it does change with the longStackSupport being turned on/off.\n\nHowever if I use done(), the only exception I receive, regardless of any option is:\n\n```\n/home/gab/src/nobe/node_modules/q/q.js:128\n                    throw e;\n```\n\nThis is really unhelpful and I fail to see yet what causes a different stack being shown. And what caused this change in behaviour?\n. ",
    "Raynos": "Right now the AGen spec has some thought into it to handle the majority of the common use cases without external helper libraries.\n\nIf we can get some minimal interop between generator runner libraries you can start exporting generator functions on npm and use `yield* functionFromOtherModule()`.\n\nFeedback is welcome on what a good minimal set of runner functionality is so that generator functions exported by modules can work with multiple runners\n. Right now the AGen spec has some thought into it to handle the majority of the common use cases without external helper libraries.\n\nIf we can get some minimal interop between generator runner libraries you can start exporting generator functions on npm and use `yield* functionFromOtherModule()`.\n\nFeedback is welcome on what a good minimal set of runner functionality is so that generator functions exported by modules can work with multiple runners\n. ",
    "jessep": ":+1: \n\nSeems a bit funny not to have an obvious pre-build version that's browser compatible. Should be linked to here: https://github.com/kriskowal/q#getting-started\n. Ah, great. Thanks!\n. :+1: \n\nSeems a bit funny not to have an obvious pre-build version that's browser compatible. Should be linked to here: https://github.com/kriskowal/q#getting-started\n. Ah, great. Thanks!\n. ",
    "OliverJAsh": "@domenic Published a draft of this module to https://gist.github.com/OliverJAsh/0c755bd05219fb8011cf. Would love some feedback before I publish, or a better name :smile: \n. I've updated this issue with a more succint description. Could we re-open this issue and consider adding it to Q, as a counterpart to `promise.nodeify`?\n. Published to https://github.com/OliverJAsh/nodeify-function.\n. I'll be using Traceur\u2019s ES6 `Promise` polyfill which will hopefully support this: https://github.com/google/traceur-compiler/pull/1518\n\nNo idea how this would be possible in Q for ES5. We could duck type the argument to see if it looks like an iterable and then use `for`-`in` in place of `for`-`of`? I could be miles off.\n. In my mind, this would work. Is it something Q would be interested in?\n. @domenic Published a draft of this module to https://gist.github.com/OliverJAsh/0c755bd05219fb8011cf. Would love some feedback before I publish, or a better name :smile: \n. I've updated this issue with a more succint description. Could we re-open this issue and consider adding it to Q, as a counterpart to `promise.nodeify`?\n. Published to https://github.com/OliverJAsh/nodeify-function.\n. I'll be using Traceur\u2019s ES6 `Promise` polyfill which will hopefully support this: https://github.com/google/traceur-compiler/pull/1518\n\nNo idea how this would be possible in Q for ES5. We could duck type the argument to see if it looks like an iterable and then use `for`-`in` in place of `for`-`of`? I could be miles off.\n. In my mind, this would work. Is it something Q would be interested in?\n. ",
    "falsyvalues": "Sure, but if you download the file, you have no such information.\n. Metadata ideally fits into release files. This should be part of build process, rather than manual file management as @kriskowal mention here https://github.com/kriskowal/q/issues/483#issuecomment-35421907.\n. Sure, but if you download the file, you have no such information.\n. Metadata ideally fits into release files. This should be part of build process, rather than manual file management as @kriskowal mention here https://github.com/kriskowal/q/issues/483#issuecomment-35421907.\n. ",
    "kilianc": "@domenic thanks.\n\nSo, what do you suggest, how would you change the wait function accordingly?\nI guess my goal here is to get a chainable version of my function.\n\nHow do you `.then` multiple promises if `then` accept only a function?\n. Ok. I just wish I could pass in a promise and chain them.\nThanks :+1: \n. This is close, I just think the first line i ugly, something like `Q.then()` would help.\n\n``` js\nfunction wait(ms) {\n  return function _wait(res) {\n    var deferred = defer()\n    setTimeout(deferred.makeNodeResolver(), ms)\n    return deferred.promise\n  }\n}\n\nwait(1000)()\n  .then(wait(1000))\n  .then(wait(200))\n  .then(wait(50))\n  .done(function () {\n    console.log('ok')\n  })\n```\n. Also:\n\n``` js\nfunction wait(ms, callback) {\n  // create a promise if there's no callback\n  if (undefined === callback) {\n    var args = [].slice.call(arguments)\n    return function makePromise(res) {\n      var deferred = defer()\n      args.push(deferred.makeNodeResolver())\n      wait.apply(this, args)\n      return deferred.promise\n    }\n  }\n\n  // function body\n  setTimeout(callback, ms)\n}\n\nwait(100, function () {\n  console.log('ok callback')\n})\n\nwait(1000)()\n  .then(wait(1000))\n  .then(wait(200))\n  .then(wait(50))\n  .done(function () {\n    console.log('ok')\n  })\n```\n. @domenic thanks.\n\nSo, what do you suggest, how would you change the wait function accordingly?\nI guess my goal here is to get a chainable version of my function.\n\nHow do you `.then` multiple promises if `then` accept only a function?\n. Ok. I just wish I could pass in a promise and chain them.\nThanks :+1: \n. This is close, I just think the first line i ugly, something like `Q.then()` would help.\n\n``` js\nfunction wait(ms) {\n  return function _wait(res) {\n    var deferred = defer()\n    setTimeout(deferred.makeNodeResolver(), ms)\n    return deferred.promise\n  }\n}\n\nwait(1000)()\n  .then(wait(1000))\n  .then(wait(200))\n  .then(wait(50))\n  .done(function () {\n    console.log('ok')\n  })\n```\n. Also:\n\n``` js\nfunction wait(ms, callback) {\n  // create a promise if there's no callback\n  if (undefined === callback) {\n    var args = [].slice.call(arguments)\n    return function makePromise(res) {\n      var deferred = defer()\n      args.push(deferred.makeNodeResolver())\n      wait.apply(this, args)\n      return deferred.promise\n    }\n  }\n\n  // function body\n  setTimeout(callback, ms)\n}\n\nwait(100, function () {\n  console.log('ok callback')\n})\n\nwait(1000)()\n  .then(wait(1000))\n  .then(wait(200))\n  .then(wait(50))\n  .done(function () {\n    console.log('ok')\n  })\n```\n. ",
    "bluepnume": "Perfect, thanks! This is exactly it.\n. Perfect, thanks! This is exactly it.\n. ",
    "jouni-kantola": "I first tried running from master, but I got a couple of errors in node. I didn't check that closely, now that I think about it. An npm install maybe would have fixed them.\n. Seems like I managed to prove my not so awesome git shell skills by getting the four previous commits in my merge. Anyways, what was intended was c703f1a and edeb9c4. I guess I branched from a branch with commits that weren't previously merged into master.\n. The previous task needs to be resolved, for the next one to be resolved. I'll post an example which maybe clarifies what is the purpose:\nhttp://www.t\u00e5g.net/Routes/from/74,U/to/74,CST\n\nSince it's a timetable, it's important that the data is displayed in the same order they are queried. However, it's not important that _all_ promises (queries) are resolved for results to be displayed. That would be contra-productive. Hence these rows:\nhttps://github.com/jouni-kantola/q/blob/chain/q.js#L1614-1617\n. No worries, I'm glad the Q lib exists. \n\nHowever, the tasks.reduce(Q.when, Q()) pattern, would that work in the scenario with parallel Ajax calls, and the order is predefined? The order for presentation must match the order of making the call, not when the promise is resolved.\n. Thanks for taking the time to discus the lib and patterns for usage. I tried tasks.reduce(Q.when, Q()) and it's not the sequence per se I'm after. That is, I don't want to wait for task 1/promise 1 to be resolved to continue with task 2. Check the image below which visualizes what Q.chain achieved (I'm sure there are better ways to implement it). First I called the helper function Q.serializeParallel, which probably explains the use better, now that we've discussed it further.\n\n![image](https://f.cloud.github.com/assets/2670127/1609619/292e264e-554f-11e3-82e9-ac581a3e6202.png)\n. I got an example snippet that's a off-the-head typed variant (so might contain oddities) of how the queries are done at http://www.t\u00e5g.net.\n\n``` javascript\nfunction executeQueries(urls) {\n    var tasks = urls.map(function(url) {\n        return makeAjaxTask(url);\n    });\n    Q.chain(tasks);\n};\n\nfunction makeAjaxTask(url) {\n    return function(deferred) {\n        $.ajax({\n            url: url,\n            type: \"GET\",\n            dataType: \"json\",\n            cache: false,\n            success: function(data) {\n                deferred.resolve(function() {\n                    displayResult(data);\n                });\n            },\n            error: function() {\n                // deferred.reject(function () {\n                // });\n            },\n            timeout: 5000\n        });\n    };\n};\n```\n. @petkaantonov I'll try it out. Thanks for your input.\n@kriskowal I think my picture gave a bit of mis-information, now that I look at it again. The queries should run in parallel, but output should be handled as soon as call 1's promise is resolved, after that 2, and so forth. \n. :+1: \n\nImplemented and tested. Works just as intended, @petkaantonov.\n\nThanks a lot, guys!\n. I first tried running from master, but I got a couple of errors in node. I didn't check that closely, now that I think about it. An npm install maybe would have fixed them.\n. Seems like I managed to prove my not so awesome git shell skills by getting the four previous commits in my merge. Anyways, what was intended was c703f1a and edeb9c4. I guess I branched from a branch with commits that weren't previously merged into master.\n. The previous task needs to be resolved, for the next one to be resolved. I'll post an example which maybe clarifies what is the purpose:\nhttp://www.t\u00e5g.net/Routes/from/74,U/to/74,CST\n\nSince it's a timetable, it's important that the data is displayed in the same order they are queried. However, it's not important that _all_ promises (queries) are resolved for results to be displayed. That would be contra-productive. Hence these rows:\nhttps://github.com/jouni-kantola/q/blob/chain/q.js#L1614-1617\n. No worries, I'm glad the Q lib exists. \n\nHowever, the tasks.reduce(Q.when, Q()) pattern, would that work in the scenario with parallel Ajax calls, and the order is predefined? The order for presentation must match the order of making the call, not when the promise is resolved.\n. Thanks for taking the time to discus the lib and patterns for usage. I tried tasks.reduce(Q.when, Q()) and it's not the sequence per se I'm after. That is, I don't want to wait for task 1/promise 1 to be resolved to continue with task 2. Check the image below which visualizes what Q.chain achieved (I'm sure there are better ways to implement it). First I called the helper function Q.serializeParallel, which probably explains the use better, now that we've discussed it further.\n\n![image](https://f.cloud.github.com/assets/2670127/1609619/292e264e-554f-11e3-82e9-ac581a3e6202.png)\n. I got an example snippet that's a off-the-head typed variant (so might contain oddities) of how the queries are done at http://www.t\u00e5g.net.\n\n``` javascript\nfunction executeQueries(urls) {\n    var tasks = urls.map(function(url) {\n        return makeAjaxTask(url);\n    });\n    Q.chain(tasks);\n};\n\nfunction makeAjaxTask(url) {\n    return function(deferred) {\n        $.ajax({\n            url: url,\n            type: \"GET\",\n            dataType: \"json\",\n            cache: false,\n            success: function(data) {\n                deferred.resolve(function() {\n                    displayResult(data);\n                });\n            },\n            error: function() {\n                // deferred.reject(function () {\n                // });\n            },\n            timeout: 5000\n        });\n    };\n};\n```\n. @petkaantonov I'll try it out. Thanks for your input.\n@kriskowal I think my picture gave a bit of mis-information, now that I look at it again. The queries should run in parallel, but output should be handled as soon as call 1's promise is resolved, after that 2, and so forth. \n. :+1: \n\nImplemented and tested. Works just as intended, @petkaantonov.\n\nThanks a lot, guys!\n. ",
    "ndkrempel": "I share your concerns about overloading; we don't want it to turn into the JavaScript `Array` constructor!\n\nIn this case, I can't think of a practical use for `yield`ing a non-promise, and we could make `yield`ing a non-promise non-Array throw an exception to avoid any potential confusion.\n\nHaving a separate keyword would be better, but since ES7 is quite a long way off, we have to thread any functionality we want through the `yield` keyword for the time being.\n. It's possible you have some value and you neither know nor care whether it's a promise or an actual value. Then `yield` can be applied to it to get a value in either case. Not sure how likely this would be in a well-structured program however...\n. Agree that requiring an explicit `Q(...)` or `cast` would be a good thing.\n. Yes, that's a good way of putting it, and I think explains why `yield Q.all([...])` is needed so much - you don't want to have to assign each promise to a local variable when it's only used once as an argument to `yield`!\n. If you prefer, you can think of `yield` as always taking an array, and `yield x` for non-array `x` is just a shorthand for `yield [x]`. This is a reasonably common convention in existing JavaScript.\n\nAnyway, I think I've said all there is to be said on the topic of this shorthand, and I defer (no pun intended) to your better judgement!\n. @erights\n`yield Q.all([x])` would have (and has) as its value a singleton array containing the promised value of x, not a promise for such.\n\nBut agree that the shorthand applies to the output as well as the input (if you used the shorthand `yield x` you get the promised value of `x` back, not a singleton array with the promised value of `x`).\n. @erights The C# equivalent seems to be `await Task.WhenAll(x, y, z)`. Note that they save on the array delimiters by having `Task.WhenAll` variadic, which improves readability I think.\n. @erights Some quick figures...\n\nGoogle search for \"C#\" \"await\": 351,000 results.\nGoogle search for \"C#\" \"await Task.WhenAll\": 22,200 results.\nThis is 6.3% (higher than I expected actually).\n\nOhloh code search for \"await\" (limited to C#): 6,008 results.\nOhloh code search for \"await Task.WhenAll\" (limited to C#): 121 results.\nThis is 2.0%.\n\nBear in mind that many users are inadvertently (or because they don't care about performance) serialising their code with `x = await AsyncOp1()` followed by `y = await AsyncOp2()`, and also that there are other idioms for parallel execution of tasks. Furthermore some of the matches for plain \"await\" are false positives... yes someone really has \"class await\".\n\nIt seems to me that it is common because it is necessary whenever you have a parallel fork point (e.g. waiting on multiple async operations), but without the annoyance of having to introduce a local variable solely to kick-off an async operation:\n\n``` javascript\nvar p1 = asyncOp1(), p2 = asyncOp2(), p3 = asyncOp3();\nvar v1 = yield p1, v2 = yield p2, v3 = yield p3;\n```\n\n...is a bit too long-winded!\n. @erights I would say it is, although more specifically the problem there is the line-noise aspect. Compare:\n\n``` javascript\nconst [v1, v2, v3] = yield [op1(), op2(), op3()];\n```\n\nI admit that if `Q.all` were variadic, that would also help your example.\n. @erights As for the implicit cast, see @petkaantonov's comments. I think `await nonTaskValue` is not allowed in C#, and there is an argument for `yield nonPromiseValue` throwing an error as it would most likely indicate a bug, particularly given the dynamically typed nature of JavaScript (again see earlier discussion.) In some hypothetical case where a cast is desired, it seems to be clearer to make it explicit as `yield Q(nonPromise)` or `yield Q(maybePromise)` (actually there is no use for the first of these is there?).\n. I share your concerns about overloading; we don't want it to turn into the JavaScript `Array` constructor!\n\nIn this case, I can't think of a practical use for `yield`ing a non-promise, and we could make `yield`ing a non-promise non-Array throw an exception to avoid any potential confusion.\n\nHaving a separate keyword would be better, but since ES7 is quite a long way off, we have to thread any functionality we want through the `yield` keyword for the time being.\n. It's possible you have some value and you neither know nor care whether it's a promise or an actual value. Then `yield` can be applied to it to get a value in either case. Not sure how likely this would be in a well-structured program however...\n. Agree that requiring an explicit `Q(...)` or `cast` would be a good thing.\n. Yes, that's a good way of putting it, and I think explains why `yield Q.all([...])` is needed so much - you don't want to have to assign each promise to a local variable when it's only used once as an argument to `yield`!\n. If you prefer, you can think of `yield` as always taking an array, and `yield x` for non-array `x` is just a shorthand for `yield [x]`. This is a reasonably common convention in existing JavaScript.\n\nAnyway, I think I've said all there is to be said on the topic of this shorthand, and I defer (no pun intended) to your better judgement!\n. @erights\n`yield Q.all([x])` would have (and has) as its value a singleton array containing the promised value of x, not a promise for such.\n\nBut agree that the shorthand applies to the output as well as the input (if you used the shorthand `yield x` you get the promised value of `x` back, not a singleton array with the promised value of `x`).\n. @erights The C# equivalent seems to be `await Task.WhenAll(x, y, z)`. Note that they save on the array delimiters by having `Task.WhenAll` variadic, which improves readability I think.\n. @erights Some quick figures...\n\nGoogle search for \"C#\" \"await\": 351,000 results.\nGoogle search for \"C#\" \"await Task.WhenAll\": 22,200 results.\nThis is 6.3% (higher than I expected actually).\n\nOhloh code search for \"await\" (limited to C#): 6,008 results.\nOhloh code search for \"await Task.WhenAll\" (limited to C#): 121 results.\nThis is 2.0%.\n\nBear in mind that many users are inadvertently (or because they don't care about performance) serialising their code with `x = await AsyncOp1()` followed by `y = await AsyncOp2()`, and also that there are other idioms for parallel execution of tasks. Furthermore some of the matches for plain \"await\" are false positives... yes someone really has \"class await\".\n\nIt seems to me that it is common because it is necessary whenever you have a parallel fork point (e.g. waiting on multiple async operations), but without the annoyance of having to introduce a local variable solely to kick-off an async operation:\n\n``` javascript\nvar p1 = asyncOp1(), p2 = asyncOp2(), p3 = asyncOp3();\nvar v1 = yield p1, v2 = yield p2, v3 = yield p3;\n```\n\n...is a bit too long-winded!\n. @erights I would say it is, although more specifically the problem there is the line-noise aspect. Compare:\n\n``` javascript\nconst [v1, v2, v3] = yield [op1(), op2(), op3()];\n```\n\nI admit that if `Q.all` were variadic, that would also help your example.\n. @erights As for the implicit cast, see @petkaantonov's comments. I think `await nonTaskValue` is not allowed in C#, and there is an argument for `yield nonPromiseValue` throwing an error as it would most likely indicate a bug, particularly given the dynamically typed nature of JavaScript (again see earlier discussion.) In some hypothetical case where a cast is desired, it seems to be clearer to make it explicit as `yield Q(nonPromise)` or `yield Q(maybePromise)` (actually there is no use for the first of these is there?).\n. ",
    "mhahne": "Updated code to check for window.console, and code style fixes.\n. Updated code to check for window.console, and code style fixes.\n. ",
    "tschaub": "Curious why you only call `console.warn` if `window` is defined.  Is this intentionally not supposed to warn in node's console (or other)?  Seems like `typeof console` is what you want to check (instead of `typeof window`).\n. Curious why you only call `console.warn` if `window` is defined.  Is this intentionally not supposed to warn in node's console (or other)?  Seems like `typeof console` is what you want to check (instead of `typeof window`).\n. ",
    "torifat": "@kriskowal there are lots of branches in your repo so I'm not sure which one to check. But, I have checked with both `v0.9` & `master` branch. The behavior is same.\n\nAnd, thanks for the clarification :smile: \n. @kriskowal there are lots of branches in your repo so I'm not sure which one to check. But, I have checked with both `v0.9` & `master` branch. The behavior is same.\n\nAnd, thanks for the clarification :smile: \n. ",
    "ayeressian": "One possible ugly workaround would be to add setTimeout.\n\n``` javascript\nfunction get() {\n    var deferred = Q.defer();\n    setTimeout(function() {\n        deferred.notify('hello');\n    });\n    setTimeout(function () {\n        deferred.resolve('world!');\n    }, 2000);\n    return deferred.promise;\n}\n\nfunction doTheThing(data) {\n    alert(data)\n}\n\nget().then(doTheThing, doTheThing, doTheThing);\n```\n. One possible ugly workaround would be to add setTimeout.\n\n``` javascript\nfunction get() {\n    var deferred = Q.defer();\n    setTimeout(function() {\n        deferred.notify('hello');\n    });\n    setTimeout(function () {\n        deferred.resolve('world!');\n    }, 2000);\n    return deferred.promise;\n}\n\nfunction doTheThing(data) {\n    alert(data)\n}\n\nget().then(doTheThing, doTheThing, doTheThing);\n```\n. ",
    "mmavko": "Ok, thanks for this clarification :)\n. Ok, thanks for this clarification :)\n. ",
    "hopehopehope": "Does this issue indicate that there should be a test whether Q.js is Promise/A+ compliant?\nSince I cannot find this on the main page here https://github.com/kriskowal/q please allow this\nseemingly stupid question:\n\n Q.js should be Promise/A+ implementation, right?\n\nIndeed there lots of useful information in the https://github.com/kriskowal/q page but at present\nI cannot see an indication regarding this there.\n. thanks\n. Does this issue indicate that there should be a test whether Q.js is Promise/A+ compliant?\nSince I cannot find this on the main page here https://github.com/kriskowal/q please allow this\nseemingly stupid question:\n\n Q.js should be Promise/A+ implementation, right?\n\nIndeed there lots of useful information in the https://github.com/kriskowal/q page but at present\nI cannot see an indication regarding this there.\n. thanks\n. ",
    "benpoyet": "Hi,\n\nThanks for taking a look. I will add the return statement ASAP.\n\nTo give you a little context, I find myself writing a lot of\npromise-returning functions that I need to export as nodeback-taking\nfunctions. This is because I'm migrating an older codebase to the newer\npromise style. With Q.nodeified, I can perform this conversion at export\ntime:\n\nmodule.exports.nodebackFunc = Q.nodeified(this, promiseFunc);\n\nI have found that this is the cleanest way to wrap my new promise-returning\nfunctions in the event that older code needs to invoke them with a nodeback.\n\nThanks,\nBen\n\nOn Dec 20, 2013, at 12:45, Kris Kowal notifications@github.com wrote:\n\nI might take this. Going to think on it.\n\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/kriskowal/q/pull/451#issuecomment-31027632\n.\n. Hello,\n\nHave you given this method any thought? I find myself using it at great length while converting a large project incrementally to q.\n\nThanks,\nBen\n. Hi,\n\nThanks for taking a look. I will add the return statement ASAP.\n\nTo give you a little context, I find myself writing a lot of\npromise-returning functions that I need to export as nodeback-taking\nfunctions. This is because I'm migrating an older codebase to the newer\npromise style. With Q.nodeified, I can perform this conversion at export\ntime:\n\nmodule.exports.nodebackFunc = Q.nodeified(this, promiseFunc);\n\nI have found that this is the cleanest way to wrap my new promise-returning\nfunctions in the event that older code needs to invoke them with a nodeback.\n\nThanks,\nBen\n\nOn Dec 20, 2013, at 12:45, Kris Kowal notifications@github.com wrote:\n\nI might take this. Going to think on it.\n\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/kriskowal/q/pull/451#issuecomment-31027632\n.\n. Hello,\n\nHave you given this method any thought? I find myself using it at great length while converting a large project incrementally to q.\n\nThanks,\nBen\n. ",
    "eric-wieser": "Can you not write that:\n\n``` javascript\nQ(someVal)\n  .then(q.nfcall.bind(q, someFunc));\n  .then(q.nmcall.bind(q, someObj, 'someMethod'));\n  .done();\n```\n. `thenNinvoke` feels a little messy. I think the API you want to go for is:\n\n```\nQ(someVal)\n  .then(q.nfbind(q, someFunc));\n  .then(q.nmbind(q, someObj, 'someMethod'));\n  .done();\n```\n\nwhich then allows you to assign names to these methods:\n\n```\nvar doSomeNodeMethod = q.nmbind(q, someObj, 'someMethod');\nvar doSomeOtherMethod = function(v) {\n    return v + v;\n};\nQ(someVal).then(doSomeOtherMethod).then(doSomeNodeMethod)\n```\n. This seems related to #392\n. Can you not write that:\n\n``` javascript\nQ(someVal)\n  .then(q.nfcall.bind(q, someFunc));\n  .then(q.nmcall.bind(q, someObj, 'someMethod'));\n  .done();\n```\n. `thenNinvoke` feels a little messy. I think the API you want to go for is:\n\n```\nQ(someVal)\n  .then(q.nfbind(q, someFunc));\n  .then(q.nmbind(q, someObj, 'someMethod'));\n  .done();\n```\n\nwhich then allows you to assign names to these methods:\n\n```\nvar doSomeNodeMethod = q.nmbind(q, someObj, 'someMethod');\nvar doSomeOtherMethod = function(v) {\n    return v + v;\n};\nQ(someVal).then(doSomeOtherMethod).then(doSomeNodeMethod)\n```\n. This seems related to #392\n. ",
    "RasterBurn": "Oops... never mind.  I found a bug in my test case.  Ignore!\n. Oops... never mind.  I found a bug in my test case.  Ignore!\n. ",
    "luiscubal": "I am. I was using v0.11.9 but I reverted to v0.11.2 because another node module I needed didn't work on the newer version yet.\nI take it this means [this page](http://wiki.ecmascript.org/doku.php?id=harmony:generators) is outdated as well, then? (the part that says next() is the same as send(undefined))\n\nWhat is the first version of node.js with the new yield behavior?\n. Yes, thank you. I found what I was looking for. https://code.google.com/p/v8/issues/detail?id=2715\nIt was fixed in v8 in June, and in node.js v0.11.3 it already works.\n\nSorry for the inconvenience.\n. I am. I was using v0.11.9 but I reverted to v0.11.2 because another node module I needed didn't work on the newer version yet.\nI take it this means [this page](http://wiki.ecmascript.org/doku.php?id=harmony:generators) is outdated as well, then? (the part that says next() is the same as send(undefined))\n\nWhat is the first version of node.js with the new yield behavior?\n. Yes, thank you. I found what I was looking for. https://code.google.com/p/v8/issues/detail?id=2715\nIt was fixed in v8 in June, and in node.js v0.11.3 it already works.\n\nSorry for the inconvenience.\n. ",
    "ljharb": "Interesting. I find that the ability to explicitly fulfill a promise, after it's created, is highly useful and I rely on it frequently.\n. What I mean by \"after it's created\" is, lexically after the returned promise is created, not temporally.\n\nI totally agree that resolution and observation should be separate - that's the usefulness of Deferreds. If, as @domenic seems to prefer, Deferreds are done away with, how would one achieve that?\n. :-( I still don't understand why Q would have Deferreds but not a way to detect them. How soon will Q be deleting deferreds, if this can't be landed?\n. Interesting. I find that the ability to explicitly fulfill a promise, after it's created, is highly useful and I rely on it frequently.\n. What I mean by \"after it's created\" is, lexically after the returned promise is created, not temporally.\n\nI totally agree that resolution and observation should be separate - that's the usefulness of Deferreds. If, as @domenic seems to prefer, Deferreds are done away with, how would one achieve that?\n. :-( I still don't understand why Q would have Deferreds but not a way to detect them. How soon will Q be deleting deferreds, if this can't be landed?\n. ",
    "kennethjor": "I added the pull request #460 to add support for vert.x. I sent it to the `v1` branch, so I hope that's ok. I'd really like to get this into Q so I can use it on my server as well as my client.\n. It appears there is some way to hack vert.x to do it properly. Will discuss with them. Thanks for your help.\n. What's different about this merge request and #150 is that it's not trying to catch an exception from require(), but rather checking for the existence of a single variable. A better solution no?\n. @kriskowal I see what you mean regarding the random require statement. I agree with you that it would be better for Vert.x to provide support for the function by itself. This is not just an issue with Q, but I've also had to modify async to make it work. I've opened [an issue](https://github.com/vert-x/mod-lang-js/issues/29) with Vert.x's JS module, so let's see what happens there.\n. I added the pull request #460 to add support for vert.x. I sent it to the `v1` branch, so I hope that's ok. I'd really like to get this into Q so I can use it on my server as well as my client.\n. It appears there is some way to hack vert.x to do it properly. Will discuss with them. Thanks for your help.\n. What's different about this merge request and #150 is that it's not trying to catch an exception from require(), but rather checking for the existence of a single variable. A better solution no?\n. @kriskowal I see what you mean regarding the random require statement. I agree with you that it would be better for Vert.x to provide support for the function by itself. This is not just an issue with Q, but I've also had to modify async to make it work. I've opened [an issue](https://github.com/vert-x/mod-lang-js/issues/29) with Vert.x's JS module, so let's see what happens there.\n. ",
    "vishy1618": "``` javascript\n// getMyPromise() --> getMyWorkDone()\n(function () {\n  try {\n    var result = getMyWorkDone();\n    if (result == 'not good')\n      return; // this is the short circuit\n  } catch(e) {\n    return 'something else';\n  }\n\n  return 'awesome ok';\n})()\n```\n. FWIW, I do this currently by returning a promise that doesn't resolve:\n\n``` javascript\n  return Q.defer().promise;\n```\n. Nesting is not really feasible when you have a large codebase, with loose coupling between different components that return promises.\n\nA short circuit would be similar to the work around I'm using now, of returning a promise that doesn't resolve any callbacks registered to it. However, I'm concerned about a memory leak in such situations. Or should I be?\n. Yes, that's exactly the workaround I'm using now.\n\nShould I be concerned that the callbacks, even though registered, doesn't get executed? Will that lead to a memory leak?\n. ``` javascript\n// getMyPromise() --> getMyWorkDone()\n(function () {\n  try {\n    var result = getMyWorkDone();\n    if (result == 'not good')\n      return; // this is the short circuit\n  } catch(e) {\n    return 'something else';\n  }\n\n  return 'awesome ok';\n})()\n```\n. FWIW, I do this currently by returning a promise that doesn't resolve:\n\n``` javascript\n  return Q.defer().promise;\n```\n. Nesting is not really feasible when you have a large codebase, with loose coupling between different components that return promises.\n\nA short circuit would be similar to the work around I'm using now, of returning a promise that doesn't resolve any callbacks registered to it. However, I'm concerned about a memory leak in such situations. Or should I be?\n. Yes, that's exactly the workaround I'm using now.\n\nShould I be concerned that the callbacks, even though registered, doesn't get executed? Will that lead to a memory leak?\n. ",
    "spion": "The easiest way is to nest:\n\n``` js\ngetMyPromise()\n.then(function() {\n  if (getOutOfHere())\n    return;\n  return success().then(function(success) {\n    // this should not be called if getOutOfHere() -> true\n    handleSuccess(success);\n  }, function(failure) {\n    // this should not be called if getOutOfHere() -> true\n    handleFailure(failure);\n  })\n})\n```\n\nA hypothetical `shortCircuit` cannot know how many steps you would want to short-circuit (what if you're returning the promise from a function?)\n. Are you saying you want this?\n\n``` js\n\nfunction f() {\n  return getMyPromise()\n    .then(function () {\n      if (getOutOfHere())\n        return Q.defer().promise;\n    }).then(function (success) {\n      // this should not be called if getOutOfHere() -> true\n      return handleSuccess(success);\n    }, function (failure) {\n      // this should not be called if getOutOfHere() -> true\n      return handleFailure(failure);\n    });\n}\n\nf().then(function() {\n  // this will never execute if getOutOfHere() returns true\n});\n```\n\nBecause your sync code doesn't do that. The equivalent sync code of that is\n\n``` js\nif (getOutOfHere())\n  return foreverBlockingOperation();\n```\n. The easiest way is to nest:\n\n``` js\ngetMyPromise()\n.then(function() {\n  if (getOutOfHere())\n    return;\n  return success().then(function(success) {\n    // this should not be called if getOutOfHere() -> true\n    handleSuccess(success);\n  }, function(failure) {\n    // this should not be called if getOutOfHere() -> true\n    handleFailure(failure);\n  })\n})\n```\n\nA hypothetical `shortCircuit` cannot know how many steps you would want to short-circuit (what if you're returning the promise from a function?)\n. Are you saying you want this?\n\n``` js\n\nfunction f() {\n  return getMyPromise()\n    .then(function () {\n      if (getOutOfHere())\n        return Q.defer().promise;\n    }).then(function (success) {\n      // this should not be called if getOutOfHere() -> true\n      return handleSuccess(success);\n    }, function (failure) {\n      // this should not be called if getOutOfHere() -> true\n      return handleFailure(failure);\n    });\n}\n\nf().then(function() {\n  // this will never execute if getOutOfHere() returns true\n});\n```\n\nBecause your sync code doesn't do that. The equivalent sync code of that is\n\n``` js\nif (getOutOfHere())\n  return foreverBlockingOperation();\n```\n. ",
    "hbrls": "I found a answer on StackOverflow: http://stackoverflow.com/a/20240981/707580.\n\nThe man said some promise/A implementations used `this.stop()` to short circuit. I looked through the docs and I think q doesn't have that. What do you think of it?\n. I found a answer on StackOverflow: http://stackoverflow.com/a/20240981/707580.\n\nThe man said some promise/A implementations used `this.stop()` to short circuit. I looked through the docs and I think q doesn't have that. What do you think of it?\n. ",
    "dts": "I guess I disagree.  A \"promise\" is a to-be object.  It can also fail-to-be, which is a necessary possibility.  What is illogical about there being statuses/progress events along the way to one of those end-states?  HTTP GET requests seem like a great case-in-point, you can handle the data as it comes in, or as a complete bundle once it's in...  The current vogue of indefinite spinners makes it easy to ignore the fact that progress is sometimes predictable and useful information, but I personally value this feature in q.\n. I guess I disagree.  A \"promise\" is a to-be object.  It can also fail-to-be, which is a necessary possibility.  What is illogical about there being statuses/progress events along the way to one of those end-states?  HTTP GET requests seem like a great case-in-point, you can handle the data as it comes in, or as a complete bundle once it's in...  The current vogue of indefinite spinners makes it easy to ignore the fact that progress is sometimes predictable and useful information, but I personally value this feature in q.\n. ",
    "NodeGuy": "I need some kind of progress notification mechanism.  If I don't get it from Q then I can create my own.\n\nI am feeling the cost right now that the progress notification feature in Q isn't fully baked, in an otherwise impeccable library.  Perhaps you could add a warning in the documentation until you figure out what to do about it?\n. I need some kind of progress notification mechanism.  If I don't get it from Q then I can create my own.\n\nI am feeling the cost right now that the progress notification feature in Q isn't fully baked, in an otherwise impeccable library.  Perhaps you could add a warning in the documentation until you figure out what to do about it?\n. ",
    "kbsanders": "To compare, here's a synchronous version of the same login procedure above:\n\n``` JavaScript\ntry{\n\n  // request parameters\n  var username = req.param('username');\n  var password = req.param('password');\n\n  // lookup username in database\n  var user = User.findOneSync({\n    username: username\n  });\n\n  // username does not exist in the database\n  // redirect user back to login page with a flash message\n  if(!user){\n\n    flash('Invalid username!');    \n    res.redirect('/login');\n\n    // return early\n    return; \n  }\n\n  // validate the password with bcrypt\n  var match = bcrypt.compareSync(password,user.password);\n\n  // password did not match\n  // redirect user back to login page with a flash message\n  if(!match){\n\n    flash('Invalid username and/or password!');\n    res.redirect('/login');\n\n    // return early\n    return;     \n  }\n\n  // login was successful, update session\n  // and redirect to admin section of site\n  req.session.authenticated = true;\n  req.session.user = user;\n\n  res.redirect('/admin');\n\n}catch(err){\n\n    // unexpected error\n    // show 500 page \n    res.serverError(err);\n}\n```\n. To compare, here's a synchronous version of the same login procedure above:\n\n``` JavaScript\ntry{\n\n  // request parameters\n  var username = req.param('username');\n  var password = req.param('password');\n\n  // lookup username in database\n  var user = User.findOneSync({\n    username: username\n  });\n\n  // username does not exist in the database\n  // redirect user back to login page with a flash message\n  if(!user){\n\n    flash('Invalid username!');    \n    res.redirect('/login');\n\n    // return early\n    return; \n  }\n\n  // validate the password with bcrypt\n  var match = bcrypt.compareSync(password,user.password);\n\n  // password did not match\n  // redirect user back to login page with a flash message\n  if(!match){\n\n    flash('Invalid username and/or password!');\n    res.redirect('/login');\n\n    // return early\n    return;     \n  }\n\n  // login was successful, update session\n  // and redirect to admin section of site\n  req.session.authenticated = true;\n  req.session.user = user;\n\n  res.redirect('/admin');\n\n}catch(err){\n\n    // unexpected error\n    // show 500 page \n    res.serverError(err);\n}\n```\n. ",
    "farzher": "Oops ty, I didn't notice that in my Google search.\n\nI'm going to go check out `co` then https://github.com/visionmedia/co\n. No worries; I hate exceptions too, but I also hate verbosity; simplicity is complicated.\n. Oops ty, I didn't notice that in my Google search.\n\nI'm going to go check out `co` then https://github.com/visionmedia/co\n. No worries; I hate exceptions too, but I also hate verbosity; simplicity is complicated.\n. ",
    "kevinsawicki": "I'm not sure I understand, don't you want this value to inspectable?\n\nRight now it isn't as shown in the screenshot since it is modified after it is logged.\n. Okay, thanks for the info, it wasn't clear that that was the intent of the logging, closing this out.\n. I'm not sure I understand, don't you want this value to inspectable?\n\nRight now it isn't as shown in the screenshot since it is modified after it is logged.\n. Okay, thanks for the info, it wasn't clear that that was the intent of the logging, closing this out.\n. ",
    "benjamingr": "Bluebird used to do this by the way (by wrapping primitives with `RejectionError`s) but I think it's currently borked https://github.com/petkaantonov/bluebird/issues/100\n. @petkaantonov So we get this absurd state where interacting with nodified code works better than working with other promise libraries?\n\nCan't it be rejected with the same (primitive) value but still show the full stack trace when getting to the unknown rejection handler?\n. @petkaantonov I don't see how the fact that: \n\n a) You need the actual rejection value to be a primitive\n b) You need to provide a stack trace\n\nAre mutually exclusive. Isn't this something the library can manage? To reject with the primitive but give a possibly unhandled rejection with a stack trace it keeps?\n\nI'm not saying it's 100% worth it or that it's straightforward - I just don't understand why it's 'impossible'\n. @petkaantonov I'm not saying I have the answer but:\n1. Debugging primitives is a _huge_ pain. \n2. There are \"Obvious\" solutions that are expensive like keeping track on the promise object itself, passing the rejection primitive value but keeping a separate field with the stack trace.\n3. In modes like longStackTraces this might be worth it, it's very expensive though - I'm not 100% convinced there isn't a more performant way - and that _you_ can't come up with it :)\n. Worth mentioning that Bluebird now does it:\n\nhttps://github.com/petkaantonov/bluebird/commit/ce2528472b5f498d15a7a0c535c234e8703a96c2\n. @kriskowal v2 \ud83d\ude06 \ud83d\ude04 . No, there is not.\n. Anyone?\n. Would a pull request at least on the v1 branch at least be entertained?\n. @kriskowal @domenic \n. Going to continue this at https://github.com/kriskowal/q/issues/637\n. @kriskowal you're alive! :D\n\nI've started a PR with Domenic's blessing to implement this now at the PR linked above - we discussed it a little and there is a done/todo list (rather minor).\n\nWhat do you think?\n. Thanks - it's really nice to hear from you again!\n. There is a suggestion https://gist.github.com/benjamingr/0237932cee84712951a2 other libraries are implementing but it doesn't look like it got much attention in Q https://github.com/kriskowal/q/issues/637\n. @kriskowal\n\nI think we should skip DOM events for now - implementing it took at least 100 LoC to get right\\*  and it will increase the library size by 5% for existing users for a use case they didn't know existed until now. \n\nI've fixed formatting issues and tested in the following browsers:\n- Safari 8 Mac\n- Chrome 40 Mac \n- Firefox 4 Mac\n- Firefox latest Mac\n\nI've also asked friends to test, @bananu7 reported:\n- Chrome Windows (40)\n- IE11 gets the same results.\n- Old IE (Visual Studio IE) gets the same results.\n\nNote that IE11 fails the following Q tests already:\n\n```\nunhandled rejection reporting reports a stack trace. Expected [ '(no stack) [object Error]' ] to equal [ undefined\n```\n\nOld IE reports the following:\n\n```\ncomputing sum of integers using promises should compute correct result without blowing stack. TypeError: Object doesn't support property or method 'reduce'\n```\n\nNeither are regressions. NodeJS works in version 0.8 0.10 and 0.12, io.js works in 1.2. \n\nI think we're good to go. @kriskowal ?\n- See bluebird's implementation here: https://github.com/petkaantonov/bluebird/blob/master/src/captured_trace.js#L436-L500 as well as in several other places referenced in the library.\n. @kriskowal the current Q specification is all for browsers - I can port over Petka's tests for this feature in io.js native promises if you'd like but it would mean introducing a second way to run tests - your call.\n. Oh, I see - in that case I'll gladly write tests in.\n. I've written some tests but I have an issue. I'm trying to run the tests in the spec runner and for some reason:\n\n``` js\n        it(\"should report unhandled rejections\", function() {\n            var d = Q.defer();\n            process.on(\"unhandledRejection\", function(p, r) {\n                d.resolve();\n            });\n            d.promise.then(function(){\n                console.log(\"RESOLVED\"); // This logs\n            });\n\n            Q.reject(new Error());\n            return d.promise;\n        });\n```\n\nThis fails with: \n\n>  1) unhandled rejection tracking should report unhandled rejections\n>   Message:\n>     Error: Timed out after 500 ms\n\nHowever doing a `return Q();` succeeds. I think it's something with `process` since if I resolve in a `setTimeout` it works.\n\nAny ideas what this might be related to? If I copy Petka's spec from io.js and run it it runs.\n. @kriskowal \n. :(\n. Awesome news!\n. What about iterables?\n. Probably just `throw` if a string is passed to `Promise.all`? \n. Yes, check the 2.0 branch of Q for what's eventually replacing progress (estimation)\n. @kriskowal just pointing out - the \"across the wire\" thing can be handled by a second method like:\n\n``` js\nQ({ foo: \"bar\" }).set(\"foo\", \"baz\").ignoreReturnValue()...\n```\n\nNot that it matters as you're super busy anyway on other stuff :)\n. @kriskowal not if `ignoreReturnValue` is called synchronously. The messages `set` sends are presumably batched anyway so presumably you don't dispatch them \"right away\" but after a tick - so plenty of time to augment whatever message sent to not return anything from the server but an ack. \n. Oh that's interesting, for Bluebird it's a promise (since Pouch uses\nBluebird) and for Q it's a `then`able.\n\nOn Thu, Jul 2, 2015 at 2:03 PM, Bergi notifications@github.com wrote:\n\n> That's just crazy code :-)\n> It's not a bug however imo, because it's not a circular promise - rather\n> it's a circular thenable (that is no more thenable when it resolves,\n> urghh). Promises/A+ https://github.com/promises-aplus/promises-spec\n> don't mandate their detection.\n> We might want to update Promises/A+, though.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/712#issuecomment-117999159.\n. The fact that weak maps have a _global_ GC overhead is crazy :/\n\nOn Thu, Jul 2, 2015 at 6:17 PM, Kris Kowal notifications@github.com wrote:\n\n> Worth looking into. v2 has weak maps to assist with this kind of problem,\n> but I\u2019ve been using them less and less because of the performance overhead.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/712#issuecomment-118065040.\n. @domenic To be fair, that's not how native finally works:\n\n``` js\nalert(function(){\n    try { return 3 } finally { return 5 }\n}()); // alerts 5, not 3\n```\n\nSome languages forbid `return` in finally or ignore it - but JS is not one of them. That said, I think the current behavior is better - just not analogous to the sync case. \n. @aletc1 Hey, I'm at fault here as I wrote the PR that added unhandledRejection for Q. The problem is that adding the events for the browser (a window object with addEventListener) required a lot of browser normalization. \n\nI think Kris's alternative of exposing a `Q.emit` which defaults to the process is a good idea. It should be simple enough. \n. I don't think Q should support cases where people deliberately override built-ins incorrectly. \n. Promises work by `return` value and you're not `return`ing anything from your `then` chains.\n\nPromises don't know how to wait for things automatically - the way to \"wait\" for previous actions is to `return` the promise they create from the `then` handler:\n\n``` js\nQ().then(() => {\n    return Q.delay(1000);\n}).then(() => {\n    // this only executes after 1000ms because the previous `then` handler `return`d a promise\n});\n```\n. @bruun there already is a way to disable it - when I wrote that feature I made sure it was entirely opt out.\n\nYou'd just call:\n\n``` js\nQ.stopUnhandledRejectionTracking();\n```\n\nWhich would cause no unhandled rejections to be tracked. \n\nAlthough _in all honesty_ if you're concerned in production I would recommend a promise library that's geared towards that. Q (v1) has many benefits and some nice design niceness - it's easy to reason about and has nice code - but speed and debuggability were never the goal (v2 might change that). Some people disagree about this last paragraph - it is just one man's opinion.\n. There's already Q.onerror and unhandled rejection tracking. \n. @seiyria In Node - you can add a `process.on(\"unhandledRejection\",` handler and see the result. \n\nI don't think at this point Q can change the default for unhandled rejection tracking to be like bluebird (log by default). \n. @seiyria ok, for what it's worth you can keep using Q's API and get better than native performance with https://github.com/petkaantonov/bluebird-q\n\nClosing then.\n. The rationale was to let people change the scheduler kind of like bluebird's setScheduler. I don't think we should explicitly hide it. \n. As the person who suggested the scheduler APi for bluebird I'll gladly implement an API for Q for the same thing if Kris asks. \n. Also, as a tip - always convert your API to promises at the _lowest level possible_ - convert `.query` itself. \n. Please create a [mcve](http://stackoverflow.com/help/mcve).\n. LGTM\n. Thanks for the contribution - it's indeed more readable now :) \n. Thanks\n. ?\n. -1 for any new changes to progression from me.\n+1 for official deprecation of the mechanism in favor of different approaches like v2 approximation or doing it differently.\n. Promises are not a special case of streams any more than numbers are a special case of arrays of numbers.\n\nThat said, what would yielding streams even look like?\n\nIf they're generic enough there are helpers that let you convert a stream to a promise for its completion event.  \n. I think the API surface is pretty frozen at this point, but you can either use a library with these helpers like https://github.com/petkaantonov/bluebird or implement them yourself (like you did above)\n. How would you write the code if it was synchronous?\n. I agree, let's merge. . Sure, thanks.. Because the promise is rejected. This is like the following sync code:\r\n\r\n```js\r\ntry { \r\n  throw Error();\r\n  sleep(5000) \r\n} catch (ex) { console.log(ex); \r\n```\r\n\r\nIt's just how control flow works in programming.. That is correct, the docs need to be updated - feel free to submit a PR (removing the \"at least\" part).. > I just updated wiki:\r\n\r\nThanks.\r\n\r\n> By the way, I don't think I should be allowed to do this?\r\n\r\nSo far, I've been a member of several projects that allowed this and I've never seen it abused. While it's possible to set permissions it is often not necessary and the good will of users helps improve documentation.\r\n\r\n. @jbunton-atlassian Node has way better stack traces with async stack traces support in debugging and better unhandled rejection detection, and `nfcall` can be easily imported independently (or better - something like promisifyAll). . @hifall this should be fine. . @kriskowal/@domenic this requires a version release and should be done to not cause Q to break on Node 9. Any chance either of you could do a release on NPM? . Bluebird used to do this by the way (by wrapping primitives with `RejectionError`s) but I think it's currently borked https://github.com/petkaantonov/bluebird/issues/100\n. @petkaantonov So we get this absurd state where interacting with nodified code works better than working with other promise libraries?\n\nCan't it be rejected with the same (primitive) value but still show the full stack trace when getting to the unknown rejection handler?\n. @petkaantonov I don't see how the fact that: \n\n a) You need the actual rejection value to be a primitive\n b) You need to provide a stack trace\n\nAre mutually exclusive. Isn't this something the library can manage? To reject with the primitive but give a possibly unhandled rejection with a stack trace it keeps?\n\nI'm not saying it's 100% worth it or that it's straightforward - I just don't understand why it's 'impossible'\n. @petkaantonov I'm not saying I have the answer but:\n1. Debugging primitives is a _huge_ pain. \n2. There are \"Obvious\" solutions that are expensive like keeping track on the promise object itself, passing the rejection primitive value but keeping a separate field with the stack trace.\n3. In modes like longStackTraces this might be worth it, it's very expensive though - I'm not 100% convinced there isn't a more performant way - and that _you_ can't come up with it :)\n. Worth mentioning that Bluebird now does it:\n\nhttps://github.com/petkaantonov/bluebird/commit/ce2528472b5f498d15a7a0c535c234e8703a96c2\n. @kriskowal v2 \ud83d\ude06 \ud83d\ude04 . No, there is not.\n. Anyone?\n. Would a pull request at least on the v1 branch at least be entertained?\n. @kriskowal @domenic \n. Going to continue this at https://github.com/kriskowal/q/issues/637\n. @kriskowal you're alive! :D\n\nI've started a PR with Domenic's blessing to implement this now at the PR linked above - we discussed it a little and there is a done/todo list (rather minor).\n\nWhat do you think?\n. Thanks - it's really nice to hear from you again!\n. There is a suggestion https://gist.github.com/benjamingr/0237932cee84712951a2 other libraries are implementing but it doesn't look like it got much attention in Q https://github.com/kriskowal/q/issues/637\n. @kriskowal\n\nI think we should skip DOM events for now - implementing it took at least 100 LoC to get right\\*  and it will increase the library size by 5% for existing users for a use case they didn't know existed until now. \n\nI've fixed formatting issues and tested in the following browsers:\n- Safari 8 Mac\n- Chrome 40 Mac \n- Firefox 4 Mac\n- Firefox latest Mac\n\nI've also asked friends to test, @bananu7 reported:\n- Chrome Windows (40)\n- IE11 gets the same results.\n- Old IE (Visual Studio IE) gets the same results.\n\nNote that IE11 fails the following Q tests already:\n\n```\nunhandled rejection reporting reports a stack trace. Expected [ '(no stack) [object Error]' ] to equal [ undefined\n```\n\nOld IE reports the following:\n\n```\ncomputing sum of integers using promises should compute correct result without blowing stack. TypeError: Object doesn't support property or method 'reduce'\n```\n\nNeither are regressions. NodeJS works in version 0.8 0.10 and 0.12, io.js works in 1.2. \n\nI think we're good to go. @kriskowal ?\n- See bluebird's implementation here: https://github.com/petkaantonov/bluebird/blob/master/src/captured_trace.js#L436-L500 as well as in several other places referenced in the library.\n. @kriskowal the current Q specification is all for browsers - I can port over Petka's tests for this feature in io.js native promises if you'd like but it would mean introducing a second way to run tests - your call.\n. Oh, I see - in that case I'll gladly write tests in.\n. I've written some tests but I have an issue. I'm trying to run the tests in the spec runner and for some reason:\n\n``` js\n        it(\"should report unhandled rejections\", function() {\n            var d = Q.defer();\n            process.on(\"unhandledRejection\", function(p, r) {\n                d.resolve();\n            });\n            d.promise.then(function(){\n                console.log(\"RESOLVED\"); // This logs\n            });\n\n            Q.reject(new Error());\n            return d.promise;\n        });\n```\n\nThis fails with: \n\n>  1) unhandled rejection tracking should report unhandled rejections\n>   Message:\n>     Error: Timed out after 500 ms\n\nHowever doing a `return Q();` succeeds. I think it's something with `process` since if I resolve in a `setTimeout` it works.\n\nAny ideas what this might be related to? If I copy Petka's spec from io.js and run it it runs.\n. @kriskowal \n. :(\n. Awesome news!\n. What about iterables?\n. Probably just `throw` if a string is passed to `Promise.all`? \n. Yes, check the 2.0 branch of Q for what's eventually replacing progress (estimation)\n. @kriskowal just pointing out - the \"across the wire\" thing can be handled by a second method like:\n\n``` js\nQ({ foo: \"bar\" }).set(\"foo\", \"baz\").ignoreReturnValue()...\n```\n\nNot that it matters as you're super busy anyway on other stuff :)\n. @kriskowal not if `ignoreReturnValue` is called synchronously. The messages `set` sends are presumably batched anyway so presumably you don't dispatch them \"right away\" but after a tick - so plenty of time to augment whatever message sent to not return anything from the server but an ack. \n. Oh that's interesting, for Bluebird it's a promise (since Pouch uses\nBluebird) and for Q it's a `then`able.\n\nOn Thu, Jul 2, 2015 at 2:03 PM, Bergi notifications@github.com wrote:\n\n> That's just crazy code :-)\n> It's not a bug however imo, because it's not a circular promise - rather\n> it's a circular thenable (that is no more thenable when it resolves,\n> urghh). Promises/A+ https://github.com/promises-aplus/promises-spec\n> don't mandate their detection.\n> We might want to update Promises/A+, though.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/712#issuecomment-117999159.\n. The fact that weak maps have a _global_ GC overhead is crazy :/\n\nOn Thu, Jul 2, 2015 at 6:17 PM, Kris Kowal notifications@github.com wrote:\n\n> Worth looking into. v2 has weak maps to assist with this kind of problem,\n> but I\u2019ve been using them less and less because of the performance overhead.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/issues/712#issuecomment-118065040.\n. @domenic To be fair, that's not how native finally works:\n\n``` js\nalert(function(){\n    try { return 3 } finally { return 5 }\n}()); // alerts 5, not 3\n```\n\nSome languages forbid `return` in finally or ignore it - but JS is not one of them. That said, I think the current behavior is better - just not analogous to the sync case. \n. @aletc1 Hey, I'm at fault here as I wrote the PR that added unhandledRejection for Q. The problem is that adding the events for the browser (a window object with addEventListener) required a lot of browser normalization. \n\nI think Kris's alternative of exposing a `Q.emit` which defaults to the process is a good idea. It should be simple enough. \n. I don't think Q should support cases where people deliberately override built-ins incorrectly. \n. Promises work by `return` value and you're not `return`ing anything from your `then` chains.\n\nPromises don't know how to wait for things automatically - the way to \"wait\" for previous actions is to `return` the promise they create from the `then` handler:\n\n``` js\nQ().then(() => {\n    return Q.delay(1000);\n}).then(() => {\n    // this only executes after 1000ms because the previous `then` handler `return`d a promise\n});\n```\n. @bruun there already is a way to disable it - when I wrote that feature I made sure it was entirely opt out.\n\nYou'd just call:\n\n``` js\nQ.stopUnhandledRejectionTracking();\n```\n\nWhich would cause no unhandled rejections to be tracked. \n\nAlthough _in all honesty_ if you're concerned in production I would recommend a promise library that's geared towards that. Q (v1) has many benefits and some nice design niceness - it's easy to reason about and has nice code - but speed and debuggability were never the goal (v2 might change that). Some people disagree about this last paragraph - it is just one man's opinion.\n. There's already Q.onerror and unhandled rejection tracking. \n. @seiyria In Node - you can add a `process.on(\"unhandledRejection\",` handler and see the result. \n\nI don't think at this point Q can change the default for unhandled rejection tracking to be like bluebird (log by default). \n. @seiyria ok, for what it's worth you can keep using Q's API and get better than native performance with https://github.com/petkaantonov/bluebird-q\n\nClosing then.\n. The rationale was to let people change the scheduler kind of like bluebird's setScheduler. I don't think we should explicitly hide it. \n. As the person who suggested the scheduler APi for bluebird I'll gladly implement an API for Q for the same thing if Kris asks. \n. Also, as a tip - always convert your API to promises at the _lowest level possible_ - convert `.query` itself. \n. Please create a [mcve](http://stackoverflow.com/help/mcve).\n. LGTM\n. Thanks for the contribution - it's indeed more readable now :) \n. Thanks\n. ?\n. -1 for any new changes to progression from me.\n+1 for official deprecation of the mechanism in favor of different approaches like v2 approximation or doing it differently.\n. Promises are not a special case of streams any more than numbers are a special case of arrays of numbers.\n\nThat said, what would yielding streams even look like?\n\nIf they're generic enough there are helpers that let you convert a stream to a promise for its completion event.  \n. I think the API surface is pretty frozen at this point, but you can either use a library with these helpers like https://github.com/petkaantonov/bluebird or implement them yourself (like you did above)\n. How would you write the code if it was synchronous?\n. I agree, let's merge. . Sure, thanks.. Because the promise is rejected. This is like the following sync code:\r\n\r\n```js\r\ntry { \r\n  throw Error();\r\n  sleep(5000) \r\n} catch (ex) { console.log(ex); \r\n```\r\n\r\nIt's just how control flow works in programming.. That is correct, the docs need to be updated - feel free to submit a PR (removing the \"at least\" part).. > I just updated wiki:\r\n\r\nThanks.\r\n\r\n> By the way, I don't think I should be allowed to do this?\r\n\r\nSo far, I've been a member of several projects that allowed this and I've never seen it abused. While it's possible to set permissions it is often not necessary and the good will of users helps improve documentation.\r\n\r\n. @jbunton-atlassian Node has way better stack traces with async stack traces support in debugging and better unhandled rejection detection, and `nfcall` can be easily imported independently (or better - something like promisifyAll). . @hifall this should be fine. . @kriskowal/@domenic this requires a version release and should be done to not cause Q to break on Node 9. Any chance either of you could do a release on NPM? . ",
    "duncanbrown": "I think I'm also seeing this issue. Running the following results in a warning in the console saying 'Error: foo' is an unhandled rejection reason:\n\n```\nvar d = Q.defer();\nsetTimeout(function () {\n    d.resolve(1);\n}, 1);\nd.promise\n    .then(function () {\n        throw new Error('foo');\n    })\n    .catch(function (e) {\n        return 1;\n    })\n    .done();\n```\n\nAs I understand it, I have handled the Error by attaching the catch handler - am I mistaken?\n. Thanks for the explanation @kriskowal.\n\nIn case it's helpful to anyone else: I have just noticed that, in Chrome, if you close and reopen Dev Tools it updates to show an empty array, as expected.\n. I think I'm also seeing this issue. Running the following results in a warning in the console saying 'Error: foo' is an unhandled rejection reason:\n\n```\nvar d = Q.defer();\nsetTimeout(function () {\n    d.resolve(1);\n}, 1);\nd.promise\n    .then(function () {\n        throw new Error('foo');\n    })\n    .catch(function (e) {\n        return 1;\n    })\n    .done();\n```\n\nAs I understand it, I have handled the Error by attaching the catch handler - am I mistaken?\n. Thanks for the explanation @kriskowal.\n\nIn case it's helpful to anyone else: I have just noticed that, in Chrome, if you close and reopen Dev Tools it updates to show an empty array, as expected.\n. ",
    "mrwillis21": "I am seeing this issue as well, with a very simple test case:\n\n``` javascript\nQ.reject(new Error('error message')).done(\n    function(result) {\n        console.log(result);\n    },\n    function(error) {\n        console.error(error);\n    });\n```\n\nAs you can see, I have an error handler in place. However, I still see the _Unhandled_ warning before I get the error output in the console. I've tested this in Chrome 32 and Firefox 26.\n. I am seeing this issue as well, with a very simple test case:\n\n``` javascript\nQ.reject(new Error('error message')).done(\n    function(result) {\n        console.log(result);\n    },\n    function(error) {\n        console.error(error);\n    });\n```\n\nAs you can see, I have an error handler in place. However, I still see the _Unhandled_ warning before I get the error output in the console. I've tested this in Chrome 32 and Firefox 26.\n. ",
    "davidchambers": "This pull request appears to have been closed without being merged. Did you apply the patch manually?\n. This warrants a patch release, I would say. :)\n. This pull request appears to have been closed without being merged. Did you apply the patch manually?\n. This warrants a patch release, I would say. :)\n. ",
    "blixt": "Nope, it just kills execution there and then...\n. Thank you, Q works fine in my Chrome App using this commit.\n. Nope, it just kills execution there and then...\n. Thank you, Q works fine in my Chrome App using this commit.\n. ",
    "EtaiG": "Excellent, thank you.\n\nThe readme is much clearer now. \nMight I also suggest you add the version into the q.js itself in the comments?\nFor example (version 1.0):\n\n// vim:ts=4:sts=4:sw=4:\n/*!\n- **Q version 1.0**\n- Copyright 2009-2012 Kris Kowal under the terms of the MIT\n- license found at http://github.com/kriskowal/q/raw/master/LICENSE\n- ...\n  - ...\n\nThis way it's easy for someone using Q to know what version they have and what version they are looking at.\n\nWhen debugging an issue, if I see I have version 1.0 and that on github the version is 1.04, I can then check to see if the issue was fixed in 1.04.\n\nI'm noting this because we had a problem and were using v0.8, and the issue was ~~supposedly~~ fixed in v0.9 (issue with nextTick in Safari 6.05 and up) - so only after doing a local 'diff' was I able to know that we were on v0.8. \nIt seems we still have the problem, which may be unrelated, though if I find anything interesting that relates to Q I'll let you know.\n. Thanks.\n\nI see you're online right now, is there a way I can chat with you for a few minutes? \n. going to download now, unless you have whatsapp or google hangouts\n. Excellent, thank you.\n\nThe readme is much clearer now. \nMight I also suggest you add the version into the q.js itself in the comments?\nFor example (version 1.0):\n\n// vim:ts=4:sts=4:sw=4:\n/*!\n- **Q version 1.0**\n- Copyright 2009-2012 Kris Kowal under the terms of the MIT\n- license found at http://github.com/kriskowal/q/raw/master/LICENSE\n- ...\n  - ...\n\nThis way it's easy for someone using Q to know what version they have and what version they are looking at.\n\nWhen debugging an issue, if I see I have version 1.0 and that on github the version is 1.04, I can then check to see if the issue was fixed in 1.04.\n\nI'm noting this because we had a problem and were using v0.8, and the issue was ~~supposedly~~ fixed in v0.9 (issue with nextTick in Safari 6.05 and up) - so only after doing a local 'diff' was I able to know that we were on v0.8. \nIt seems we still have the problem, which may be unrelated, though if I find anything interesting that relates to Q I'll let you know.\n. Thanks.\n\nI see you're online right now, is there a way I can chat with you for a few minutes? \n. going to download now, unless you have whatsapp or google hangouts\n. ",
    "tobie": "That's it!? I thought you'd put a little more sweat into something you'd dedicate to me.\n. That's it!? I thought you'd put a little more sweat into something you'd dedicate to me.\n. ",
    "nathansobo": ":heart:\n. Just a heads-up. Not seeing it on npm yet, but maybe it's cached. Thanks again.\n. :heart:\n. Just a heads-up. Not seeing it on npm yet, but maybe it's cached. Thanks again.\n. ",
    "nillis": "It is a problem specific for the q library. When Chrome performs a Garbage collection memory from unused objects is released. Something in the q library prevents this which causes the memory leak. In the screenshot you can see that on each page refresh the memory increases and each time 1 doc, 10 nodes and 1 listener is added to memory but never cleaned.\n\nYou can monitor these object with heap profiling to solve the problem.\n\n![screen](https://f.cloud.github.com/assets/2675228/2386979/eb523c2a-a931-11e3-9963-7269925d7e45.PNG)\n. I further inspected the code and the leak is caused by the MemoryChannel. I reduced the script to the following:\n\nvar channel = new MessageChannel();\nchannel.port1.onmessage = function () {};\n\nThe listener isn't collected on a page refresh. \n\nhttps://code.google.com/p/chromium/issues/detail?id=320723\n\nThis was the bug. It's already fixed in Chrome Canary, so it will be fixed soon in Chrome as well.\n. It is a problem specific for the q library. When Chrome performs a Garbage collection memory from unused objects is released. Something in the q library prevents this which causes the memory leak. In the screenshot you can see that on each page refresh the memory increases and each time 1 doc, 10 nodes and 1 listener is added to memory but never cleaned.\n\nYou can monitor these object with heap profiling to solve the problem.\n\n![screen](https://f.cloud.github.com/assets/2675228/2386979/eb523c2a-a931-11e3-9963-7269925d7e45.PNG)\n. I further inspected the code and the leak is caused by the MemoryChannel. I reduced the script to the following:\n\nvar channel = new MessageChannel();\nchannel.port1.onmessage = function () {};\n\nThe listener isn't collected on a page refresh. \n\nhttps://code.google.com/p/chromium/issues/detail?id=320723\n\nThis was the bug. It's already fixed in Chrome Canary, so it will be fixed soon in Chrome as well.\n. ",
    "soywiz": "It is not a concern of performance, but flexibility. In fact, when you are using generators you accept that the generated code will be slower with current implementations or even more if you are using something like traceur compiler. (In my case node.js 0.11 using v8.). So I am here because I love promises, even with the overhead of using promises and generators instead of just plain callbacks and pyramids of hell.\n\nSince you can still use Q.async for performant cases, I don't think it hurts anybody to include this improvement. Or even create other function performing a spawn with or without this.\n\nI was intended to use it in typescript where I cannot use Q.async the way you suggested. I want to be able to do stuff like this:\n\n``` js\nclass MyClass {\n    downloadTwoFilesAsync(url1:string, url2:string):Promise<string> {\n        return Q.spawn(function*() {\n            var contents1 = yield downloadFileAsync(url1);\n            var contents2 = yield downloadFileAsync(url2);\n            return contents1 + contents2;\n        });\n    }\n}\n```\n\nI don't want to lose most of the benefits using typescript by creating code like:\n\n``` js\nMyClass.prototype.downloadTwoFilesAsync = Q.async(function* (url1, url2) {\n    var contents1 = yield downloadFileAsync(url1);\n    var contents2 = yield downloadFileAsync(url2);\n    return contents1 + contents2;\n});\n```\n\nI don't want to enter into a battle with this. It was just a suggestion. I can always create my own function doing that. In fact I did it already. But I think this is something anybody could benefit from and pretty useful without having into account the performance.\n. That's great. I'm happy it is getting faster and faster and impacting less the memory and the GC cycle :) so probably the overhead introduced by my proposal is small and will allow some people to create cleaner code without clever stuff at least in typescript. Also I like the idea to have a function body that I can replace with something else without having to change the definition. So if i want just to call another function that returns me a promise instead of calling Q.spawn I can. And for example, if I have cached a promise I can just return it without repeating the whole process.\n. Well I don't know about that benchmark. And about the implementation. And if the implementation could be hugely improved or if the v8 engine will improve that situation on the future.\n\nI really appreciate your comments. I am currently using my own spawn/promise implementation. I can't give you numbers, but since my main problem is concurrency on the server and I/O is several orders of magnitude slower than the overhead introducing by this stuff, I don't really mind about that.\n\nSo again: I don't mind the speed, just the flexibility and the clean code I get by using promises and generators, and the classes, generics and autocompletion I get from typescript. So I don't mind writting two more lines or getting 5x slower stuff if I'm making a http request that takes, for example. 3 seconds to complete.\n\nAnd again: This issue is just a suggestion.\n. I don't see this as a typescript-specific stuff. I was just showing examples.\nI see spawn function like this:\n\n\"I'm spawning a asynchronous process and I want to know when it is completed and which was its result.\"\n\nI think that it is logical without the existence of typescript.\n. Ok\n. Not related to the spawn stuff, but related to speed:\n\nI was a bit surprised because spawn was 5x times slower than async (I didn't checked but petkaantonov said that). I was reviewing the code I created before start using Q. That code is not that polished and a bit messy, and it doesn't have those all great features from Q, but I wanted to measure the speed.\n\nI created this demo:\nhttps://gist.github.com/soywiz/c11ae56076539355e06a\n\nOn my computer:\ncls && node --version && node --harmony qbench.js\n\nv0.11.11\nla.spawn:411\nQ.async:3115\nQ.spawn:3130\n\nSo I suspect spawn is 5x times slower if you call it many times and just with a few yields.\nBut also I was a bit surprised why my implementation is that fast compared to Q with lots of yields and both all wasting 100% of the cpu.\n\nIs Q doing some stuff I should do to get it safe? I have seen a comment like this in the code \"In node, uncaught exceptions are considered fatal errors.\" and code related to that. It is that code the one that is making things slower?\n. It is not a concern of performance, but flexibility. In fact, when you are using generators you accept that the generated code will be slower with current implementations or even more if you are using something like traceur compiler. (In my case node.js 0.11 using v8.). So I am here because I love promises, even with the overhead of using promises and generators instead of just plain callbacks and pyramids of hell.\n\nSince you can still use Q.async for performant cases, I don't think it hurts anybody to include this improvement. Or even create other function performing a spawn with or without this.\n\nI was intended to use it in typescript where I cannot use Q.async the way you suggested. I want to be able to do stuff like this:\n\n``` js\nclass MyClass {\n    downloadTwoFilesAsync(url1:string, url2:string):Promise<string> {\n        return Q.spawn(function*() {\n            var contents1 = yield downloadFileAsync(url1);\n            var contents2 = yield downloadFileAsync(url2);\n            return contents1 + contents2;\n        });\n    }\n}\n```\n\nI don't want to lose most of the benefits using typescript by creating code like:\n\n``` js\nMyClass.prototype.downloadTwoFilesAsync = Q.async(function* (url1, url2) {\n    var contents1 = yield downloadFileAsync(url1);\n    var contents2 = yield downloadFileAsync(url2);\n    return contents1 + contents2;\n});\n```\n\nI don't want to enter into a battle with this. It was just a suggestion. I can always create my own function doing that. In fact I did it already. But I think this is something anybody could benefit from and pretty useful without having into account the performance.\n. That's great. I'm happy it is getting faster and faster and impacting less the memory and the GC cycle :) so probably the overhead introduced by my proposal is small and will allow some people to create cleaner code without clever stuff at least in typescript. Also I like the idea to have a function body that I can replace with something else without having to change the definition. So if i want just to call another function that returns me a promise instead of calling Q.spawn I can. And for example, if I have cached a promise I can just return it without repeating the whole process.\n. Well I don't know about that benchmark. And about the implementation. And if the implementation could be hugely improved or if the v8 engine will improve that situation on the future.\n\nI really appreciate your comments. I am currently using my own spawn/promise implementation. I can't give you numbers, but since my main problem is concurrency on the server and I/O is several orders of magnitude slower than the overhead introducing by this stuff, I don't really mind about that.\n\nSo again: I don't mind the speed, just the flexibility and the clean code I get by using promises and generators, and the classes, generics and autocompletion I get from typescript. So I don't mind writting two more lines or getting 5x slower stuff if I'm making a http request that takes, for example. 3 seconds to complete.\n\nAnd again: This issue is just a suggestion.\n. I don't see this as a typescript-specific stuff. I was just showing examples.\nI see spawn function like this:\n\n\"I'm spawning a asynchronous process and I want to know when it is completed and which was its result.\"\n\nI think that it is logical without the existence of typescript.\n. Ok\n. Not related to the spawn stuff, but related to speed:\n\nI was a bit surprised because spawn was 5x times slower than async (I didn't checked but petkaantonov said that). I was reviewing the code I created before start using Q. That code is not that polished and a bit messy, and it doesn't have those all great features from Q, but I wanted to measure the speed.\n\nI created this demo:\nhttps://gist.github.com/soywiz/c11ae56076539355e06a\n\nOn my computer:\ncls && node --version && node --harmony qbench.js\n\nv0.11.11\nla.spawn:411\nQ.async:3115\nQ.spawn:3130\n\nSo I suspect spawn is 5x times slower if you call it many times and just with a few yields.\nBut also I was a bit surprised why my implementation is that fast compared to Q with lots of yields and both all wasting 100% of the cpu.\n\nIs Q doing some stuff I should do to get it safe? I have seen a comment like this in the code \"In node, uncaught exceptions are considered fatal errors.\" and code related to that. It is that code the one that is making things slower?\n. ",
    "soundstep": "I see. So anyone omitting a throw might change an application behavior. I find the syntax a bit too much prone to error, I'll stick to return the promise itself.\n\nThanks for the explanation!\n. What I meant is that the chain can be broken by someone else in another part of the code. It makes complete sense now that @kriskowal pointed it out, but it is not that obvious that one need to think that he might break the chain at another level if he forgot to re-throw the error.\n. I see. So anyone omitting a throw might change an application behavior. I find the syntax a bit too much prone to error, I'll stick to return the promise itself.\n\nThanks for the explanation!\n. What I meant is that the chain can be broken by someone else in another part of the code. It makes complete sense now that @kriskowal pointed it out, but it is not that obvious that one need to think that he might break the chain at another level if he forgot to re-throw the error.\n. ",
    "kornelski": ":+1: \n. Thank you\n. :+1: \n. Thank you\n. ",
    "xogeny": "OK, so I came to this issue because I was having trouble with installing `q` via `bower`.  Seeing these notes about how `2.0.0` isn't really supposed to be getting distributed through `bower` clears things up.\n\nThe specific issue I was having was the fact that when I did `bower install q`, I got a version where `q.js` included `require` calls rather than being standalone.  I realized I could `grunt build` a version of `q.min.js` from there, but it seemed odd that I should have to include a build step with a version I installed from `bower.\n\nIf, instead, I do `bower install --save 'q#1.0.1'`, then I get a `q.js` that I can use directly.\n\nthis is mainly a comment for anyone who follows the same path I did and is interested in how I resolved the issue.\n. @domenic I'd like to make a plea for supporting `bower`.  I know, in #520, you say that `Q` is really only targeted at `npm` and that people who want support for bower should maintain a fork to do so.\n\nThe first problem is that `Q` is already registered with `bower` (as far as I can tell, by @kriskowal) so if someone wants to _continue_ support for `bower` that ownership either needs to be transferred or a new (and very confusing) alternative (parallel) name would have to be used.\n\nAlso, keep in mind that `q` was supported in `bower` previously (prior to version 2) so you'd really be _withdrawing_ support for `bower` (which is widely used by frontend people and is leveraged by other tools like Yeoman).\n\nI really like `Q` and I'd like be able to easily use it both in the Node world and in the browser.  It seems like a relatively small price to pay to maintain the bower compatibility that was there before and, as a result, serve both communities.\n. OK, I stand corrected.  I was going by this:\n\nhttp://bower.io/search/?q=q\n\nwhich shows the owner as \"kriskowal\".  But it looks like it just uses the username from the GitHub repository.  So, it is not clear who added it to the registry.  Also, I guess I assumed `bower` was supported simply because the version 1.x branches and tags don't have any dependencies so `q.js` can be used \"out of the box\" without any need to build anything.\n\nIt still seems like a shame to not support `bower`.  But I guess that is your choice. :-(\n. OK, so I came to this issue because I was having trouble with installing `q` via `bower`.  Seeing these notes about how `2.0.0` isn't really supposed to be getting distributed through `bower` clears things up.\n\nThe specific issue I was having was the fact that when I did `bower install q`, I got a version where `q.js` included `require` calls rather than being standalone.  I realized I could `grunt build` a version of `q.min.js` from there, but it seemed odd that I should have to include a build step with a version I installed from `bower.\n\nIf, instead, I do `bower install --save 'q#1.0.1'`, then I get a `q.js` that I can use directly.\n\nthis is mainly a comment for anyone who follows the same path I did and is interested in how I resolved the issue.\n. @domenic I'd like to make a plea for supporting `bower`.  I know, in #520, you say that `Q` is really only targeted at `npm` and that people who want support for bower should maintain a fork to do so.\n\nThe first problem is that `Q` is already registered with `bower` (as far as I can tell, by @kriskowal) so if someone wants to _continue_ support for `bower` that ownership either needs to be transferred or a new (and very confusing) alternative (parallel) name would have to be used.\n\nAlso, keep in mind that `q` was supported in `bower` previously (prior to version 2) so you'd really be _withdrawing_ support for `bower` (which is widely used by frontend people and is leveraged by other tools like Yeoman).\n\nI really like `Q` and I'd like be able to easily use it both in the Node world and in the browser.  It seems like a relatively small price to pay to maintain the bower compatibility that was there before and, as a result, serve both communities.\n. OK, I stand corrected.  I was going by this:\n\nhttp://bower.io/search/?q=q\n\nwhich shows the owner as \"kriskowal\".  But it looks like it just uses the username from the GitHub repository.  So, it is not clear who added it to the registry.  Also, I guess I assumed `bower` was supported simply because the version 1.x branches and tags don't have any dependencies so `q.js` can be used \"out of the box\" without any need to build anything.\n\nIt still seems like a shame to not support `bower`.  But I guess that is your choice. :-(\n. ",
    "codeclown": "Actually, a built version should always be included in the repo. Bower components are meant to be usable without any additional build process.\n\nThanks to @xogeny for finding a version that can be used with Bower.\n. Actually, a built version should always be included in the repo. Bower components are meant to be usable without any additional build process.\n\nThanks to @xogeny for finding a version that can be used with Bower.\n. ",
    "HarryPehkonen": "What an interesting design, @cowwoc .  Can you post an example of the code?  Maybe there's an alternative.\n. What an interesting design, @cowwoc .  Can you post an example of the code?  Maybe there's an alternative.\n. ",
    "jimCresswell": "Fair enough, it just seemed inconsistent that the first three examples in the Sequences section had an initialValue and the fourth didn't given the implication that the examples are functionally identical. Perhaps I am missing something.\n. @kriskowal no problem, and thanks for the documentation and presentations, they were very helpful to me today.\n. Fair enough, it just seemed inconsistent that the first three examples in the Sequences section had an initialValue and the fourth didn't given the implication that the examples are functionally identical. Perhaps I am missing something.\n. @kriskowal no problem, and thanks for the documentation and presentations, they were very helpful to me today.\n. ",
    "x-yuri": "Indeed...\n. Indeed...\n. ",
    "aexmachina": "Yes it's version 2.0. I just ran `npm install q` and that's what I got. I ended up using `denodeify`.\n. Cool, glad I created the issue then :) Thanks.\n. Yes it's version 2.0. I just ran `npm install q` and that's what I got. I ended up using `denodeify`.\n. Cool, glad I created the issue then :) Thanks.\n. ",
    "jkinzel-r7": "It appears as though at times the IE Error object does not have a stack property associated with it. If you inspect the error object created during the test, you will see this is the case.\n. It appears as though at times the IE Error object does not have a stack property associated with it. If you inspect the error object created during the test, you will see this is the case.\n. ",
    "kyeotic": "Yes, I know that. I said it was my fault, and I even posted a working fiddle. I am aware that I am not supposed to do it, my point was that when I did it accidentally it was _difficult to debug_. I don't know about you, but I often have to debug my code; it helps when mistakes are easy to find.\n. @medikoo  It did raise a warning flag, but I was more focused on the fact that the end was happening before the middle of the chain. This makes sense now, as the end was getting queued up at the same time as the middle, but when I kept parsing right over `done()` the reason _why_ the chain wasn't happening in order escaped me... for much longer than it should have\n\nIt was difficult to debug because a promise being resolved with `undefined` doesn't (at least for me)  finger `done()` as the culprit. Having run in to very few issues with Q, it didn't point to anything in particular. And with no error message, I assumed everything was happening, but I thought that it meant the promise was actually getting resolved and losing the value somehow (my real chain was rather deep).\n. @medikoo That's the thing. I've been using Q for over a year. I'm not learning it. I've gotten myself into a habit of adding `done` to promises under certain conditions, and I made a mistake this time adding it where it didn't belong. It seems like a really easy mistake to make, at leas to me.\nAnd the only aid is _not_ just to learn more about the API. Kris just proposed an actual solution.\n\nYour statement that it isn't strictly related to `done` is incorrect. `done` turns an otherwise totally valid promise chain into `undefined`, and this is what caused the problem. I don't know how it could be any _more_ related to `done`.\n. Yes, I know that. I said it was my fault, and I even posted a working fiddle. I am aware that I am not supposed to do it, my point was that when I did it accidentally it was _difficult to debug_. I don't know about you, but I often have to debug my code; it helps when mistakes are easy to find.\n. @medikoo  It did raise a warning flag, but I was more focused on the fact that the end was happening before the middle of the chain. This makes sense now, as the end was getting queued up at the same time as the middle, but when I kept parsing right over `done()` the reason _why_ the chain wasn't happening in order escaped me... for much longer than it should have\n\nIt was difficult to debug because a promise being resolved with `undefined` doesn't (at least for me)  finger `done()` as the culprit. Having run in to very few issues with Q, it didn't point to anything in particular. And with no error message, I assumed everything was happening, but I thought that it meant the promise was actually getting resolved and losing the value somehow (my real chain was rather deep).\n. @medikoo That's the thing. I've been using Q for over a year. I'm not learning it. I've gotten myself into a habit of adding `done` to promises under certain conditions, and I made a mistake this time adding it where it didn't belong. It seems like a really easy mistake to make, at leas to me.\nAnd the only aid is _not_ just to learn more about the API. Kris just proposed an actual solution.\n\nYour statement that it isn't strictly related to `done` is incorrect. `done` turns an otherwise totally valid promise chain into `undefined`, and this is what caused the problem. I don't know how it could be any _more_ related to `done`.\n. ",
    "mihail-stanchev": "Thanks for making this clear - closing the issue.\n. Thanks for making this clear - closing the issue.\n. ",
    "und3fined": "thanks.\nplz close.\n. thanks.\nplz close.\n. ",
    "Yogu": "> No, the current behavior is consistent with the design\n\nLet me quote your [examples/async-generators/README.md](https://github.com/kriskowal/q/tree/fe0d26a05f88bd68d351ed05f44e02704ce9ee72/examples/async-generators):\n\n> Q has an async function. This can be used to decorate a generator function such that yield is effectively equivalent to await or defer syntax as supported by languages like Go and C# 5.\n\nIn C#, the following method signature is possible:\n\n```\npublic async Task<Task<int>> GetTaskAsync()\n```\n\nYou can call it like that:\n\n```\nTask<int> result = await GetTaskAsync();\n```\n\nSo resolving in a `Task<int>` is not any different from resolving e.g. in a `List<int>`.\n\nThe equivalent Q code is the one I posted above. That is, the current Q.async implementation treats Promises (more specificially thenables) different from other result tasks, and that makes it inconsistent.\n\nIt's even worse: If your returned value happens to have a `then` function that does not act like a promise, the promise returned by `Q.async(func)()` will never resolve. I think that's pretty unexpected.\n\n> `fulfill` does not produce a promise for a promise\n\nYes, it does:\n\n```\nvar promise = Q.fulfill(Q(123)); // is { state: 'fulfilled', value: { state: 'fulfilled', value: 123 } }\npromise.then(console.log); // prints { state: 'fulfilled', value: 123 }\n```\n\nand I think that's good, because `Q.fulfill` should not treat objects with a `then` function different from other objects. `Q` however is a convenience function that can be used for two different things: a) Converting a thenable into a Q promise, and b) Creating a promise that immediately resolves in the specified value.\n\n> Async methods must always return a promise\n\nthat's what #499 addressed, and my pull request does not change it.\n\n> and returning a promise from within an async generator should defer resolution of the async function.\n\nAnd why so? This behaviour can be more readably achieved with an additional `yield`:\n\n```\nQ.async(function*() {\n  var a = yield doSomething();\n  return yield doSomethingElse(a);\n}\n```\n\nCould you please re-think my proposal? (Sorry for the long comment, but I'm quite passionate about it ;-) Apart from this, I love Q. )\n. I see, there is quite some more depth than I saw at first. Thank you for sharing your thoughts and results! \n\nI'm looking forward to [async/await](http://wiki.ecmascript.org/doku.php?id=strawman:async_functions) syntax, which - according to the _Notes on types_ - features my approach.\n. > No, the current behavior is consistent with the design\n\nLet me quote your [examples/async-generators/README.md](https://github.com/kriskowal/q/tree/fe0d26a05f88bd68d351ed05f44e02704ce9ee72/examples/async-generators):\n\n> Q has an async function. This can be used to decorate a generator function such that yield is effectively equivalent to await or defer syntax as supported by languages like Go and C# 5.\n\nIn C#, the following method signature is possible:\n\n```\npublic async Task<Task<int>> GetTaskAsync()\n```\n\nYou can call it like that:\n\n```\nTask<int> result = await GetTaskAsync();\n```\n\nSo resolving in a `Task<int>` is not any different from resolving e.g. in a `List<int>`.\n\nThe equivalent Q code is the one I posted above. That is, the current Q.async implementation treats Promises (more specificially thenables) different from other result tasks, and that makes it inconsistent.\n\nIt's even worse: If your returned value happens to have a `then` function that does not act like a promise, the promise returned by `Q.async(func)()` will never resolve. I think that's pretty unexpected.\n\n> `fulfill` does not produce a promise for a promise\n\nYes, it does:\n\n```\nvar promise = Q.fulfill(Q(123)); // is { state: 'fulfilled', value: { state: 'fulfilled', value: 123 } }\npromise.then(console.log); // prints { state: 'fulfilled', value: 123 }\n```\n\nand I think that's good, because `Q.fulfill` should not treat objects with a `then` function different from other objects. `Q` however is a convenience function that can be used for two different things: a) Converting a thenable into a Q promise, and b) Creating a promise that immediately resolves in the specified value.\n\n> Async methods must always return a promise\n\nthat's what #499 addressed, and my pull request does not change it.\n\n> and returning a promise from within an async generator should defer resolution of the async function.\n\nAnd why so? This behaviour can be more readably achieved with an additional `yield`:\n\n```\nQ.async(function*() {\n  var a = yield doSomething();\n  return yield doSomethingElse(a);\n}\n```\n\nCould you please re-think my proposal? (Sorry for the long comment, but I'm quite passionate about it ;-) Apart from this, I love Q. )\n. I see, there is quite some more depth than I saw at first. Thank you for sharing your thoughts and results! \n\nI'm looking forward to [async/await](http://wiki.ecmascript.org/doku.php?id=strawman:async_functions) syntax, which - according to the _Notes on types_ - features my approach.\n. ",
    "fabslab": "version 1 still doesn't include mutation observer?\n. version 1 still doesn't include mutation observer?\n. ",
    "AsaAyers": "The error tracking doesn't really solve this problem. Often in development everything is working fine, but then an intermediate step fails in production and the error is just silently consumed. I really want to lint the code for unterminated promises, but I'm not sure that's possible.\n. ```\npromise1 = Q({something: 1})\npromise2 = promise1.get('something')\npromise3 = promise2.then(alert)\n```\n\nI broke this out into pieces just to give each promise a name. In this example `promise1` & `promise2` are fine, because they were continued. `promise3` is a mistake and shouldn't even exist. `Q.getUnhandledReasons()` will only detect this if one of these is rejected.\n\nIt seems like the code could be reused to provide something like a `Q.getUnterminatedPromises()`. I'm not sure how it would work to point me back to the code that generates the promise.\n. :thumbsup: a promise-debugger really is what's needed. I haven't seen Ember's promise debugger. Can it be used with Q and without using anything else from Ember?\n. See https://github.com/kriskowal/q/issues/522 it won't solve your problem, but there has been some discussion around this topic.\n. The error tracking doesn't really solve this problem. Often in development everything is working fine, but then an intermediate step fails in production and the error is just silently consumed. I really want to lint the code for unterminated promises, but I'm not sure that's possible.\n. ```\npromise1 = Q({something: 1})\npromise2 = promise1.get('something')\npromise3 = promise2.then(alert)\n```\n\nI broke this out into pieces just to give each promise a name. In this example `promise1` & `promise2` are fine, because they were continued. `promise3` is a mistake and shouldn't even exist. `Q.getUnhandledReasons()` will only detect this if one of these is rejected.\n\nIt seems like the code could be reused to provide something like a `Q.getUnterminatedPromises()`. I'm not sure how it would work to point me back to the code that generates the promise.\n. :thumbsup: a promise-debugger really is what's needed. I haven't seen Ember's promise debugger. Can it be used with Q and without using anything else from Ember?\n. See https://github.com/kriskowal/q/issues/522 it won't solve your problem, but there has been some discussion around this topic.\n. ",
    "stri8ed": "I used  `npm install q`. I am running npm 1.3.15. Ill try upgrading npm and see if that fixed it.\n. Updating npm to 1.4.7 fixed the problem. Thanks.\n. I used  `npm install q`. I am running npm 1.3.15. Ill try upgrading npm and see if that fixed it.\n. Updating npm to 1.4.7 fixed the problem. Thanks.\n. ",
    "janbaer": "What I'm trying todo is this:\n\n```\nvar promises = [];\n\nfiles.forEach(function (file) {\n  var filePath = path.join(directoryPath, file);\n  promises.push(fileChecker.check(filePath, whatIf));\n});\n\npromises.reduce(Q.when, Q()).then(function () {\n  console.log('All functions resolved');\n  q.resolve();\n});\n```\n\nIt's not necessary that a function is depending on the result of the previous function. But it's necessary that the following function waits until the previous function has resolved the promise.\n. @kriskowal  Many thanks! Your snippet has solved my problem! And sorry, that I've misused this channel to find a solution. Normally I'm using **stackoverflow** for questions like this. But I'm sure that your answer was quickly enough for me! ;)\n. What I'm trying todo is this:\n\n```\nvar promises = [];\n\nfiles.forEach(function (file) {\n  var filePath = path.join(directoryPath, file);\n  promises.push(fileChecker.check(filePath, whatIf));\n});\n\npromises.reduce(Q.when, Q()).then(function () {\n  console.log('All functions resolved');\n  q.resolve();\n});\n```\n\nIt's not necessary that a function is depending on the result of the previous function. But it's necessary that the following function waits until the previous function has resolved the promise.\n. @kriskowal  Many thanks! Your snippet has solved my problem! And sorry, that I've misused this channel to find a solution. Normally I'm using **stackoverflow** for questions like this. But I'm sure that your answer was quickly enough for me! ;)\n. ",
    "adamziel": "How would one catch all Error-based rejections then? It would be very useful to print all Errors for debugging. Unless I missed something, right now they just go under the radar unless I explicitly set .catch() for each promise in my code, check if rejection is an error, and then print it if current verbosity level is appropriate.\n. I don't think modifying `reject` is a way to go since there may be a lot of user-caused rejections which are perfectly fine.\n\nI thought of something else, like adding global config parameter `Q.throwErrors = false;` and something like `throwErrorIfUserWantsToSeeErrors(exception);` to each `try/catch` that attempts to convert errors to rejections; This way we may throw errors, and errors only.\n. I can see that, but then how do you find a legitimate Error thrown somewhere in a Q-based code? As far as I understand, one would have to check rejection reason in each and every single `catch` and throw it if it's not whitelisted?\n. Okay that works, great!\n. Actually I still have one more concern. `catch` callback is called when any Error is thrown\nLet's assume:\n- I am either deliberately using throw new Error() or expect an error from a library call like `JSON.parse` as in your example\n- I want to do something when promise is rejected so I define a `catch` callback.\n- I want to know if there was a runtime Error I didn't expect, perhaps from an invalid function call, or type mismatch, or accessing a property on undefined object - just usual stuff\n\nDo I have to specifically whitelist all expected errors in my `catch` function and act if rejection reason is not known, or is there some generic way of dealing with that?\n. Ah, that makes sense, thanks\n. How would one catch all Error-based rejections then? It would be very useful to print all Errors for debugging. Unless I missed something, right now they just go under the radar unless I explicitly set .catch() for each promise in my code, check if rejection is an error, and then print it if current verbosity level is appropriate.\n. I don't think modifying `reject` is a way to go since there may be a lot of user-caused rejections which are perfectly fine.\n\nI thought of something else, like adding global config parameter `Q.throwErrors = false;` and something like `throwErrorIfUserWantsToSeeErrors(exception);` to each `try/catch` that attempts to convert errors to rejections; This way we may throw errors, and errors only.\n. I can see that, but then how do you find a legitimate Error thrown somewhere in a Q-based code? As far as I understand, one would have to check rejection reason in each and every single `catch` and throw it if it's not whitelisted?\n. Okay that works, great!\n. Actually I still have one more concern. `catch` callback is called when any Error is thrown\nLet's assume:\n- I am either deliberately using throw new Error() or expect an error from a library call like `JSON.parse` as in your example\n- I want to do something when promise is rejected so I define a `catch` callback.\n- I want to know if there was a runtime Error I didn't expect, perhaps from an invalid function call, or type mismatch, or accessing a property on undefined object - just usual stuff\n\nDo I have to specifically whitelist all expected errors in my `catch` function and act if rejection reason is not known, or is there some generic way of dealing with that?\n. Ah, that makes sense, thanks\n. ",
    "sth": "The work around I mentioned before doesn't work reliably. In Safari 6.1.3 the problem is also present, but the `webkitPostMessage` property I used for browser detection doesn't exist.\n. Another workaround I came up with is to use a `setTimeout()` backup for potentially problematic cases:\n\n```\nfunction makeTrigger() {\n    var done = false;\n    function trigger() {\n        if (!done) {\n             done = true;\n             flush();\n        }\n    }\n    return trigger;\n}\n\nrequestTick = function () {\n    var trigger = makeTrigger();\n    channel.port1.onmessage = trigger;\n    channel.port2.postMessage(0);\n    setTimeout(trigger, 0);\n};\n```\n\nI'm putting this here just in case `MutationObserver` also turns out to have subtle problems in some browsers.\n. In the jsfiddle, the `stack` property is not writable. This causes `makeStackTraceLong()` to throw, aborting the promise rejection that was being handled.\n\nThere seem to be real environments where [`Error.stack` is not writable](https://github.com/ariya/phantomjs/issues/12381), and I wouldn't be surprised if there were old browsers that had the same issues in some cases, for example the error is a wrapped native object.\n. @baracoder: You could try sth/q@cbf5ccf79053076f7f64b86fe2bbe024d3206c0c to see if it fixes your issues.\n\nThat branch adds a `try-catch` to ignore problems caused by non-writable exception stacks.\n. It intentionally doesn't wait, that's how a deferred/promise works.\n\nThe function given to `then()` would be called once the deferred gets resolved. Since the deferred doesn't get resolved, the function doesn't get called.\n. It's not clear what you are trying to do. What \"series\" are you talking abbut and what are you trying to do with them?\n. The work around I mentioned before doesn't work reliably. In Safari 6.1.3 the problem is also present, but the `webkitPostMessage` property I used for browser detection doesn't exist.\n. Another workaround I came up with is to use a `setTimeout()` backup for potentially problematic cases:\n\n```\nfunction makeTrigger() {\n    var done = false;\n    function trigger() {\n        if (!done) {\n             done = true;\n             flush();\n        }\n    }\n    return trigger;\n}\n\nrequestTick = function () {\n    var trigger = makeTrigger();\n    channel.port1.onmessage = trigger;\n    channel.port2.postMessage(0);\n    setTimeout(trigger, 0);\n};\n```\n\nI'm putting this here just in case `MutationObserver` also turns out to have subtle problems in some browsers.\n. In the jsfiddle, the `stack` property is not writable. This causes `makeStackTraceLong()` to throw, aborting the promise rejection that was being handled.\n\nThere seem to be real environments where [`Error.stack` is not writable](https://github.com/ariya/phantomjs/issues/12381), and I wouldn't be surprised if there were old browsers that had the same issues in some cases, for example the error is a wrapped native object.\n. @baracoder: You could try sth/q@cbf5ccf79053076f7f64b86fe2bbe024d3206c0c to see if it fixes your issues.\n\nThat branch adds a `try-catch` to ignore problems caused by non-writable exception stacks.\n. It intentionally doesn't wait, that's how a deferred/promise works.\n\nThe function given to `then()` would be called once the deferred gets resolved. Since the deferred doesn't get resolved, the function doesn't get called.\n. It's not clear what you are trying to do. What \"series\" are you talking abbut and what are you trying to do with them?\n. ",
    "sshaw": "I have this problem (`Uncaught ReferenceError: require is not defined`) with any 2.X release. 1.X releases are fine. Checkout [this fiddle](http://jsfiddle.net/pw92nuwv/). \n. I have this problem (`Uncaught ReferenceError: require is not defined`) with any 2.X release. 1.X releases are fine. Checkout [this fiddle](http://jsfiddle.net/pw92nuwv/). \n. ",
    "doapp-ryanp": "Awesome - appreciate it. thanks guys and keep up the great work.\n. Awesome - appreciate it. thanks guys and keep up the great work.\n. ",
    "pedroteixeira": "you are right, thanks. I'm porting some code from jquery Deferred.\n\nbut isn't better to always ensure then is called with the correct scope?\nperhaps, could emit a warning if self != expected. because the currect error.stack makes it hard to trace back to the original line.\n. you are right, thanks. I'm porting some code from jquery Deferred.\n\nbut isn't better to always ensure then is called with the correct scope?\nperhaps, could emit a warning if self != expected. because the currect error.stack makes it hard to trace back to the original line.\n. ",
    "dantman": "^_^ Great, then I can keep using Q even in the code that gets shared between the server and client.\n. > to elegantly handle both rate limiting and calls for subsequent pages where I don't know where the end is.\n\nOn this note I should note a separate relevant, IE has flawed handling of its setImmediate function. In some cases setTimeout loops and DOM modifications can result in setImmediate callbacks never being called.\nhttp://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/\n. ^_^ Great, then I can keep using Q even in the code that gets shared between the server and client.\n. > to elegantly handle both rate limiting and calls for subsequent pages where I don't know where the end is.\n\nOn this note I should note a separate relevant, IE has flawed handling of its setImmediate function. In some cases setTimeout loops and DOM modifications can result in setImmediate callbacks never being called.\nhttp://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/\n. ",
    "dsimmons": "+1\n\nI too just started having the same exact problem. I'm also processing large amounts of data, using recursive promises, to elegantly handle both rate limiting and calls for subsequent pages where I don't know where the end is.\n\nIt hums along great for several hours (was watching `htop` the entire time to monitor for potential memory leaks), but eventually terminates with the above error.\n. @dantman: that's a valid concern that should be taken into consideration, but just in the interest of debugging this: at least for my case, it's entirely in a server-side environment with no front-end interaction.\n. +1\n\nI too just started having the same exact problem. I'm also processing large amounts of data, using recursive promises, to elegantly handle both rate limiting and calls for subsequent pages where I don't know where the end is.\n\nIt hums along great for several hours (was watching `htop` the entire time to monitor for potential memory leaks), but eventually terminates with the above error.\n. @dantman: that's a valid concern that should be taken into consideration, but just in the interest of debugging this: at least for my case, it's entirely in a server-side environment with no front-end interaction.\n. ",
    "jimlloyd": " @joe-spanning: Thanks for logging this issue, you saved me some debugging time. I am using the exact same pattern. My code looks like:\n\n```\nfunction onScriptInput() {\n  self.promptForInput()\n    .then(lineReader.readLine)\n    .then(self.onEchoInput)\n    .then(self.compileAndExecuteScript)\n    .then(self.printResult)\n    .catch(function(err) { console.error(chalk.bold.red(err)); })\n    .done(onScriptInput);\n}\n```\n\nIt seems I can work around the problem by inserting a delay of 1ms:\n\n```\nfunction onScriptInput() {\n  self.promptForInput()\n    .then(lineReader.readLine)\n    .then(self.onEchoInput)\n    .then(self.compileAndExecuteScript)\n    .then(self.printResult)\n    .catch(function(err) { console.error(chalk.bold.red(err)); })\n    .delay(1)\n    .done(onScriptInput);\n}\n```\n.  @joe-spanning: Thanks for logging this issue, you saved me some debugging time. I am using the exact same pattern. My code looks like:\n\n```\nfunction onScriptInput() {\n  self.promptForInput()\n    .then(lineReader.readLine)\n    .then(self.onEchoInput)\n    .then(self.compileAndExecuteScript)\n    .then(self.printResult)\n    .catch(function(err) { console.error(chalk.bold.red(err)); })\n    .done(onScriptInput);\n}\n```\n\nIt seems I can work around the problem by inserting a delay of 1ms:\n\n```\nfunction onScriptInput() {\n  self.promptForInput()\n    .then(lineReader.readLine)\n    .then(self.onEchoInput)\n    .then(self.compileAndExecuteScript)\n    .then(self.printResult)\n    .catch(function(err) { console.error(chalk.bold.red(err)); })\n    .delay(1)\n    .done(onScriptInput);\n}\n```\n. ",
    "sideroad": "+1\n. +1\n. ",
    "ciel": "I am looking forward to it, I've been using `Q` for only three days now, and I just posted a lengthy topic about my experience with the documentation. I love the library, truly. It solved a huge, huge, huge problem I was having and I'm a novice programmer at best. You've done some truly stellar work with this thing.\n. I am not knowledgeable enough on everything `Q` does to comment to a great degree on what you **should** do. I can only tell you what my own personal experience was like. It's overwhelming, and it was pretty difficult to get into, but certainly not bad in any sense.\n\nI think the most disconnecting part of it all was being so confused about **how to get a promise** and then **how that promise had anything to do with my existing code**. That's where I got stuck the most.\n\nTo cite an example, my exact problem was that I needed things to run in a specific order. I am using `ASP.NET MVC` with a `_Layout.cshtml` and then each individual View has a `scripts` section. So what was happening was ...\n- Layout.cshtml Javascript runs\n- [view].cshtml Javascript runs\n\nThis was presenting a real challenge though, because I needed things to occur after the individual view, but still be on the `_Layout`. I had a huge problem overcoming this and tried all kinds of stupid, fanciful methods of delaying methods, I tried a library called `jsdeferred` and it kind of helped.\n\nI was directed to `Q` as a solution to this, because it supposedly had the ability to, and I quote _\"turn blocks of code into something that promises to be a block of code, but isn't yet a block of code. It actually delays running that code until you're ready for it, but you still have to find a way to be aware of it.\"_ (exact statement from a friend of mine)\n\nI had no idea what `promises` were, or what `deferrable` was, to be honest. I just knew that I wanted these functions to run in the order I wanted them, and not sooner, and not later. Using `Q`, I finally managed to accomplish that. And I am super excited about it. It makes my code cleaner to read. It makes it easier to maintain. It means I'm not having to come up with clever tricks to delay things until later, it means I'm not having to try and 'fool' Visual Studio's intellisense support.\n\nI don't know what your audience is, but I do know what your product is - and the answer is **awesome**. I mean, I'm not even using it right, and the performance of my pages is increasing. I can't even imagine how much better it'll be once I grasp what the hell I am doing and use it to its real potential.\n. By the way, if you want to see what I ended up doing, you can see it here on my [Stackoverflow Post](http://stackoverflow.com/questions/24352165/using-q-js-broken-between-two-files-in-asp-net-mvc) post. \n\nI may be using the library totally wrong, in fact I am almost certain that I am. But it solved a problem for me, and that is what mattered at the end of the day. I'm really looking forward to how I can use Q in other places in my code _correctly_ in order to boost performance and make it function the way I want.\n. Ah, I want to be extremely, unquestionably clear here that my intention was in no way a jab at the writers of this plugin. Reading over it this morning, I am a bit ashamed at myself as I realize that, if read in the wrong context, the post I made could sound horribly condescending and snide, almost self entitled. That was absolutely never my intention.\n\nI follow up to what @zackster said, I found it challenging to get involved. Even the working solution I amalgamated, while it works and does **I want it to do**, it isn't using the library for its actual intended purpose. (_I would also love any weighing in on opinions of what I did with it. Is the way I used it so bad that I should scrap it and try a new approach? Or is it fine to use it that way?_ You can see how I used it here in my [Stackoverflow Question](http://stackoverflow.com/questions/24352165/using-q-js-broken-between-two-files-in-asp-net-mvc))\n\nI am a technical writer, and a programmer. It is my experience that most programmers have 2 out of 5 typical skill sets needed (thus why teams work so well). These 5 skill sets, as I have determined in the last 20 years, are as follows;\n1. Programmer (_actual coding_)\n2. Technical Writer (_documentation_)\n3. Analyst (_reviews behavior and reports on it_)\n4. Tester (_thoroughly capable of performing rigorous breaking of things made_)\n5. Theorist (_comes up with the general ideas of what needs to happen, and why_)\n\nIn the past 20 years of experience I have had, I find that **most** (not all) developers have _at least 2 of these_ as a strength, and _at least 1 of them_ as a weakness. \n\nI am extremely good at writing documentation, so I may take the time to sit down and try to learn `Q` inside and out, and try to contribute to its documentation. Though my knowledge and time may not allow for it.\n\nI honestly think the best place for you to start, though, would be simple. If I were looking for a library like `Q`, and I did not already understand how to use it, then this is what is going through my head.\n\n**`I have code that is running at the wrong time. I need to fix that.`**\n**`I have code that needs to wait on something else. How do I do that?`**\n**`I have code that needs to run at the same time as other code, but finish earlier.`**\n**`I have no idea what I'm doing`**\n\nI guide you to exhibit A\n![Caterpie Can't Hack It](http://i.imgur.com/TyB2zXI.jpg)\n\nIn all seriousness, though, here's what I would suggest.\n- First, and foremost, I think it would be helpful if you put a `dist` folder on the github that has the fully compiled, fully ready `q.js` file that any average joe can copy/paste into their stuff. One of the first entry barriers was just **getting** `Q.js`. I found that the file at [https://github.com/kriskowal/q/blob/v1/q.js](https://github.com/kriskowal/q/blob/v1/q.js) did not work as expected. It seemed to demand I have some other pre-requisites. The only way I was able to get a running version was to make a **fake Web Project in Visual Studio** and download it through **NuGet**. A `dist` folder that has this _'compiled'_ version would really be nice. \n- Then, lead strong with samples from the `#the-beginning` part. Tell us `what a promise is` and `why we want one`, then show us `how to get one`. \n\nSo it would briefly look like this;\n\n> A **promise** is ....\n> You can get a promise like this ... \n> You can run this code to see an example.\n> \n> What is `Q.fcall`? Why is it called `fcall`? That's weird. Why not just `Q.call`? Or `Q(fn)`? What is valid to pass through an `fcall`?\n\nThese are all questions that went through my head as I was reading through it. I do think `fcall` is a strange name for the function, and I would honestly prefer it be something that satisfied my own OCD more like `Q.invoke` or `Q.start(fn)`, but I'm not the genius who wrote the code, so I don't get the right to say anything on that matter. \n\nAnd then a short snippet that shows a real world use that can be copied and pasted without the need for server side technology. Something the user could quickly put up in a `jsbin` or a `jsfiddle`. Perhaps even **lightweight cdn** links so that it becomes a little less distracting to get the library into those external code runners (_note. I am not suggesting you host a cdn. I am merely stating that if you take a `https://raw.githubusercontent.com/kriskowal/q/v1/q.js` and change the url to `https://rawgithub.com/kriskowal/q/v1/q.js` you get a url that is accessible to things like `jsBin` and `jsFiddle`._)\n\nSo you could start off with a sample file that looked something like this ...\n\n```\n<html>\n    <head>\n        <title>Q.js</title>\n        <script src=\"https://code.jquery.com/jquery-2.1.1.min.js\"></script>\n\n        <!-- example, demonstrative url only. do not use in production. -->\n        <script src=\"https://rawgithub.com/kriskowal/q/v1/q.js\"></script>\n\n        <script type=\"text/javascript\">\n           $(function(){\n              // show us a real deferrable use, show us Q in action.\n           });\n        </script>\n   </head>\n   <body>\n        // obviously, body content is here.\n    </body>\n</html>\n```\n\n# Bam\n\nI can take that to the bank, I can almost copy it right over to `jsbin`, or segment it up for `jsfiddle`, or `http://codepen.io` very quickly, now I'm prepared to start just trying things. \n\n#### Take a look at how they are presenting the idea of `MVVM` over at `knockoutjs`.\n\n![MVVM](http://i.imgur.com/SxMqSPJ.jpg)\n\nThere is actually a lot of information here quickly taught to me. While you may not be able to a _runnable example__, something that quickly breaks apart the pieces of the puzzle would make most of the rest of the documentation fall together in line much faster.\n\nWhat is happening here on the `knockoutjs` page, though? A few things;\n- They show me a **real world example**. \n  \n  > This is super important. Something I would actually want to see in the real world. Not `foo`, not `bar`, they are presenting a set of code that relates to something any of us as programmers have probably done before - a general shopping cart/ticket/storage system. It's basic, it's cut and dry, it's extremely simple. It triggers a lot of memory.\n- The point out the important pieces that come from their library\n  \n  > There is a distinct differentiation in what comes from `knockout.js` and just `javascript`. The little tool tip call outs accomplish this. I instantly see what the code is intending to accomplish, and how it is divided up. They have subconsciously gotten my mind to start focusing on **their functions** instead of my own. With those little bubbles, my attention is now on **data-bind** and **ko.applyBindings**.\n- I can write this exact code into an HTML file, and simply including `jquery.js` and `knockout.js`, and run it.\n  \n  > This is the part where I felt like `Q` falls the furthest behind. I had a really hard time finding something that **could just run and try**. There was a lot of wiring and collecting involved. I tried to get it all set up on a `jsbin` to use for some testing, but it was honestly a lot harder than that.  \n\n# Tying it together\n\nThe `#the-beginning` part really fell short when it started assuming I grasped what it meant by `returns a promise of 10`. What? Huh? I was scratching my head, lost in thought. \n\nI think the first fully composed 'example' I saw that started to make sense was the 5th code block of `https://github.com/kriskowal/q#using-deferreds`.\n\nAnyway, I hope some of that helps you a bit in thinking of how you're going to piece together new documentation, if you truly are aiming to do that. I am going to keep studying `Q.js` very hard, because it's slicker than boiled okra right now, and if I get to a point where I feel confident that I even know what the hell I am talking about, I will try to contribute.\n. > It isn't a performance or security killer is it? I sincerely hope not :)\n\nAt present, even with my poor understanding, I have seen nothing but **improved** performance from using `Q`.\n\n> To clarify, when you say \"documentation\" are you talking about the README, or the API reference? You kind of make it sound like the readme and the documentation are different, which has me a bit confused.\n\nI kind of mean both. The fact that it is split between different sections may be part of my confusion. I also attribute my sheer lack of experience to it, so bear that in mind. I am giving you the perspective from someone who is not even close to your level, if that makes any sense.\n. I am extremely grateful that the project contributors and creator here at `Q.js` found my comments as the edifying statements they were intended to be, and not jabs at their ability. I am a verbose and outspoken person, and I have had instances in the past where, when I present something to a project, I am met with intense disdain as someone who has no right to comment on it.\n. @kurtflint `Q` makes me think of when I first dabbled in programming at pre-junior high, when I played with `LOGOS` in the school lab. I do not know why. When I am working with `Q`, I just have these flashbacks to working **extremely** hard to get that little turtle to move, to get it to do one simple thing, but the overwhelming and exciting satisfaction when I got it to work, and follow a sequence of events to complete the puzzle. I totally get what nostalgia you're talking about.\n. Also, @kurtflint when I first got `Q.js` to work 'properly', I looked at the performance boost, and it was considerable. In fact I would say my program loads over 10x faster since I got it wired right, since I don't have to use any waiting or strange loading scripts. \n\nThis was pretty much my face: ![Image](http://i.imgur.com/t2QGkQt.png)\n. I am looking forward to it, I've been using `Q` for only three days now, and I just posted a lengthy topic about my experience with the documentation. I love the library, truly. It solved a huge, huge, huge problem I was having and I'm a novice programmer at best. You've done some truly stellar work with this thing.\n. I am not knowledgeable enough on everything `Q` does to comment to a great degree on what you **should** do. I can only tell you what my own personal experience was like. It's overwhelming, and it was pretty difficult to get into, but certainly not bad in any sense.\n\nI think the most disconnecting part of it all was being so confused about **how to get a promise** and then **how that promise had anything to do with my existing code**. That's where I got stuck the most.\n\nTo cite an example, my exact problem was that I needed things to run in a specific order. I am using `ASP.NET MVC` with a `_Layout.cshtml` and then each individual View has a `scripts` section. So what was happening was ...\n- Layout.cshtml Javascript runs\n- [view].cshtml Javascript runs\n\nThis was presenting a real challenge though, because I needed things to occur after the individual view, but still be on the `_Layout`. I had a huge problem overcoming this and tried all kinds of stupid, fanciful methods of delaying methods, I tried a library called `jsdeferred` and it kind of helped.\n\nI was directed to `Q` as a solution to this, because it supposedly had the ability to, and I quote _\"turn blocks of code into something that promises to be a block of code, but isn't yet a block of code. It actually delays running that code until you're ready for it, but you still have to find a way to be aware of it.\"_ (exact statement from a friend of mine)\n\nI had no idea what `promises` were, or what `deferrable` was, to be honest. I just knew that I wanted these functions to run in the order I wanted them, and not sooner, and not later. Using `Q`, I finally managed to accomplish that. And I am super excited about it. It makes my code cleaner to read. It makes it easier to maintain. It means I'm not having to come up with clever tricks to delay things until later, it means I'm not having to try and 'fool' Visual Studio's intellisense support.\n\nI don't know what your audience is, but I do know what your product is - and the answer is **awesome**. I mean, I'm not even using it right, and the performance of my pages is increasing. I can't even imagine how much better it'll be once I grasp what the hell I am doing and use it to its real potential.\n. By the way, if you want to see what I ended up doing, you can see it here on my [Stackoverflow Post](http://stackoverflow.com/questions/24352165/using-q-js-broken-between-two-files-in-asp-net-mvc) post. \n\nI may be using the library totally wrong, in fact I am almost certain that I am. But it solved a problem for me, and that is what mattered at the end of the day. I'm really looking forward to how I can use Q in other places in my code _correctly_ in order to boost performance and make it function the way I want.\n. Ah, I want to be extremely, unquestionably clear here that my intention was in no way a jab at the writers of this plugin. Reading over it this morning, I am a bit ashamed at myself as I realize that, if read in the wrong context, the post I made could sound horribly condescending and snide, almost self entitled. That was absolutely never my intention.\n\nI follow up to what @zackster said, I found it challenging to get involved. Even the working solution I amalgamated, while it works and does **I want it to do**, it isn't using the library for its actual intended purpose. (_I would also love any weighing in on opinions of what I did with it. Is the way I used it so bad that I should scrap it and try a new approach? Or is it fine to use it that way?_ You can see how I used it here in my [Stackoverflow Question](http://stackoverflow.com/questions/24352165/using-q-js-broken-between-two-files-in-asp-net-mvc))\n\nI am a technical writer, and a programmer. It is my experience that most programmers have 2 out of 5 typical skill sets needed (thus why teams work so well). These 5 skill sets, as I have determined in the last 20 years, are as follows;\n1. Programmer (_actual coding_)\n2. Technical Writer (_documentation_)\n3. Analyst (_reviews behavior and reports on it_)\n4. Tester (_thoroughly capable of performing rigorous breaking of things made_)\n5. Theorist (_comes up with the general ideas of what needs to happen, and why_)\n\nIn the past 20 years of experience I have had, I find that **most** (not all) developers have _at least 2 of these_ as a strength, and _at least 1 of them_ as a weakness. \n\nI am extremely good at writing documentation, so I may take the time to sit down and try to learn `Q` inside and out, and try to contribute to its documentation. Though my knowledge and time may not allow for it.\n\nI honestly think the best place for you to start, though, would be simple. If I were looking for a library like `Q`, and I did not already understand how to use it, then this is what is going through my head.\n\n**`I have code that is running at the wrong time. I need to fix that.`**\n**`I have code that needs to wait on something else. How do I do that?`**\n**`I have code that needs to run at the same time as other code, but finish earlier.`**\n**`I have no idea what I'm doing`**\n\nI guide you to exhibit A\n![Caterpie Can't Hack It](http://i.imgur.com/TyB2zXI.jpg)\n\nIn all seriousness, though, here's what I would suggest.\n- First, and foremost, I think it would be helpful if you put a `dist` folder on the github that has the fully compiled, fully ready `q.js` file that any average joe can copy/paste into their stuff. One of the first entry barriers was just **getting** `Q.js`. I found that the file at [https://github.com/kriskowal/q/blob/v1/q.js](https://github.com/kriskowal/q/blob/v1/q.js) did not work as expected. It seemed to demand I have some other pre-requisites. The only way I was able to get a running version was to make a **fake Web Project in Visual Studio** and download it through **NuGet**. A `dist` folder that has this _'compiled'_ version would really be nice. \n- Then, lead strong with samples from the `#the-beginning` part. Tell us `what a promise is` and `why we want one`, then show us `how to get one`. \n\nSo it would briefly look like this;\n\n> A **promise** is ....\n> You can get a promise like this ... \n> You can run this code to see an example.\n> \n> What is `Q.fcall`? Why is it called `fcall`? That's weird. Why not just `Q.call`? Or `Q(fn)`? What is valid to pass through an `fcall`?\n\nThese are all questions that went through my head as I was reading through it. I do think `fcall` is a strange name for the function, and I would honestly prefer it be something that satisfied my own OCD more like `Q.invoke` or `Q.start(fn)`, but I'm not the genius who wrote the code, so I don't get the right to say anything on that matter. \n\nAnd then a short snippet that shows a real world use that can be copied and pasted without the need for server side technology. Something the user could quickly put up in a `jsbin` or a `jsfiddle`. Perhaps even **lightweight cdn** links so that it becomes a little less distracting to get the library into those external code runners (_note. I am not suggesting you host a cdn. I am merely stating that if you take a `https://raw.githubusercontent.com/kriskowal/q/v1/q.js` and change the url to `https://rawgithub.com/kriskowal/q/v1/q.js` you get a url that is accessible to things like `jsBin` and `jsFiddle`._)\n\nSo you could start off with a sample file that looked something like this ...\n\n```\n<html>\n    <head>\n        <title>Q.js</title>\n        <script src=\"https://code.jquery.com/jquery-2.1.1.min.js\"></script>\n\n        <!-- example, demonstrative url only. do not use in production. -->\n        <script src=\"https://rawgithub.com/kriskowal/q/v1/q.js\"></script>\n\n        <script type=\"text/javascript\">\n           $(function(){\n              // show us a real deferrable use, show us Q in action.\n           });\n        </script>\n   </head>\n   <body>\n        // obviously, body content is here.\n    </body>\n</html>\n```\n\n# Bam\n\nI can take that to the bank, I can almost copy it right over to `jsbin`, or segment it up for `jsfiddle`, or `http://codepen.io` very quickly, now I'm prepared to start just trying things. \n\n#### Take a look at how they are presenting the idea of `MVVM` over at `knockoutjs`.\n\n![MVVM](http://i.imgur.com/SxMqSPJ.jpg)\n\nThere is actually a lot of information here quickly taught to me. While you may not be able to a _runnable example__, something that quickly breaks apart the pieces of the puzzle would make most of the rest of the documentation fall together in line much faster.\n\nWhat is happening here on the `knockoutjs` page, though? A few things;\n- They show me a **real world example**. \n  \n  > This is super important. Something I would actually want to see in the real world. Not `foo`, not `bar`, they are presenting a set of code that relates to something any of us as programmers have probably done before - a general shopping cart/ticket/storage system. It's basic, it's cut and dry, it's extremely simple. It triggers a lot of memory.\n- The point out the important pieces that come from their library\n  \n  > There is a distinct differentiation in what comes from `knockout.js` and just `javascript`. The little tool tip call outs accomplish this. I instantly see what the code is intending to accomplish, and how it is divided up. They have subconsciously gotten my mind to start focusing on **their functions** instead of my own. With those little bubbles, my attention is now on **data-bind** and **ko.applyBindings**.\n- I can write this exact code into an HTML file, and simply including `jquery.js` and `knockout.js`, and run it.\n  \n  > This is the part where I felt like `Q` falls the furthest behind. I had a really hard time finding something that **could just run and try**. There was a lot of wiring and collecting involved. I tried to get it all set up on a `jsbin` to use for some testing, but it was honestly a lot harder than that.  \n\n# Tying it together\n\nThe `#the-beginning` part really fell short when it started assuming I grasped what it meant by `returns a promise of 10`. What? Huh? I was scratching my head, lost in thought. \n\nI think the first fully composed 'example' I saw that started to make sense was the 5th code block of `https://github.com/kriskowal/q#using-deferreds`.\n\nAnyway, I hope some of that helps you a bit in thinking of how you're going to piece together new documentation, if you truly are aiming to do that. I am going to keep studying `Q.js` very hard, because it's slicker than boiled okra right now, and if I get to a point where I feel confident that I even know what the hell I am talking about, I will try to contribute.\n. > It isn't a performance or security killer is it? I sincerely hope not :)\n\nAt present, even with my poor understanding, I have seen nothing but **improved** performance from using `Q`.\n\n> To clarify, when you say \"documentation\" are you talking about the README, or the API reference? You kind of make it sound like the readme and the documentation are different, which has me a bit confused.\n\nI kind of mean both. The fact that it is split between different sections may be part of my confusion. I also attribute my sheer lack of experience to it, so bear that in mind. I am giving you the perspective from someone who is not even close to your level, if that makes any sense.\n. I am extremely grateful that the project contributors and creator here at `Q.js` found my comments as the edifying statements they were intended to be, and not jabs at their ability. I am a verbose and outspoken person, and I have had instances in the past where, when I present something to a project, I am met with intense disdain as someone who has no right to comment on it.\n. @kurtflint `Q` makes me think of when I first dabbled in programming at pre-junior high, when I played with `LOGOS` in the school lab. I do not know why. When I am working with `Q`, I just have these flashbacks to working **extremely** hard to get that little turtle to move, to get it to do one simple thing, but the overwhelming and exciting satisfaction when I got it to work, and follow a sequence of events to complete the puzzle. I totally get what nostalgia you're talking about.\n. Also, @kurtflint when I first got `Q.js` to work 'properly', I looked at the performance boost, and it was considerable. In fact I would say my program loads over 10x faster since I got it wired right, since I don't have to use any waiting or strange loading scripts. \n\nThis was pretty much my face: ![Image](http://i.imgur.com/t2QGkQt.png)\n. ",
    "zackster": "@domenic  I have plenty of experience with using promises and the patterns as implemented by popular 3rd party libraries and I still found the documentation challenging.  \n\nThe problem I personally had was \"**The Beginning**\n\nEverything above assumes you get a promise from somewhere else. This is the common case. Every once in a while, you will need to create a promise from scratch.\"\n\nWe need to set the frame at the top.  \"Everything above assumes ...\" needs to go BEFORE we process the information, so we can encode it correctly.  Otherwise it is confusing. :-) \n. @domenic  I have plenty of experience with using promises and the patterns as implemented by popular 3rd party libraries and I still found the documentation challenging.  \n\nThe problem I personally had was \"**The Beginning**\n\nEverything above assumes you get a promise from somewhere else. This is the common case. Every once in a while, you will need to create a promise from scratch.\"\n\nWe need to set the frame at the top.  \"Everything above assumes ...\" needs to go BEFORE we process the information, so we can encode it correctly.  Otherwise it is confusing. :-) \n. ",
    "kurtflint": "You ever not know you needed something and then bam! Game changer?\n\nHello, my name is Kurt, and I'm a software architect and producer. I was a bit amused to find this (#543) in my inbox this morning, because yesterday I found Q completely by accident while looking for something unrelated on github, and for some reason was intrigued enough by the README to jump over and take a look at the documentation. And I that is what sold me on the idea in about 30 seconds flat. I found it not just readable and usable, but that it described the base paradigm so strongly in the first half page or so that the rest of it almost becomes superfluous once you understand what the authors of the code are getting at.\n\nAny additional documentation I would expect to see at the code level, probably as a folder of usable tests with correct markup on the classes etc. as an example. Maybe with a nice index page as a jumping off point that explains what the test code does and why, and references the correct part of the online docs.\n\nThat is my 2c worth - the only value I am claiming to bring to the conversation might be my professional first impression. I scheduled a block of time for later this week to stop the world and take a deep dive into the subject which is unusual, and I forwarded a link to the docs and github source to my javascript users right then and there.\n\nIt isn't a performance or security killer is it? I sincerely hope not :)\n\nCheers!\nK\n. Oh, look at that! I overlooked the API reference, though I was just getting a view from 10k feet in passing.\n\nI saw README on github and did a bit of a double take when I realized what was being built and how handy it could be, and then jumped to http://documentup.com and browsed around for a few minutes. I was properly impressed, but maybe I am just too easy. It is still possible that in a couple of days when I start trying to build some code I'll get frustrated. I don't write a lot of javascript anymore, or anything else that doesn't compile to be honest. Most of my js time in the last few years has been debugging other people's client side snafus, and trying to figure out what in the world someone did to my perfectly elegant spec ;)\n\nThe Q here sort of reminds me of something from my programming past, but I can't put my finger on it.  My memory isn't what it used to be.\n\nCheers (by the way, I am going to have to leave this fascinating conversation because I get to move house! Off this darned mountain and back to Santa Cruz! Take care, and don't forget - not _everything_ has to be a closure!)\n. You ever not know you needed something and then bam! Game changer?\n\nHello, my name is Kurt, and I'm a software architect and producer. I was a bit amused to find this (#543) in my inbox this morning, because yesterday I found Q completely by accident while looking for something unrelated on github, and for some reason was intrigued enough by the README to jump over and take a look at the documentation. And I that is what sold me on the idea in about 30 seconds flat. I found it not just readable and usable, but that it described the base paradigm so strongly in the first half page or so that the rest of it almost becomes superfluous once you understand what the authors of the code are getting at.\n\nAny additional documentation I would expect to see at the code level, probably as a folder of usable tests with correct markup on the classes etc. as an example. Maybe with a nice index page as a jumping off point that explains what the test code does and why, and references the correct part of the online docs.\n\nThat is my 2c worth - the only value I am claiming to bring to the conversation might be my professional first impression. I scheduled a block of time for later this week to stop the world and take a deep dive into the subject which is unusual, and I forwarded a link to the docs and github source to my javascript users right then and there.\n\nIt isn't a performance or security killer is it? I sincerely hope not :)\n\nCheers!\nK\n. Oh, look at that! I overlooked the API reference, though I was just getting a view from 10k feet in passing.\n\nI saw README on github and did a bit of a double take when I realized what was being built and how handy it could be, and then jumped to http://documentup.com and browsed around for a few minutes. I was properly impressed, but maybe I am just too easy. It is still possible that in a couple of days when I start trying to build some code I'll get frustrated. I don't write a lot of javascript anymore, or anything else that doesn't compile to be honest. Most of my js time in the last few years has been debugging other people's client side snafus, and trying to figure out what in the world someone did to my perfectly elegant spec ;)\n\nThe Q here sort of reminds me of something from my programming past, but I can't put my finger on it.  My memory isn't what it used to be.\n\nCheers (by the way, I am going to have to leave this fascinating conversation because I get to move house! Off this darned mountain and back to Santa Cruz! Take care, and don't forget - not _everything_ has to be a closure!)\n. ",
    "maxiwu": "thank you for bringing up this issue.\nI too find it difficult to understand how to use Q after reading the readme article.\n\nI am guess, if I have asynchronous function myAsyncFunc(), then I could enhance with Q by\nQ.fcall(myAsyncFunc).then(resolve(value),reject(err));\nIs it what Q is trying to achieve?\n\nciel, could you kindly show us hello world sample code of using Q?\n. thank you for bringing up this issue.\nI too find it difficult to understand how to use Q after reading the readme article.\n\nI am guess, if I have asynchronous function myAsyncFunc(), then I could enhance with Q by\nQ.fcall(myAsyncFunc).then(resolve(value),reject(err));\nIs it what Q is trying to achieve?\n\nciel, could you kindly show us hello world sample code of using Q?\n. ",
    "chrisDeFouRire": "Hi !\nI've found a way around that bug! at last! and it taught me something: it must be due to partially initialized modules. I was using Q with partially-initialized modules...\nSo I guess it's not really a bug in Q, just a nasty bug in my code!\n\nThanks for your prompt answer ! 1.0.1 didn't change a thing btw, but I'll stick to 1.0.1 for the time being\n. Hi !\nI've found a way around that bug! at last! and it taught me something: it must be due to partially initialized modules. I was using Q with partially-initialized modules...\nSo I guess it's not really a bug in Q, just a nasty bug in my code!\n\nThanks for your prompt answer ! 1.0.1 didn't change a thing btw, but I'll stick to 1.0.1 for the time being\n. ",
    "luckydrq": "Oh,i misunderstood. Thanks!\n. Oh,i misunderstood. Thanks!\n. ",
    "anilanar": "It comes from the `collections` dependency added in commit: 6c395343f0624354f7cf8d1d641b56d66154828f\nSee `./node_modules/collections/shim_array.js`:\n\n```\ndefine(\"add\", function (value) {\n  this.push(value);\n  return true;\n});\n```\n\nI'm not sure if it's intended.\n. It comes from the `collections` dependency added in commit: 6c395343f0624354f7cf8d1d641b56d66154828f\nSee `./node_modules/collections/shim_array.js`:\n\n```\ndefine(\"add\", function (value) {\n  this.push(value);\n  return true;\n});\n```\n\nI'm not sure if it's intended.\n. ",
    "Alexsey": "We use <a href=\"http://sugarjs.com/\">sugarjs<a> in our project, it's a library that brings a lot of methods to prototypes, and it also has <code>.add</code> method. So after <code>Q</code> installation code just break. Single project should not have more than one library that extends prototypes, and imho it should do library that extends prototypes, not one that bring promises.\n. @kriskowal yes, of course it's not a problem of official release, that is why <code>2.0.2</code> is in the title. \n. @kriskowal, thanks for reply. Hope I would be able to close this soon :)\n. We use <a href=\"http://sugarjs.com/\">sugarjs<a> in our project, it's a library that brings a lot of methods to prototypes, and it also has <code>.add</code> method. So after <code>Q</code> installation code just break. Single project should not have more than one library that extends prototypes, and imho it should do library that extends prototypes, not one that bring promises.\n. @kriskowal yes, of course it's not a problem of official release, that is why <code>2.0.2</code> is in the title. \n. @kriskowal, thanks for reply. Hope I would be able to close this soon :)\n. ",
    "sowelie": "Thanks for the reply @kriskowal, however this is not working.  I am using Q in nodejs.  Neither my onerror nor the uncaughtException event of the process object are being triggered.  Here is some code, I'm sure I must be doing something wrong.\n\n``` javascript\nq.onerror = function() {\n    console.log(arguments);\n};\n\nprocess.on('uncaughtException', function(err) {\n    console.log('Caught exception: ' + err);\n});\n```\n\nAnd here, I'm creating a deferred and triggering an error within the then callback:\n\n``` javascript\nrouter.all(\"/owned\", function(req, res) {\n    var deferred = q.defer();\n\n    deferred.promise.then(function() {\n        throw new Error(\"OH NO!\");\n    });\n\n    deferred.resolve();\n    res.jsonp({ test: \"test\" });\n});\n```\n\nAs you can see I'm using \"express\".  I'm not sure if this is interfering in any way.\n\nIf I modify the Promise.then function, I can get the result I expect:\n\n``` javascript\nfunction _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            // my change, trigger the global error handler\n            if (typeof(q.onerror) == \"function\")\n                 q.onerror(exception);\n\n            return q.reject(exception);\n        }\n    }\n```\n. Thanks for the reply @kriskowal, however this is not working.  I am using Q in nodejs.  Neither my onerror nor the uncaughtException event of the process object are being triggered.  Here is some code, I'm sure I must be doing something wrong.\n\n``` javascript\nq.onerror = function() {\n    console.log(arguments);\n};\n\nprocess.on('uncaughtException', function(err) {\n    console.log('Caught exception: ' + err);\n});\n```\n\nAnd here, I'm creating a deferred and triggering an error within the then callback:\n\n``` javascript\nrouter.all(\"/owned\", function(req, res) {\n    var deferred = q.defer();\n\n    deferred.promise.then(function() {\n        throw new Error(\"OH NO!\");\n    });\n\n    deferred.resolve();\n    res.jsonp({ test: \"test\" });\n});\n```\n\nAs you can see I'm using \"express\".  I'm not sure if this is interfering in any way.\n\nIf I modify the Promise.then function, I can get the result I expect:\n\n``` javascript\nfunction _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            // my change, trigger the global error handler\n            if (typeof(q.onerror) == \"function\")\n                 q.onerror(exception);\n\n            return q.reject(exception);\n        }\n    }\n```\n. ",
    "heymatthew": "You're right. Apologies, I got lost in something a bit more complex and missed that point.\n\nIt'd be nice to allow for a q.all that explodes if you pass it more than one argument, or let it handle variable number of args as well-- but that's a feature request, and not a bug.\n. You're right. Apologies, I got lost in something a bit more complex and missed that point.\n\nIt'd be nice to allow for a q.all that explodes if you pass it more than one argument, or let it handle variable number of args as well-- but that's a feature request, and not a bug.\n. ",
    "netpoetica": "What is the source code/definition of this function?\n\n```\nself.$Model.Player.findByIdQ\n```\n. Yes, see here: https://github.com/kriskowal/q#getting-started\n\n\"Can be used with a script tag...\"\n\nIf you're interested in using in clientside, try using component or bower. There's also a guide for people who are familiar with jQuery promises [here](https://github.com/kriskowal/q/wiki/Coming-from-jQuery).\n\nYou may want to look into [q-xhr](https://github.com/nathanboktae/q-xhr) as well which is a cute little bundle that lets you work with XHR in the browser in a combination of the way Q and Angulars $http resource operate.\n. What is the source code/definition of this function?\n\n```\nself.$Model.Player.findByIdQ\n```\n. Yes, see here: https://github.com/kriskowal/q#getting-started\n\n\"Can be used with a script tag...\"\n\nIf you're interested in using in clientside, try using component or bower. There's also a guide for people who are familiar with jQuery promises [here](https://github.com/kriskowal/q/wiki/Coming-from-jQuery).\n\nYou may want to look into [q-xhr](https://github.com/nathanboktae/q-xhr) as well which is a cute little bundle that lets you work with XHR in the browser in a combination of the way Q and Angulars $http resource operate.\n. ",
    "zj8487": "hi netpoetica, \nthank you for your response.\nPlayer is a model. findByIdQ is from mongoose-q which is a lib make mongoose API to return Q promise.\n\nand i test for bluebird for the testcase and it passed.\n\nthe only change is as follow:\n\n``` javascript\nvar Promise = require(\"bluebird\");\nQ.async(function* () ----------> Promise.coroutine(function* ()\n```\n. hi netpoetica, \nthank you for your response.\nPlayer is a model. findByIdQ is from mongoose-q which is a lib make mongoose API to return Q promise.\n\nand i test for bluebird for the testcase and it passed.\n\nthe only change is as follow:\n\n``` javascript\nvar Promise = require(\"bluebird\");\nQ.async(function* () ----------> Promise.coroutine(function* ()\n```\n. ",
    "slorber": "Thanks @kriskowal , yes it does the job well. Sorry I didn't know this method\n. @kriskowal as mentionned in the linked issue I got a problem with this too.\nIn case of some error, Q completely stops working, producing important problems in production (SPA needing F5 refresh, as not a single promise can resolve anymore)\n\n@dominataa is right, the problem seems to be related to the synchronous exception rethrow in case of isNodeJs = true, in case of a Browserify context.\n\nThis would be nice to be able to disable the \"fail fast flushing behavior\" used for NodeJS (`In node, uncaught exceptions are considered fatal errors. Re-throw them synchronously to interrupt flushing!`).\n. This problem appeared between releases Browserify 8.0.3 and 8.1.0. Q works fine with older versions of Browserify\n. I've made a PR for node-process/browserify that solves this problem.\nSee https://github.com/defunctzombie/node-process/pull/37\n. I have added the following test:\n\n``` javascript\nfunction testQ() {\n    console.debug(\"testQ\");\n    Q.promise(function(resolve) {\n        resolve(\"test\");\n    }).then(function(res) {\n        console.debug(\"testQ success!\",res);\n    });\n}\n\nsetInterval(function() {\n    testQ();\n},1000);\n```\n\nCheck yourself the behavior around the error I get:\n\n``` javascript\ntestQ qUtils.js:11\ntestQ success! test qUtils.js:15\ntestQ qUtils.js:11\ntestQ success! test qUtils.js:15\ntestQ qUtils.js:11\ntestQ success! test qUtils.js:15\ntestQ qUtils.js:11\ntestQ success! test qUtils.js:15\nREQ Object {method: \"GET\", url: \"http://localhost:9000/timeline/stamples/count\", data: Object, dataType: \"json\", contentType: \"application/json\"} qUtils.js:25\nGET http://localhost:9000/timeline/stamples/count?lastEventAfterDate=1426848481\u2026D=550694d68d9400b97b04bd34&exceptStampleIds%5B%5D=5505c3b18d9400b97b04bbda net::ERR_CONNECTION_RESET jquery.js:8625\nthen error Object {method: \"GET\", url: \"http://localhost:9000/timeline/stamples/count\", data: Object, dataType: \"json\", contentType: \"application/json\"} Object {readyState: 0, getResponseHeader: function, getAllResponseHeaders: function, setRequestHeader: function, overrideMimeType: function\u2026} qUtils.js:35\nRES Object {readyState: 0, getResponseHeader: function, getAllResponseHeaders: function, setRequestHeader: function, overrideMimeType: function\u2026} qUtils.js:43\nUnexpected ApiRequest response Object {readyState: 0, getResponseHeader: function, getAllResponseHeaders: function, setRequestHeader: function, overrideMimeType: function\u2026} apiResponseUtils.js:21\nUncaught Error: Unexpected ApiRequest response apiResponseUtils.js:22\ntestQ qUtils.js:11\ntestQ qUtils.js:11\ntestQ qUtils.js:11\ntestQ qUtils.js:11\ntestQ qUtils.js:11\ntestQ qUtils.js:11\n```\n\nAs you can see, it seems my error messes up with Q internals and then Q can't resolve any promise :(\n. I tried with an implementation based on deferred and it did not work better:\n\n``` javascript\nexports.Qajax = function(ajaxOptions) {\n    var deferred = Q.defer();\n    try {\n        $.ajax(ajaxOptions)\n            .then(function (data, textStatus, jqXHR) {\n                delete jqXHR.then; // treat xhr as a non-promise\n                deferred.resolve(jqXHR);\n                console.error(\"then success\",ajaxOptions,jqXHR);\n            }, function (jqXHR, textStatus, errorThrown) {\n                delete jqXHR.then; // treat xhr as a non-promise\n                deferred.resolve(jqXHR);\n                console.error(\"then error\",ajaxOptions,jqXHR);\n            });\n    } catch (e) {\n        console.error(\"Could not issue ajax request\",e);\n        deferred.reject(e);\n    }\n    return deferred.promise.then(function(res) {\n        console.error(\"RES\",res);\n        return res;\n    });\n};\n```\n\nI also tried, in `handleApiJsonResponse`, to not throw an exception but instead to return a bad result, and it fixed the problem. \n\nSo it seems throwing an exception in a `then` callback can mess up with Q. This is not expected, according to the documentation `If you throw an exception in a handler, outputPromise will get rejected.`\n\nI tried to replace the exception thrown synchronously in the handler by a failed promise, and it also fails. \n\nSee my 3 attemps here, only returning an invalid result will lead to Q continue working:\n\n``` javascript\nfunction handleApiJsonResponse($ajaxResponse) {\n    if ( $ajaxResponse.status == 200 &&  Preconditions.hasValue($ajaxResponse.responseJSON) && Preconditions.hasValue($ajaxResponse.responseJSON.response) ) {\n        var json = $ajaxResponse.responseJSON;\n        if ( json.request && json.request.success ) {\n            DeepFreeze(json.response); // Yes We make the result immutable before returning it\n            return json.response;\n        }\n        else {\n            var error = new Error(json.response);\n            error.stampleErrorCode = json.request.errorCode;\n            throw error;\n        }\n    }\n    else {\n        console.error(\"Unexpected ApiRequest response\",$ajaxResponse);\n        //throw new Error(\"Unexpected ApiRequest response\");\n\n        return Q.fcall(function () {\n            throw new Error(\"Can't do it\");\n        });\n\n        // return \"Unexpected ApiRequest response\";\n    }\n}\n```\n\nI have no idea what is happening. I could not reproduce this in a sandbox. I tried to disable longStackSupport with no effect.\n. Note that I use Browserify, so it may be related to this issue:\nhttps://github.com/kriskowal/q/issues/645\n\nI saw that isNodeJS = true in Q.nextTick\n\nI modified Q locally and forced the use of:\n\n``` javascript\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n```\n\nand it works fine now! Q is not broken anymore.\n\nSo I think this is an issue that only happens when used with Browserify and related to usage of nextTick\n. Closing as this is a problem in nextTick shim of Browserify.\nSee PR: https://github.com/defunctzombie/node-process/pull/37\n. Thanks @kriskowal , yes it does the job well. Sorry I didn't know this method\n. @kriskowal as mentionned in the linked issue I got a problem with this too.\nIn case of some error, Q completely stops working, producing important problems in production (SPA needing F5 refresh, as not a single promise can resolve anymore)\n\n@dominataa is right, the problem seems to be related to the synchronous exception rethrow in case of isNodeJs = true, in case of a Browserify context.\n\nThis would be nice to be able to disable the \"fail fast flushing behavior\" used for NodeJS (`In node, uncaught exceptions are considered fatal errors. Re-throw them synchronously to interrupt flushing!`).\n. This problem appeared between releases Browserify 8.0.3 and 8.1.0. Q works fine with older versions of Browserify\n. I've made a PR for node-process/browserify that solves this problem.\nSee https://github.com/defunctzombie/node-process/pull/37\n. I have added the following test:\n\n``` javascript\nfunction testQ() {\n    console.debug(\"testQ\");\n    Q.promise(function(resolve) {\n        resolve(\"test\");\n    }).then(function(res) {\n        console.debug(\"testQ success!\",res);\n    });\n}\n\nsetInterval(function() {\n    testQ();\n},1000);\n```\n\nCheck yourself the behavior around the error I get:\n\n``` javascript\ntestQ qUtils.js:11\ntestQ success! test qUtils.js:15\ntestQ qUtils.js:11\ntestQ success! test qUtils.js:15\ntestQ qUtils.js:11\ntestQ success! test qUtils.js:15\ntestQ qUtils.js:11\ntestQ success! test qUtils.js:15\nREQ Object {method: \"GET\", url: \"http://localhost:9000/timeline/stamples/count\", data: Object, dataType: \"json\", contentType: \"application/json\"} qUtils.js:25\nGET http://localhost:9000/timeline/stamples/count?lastEventAfterDate=1426848481\u2026D=550694d68d9400b97b04bd34&exceptStampleIds%5B%5D=5505c3b18d9400b97b04bbda net::ERR_CONNECTION_RESET jquery.js:8625\nthen error Object {method: \"GET\", url: \"http://localhost:9000/timeline/stamples/count\", data: Object, dataType: \"json\", contentType: \"application/json\"} Object {readyState: 0, getResponseHeader: function, getAllResponseHeaders: function, setRequestHeader: function, overrideMimeType: function\u2026} qUtils.js:35\nRES Object {readyState: 0, getResponseHeader: function, getAllResponseHeaders: function, setRequestHeader: function, overrideMimeType: function\u2026} qUtils.js:43\nUnexpected ApiRequest response Object {readyState: 0, getResponseHeader: function, getAllResponseHeaders: function, setRequestHeader: function, overrideMimeType: function\u2026} apiResponseUtils.js:21\nUncaught Error: Unexpected ApiRequest response apiResponseUtils.js:22\ntestQ qUtils.js:11\ntestQ qUtils.js:11\ntestQ qUtils.js:11\ntestQ qUtils.js:11\ntestQ qUtils.js:11\ntestQ qUtils.js:11\n```\n\nAs you can see, it seems my error messes up with Q internals and then Q can't resolve any promise :(\n. I tried with an implementation based on deferred and it did not work better:\n\n``` javascript\nexports.Qajax = function(ajaxOptions) {\n    var deferred = Q.defer();\n    try {\n        $.ajax(ajaxOptions)\n            .then(function (data, textStatus, jqXHR) {\n                delete jqXHR.then; // treat xhr as a non-promise\n                deferred.resolve(jqXHR);\n                console.error(\"then success\",ajaxOptions,jqXHR);\n            }, function (jqXHR, textStatus, errorThrown) {\n                delete jqXHR.then; // treat xhr as a non-promise\n                deferred.resolve(jqXHR);\n                console.error(\"then error\",ajaxOptions,jqXHR);\n            });\n    } catch (e) {\n        console.error(\"Could not issue ajax request\",e);\n        deferred.reject(e);\n    }\n    return deferred.promise.then(function(res) {\n        console.error(\"RES\",res);\n        return res;\n    });\n};\n```\n\nI also tried, in `handleApiJsonResponse`, to not throw an exception but instead to return a bad result, and it fixed the problem. \n\nSo it seems throwing an exception in a `then` callback can mess up with Q. This is not expected, according to the documentation `If you throw an exception in a handler, outputPromise will get rejected.`\n\nI tried to replace the exception thrown synchronously in the handler by a failed promise, and it also fails. \n\nSee my 3 attemps here, only returning an invalid result will lead to Q continue working:\n\n``` javascript\nfunction handleApiJsonResponse($ajaxResponse) {\n    if ( $ajaxResponse.status == 200 &&  Preconditions.hasValue($ajaxResponse.responseJSON) && Preconditions.hasValue($ajaxResponse.responseJSON.response) ) {\n        var json = $ajaxResponse.responseJSON;\n        if ( json.request && json.request.success ) {\n            DeepFreeze(json.response); // Yes We make the result immutable before returning it\n            return json.response;\n        }\n        else {\n            var error = new Error(json.response);\n            error.stampleErrorCode = json.request.errorCode;\n            throw error;\n        }\n    }\n    else {\n        console.error(\"Unexpected ApiRequest response\",$ajaxResponse);\n        //throw new Error(\"Unexpected ApiRequest response\");\n\n        return Q.fcall(function () {\n            throw new Error(\"Can't do it\");\n        });\n\n        // return \"Unexpected ApiRequest response\";\n    }\n}\n```\n\nI have no idea what is happening. I could not reproduce this in a sandbox. I tried to disable longStackSupport with no effect.\n. Note that I use Browserify, so it may be related to this issue:\nhttps://github.com/kriskowal/q/issues/645\n\nI saw that isNodeJS = true in Q.nextTick\n\nI modified Q locally and forced the use of:\n\n``` javascript\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n```\n\nand it works fine now! Q is not broken anymore.\n\nSo I think this is an issue that only happens when used with Browserify and related to usage of nextTick\n. Closing as this is a problem in nextTick shim of Browserify.\nSee PR: https://github.com/defunctzombie/node-process/pull/37\n. ",
    "darkwing": "Wanted to ping in on this :)  Any progress or new thoughts?\n\n@cadorn What file did you add `setTimeout` to?  q.js is a dependency of another npm module and adding setTimeout just about everywhere within my codebase results in no improvement. :(\n. Wanted to ping in on this :)  Any progress or new thoughts?\n\n@cadorn What file did you add `setTimeout` to?  q.js is a dependency of another npm module and adding setTimeout just about everywhere within my codebase results in no improvement. :(\n. ",
    "getify": "`Promise.race([ .. ])` returns a promise for the first **resolved** (fulfillment or rejection) promise in the list. IOW, the behavior sounds correct and the docs need to change. :)\n. `Promise.race([ .. ])` returns a promise for the first **resolved** (fulfillment or rejection) promise in the list. IOW, the behavior sounds correct and the docs need to change. :)\n. ",
    "vilic": "hope you will. ;)\n. The file systems of Windows and OS X (by default) are not case sensitive, I don't see why this is unexpected.\n. @girishsortur Actually this has nothing to do with Q, if you would want more context, please refer to Node.js issues like https://github.com/nodejs/node-v0.x-archive/issues/6000\n. A good practice of using Promise is that: let error throw.\n. @pedro93  If an error occurs in a chain is fatal, you should not simply handle it with log. Instead, it's better to throw it out (that's when you really want to log it down, otherwise, just let itself pass through the promise chain to the end).\n\nI would suggest a centralized error handling, near the end of everything. For example, for a web application, the (fatal) error should be passed through and finally be handled only a little before rendered on the view.\n. hope you will. ;)\n. The file systems of Windows and OS X (by default) are not case sensitive, I don't see why this is unexpected.\n. @girishsortur Actually this has nothing to do with Q, if you would want more context, please refer to Node.js issues like https://github.com/nodejs/node-v0.x-archive/issues/6000\n. A good practice of using Promise is that: let error throw.\n. @pedro93  If an error occurs in a chain is fatal, you should not simply handle it with log. Instead, it's better to throw it out (that's when you really want to log it down, otherwise, just let itself pass through the promise chain to the end).\n\nI would suggest a centralized error handling, near the end of everything. For example, for a web application, the (fatal) error should be passed through and finally be handled only a little before rendered on the view.\n. ",
    "Orion98MC": "Hi Kris, \n\nThanks for your time. Packing stuff ... I've done that a bunch of times, it's very depressing, so I wish your wife and you good luck!\n\nThe reason I was looking for a way to manage this problem with Q is that promises are a great way to build dependency chains. As far as I understand the problem it would be nearly impossible to do this with observables. \n\nWhat I am trying to achieve is that a dependency chain could be marked as needing a completion function to be executed when all dependencies attached to _this_ chain are completed. You can create other dependency chains from within the chain, but if you want them to be accounted you need to bind them to the former chain or else they will continue to live their lives outside the context of the completion chain.\n\nThe promise.fin() method was nearly what I needed, but it creates a new promise so the problem was to keep track of the tail of the chain and attach a .fin() to it. But since the chain may be growing with other then-s the .fin() would have to check if it is indeed the tail of the chain.\n\nSo I managed to put that in a little Q add-on which I named QChain. The QChain is created with a starting promise and then-s are enqueued by calling the QChain.then() which records the tail of the chain. Now If someone attaches a _last_ callback to the Qchain with QChain.last(), it calls in fact a .fin() on the tail promise.\n\nI'd like to add I am not a Promise expert, so forgive me if this defeats the Promise protocols.\n\n``` js\nvar Q = require('q');\n\nfunction qchain(promise, last_fn) {\n  return new QChain(promise, last_fn);\n}\n\nfunction QChain(promise, last_fn) {\n  this.promise = promise || Q.when(true);\n  if (last_fn) this.last(last_fn);\n  return this;\n}\n\nQChain.prototype.then = function () {\n  this.promise = this.promise.then.apply(this.promise, arguments);\n  return this;\n};\n\nQChain.prototype.fail = function () {\n  this.promise = this.promise.fail.apply(this.promise, arguments);\n  return this;  \n};\n\nQChain.prototype.last = function (fn) {\n  var self = this;\n  this._last = fn;\n\n  // Leave a chance to enqueue then-s, see you on next tick.\n  process.nextTick(function tryLast() {\n    var promise = self.promise; // Record the current tail\n    var last = self.promise.finally(function () {\n      if (self.promise === last) { // We are indeed the last added promise\n        self._last.call(promise);\n      } else {\n        console.log('Wrong last, retrying...');\n        tryLast();\n      }\n    });\n    self.promise = last; // Set ourselves as the tail\n  });\n  return this;\n};\n\nmodule.exports = qchain;\n```\n\nIt seems to work ... \n\nExample:\n\n```\n$ node\n>  var QChain = require('qchain');var Q = require('q')\n> var chain = QChain().last(function(){ console.log(this.inspect()); })\n   .then(function(){ return Q.delay('A', 1000)})\n   .then(function (a) { \n      console.log('A:',a); \n      chain.then(function(){ return Q.delay('B', 1000)}); \n      return a; \n   }).then(function (b){ console.log('B:',b); })\n\nundefined\n> A: A\nB: A\nWrong last, retrying...\n{ state: 'fulfilled', value: 'B' }\n```\n\nThe _Wrong last_ message is just there to prove the QChain does a good job.\n\nSo, with this little trick, I could render my templates and attach a last function to the rendering (promise) chain so that when the last render is done, the rendered data is flushed to the network. \nWell, at least it seems to work... but you never know...\n\nRegards,\nThierry\n. Hi Kris, \n\nThanks for your time. Packing stuff ... I've done that a bunch of times, it's very depressing, so I wish your wife and you good luck!\n\nThe reason I was looking for a way to manage this problem with Q is that promises are a great way to build dependency chains. As far as I understand the problem it would be nearly impossible to do this with observables. \n\nWhat I am trying to achieve is that a dependency chain could be marked as needing a completion function to be executed when all dependencies attached to _this_ chain are completed. You can create other dependency chains from within the chain, but if you want them to be accounted you need to bind them to the former chain or else they will continue to live their lives outside the context of the completion chain.\n\nThe promise.fin() method was nearly what I needed, but it creates a new promise so the problem was to keep track of the tail of the chain and attach a .fin() to it. But since the chain may be growing with other then-s the .fin() would have to check if it is indeed the tail of the chain.\n\nSo I managed to put that in a little Q add-on which I named QChain. The QChain is created with a starting promise and then-s are enqueued by calling the QChain.then() which records the tail of the chain. Now If someone attaches a _last_ callback to the Qchain with QChain.last(), it calls in fact a .fin() on the tail promise.\n\nI'd like to add I am not a Promise expert, so forgive me if this defeats the Promise protocols.\n\n``` js\nvar Q = require('q');\n\nfunction qchain(promise, last_fn) {\n  return new QChain(promise, last_fn);\n}\n\nfunction QChain(promise, last_fn) {\n  this.promise = promise || Q.when(true);\n  if (last_fn) this.last(last_fn);\n  return this;\n}\n\nQChain.prototype.then = function () {\n  this.promise = this.promise.then.apply(this.promise, arguments);\n  return this;\n};\n\nQChain.prototype.fail = function () {\n  this.promise = this.promise.fail.apply(this.promise, arguments);\n  return this;  \n};\n\nQChain.prototype.last = function (fn) {\n  var self = this;\n  this._last = fn;\n\n  // Leave a chance to enqueue then-s, see you on next tick.\n  process.nextTick(function tryLast() {\n    var promise = self.promise; // Record the current tail\n    var last = self.promise.finally(function () {\n      if (self.promise === last) { // We are indeed the last added promise\n        self._last.call(promise);\n      } else {\n        console.log('Wrong last, retrying...');\n        tryLast();\n      }\n    });\n    self.promise = last; // Set ourselves as the tail\n  });\n  return this;\n};\n\nmodule.exports = qchain;\n```\n\nIt seems to work ... \n\nExample:\n\n```\n$ node\n>  var QChain = require('qchain');var Q = require('q')\n> var chain = QChain().last(function(){ console.log(this.inspect()); })\n   .then(function(){ return Q.delay('A', 1000)})\n   .then(function (a) { \n      console.log('A:',a); \n      chain.then(function(){ return Q.delay('B', 1000)}); \n      return a; \n   }).then(function (b){ console.log('B:',b); })\n\nundefined\n> A: A\nB: A\nWrong last, retrying...\n{ state: 'fulfilled', value: 'B' }\n```\n\nThe _Wrong last_ message is just there to prove the QChain does a good job.\n\nSo, with this little trick, I could render my templates and attach a last function to the rendering (promise) chain so that when the last render is done, the rendered data is flushed to the network. \nWell, at least it seems to work... but you never know...\n\nRegards,\nThierry\n. ",
    "pulakb": "@kitcambridge you are correct but if you go to the URL of the wiki mentioned above and the section specified, where it is saying you can \"return result\" too.\n\nThat is the reason I have the confusion.\n. @kitcambridge thanks a lot, it is working and i have updated my gist accordingly.\n. @kitcambridge you are correct but if you go to the URL of the wiki mentioned above and the section specified, where it is saying you can \"return result\" too.\n\nThat is the reason I have the confusion.\n. @kitcambridge thanks a lot, it is working and i have updated my gist accordingly.\n. ",
    "franksrevenge": "Hi @domenic,\n\nYes, assuming that you are dealing with a single function scope, using function context would be useful. But with a larger codebase, functions that produce subchains are likely spread across multiple modules and have no way for sharing context, and may even be relying on their own local context to start with.\n. @domenic Here's an improved example of what I'm trying to solve. Assume that each module is its own independent unit and _not aware of each other_.\n\n``` javascript\n// ---------- module 1\n\nvar ClassA = function () {};\n\nClassA.prototype.getPromiseChain = function () {\n    return function() {\n        return Q(10).local(function (localData) {\n            localData.testVariable = 'Hello world';\n        });\n    };\n};\n\n\n// ---------- module 2\n\nvar ClassB = function () {};\n\nClassB.prototype.getPromiseChain = function() {\n    return function() {\n        return Q(10).local(function (localData ) {\n            console.log(localData.testVariable);\n        });\n    };\n};\n\n\n// ---------- module 3\n\n/* (I'm simplifying here. It's entirely possible that centralized point \n * like this never exists, so injecting contextual data to each object\n * wouldn't solve the problem */\n\nvar a = new ClassA(),\n    b = new ClassB();\n\nQ(10).then(a.getPromiseChain()).then(b.getPromiseChain());\n```\n. Hi @domenic,\n\nYes, assuming that you are dealing with a single function scope, using function context would be useful. But with a larger codebase, functions that produce subchains are likely spread across multiple modules and have no way for sharing context, and may even be relying on their own local context to start with.\n. @domenic Here's an improved example of what I'm trying to solve. Assume that each module is its own independent unit and _not aware of each other_.\n\n``` javascript\n// ---------- module 1\n\nvar ClassA = function () {};\n\nClassA.prototype.getPromiseChain = function () {\n    return function() {\n        return Q(10).local(function (localData) {\n            localData.testVariable = 'Hello world';\n        });\n    };\n};\n\n\n// ---------- module 2\n\nvar ClassB = function () {};\n\nClassB.prototype.getPromiseChain = function() {\n    return function() {\n        return Q(10).local(function (localData ) {\n            console.log(localData.testVariable);\n        });\n    };\n};\n\n\n// ---------- module 3\n\n/* (I'm simplifying here. It's entirely possible that centralized point \n * like this never exists, so injecting contextual data to each object\n * wouldn't solve the problem */\n\nvar a = new ClassA(),\n    b = new ClassB();\n\nQ(10).then(a.getPromiseChain()).then(b.getPromiseChain());\n```\n. ",
    "ExplodingCabbage": "Looks like you did this, @kriskowal, in https://github.com/kriskowal/q/commit/6d81e4c629332227d1d0302c0b266f500b585f39 (although interestingly, for whatever reason, you didn't follow through on your own thought that it'd be good to include a truthiness check on `module`). I think this pull request can be closed?\n. Looks like you did this, @kriskowal, in https://github.com/kriskowal/q/commit/6d81e4c629332227d1d0302c0b266f500b585f39 (although interestingly, for whatever reason, you didn't follow through on your own thought that it'd be good to include a truthiness check on `module`). I think this pull request can be closed?\n. ",
    "ajainarayanan": "My Bad. Had file path wrong and didn't specify the format to read the file. Seems pretty lame. Sorry about that. Closing the issue. \n. However the above `readfile`  implementation is causing the then handler to be executed twice. Not sure if this is a bug of Q or the implementation. \n. My Bad. Had file path wrong and didn't specify the format to read the file. Seems pretty lame. Sorry about that. Closing the issue. \n. However the above `readfile`  implementation is causing the then handler to be executed twice. Not sure if this is a bug of Q or the implementation. \n. ",
    "kahnvex": "Are you calling `.done()` as the last operation? If so this is intended behavior. Check [this](https://jsfiddle.net/qj8zj8r2/1/) fiddle and look at the dev console.\n. Not sure if this should be against `1.0.0` line or `2.0.0`?\n. No worries @kriskowal, we have a bunch of these little utility functions, putting them in `.then` is fine for us. Just wanted to see if you'd be interested. Also, contributing this didn't take long, so don't feel bad.\n. This is likely due to changes to Nodejs or v8 and nothing to do with Q. I noted a pretty big performance loss for some compute intensive tasks (without Q) after upgrading my machine to 0.12. I didn't have time to look into it further to figure out what exactly was different. I'm also on OSX.\n. @kriskowal done.\n. Will do. I probably won't have time to update until tomorrow anyway.\n. > mid May\n\nWhops, misread this as \"mid day.\" Got it.\n\nI've updated the pull.\n. Are you calling `.done()` as the last operation? If so this is intended behavior. Check [this](https://jsfiddle.net/qj8zj8r2/1/) fiddle and look at the dev console.\n. Not sure if this should be against `1.0.0` line or `2.0.0`?\n. No worries @kriskowal, we have a bunch of these little utility functions, putting them in `.then` is fine for us. Just wanted to see if you'd be interested. Also, contributing this didn't take long, so don't feel bad.\n. This is likely due to changes to Nodejs or v8 and nothing to do with Q. I noted a pretty big performance loss for some compute intensive tasks (without Q) after upgrading my machine to 0.12. I didn't have time to look into it further to figure out what exactly was different. I'm also on OSX.\n. @kriskowal done.\n. Will do. I probably won't have time to update until tomorrow anyway.\n. > mid May\n\nWhops, misread this as \"mid day.\" Got it.\n\nI've updated the pull.\n. ",
    "aramk": "While we can call `Q.getUnhandledReasons()` at any time, I've added https://github.com/aramk/q/commit/2f0413498eadbc37faeba7d402d4325c4b3e7710 to log once it's determined that a rejected promise has not been handled.\n. @jcalfee I'm not entirely sure this is necessary anymore since discovering you actually need to call `.done()` after any `.then()` or `.fin()` calls to ensure exceptions are thrown - since you're making it clear no other callbacks will be used later in the code. It's an extra step but it's official way it seems.\n. Thanks @kriskowal for the detailed justification. \n. Thanks @domenic that works great. My question was whether it's possible to reduce the need for using .then() each time and just linking the result of one promise to another.\n. Yeah that was just an example. My main confusion was whether I could bind the outcome of one promise to that of another, and `df.resolve(test())` does exactly that. Thanks, this will cleanup a lot of code!\n. While we can call `Q.getUnhandledReasons()` at any time, I've added https://github.com/aramk/q/commit/2f0413498eadbc37faeba7d402d4325c4b3e7710 to log once it's determined that a rejected promise has not been handled.\n. @jcalfee I'm not entirely sure this is necessary anymore since discovering you actually need to call `.done()` after any `.then()` or `.fin()` calls to ensure exceptions are thrown - since you're making it clear no other callbacks will be used later in the code. It's an extra step but it's official way it seems.\n. Thanks @kriskowal for the detailed justification. \n. Thanks @domenic that works great. My question was whether it's possible to reduce the need for using .then() each time and just linking the result of one promise to another.\n. Yeah that was just an example. My main confusion was whether I could bind the outcome of one promise to that of another, and `df.resolve(test())` does exactly that. Thanks, this will cleanup a lot of code!\n. ",
    "jcalfee": "This is critical in my app.  It is getting to be very painful to grow the code base when there are hidden exceptions.  This is crippling my time by not being able to see these hidden errors.  I do not always have a clear point there I can call \"done\"...   I'm ready to patch the code, anything.  I just need it to log it, it does not have to change the flow of control.\n. Thanks for the patch!\n. I'm sure I will grow to love this architecture.  I would still suggest that a safeguard here is clearly needed to make the library a bit more friendly.  This is not a solution for us but perhaps a good example: In Java if an exception goes uncatched it makes it out of the `main` method.  The JVM does not ignore it, it gets logged.  Since this is standard, it is a very normal thing (good practice) to rely on that behaviour to report fatal exceptions that require user or programmer intervention.\n\nIn our case, it sounds like if one does not use `done` it is clearly an error so this should not be necessary.  By that logic though, compilers should not contain errors and programmers should just write the code without any errors the first time..\n. q.js work-around, add console.error(...):\n\n```\nfunction reject(reason) {\n...\n    console.error('[Q] Unhandled promise rejection:', reason && reason.hasOwnProperty('stack') ? reason.stack : reason);\n    return rejection;\n}\n```\n. This is critical in my app.  It is getting to be very painful to grow the code base when there are hidden exceptions.  This is crippling my time by not being able to see these hidden errors.  I do not always have a clear point there I can call \"done\"...   I'm ready to patch the code, anything.  I just need it to log it, it does not have to change the flow of control.\n. Thanks for the patch!\n. I'm sure I will grow to love this architecture.  I would still suggest that a safeguard here is clearly needed to make the library a bit more friendly.  This is not a solution for us but perhaps a good example: In Java if an exception goes uncatched it makes it out of the `main` method.  The JVM does not ignore it, it gets logged.  Since this is standard, it is a very normal thing (good practice) to rely on that behaviour to report fatal exceptions that require user or programmer intervention.\n\nIn our case, it sounds like if one does not use `done` it is clearly an error so this should not be necessary.  By that logic though, compilers should not contain errors and programmers should just write the code without any errors the first time..\n. q.js work-around, add console.error(...):\n\n```\nfunction reject(reason) {\n...\n    console.error('[Q] Unhandled promise rejection:', reason && reason.hasOwnProperty('stack') ? reason.stack : reason);\n    return rejection;\n}\n```\n. ",
    "NoxHarmonium": "This is happening to me, but only if I define a custom exception and create a custom getter for stack.\n\n``` javascript\n var util = require('util');\n\n  function InvalidQueryParams(message, params) {\n\n    var childError = Error(message);\n    this.name = this.constructor.name;\n    this.message = message;\n    if (params) {\n      if (Array.isArray(params)) {\n        this.params = params;\n      } else {\n        this.params = [params];\n      }\n    }\n\n    Object.defineProperty(this, 'stack', {\n      get: function () {\n        return childError.stack;\n      }\n    });\n\n    return this;\n  }\n\n  util.inherits(InvalidQueryParams, Error);\n\n  module.exports = InvalidQueryParams;\n```\n\nI know that creating a custom stack getter in an exception is a bit of an edge case but it might be a clue.\n\nI have extracted out the relevant code and you can see the problem in action here: http://jsfiddle.net/8v7qnrq8/2/\n. This is happening to me, but only if I define a custom exception and create a custom getter for stack.\n\n``` javascript\n var util = require('util');\n\n  function InvalidQueryParams(message, params) {\n\n    var childError = Error(message);\n    this.name = this.constructor.name;\n    this.message = message;\n    if (params) {\n      if (Array.isArray(params)) {\n        this.params = params;\n      } else {\n        this.params = [params];\n      }\n    }\n\n    Object.defineProperty(this, 'stack', {\n      get: function () {\n        return childError.stack;\n      }\n    });\n\n    return this;\n  }\n\n  util.inherits(InvalidQueryParams, Error);\n\n  module.exports = InvalidQueryParams;\n```\n\nI know that creating a custom stack getter in an exception is a bit of an edge case but it might be a clue.\n\nI have extracted out the relevant code and you can see the problem in action here: http://jsfiddle.net/8v7qnrq8/2/\n. ",
    "unional": "@sth , which environment (besides phantomjs) where `Error.stack` is not writable?\n. @sth , which environment (besides phantomjs) where `Error.stack` is not writable?\n. ",
    "taudep": "I think you need to finish your Q chain off with a call to .done() ?     From the docs: \"Ending a promise chain makes sure that, if an error doesn\u2019t get handled before the end, it will get rethrown and reported.\"\n. I think you need to finish your Q chain off with a call to .done() ?     From the docs: \"Ending a promise chain makes sure that, if an error doesn\u2019t get handled before the end, it will get rethrown and reported.\"\n. ",
    "suprMax": "I see. That's really confusing. I have a global app-wide exception handler and these errors never reach it. Why would you want to make an extra effort to capture errors like that? IMO it's totally cool if `.catch` only gets called on rejected promises, and errors just throw whatever and blow up the process.\n. Yes, this is not the nicest way, but it works. Thanks!\n. I see. That's really confusing. I have a global app-wide exception handler and these errors never reach it. Why would you want to make an extra effort to capture errors like that? IMO it's totally cool if `.catch` only gets called on rejected promises, and errors just throw whatever and blow up the process.\n. Yes, this is not the nicest way, but it works. Thanks!\n. ",
    "fiznool": "I would consider an improvement to the method signature for `Q.Promise` to be:\n\n```\nQ.Promise(function(deferred) {} )\n```\n\nwhere `deferred` is the same object as returned from `Q.defer()`. But I guess this might break older code expecting the existing method signature.\n. I would consider an improvement to the method signature for `Q.Promise` to be:\n\n```\nQ.Promise(function(deferred) {} )\n```\n\nwhere `deferred` is the same object as returned from `Q.defer()`. But I guess this might break older code expecting the existing method signature.\n. ",
    "willtcarey": "I believe it is intended to be different based on the [API docs](https://github.com/kriskowal/q/wiki/API-Reference#qpromiseresolver).\n\nIt also more closely aligns with the promise concept coming in ES6\n. I believe it is intended to be different based on the [API docs](https://github.com/kriskowal/q/wiki/API-Reference#qpromiseresolver).\n\nIt also more closely aligns with the promise concept coming in ES6\n. ",
    "oliseviche": "Ok, comparing with to try-catch-finally pattern is clear.\nSo, for example, does something like this is correct?\n\n``` javascript\nshowLoader()\n.then(tryLoadServerData)\n.then(parseLoadServerData)\n.fail(showErrorMessage)\n.fin(hideLoader)\n.done()\n```\n\nI mean, according to documentation, we must call done() always at the end of the chain. Is example above considered valid according to promise pattern?\n. Great, Thanks!\n. Ok, comparing with to try-catch-finally pattern is clear.\nSo, for example, does something like this is correct?\n\n``` javascript\nshowLoader()\n.then(tryLoadServerData)\n.then(parseLoadServerData)\n.fail(showErrorMessage)\n.fin(hideLoader)\n.done()\n```\n\nI mean, according to documentation, we must call done() always at the end of the chain. Is example above considered valid according to promise pattern?\n. Great, Thanks!\n. ",
    "buildmaster": "whoops I'll reformat the code, sorry\n. whoops I'll reformat the code, sorry\n. ",
    "happylynx": "Sorry, my bad. Thank you guys for quick response.\n\nRESOLUTION: NOT A BUG\n. Sorry, my bad. Thank you guys for quick response.\n\nRESOLUTION: NOT A BUG\n. ",
    "ghost": "Yes. In the `function def` I have to invoke asynchronously a query to a database, that's why I used a defer. Should I use something else?\n. There is no memory leak. My mistake. Sorry\n. Yes. In the `function def` I have to invoke asynchronously a query to a database, that's why I used a defer. Should I use something else?\n. There is no memory leak. My mistake. Sorry\n. ",
    "dragosrususv": "@domenic : I am aware of current functionality. This is a feature proposal, not a bug.\n\nAs for your solution: how does that catch work in a success scenario?\n. I don't get it.\nYou just have a catch in between. Your last \"then\" from above will only cover the SUCCESS/RESOLVED case scenario. In case that promise will be rejected, the msgService will not be called. Please tell me I'm wrong. And please provide full code samples and not logical arrows.\n. Ok... and if the promise is resolved, am I forced to add that catch?\n. I'm not 100% sure of the differences between @kriskowal 's Q and AngularJS $q so this might be the root of this issue.\n\nIn your code you added just 1 method in the last \".then\" - there is no 2nd function added there. Do you confirm that method is called regardless of resolve/reject?\n. Ok. So what you are basically saying is that I MUST have a \"catch\", and then a \".then\" and stop using the \"finally\". I'll test and get back.\n\nStill, I am being forced to add a \"catch\" that I don't need as an empty function - the aim here is to reduce the lines of written code, not to add more...\n. :) You have your way with words.\nI understood what you tried to \"pixelcopy\" (so to say) the default mechanism, but you actually have another step in this flow, the THEN (not part of try-catch-finally) - this is the root of the idea of a promise I presume.\n\nAnd what you are doing is to insert this \"then\" everywhere in this flow. Fine with me if that works.\nBut with the use-case above, as a developer, I am forced to insert some lines of code in my app that I do not use to achieve my goal - with this, I do not agree. There should be a way to achieve this without this extra line (not saying today, but in future, for the sake of writing nice code).\n. @domenic : I can rewrite Q if I want. But that is not the goal here.\nThe goal and the main reason I insist is for other developers to be able to use a out-of-the-box library behavior - easy and with as less code as possible.\nOn my side I will probably go on with the catch solution (will get back if doesn't cover all cases). \n\nBut again, the point is to write clean code - everybody should have this freedom without hi-jacking existing libraries/frameworks and doing their own versions. Do you agree?\n. :) We'll just have to have a 3rd opinion I guess.\nI disagree with the idea of adding code that I do not use. Period. This is a hack that I wouldn't have found myself if I didn't had the opportunity to speak with you. But how about the rest? Do they have to dig into source code, understand their logic and find work-arounds?\n\nI still believe adding a parameter to the finally call is a good idea and it's also a good idea for the finally call to be called EVEN IF catch is not added - which happens today!!! I'm just saying: \"add a parameter, so I know how to handle my finally\"!\n. I totally respect your opinion. Still, you often think in a \"doing it for myself\" way, while I'm suggesting a more common approach - let others write clean code via general libraries - why not?\n\nAt this moment I don't have the background to evaluate your 2nd statement with parallel sync - you might just be right. And still, solutions can be found I'm sure. \n\nAnd no, your blog is not a reference so I haven't read that. I will.\n\nAnd as a final word: \"finally\" is called anyway - if you are so keen on having the \"try-catch-finally\" blocks, why are you calling the finally when no catch is there?\n. @domenic : So this would be once difference between this library Q and AngularJS. In AngularJS finally is ALWAYS called - even if there's no error and even if there's no catch.\n. @kriskowal : what's your opinion here, if the finally is called anyway, is there a real coomon-sense reason why that should not receive a parameter?\n\nAs per previous comments (and this will be my last), I do not agree with @domenic - I respect him from all points of view, but he's just keen on leaving as is, because it's easier. But it's NOT easier for people who use this library.\n. :) I rest my case.\n. @kriskowal : how about an extra \".always()\" that would have this parameter?\n(see http://api.jquery.com/deferred.always/ )\n\nI'm not keen on the name - it wast he only name I knew it would be called at the end, but that can be different.\n. @kriskowal : so in your opinion adding a fake \".catch(function () {})\" and another \".then(function (value) {})\" makes perfect sense to handle the case when parameter is needed in some method that should be called at the end? (finally/always/whatever)\n\nFor me, as previously stated to @domenic , that is just a work-around - nobody will document such a thing because it's hilarious.\n. @domenic : I am aware of current functionality. This is a feature proposal, not a bug.\n\nAs for your solution: how does that catch work in a success scenario?\n. I don't get it.\nYou just have a catch in between. Your last \"then\" from above will only cover the SUCCESS/RESOLVED case scenario. In case that promise will be rejected, the msgService will not be called. Please tell me I'm wrong. And please provide full code samples and not logical arrows.\n. Ok... and if the promise is resolved, am I forced to add that catch?\n. I'm not 100% sure of the differences between @kriskowal 's Q and AngularJS $q so this might be the root of this issue.\n\nIn your code you added just 1 method in the last \".then\" - there is no 2nd function added there. Do you confirm that method is called regardless of resolve/reject?\n. Ok. So what you are basically saying is that I MUST have a \"catch\", and then a \".then\" and stop using the \"finally\". I'll test and get back.\n\nStill, I am being forced to add a \"catch\" that I don't need as an empty function - the aim here is to reduce the lines of written code, not to add more...\n. :) You have your way with words.\nI understood what you tried to \"pixelcopy\" (so to say) the default mechanism, but you actually have another step in this flow, the THEN (not part of try-catch-finally) - this is the root of the idea of a promise I presume.\n\nAnd what you are doing is to insert this \"then\" everywhere in this flow. Fine with me if that works.\nBut with the use-case above, as a developer, I am forced to insert some lines of code in my app that I do not use to achieve my goal - with this, I do not agree. There should be a way to achieve this without this extra line (not saying today, but in future, for the sake of writing nice code).\n. @domenic : I can rewrite Q if I want. But that is not the goal here.\nThe goal and the main reason I insist is for other developers to be able to use a out-of-the-box library behavior - easy and with as less code as possible.\nOn my side I will probably go on with the catch solution (will get back if doesn't cover all cases). \n\nBut again, the point is to write clean code - everybody should have this freedom without hi-jacking existing libraries/frameworks and doing their own versions. Do you agree?\n. :) We'll just have to have a 3rd opinion I guess.\nI disagree with the idea of adding code that I do not use. Period. This is a hack that I wouldn't have found myself if I didn't had the opportunity to speak with you. But how about the rest? Do they have to dig into source code, understand their logic and find work-arounds?\n\nI still believe adding a parameter to the finally call is a good idea and it's also a good idea for the finally call to be called EVEN IF catch is not added - which happens today!!! I'm just saying: \"add a parameter, so I know how to handle my finally\"!\n. I totally respect your opinion. Still, you often think in a \"doing it for myself\" way, while I'm suggesting a more common approach - let others write clean code via general libraries - why not?\n\nAt this moment I don't have the background to evaluate your 2nd statement with parallel sync - you might just be right. And still, solutions can be found I'm sure. \n\nAnd no, your blog is not a reference so I haven't read that. I will.\n\nAnd as a final word: \"finally\" is called anyway - if you are so keen on having the \"try-catch-finally\" blocks, why are you calling the finally when no catch is there?\n. @domenic : So this would be once difference between this library Q and AngularJS. In AngularJS finally is ALWAYS called - even if there's no error and even if there's no catch.\n. @kriskowal : what's your opinion here, if the finally is called anyway, is there a real coomon-sense reason why that should not receive a parameter?\n\nAs per previous comments (and this will be my last), I do not agree with @domenic - I respect him from all points of view, but he's just keen on leaving as is, because it's easier. But it's NOT easier for people who use this library.\n. :) I rest my case.\n. @kriskowal : how about an extra \".always()\" that would have this parameter?\n(see http://api.jquery.com/deferred.always/ )\n\nI'm not keen on the name - it wast he only name I knew it would be called at the end, but that can be different.\n. @kriskowal : so in your opinion adding a fake \".catch(function () {})\" and another \".then(function (value) {})\" makes perfect sense to handle the case when parameter is needed in some method that should be called at the end? (finally/always/whatever)\n\nFor me, as previously stated to @domenic , that is just a work-around - nobody will document such a thing because it's hilarious.\n. ",
    "piepkrak": "Thank you for your feedback! \n. Thank you for your feedback! \n. ",
    "umarashfaq": "@arikon I'm hoping following code to work:\n\n``` javascript\nvar fs_exists = q.denodeify(fs.exists);\n\nfs_exists('/some/file/path')\n.then(function( exists ){\n    console.log('file exists: %s', exists);\n}, function( err ) {\n   console.log('An error occurred: %s', err);\n});\n```\n\nBut it doesn't really work the way I expected it to. I thought whether the file exists or not, control would flow into success callback, unless an error occurs, in which case, control would flow into failure callback. Which is not the case. Here is what happens:\n\nWhen the file exists, controls flows into error callback and when it doesn't exist, the success callback is invoked. To make it work, I have to do something like this:\n\n``` javascript\nvar fs_exists = q.denodeify(fs.exists);\n\nfs_exists('/some/file/path')\n.then(function( exists ){\n    console.log('file doesn\\'t exist');\n}, function( err ) {\n   console.log('file exists');\n});\n```\n\nLet me know if I'm missing something or if it is deliberate and not a flaw. Otherwise if you think behavior I proposed above (first of the two snippets) looks viable, I can send you a pull request.\n. @domenic Thanks for explanation.\n. @arikon I'm hoping following code to work:\n\n``` javascript\nvar fs_exists = q.denodeify(fs.exists);\n\nfs_exists('/some/file/path')\n.then(function( exists ){\n    console.log('file exists: %s', exists);\n}, function( err ) {\n   console.log('An error occurred: %s', err);\n});\n```\n\nBut it doesn't really work the way I expected it to. I thought whether the file exists or not, control would flow into success callback, unless an error occurs, in which case, control would flow into failure callback. Which is not the case. Here is what happens:\n\nWhen the file exists, controls flows into error callback and when it doesn't exist, the success callback is invoked. To make it work, I have to do something like this:\n\n``` javascript\nvar fs_exists = q.denodeify(fs.exists);\n\nfs_exists('/some/file/path')\n.then(function( exists ){\n    console.log('file doesn\\'t exist');\n}, function( err ) {\n   console.log('file exists');\n});\n```\n\nLet me know if I'm missing something or if it is deliberate and not a flaw. Otherwise if you think behavior I proposed above (first of the two snippets) looks viable, I can send you a pull request.\n. @domenic Thanks for explanation.\n. ",
    "mkb": "Understood. Thanks for clarifying.\n. Understood. Thanks for clarifying.\n. ",
    "anton-rudeshko": "See #599\n. So?\n. @kriskowal, okay, thank you, I got it. Have a nice day!\n. Thanks! Will send a PR to `v2` branch later this week.\n. Any news?\n. Okay, cool. Give me two days to update PR.\n. Done, check it out. Resulting package will include:\n\n```\npackage.json\nREADME.md\nLICENSE\nq.js\nqueue.js\n```\n. Thank you too, have a nice day\n. See #599\n. So?\n. @kriskowal, okay, thank you, I got it. Have a nice day!\n. Thanks! Will send a PR to `v2` branch later this week.\n. Any news?\n. Okay, cool. Give me two days to update PR.\n. Done, check it out. Resulting package will include:\n\n```\npackage.json\nREADME.md\nLICENSE\nq.js\nqueue.js\n```\n. Thank you too, have a nice day\n. ",
    "hankduan": "I should clarify. My question isn't why the `console.log(\"here\")` doesn't run (I know it shouldn't run), but rather, how does q know that the deferred would never be resolved?\n\ni.e. here q would just wait (and potentially block forever) for the subprocess to exit\n\n```\nvar deferred = require('q').defer();\nvar spawn = require('child_process').spawn,\n\nspawn('sleep', ['3']).on('exit', function(code) {\n  deferred.resolve();\n});\n\ndeferred.promise.then(function() {\n  console.log(\"here\");\n});\n```\n\nWhereas in my first example, q would just not wait at all. \n\nIn other words, when does q wait for the promise to resolve, and when does q skip over the promise?\n. Thanks, that was helpful!\n. I should clarify. My question isn't why the `console.log(\"here\")` doesn't run (I know it shouldn't run), but rather, how does q know that the deferred would never be resolved?\n\ni.e. here q would just wait (and potentially block forever) for the subprocess to exit\n\n```\nvar deferred = require('q').defer();\nvar spawn = require('child_process').spawn,\n\nspawn('sleep', ['3']).on('exit', function(code) {\n  deferred.resolve();\n});\n\ndeferred.promise.then(function() {\n  console.log(\"here\");\n});\n```\n\nWhereas in my first example, q would just not wait at all. \n\nIn other words, when does q wait for the promise to resolve, and when does q skip over the promise?\n. Thanks, that was helpful!\n. ",
    "turadg": "I'd also like to know where Q stands in relation to ES6.\n\nThe [wiki page](https://github.com/kriskowal/q/wiki/Comparing-ES-Harmony-Concurrency-Strawman) was last updated March 2012.\n\nWill Q align with ES6 Promise spec?\n. I'd also like to know where Q stands in relation to ES6.\n\nThe [wiki page](https://github.com/kriskowal/q/wiki/Comparing-ES-Harmony-Concurrency-Strawman) was last updated March 2012.\n\nWill Q align with ES6 Promise spec?\n. ",
    "beck": "If I understand correctly, the request here is to be able to execute a series of promises in sequential order but have them all resolve to an array of values.\n\n`Q.all` is not the the right approach.  The right approach is still using a promise chain (or the `reduce` shortcut) but instead of a single value flowing through the promise chain, wrap the functions in such a way where the values are captured and aggregated.  Suggesting something like:\n\n``` js\n'use strict';\nvar Q = require('q');\n\nvar order = 0;\n\nfunction foo() {\n  return 'foo ' + ++order;\n}\n\nfunction bar() {\n  return 'bar ' + ++order;\n}\n\nfunction baz() {\n  return 'baz ' + ++order;\n}\n\nfunction wrap(func){\n    return function(results) {\n        var result = func();\n        results.push(result);\n        return results;\n    };\n}\n\nvar funcs = [foo, bar, baz];\nvar wrapped = funcs.map(wrap);\n\nwrapped\n  .reduce(Q.when, Q([]))\n  .then(console.log);\n\n// output:\n// [ 'foo 1', 'bar 2', 'baz 3' ]\n```\n\nDoes this make sense?\n. If I understand correctly, the request here is to be able to execute a series of promises in sequential order but have them all resolve to an array of values.\n\n`Q.all` is not the the right approach.  The right approach is still using a promise chain (or the `reduce` shortcut) but instead of a single value flowing through the promise chain, wrap the functions in such a way where the values are captured and aggregated.  Suggesting something like:\n\n``` js\n'use strict';\nvar Q = require('q');\n\nvar order = 0;\n\nfunction foo() {\n  return 'foo ' + ++order;\n}\n\nfunction bar() {\n  return 'bar ' + ++order;\n}\n\nfunction baz() {\n  return 'baz ' + ++order;\n}\n\nfunction wrap(func){\n    return function(results) {\n        var result = func();\n        results.push(result);\n        return results;\n    };\n}\n\nvar funcs = [foo, bar, baz];\nvar wrapped = funcs.map(wrap);\n\nwrapped\n  .reduce(Q.when, Q([]))\n  .then(console.log);\n\n// output:\n// [ 'foo 1', 'bar 2', 'baz 3' ]\n```\n\nDoes this make sense?\n. ",
    "timjacobi": "> If I understand correctly\n\nYou do! ;)\n\n> Does this make sense?\n\nYes, thanks for the code! It makes perfectly sense but it's really really verbose. That's why I'm asking for an additional method on Q like Q.all() but sequential. Q.sequentiAll() (pun intended)...\n. Thanks! It's not the best example in the world but I hope it shows my intentions well enough.\n\n#### Code\n\n```\nvar asyncAddOne = function(a){\n    var deferred = Q.defer();\n    window.setTimeout(function(){\n        console.log(\"Calculating: \" + a + \" + 1\");\n        deferred.resolve(a + 1);\n    }, 1000 - (a*100));\n    return deferred.promise;\n};\n\nQ.sequential([asyncAdd, asyncAdd, asyncAdd], 8).then(function(result){\n    console.log(result);\n});\n```\n\n#### Output\n\n```\nCalculating 8 + 1\nCalculating 9 + 1\nCalculating 10 + 1\n[9, 10, 11]\n```\n. Are there any plans to follow up on this?\n. > If I understand correctly\n\nYou do! ;)\n\n> Does this make sense?\n\nYes, thanks for the code! It makes perfectly sense but it's really really verbose. That's why I'm asking for an additional method on Q like Q.all() but sequential. Q.sequentiAll() (pun intended)...\n. Thanks! It's not the best example in the world but I hope it shows my intentions well enough.\n\n#### Code\n\n```\nvar asyncAddOne = function(a){\n    var deferred = Q.defer();\n    window.setTimeout(function(){\n        console.log(\"Calculating: \" + a + \" + 1\");\n        deferred.resolve(a + 1);\n    }, 1000 - (a*100));\n    return deferred.promise;\n};\n\nQ.sequential([asyncAdd, asyncAdd, asyncAdd], 8).then(function(result){\n    console.log(result);\n});\n```\n\n#### Output\n\n```\nCalculating 8 + 1\nCalculating 9 + 1\nCalculating 10 + 1\n[9, 10, 11]\n```\n. Are there any plans to follow up on this?\n. ",
    "dougmolineux": "Jamming a large array of promises into Q.all() isn't scalable (especially when you can't really tell how large it could grow). As a consequence we've been forced to not use it anywhere where we are unsure of the size of the array. In my opinion, A `Q.sequenceAll` would be an ideal and cleaner way to fix this, rather than using a custom reduce method. \n\nIt is reasonable to assume that many small implementations of this method will probably not run into this issue, but as soon as we deployed our code to a production environment we ran into this issue in many places.\n. Jamming a large array of promises into Q.all() isn't scalable (especially when you can't really tell how large it could grow). As a consequence we've been forced to not use it anywhere where we are unsure of the size of the array. In my opinion, A `Q.sequenceAll` would be an ideal and cleaner way to fix this, rather than using a custom reduce method. \n\nIt is reasonable to assume that many small implementations of this method will probably not run into this issue, but as soon as we deployed our code to a production environment we ran into this issue in many places.\n. ",
    "danielmhair": "Thank you @dougmolineux  and @kriskowal for your last comments. @dougmolineux, for your thoughts about Q.all not being scalable for a large array of promises. Right before I read that, I was thinking the same thing, which is what led me to this issue. And @kriskowal, for your thoughts that we are doing it wrong by using `Q.all` for long indefinite sequences of values. It has inspired me to upgrade to streams.\n. Thank you @dougmolineux  and @kriskowal for your last comments. @dougmolineux, for your thoughts about Q.all not being scalable for a large array of promises. Right before I read that, I was thinking the same thing, which is what led me to this issue. And @kriskowal, for your thoughts that we are doing it wrong by using `Q.all` for long indefinite sequences of values. It has inspired me to upgrade to streams.\n. ",
    "Cdvalencia": "posible [solution](https://gist.github.com/slavafomin/8ee69f447765bc5c5e19). posible [solution](https://gist.github.com/slavafomin/8ee69f447765bc5c5e19). ",
    "jmbertoncelli": "thanks!  will check close when Nuget Package be available.\n. thanks!  will check close when Nuget Package be available.\n. ",
    "piglovesyou": "I proposed such an utility in #621.\n. I closed the https://github.com/kriskowal/q/pull/630#issuecomment-300648112 for a reason.. @hege91  Cool and we definitly have to do that for similarity to a spec of Q.all.\n. @deanshub I really understand what you'r doing because once I used to think of it just like you do. But `Q.consume` (#630) would be faster, because `Q.all` can contain a lazy time to wait for the slowest promise being fulfilled among the `limitedPromises`. So I used Producer-Consumer Pattern to reduce that overhead time. In addition, sometimes we want to keep an array of `values` itself so that's why I didn't use `values.shift()`.\n. @deanshub I don't know, I'm really interested in how the core developers think about this issue.\n. > That is available in Q-IO,\n\n@kriskowal I will try to help, but I need more info. I read `q-io/reader.js`. Although I understand what \"asynchronous iterator\" means, I couldn't find the idea of \"concurrency limit\" because it only wraps a native stream object and uses \"data\" event. Which code can exactly makes me know what's in your mind?\n. Thank you (sorry I've read only `q-io@1`). I'll read v2 code more.\n. @heipei No I have not, I didn't too dive into `q-io@2` because I didn't figure out what exactly @kriskowal suggested me in q-io, afterwards... @jtmarmon It is hard to find out the most efficient number because there must be many factors to be a problem: out of memory, hunging up of an opposit server response, so on. How about `5` as a start? In this case it's better to take stability instead of speed.\n. If you don't care to provide the error log and the execution code I would like to see them.\n. `.catch(function(err) { console.log(err.stack) })` might show an error log. I'm not familiar to `R`...\n. In https://github.com/kriskowal/q/issues/621#issuecomment-92546791, @kriskowal suggested me that the problem should be dealt in q-io. The PR is too small-scoped in the case so I'll close.. I proposed such an utility in #621.\n. I closed the https://github.com/kriskowal/q/pull/630#issuecomment-300648112 for a reason.. @hege91  Cool and we definitly have to do that for similarity to a spec of Q.all.\n. @deanshub I really understand what you'r doing because once I used to think of it just like you do. But `Q.consume` (#630) would be faster, because `Q.all` can contain a lazy time to wait for the slowest promise being fulfilled among the `limitedPromises`. So I used Producer-Consumer Pattern to reduce that overhead time. In addition, sometimes we want to keep an array of `values` itself so that's why I didn't use `values.shift()`.\n. @deanshub I don't know, I'm really interested in how the core developers think about this issue.\n. > That is available in Q-IO,\n\n@kriskowal I will try to help, but I need more info. I read `q-io/reader.js`. Although I understand what \"asynchronous iterator\" means, I couldn't find the idea of \"concurrency limit\" because it only wraps a native stream object and uses \"data\" event. Which code can exactly makes me know what's in your mind?\n. Thank you (sorry I've read only `q-io@1`). I'll read v2 code more.\n. @heipei No I have not, I didn't too dive into `q-io@2` because I didn't figure out what exactly @kriskowal suggested me in q-io, afterwards... @jtmarmon It is hard to find out the most efficient number because there must be many factors to be a problem: out of memory, hunging up of an opposit server response, so on. How about `5` as a start? In this case it's better to take stability instead of speed.\n. If you don't care to provide the error log and the execution code I would like to see them.\n. `.catch(function(err) { console.log(err.stack) })` might show an error log. I'm not familiar to `R`...\n. In https://github.com/kriskowal/q/issues/621#issuecomment-92546791, @kriskowal suggested me that the problem should be dealt in q-io. The PR is too small-scoped in the case so I'll close.. ",
    "nmschulte-aviture": "I think I am being annoyed by this \"issue\" in Chromium (Chrome).\n\nIf I throw an error synchronously (or just cause an exception in general), like normal, Chromium's console outputs the stack trace of the error.  If I wrap it in a `Q.fcall(...).done()` (asynchronously) Chromium still outputs the error, but it refuses to output the stack trace.  \n\nIceweasel (Firefox) doesn't output stack traces at all in its console.\n\nIt seems this is browser specific then, and I just prefer the way Chromium behaves normally.  I'm not sure why doing things asynchronously keeps it from outputting the stack trace, but it seems I should find a better way in my application to enable debugging.  Should I consider using the `onerror` callback somehow?  How are others viewing the stack traces while debugging?\n. As it was written, `fail(handler)` is just a convenience method for `then(null, handler)`.  Changing it to be `done(null, handler)` would break lots of code, no?  I don't think that's a good idea.\n\nI'm still skeptical that the OP's (@nishantkyal's) issue is due to the well-known swallowing of unhanded errors when not using `done`.  The issue I described with Chromium (or WebKit/V8) seems more likely.  It would be great if the OP would clarify.\n\nYou can view the difference I'm referring to with this example: http://jsfiddle.net/uawjd0vk/3/  View it with different browsers and you can see how Q behaves differently in each.\n\nI did not know this, but apparently stack trace support is entirely non-standard.  As Q already has \"long stack trace support\" (that is, dealing with the browser-specifics of stack traces), I would expect the behavior of that example to be the same across browsers as well.\n\nIn Chromium (Chrome), asynchronous errors (Q's errors; from `done`) don't have an Error object as the 5th argument to the onerror handler.  In Iceweasel (Firefox), they do.  Synchronous errors are browser-specific, but browsers of interest all have the same basic support.  I'm sure other browsers vary as well.\n. I think I am being annoyed by this \"issue\" in Chromium (Chrome).\n\nIf I throw an error synchronously (or just cause an exception in general), like normal, Chromium's console outputs the stack trace of the error.  If I wrap it in a `Q.fcall(...).done()` (asynchronously) Chromium still outputs the error, but it refuses to output the stack trace.  \n\nIceweasel (Firefox) doesn't output stack traces at all in its console.\n\nIt seems this is browser specific then, and I just prefer the way Chromium behaves normally.  I'm not sure why doing things asynchronously keeps it from outputting the stack trace, but it seems I should find a better way in my application to enable debugging.  Should I consider using the `onerror` callback somehow?  How are others viewing the stack traces while debugging?\n. As it was written, `fail(handler)` is just a convenience method for `then(null, handler)`.  Changing it to be `done(null, handler)` would break lots of code, no?  I don't think that's a good idea.\n\nI'm still skeptical that the OP's (@nishantkyal's) issue is due to the well-known swallowing of unhanded errors when not using `done`.  The issue I described with Chromium (or WebKit/V8) seems more likely.  It would be great if the OP would clarify.\n\nYou can view the difference I'm referring to with this example: http://jsfiddle.net/uawjd0vk/3/  View it with different browsers and you can see how Q behaves differently in each.\n\nI did not know this, but apparently stack trace support is entirely non-standard.  As Q already has \"long stack trace support\" (that is, dealing with the browser-specifics of stack traces), I would expect the behavior of that example to be the same across browsers as well.\n\nIn Chromium (Chrome), asynchronous errors (Q's errors; from `done`) don't have an Error object as the 5th argument to the onerror handler.  In Iceweasel (Firefox), they do.  Synchronous errors are browser-specific, but browsers of interest all have the same basic support.  I'm sure other browsers vary as well.\n. ",
    "dwoldrich": "I propose we change .fail(rejected) to equate to .done(null, rejected)  \n\nCurrently, .fail(rejected) equates to .catch(rejected), which equates to .then(null, rejected)\n\nThe problem as I understand it is that ending a promise chain with .then rather than .done allows the exceptions to be swallowed.  Perhaps the reporter of this bug was trying to end his chain with .fail(), thinking it would behave like .done().\n\nIf we had two aliases for the \"handle only the exceptional case\", .catch for intra-chain, and .fail for end-of-chain, we would have a nice elegant solution for error handling in all cases.  I like the use of the word fail as opposed to catch here, \"catch\" connotes an option of continuing after a fall, whereas \"fail\" connotes the finality of our situation.\n\nIn the meantime, I suspect the workaround for the original bug reporter should be: use .done(null, rejected) rather than .fail(rejected) to handle your final failure case and you should get your stack traces.\n. @nmschulte-aviture you are probably right that lots of code would break in changing `fail()` since `done()` does not return a promise, but `then()` does.  You may be right that the OP was failing due to the Chromium issue.  I'd still like to see something in the API that works like `catch` that aliases to `done`.\n\nOk, how about this for plan B:  double-deprecate `fail()` and offer a replacement like `failure(handler)` or `fails(handler)` that serves as an alias for `done(null, handler)`.\n. I propose we change .fail(rejected) to equate to .done(null, rejected)  \n\nCurrently, .fail(rejected) equates to .catch(rejected), which equates to .then(null, rejected)\n\nThe problem as I understand it is that ending a promise chain with .then rather than .done allows the exceptions to be swallowed.  Perhaps the reporter of this bug was trying to end his chain with .fail(), thinking it would behave like .done().\n\nIf we had two aliases for the \"handle only the exceptional case\", .catch for intra-chain, and .fail for end-of-chain, we would have a nice elegant solution for error handling in all cases.  I like the use of the word fail as opposed to catch here, \"catch\" connotes an option of continuing after a fall, whereas \"fail\" connotes the finality of our situation.\n\nIn the meantime, I suspect the workaround for the original bug reporter should be: use .done(null, rejected) rather than .fail(rejected) to handle your final failure case and you should get your stack traces.\n. @nmschulte-aviture you are probably right that lots of code would break in changing `fail()` since `done()` does not return a promise, but `then()` does.  You may be right that the OP was failing due to the Chromium issue.  I'd still like to see something in the API that works like `catch` that aliases to `done`.\n\nOk, how about this for plan B:  double-deprecate `fail()` and offer a replacement like `failure(handler)` or `fails(handler)` that serves as an alias for `done(null, handler)`.\n. ",
    "anba": "@domenic Here you are: https://mail.mozilla.org/pipermail/es-discuss/2014-September/039245.html\n. @domenic Here you are: https://mail.mozilla.org/pipermail/es-discuss/2014-September/039245.html\n. ",
    "5outh": "I'm not sure I understand how Q.nodeify works then; it seems like the functions are trying to accomplish two separate things. Here's an example:\n\n```\n\"use strict\";\n\nvar _ = require('lodash'),\n    Q = require('q'),\n    fs = require('fs'),\n\n    deferred,\n    curriedReadFile,\n    testFunction;\n\ndeferred = function (func) {\n    var deferred = Q.defer();\n\n    func(function (err, res) {\n        if (err) {\n            deferred.reject(err);\n        } else {\n            deferred.resolve(res);\n        }\n    });\n\n    return deferred.promise;\n};\n\ncurriedReadFile = _.curry(fs.readFile, 3);\ntestFunction = curriedReadFile('foo.txt', 'utf8');\n\nQ.nodeify(testFunction).then(console.log);\n// logs [Function: bound]\n\ndeferred(testFunction).then(console.log);\n// logs bar (contents of foo.txt)\n```\n\nClearly they're not doing the same thing, but maybe it's just a case of moving things around a little. If that's the case, that's cool! I just don't understand right now how the two functions are \"the same.\"\n. That makes more sense. It's not exactly the same but I can see how that mitigates the need for what I proposed. Thanks!\n. I'm not sure I understand how Q.nodeify works then; it seems like the functions are trying to accomplish two separate things. Here's an example:\n\n```\n\"use strict\";\n\nvar _ = require('lodash'),\n    Q = require('q'),\n    fs = require('fs'),\n\n    deferred,\n    curriedReadFile,\n    testFunction;\n\ndeferred = function (func) {\n    var deferred = Q.defer();\n\n    func(function (err, res) {\n        if (err) {\n            deferred.reject(err);\n        } else {\n            deferred.resolve(res);\n        }\n    });\n\n    return deferred.promise;\n};\n\ncurriedReadFile = _.curry(fs.readFile, 3);\ntestFunction = curriedReadFile('foo.txt', 'utf8');\n\nQ.nodeify(testFunction).then(console.log);\n// logs [Function: bound]\n\ndeferred(testFunction).then(console.log);\n// logs bar (contents of foo.txt)\n```\n\nClearly they're not doing the same thing, but maybe it's just a case of moving things around a little. If that's the case, that's cool! I just don't understand right now how the two functions are \"the same.\"\n. That makes more sense. It's not exactly the same but I can see how that mitigates the need for what I proposed. Thanks!\n. ",
    "slawo": "@kriskowal It seems the Reader has an issue:\n\n```\n      var testQIO = function (v) {\n        var deferred = Q.defer();\n        console.log(\"+\",v.code2);\n        setTimeout(function() {\n          console.log(\"-\",v.code2);\n          deferred.resolve(v.code2);\n        }, 200);\n        return deferred.promise;\n      }\n\n      console.log(\" setting up\",values.length, 'values');\n      var runOnAll = new Reader(values).map(testQIO, null, 1).all();\n```\n\nWill run all the values 2 by 2:\n\n```\nsetting up 1445 values\n+ 011A\n+ 011C\n- 011A\n- 011C\n+ 011D\n+ 011F\n- 011D\n- 011F\n+ 011P\n+ 011G\n- 011P\n- 011G\n...\n```\n. Actually after updating both q and q-io the result is slightly different but still wrong:\n\n```\n+ 011A\n+ 011C\n- 011A\n+ 011D\n- 011C\n+ 011F\n- 011D\n+ 011P\n- 011F\n```\n\nYou can see there are always 2 instances of the `testQIO` function running in parallel.\n. @kriskowal It seems the Reader has an issue:\n\n```\n      var testQIO = function (v) {\n        var deferred = Q.defer();\n        console.log(\"+\",v.code2);\n        setTimeout(function() {\n          console.log(\"-\",v.code2);\n          deferred.resolve(v.code2);\n        }, 200);\n        return deferred.promise;\n      }\n\n      console.log(\" setting up\",values.length, 'values');\n      var runOnAll = new Reader(values).map(testQIO, null, 1).all();\n```\n\nWill run all the values 2 by 2:\n\n```\nsetting up 1445 values\n+ 011A\n+ 011C\n- 011A\n- 011C\n+ 011D\n+ 011F\n- 011D\n- 011F\n+ 011P\n+ 011G\n- 011P\n- 011G\n...\n```\n. Actually after updating both q and q-io the result is slightly different but still wrong:\n\n```\n+ 011A\n+ 011C\n- 011A\n+ 011D\n- 011C\n+ 011F\n- 011D\n+ 011P\n- 011F\n```\n\nYou can see there are always 2 instances of the `testQIO` function running in parallel.\n. ",
    "ppannuto": "Using yield instead causes it run incorrectly in Chrome and hang in Firefox.\n\n### Chrome Output\n\n> before spawn\n> before top-level spawn yield\n> after spawn\n> after top-level spawn yield\n\n### Firefox Output (after killing unresponsive script)\n\n> \"before spawn\"\n> \"before top-level spawn yield\"\n> \"after spawn\"\n> \"after top-level spawn yield\"\n> \n> Error: Script terminated by timeout at:\n> flush@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:98:1\n\nSince `readURL` is also a generator, I would expect to have to use yield\\* to delegate the yield down?\n. Hmm.. wrapping readURL in Q.async and changing yield\\* to yield (i.e. http://jsfiddle.net/72f026k1/7/) works correctly in Chrome, but causes Firefox to hang with an unresponsive script.\n\n### Firefox (after killing unresponsive script)\n\n> \"before spawn\"\n> \"before top-level spawn yield\"\n> \"before yeild in readURL\" \n> \"in body expect false:\" \n> false \n> \"after spawn\" \n> \"after yeild in readURL\" \n> \"in body expect true:\"\n> false \n> \"after top-level spawn yield\"\n> \"in callback expect false:\" \n> false \n> \"in callback expect true:\" \n> true\n> \n> Error: Script terminated by timeout at:\n> Promise/promise.promiseDispatch@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:745:1\n> Promise.prototype.then@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:835:1\n> when@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:899:12\n> continuer@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:1241:24\n> _fulfilled@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:794:54\n> Promise.prototype.then/</<@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:823:30\n> Promise/promise.promiseDispatch@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:756:13\n> Promise.prototype.then/<@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:817:1\n> flush@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:110:17\n. Any thoughts on a potential workaround? From that stack trace it does look to be hung up somewhere internal in Q\n. The incentive for the architecture is to have a (in principle) library agnostic {a}synchronous mechanism. \n\nImagine a runtime (`test` from your block) that supplies some utility functions in library code (`loadXHR` from your block). People writing against the runtime (e.g. the author of `readURL`) don't need to even know Q exists. Runtimes can also be changed out, indeed `test` and `loadXHR` can actually be Python or Java etc. The implication is that the \"middle\" code can't have any library-specific information in it (e.g. `Q.async`).\n\nFor some more detail see https://github.com/lab11/accessors/tree/master/runtimes#synchronizing-asynchronous-events and the surrounding material.\n\nThe infinite loop in FF is a little unfortunate.. I suppose I can always transpile this for FF for now if it there's no better solution.\n. Aha! I have solved the problem -- and it's good news.\n\nIt looks like Firefox (as of 33.1.1 at least) now supports real ES6 Generators. The problem is the detection logic trips and Q's workaround for old SpiderMonkey generators now creates a bug.\n\nChanging:\n`if (typeof StopIteration === \"undefined\")` ( https://github.com/kriskowal/q/blob/v1/q.js#L1217 )\n\nto `if (true)` fixes this issue for me on firefox.\n\nUnfortunately, I'm not nearly good enough at JS to divine a more robust detection mechanism.\n\n<trigger-happy \"enter\", sorry for the partial email>\n. Using yield instead causes it run incorrectly in Chrome and hang in Firefox.\n\n### Chrome Output\n\n> before spawn\n> before top-level spawn yield\n> after spawn\n> after top-level spawn yield\n\n### Firefox Output (after killing unresponsive script)\n\n> \"before spawn\"\n> \"before top-level spawn yield\"\n> \"after spawn\"\n> \"after top-level spawn yield\"\n> \n> Error: Script terminated by timeout at:\n> flush@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:98:1\n\nSince `readURL` is also a generator, I would expect to have to use yield\\* to delegate the yield down?\n. Hmm.. wrapping readURL in Q.async and changing yield\\* to yield (i.e. http://jsfiddle.net/72f026k1/7/) works correctly in Chrome, but causes Firefox to hang with an unresponsive script.\n\n### Firefox (after killing unresponsive script)\n\n> \"before spawn\"\n> \"before top-level spawn yield\"\n> \"before yeild in readURL\" \n> \"in body expect false:\" \n> false \n> \"after spawn\" \n> \"after yeild in readURL\" \n> \"in body expect true:\"\n> false \n> \"after top-level spawn yield\"\n> \"in callback expect false:\" \n> false \n> \"in callback expect true:\" \n> true\n> \n> Error: Script terminated by timeout at:\n> Promise/promise.promiseDispatch@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:745:1\n> Promise.prototype.then@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:835:1\n> when@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:899:12\n> continuer@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:1241:24\n> _fulfilled@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:794:54\n> Promise.prototype.then/</<@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:823:30\n> Promise/promise.promiseDispatch@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:756:13\n> Promise.prototype.then/<@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:817:1\n> flush@http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js:110:17\n. Any thoughts on a potential workaround? From that stack trace it does look to be hung up somewhere internal in Q\n. The incentive for the architecture is to have a (in principle) library agnostic {a}synchronous mechanism. \n\nImagine a runtime (`test` from your block) that supplies some utility functions in library code (`loadXHR` from your block). People writing against the runtime (e.g. the author of `readURL`) don't need to even know Q exists. Runtimes can also be changed out, indeed `test` and `loadXHR` can actually be Python or Java etc. The implication is that the \"middle\" code can't have any library-specific information in it (e.g. `Q.async`).\n\nFor some more detail see https://github.com/lab11/accessors/tree/master/runtimes#synchronizing-asynchronous-events and the surrounding material.\n\nThe infinite loop in FF is a little unfortunate.. I suppose I can always transpile this for FF for now if it there's no better solution.\n. Aha! I have solved the problem -- and it's good news.\n\nIt looks like Firefox (as of 33.1.1 at least) now supports real ES6 Generators. The problem is the detection logic trips and Q's workaround for old SpiderMonkey generators now creates a bug.\n\nChanging:\n`if (typeof StopIteration === \"undefined\")` ( https://github.com/kriskowal/q/blob/v1/q.js#L1217 )\n\nto `if (true)` fixes this issue for me on firefox.\n\nUnfortunately, I'm not nearly good enough at JS to divine a more robust detection mechanism.\n\n<trigger-happy \"enter\", sorry for the partial email>\n. ",
    "eteeselink": "I'm running into this problem too. Can anyone smarter than me assess the safety of the workaround proposed by @ppannuto in a web application? (I'm using babel/regenerator with Q.async/spawn). I have a hard time finding out from which Firefox version onwards Q.async is current broken and how many users I block out by implementing that workaround.\n. I'm running into this problem too. Can anyone smarter than me assess the safety of the workaround proposed by @ppannuto in a web application? (I'm using babel/regenerator with Q.async/spawn). I have a hard time finding out from which Firefox version onwards Q.async is current broken and how many users I block out by implementing that workaround.\n. ",
    "chchrist": "Any update on this one? \n. Any update on this one? \n. ",
    "hipertracker": "OK. All clear. Tnx.\n. Sorry, wrong example\n. OK. All clear. Tnx.\n. Sorry, wrong example\n. ",
    "heycalmdown": "``` bash\nkson@ubuntu:~$ node pt.js\nstart with QP(Q+Promise), QQ(Q+Q), PP(Promise+Promise)\ndelay\n<QP>\n<QQ>\n<QQ><Q/>\n<QQ><Q/></QQ>\n<PP>\n<QP><Promise/>\n<PP><Promise/>\n<PP><Promise/></PP>\n<QP><Promise/></QP>\ntimeout\nkson@ubuntu:~$ nvm ls\n->  v0.11.14\nunstable -> 0.11 (-> v0.11.14) (default)\nkson@ubuntu:~$ nvm install v0.11.13\n######################################################################## 100.0%\nNow using node v0.11.13\nkson@ubuntu:~$ nvm ls\n->  v0.11.13\n    v0.11.14\nunstable -> 0.11 (-> v0.11.14) (default)\nkson@ubuntu:~$ node pt.js\nstart with QP(Q+Promise), QQ(Q+Q), PP(Promise+Promise)\ndelay\n<QP>\n<QQ>\n<QQ><Q/>\n<QQ><Q/></QQ>\n<PP>\n<QP><Promise/>\n<PP><Promise/>\n<PP><Promise/></PP>\ntimeout\n<QP><Promise/></QP>\nkson@ubuntu:~$ nvm install v0.11.12\n######################################################################## 100.0%\nNow using node v0.11.12\nkson@ubuntu:~$ node pt.js\nstart with QP(Q+Promise), QQ(Q+Q), PP(Promise+Promise)\nmodule.js:333\n    throw err;\n          ^\nError: Cannot find module 'es6-promise'\n    at Function.Module._resolveFilename (module.js:331:15)\n    at Function.Module._load (module.js:273:25)\n    at Module.require (module.js:357:17)\n    at require (module.js:373:17)\n    at Object.<anonymous> (/home/kson/pt.js:6:6)\n    at Module._compile (module.js:449:26)\n    at Object.Module._extensions..js (module.js:467:10)\n    at Module.load (module.js:349:32)\n    at Function.Module._load (module.js:305:12)\n    at Function.Module.runMain (module.js:490:10)\n```\n\nIt seems like a very edge case which is from the newly imported feature to Node.js, not about Q.\nSorry.\n. ``` bash\nkson@ubuntu:~$ node pt.js\nstart with QP(Q+Promise), QQ(Q+Q), PP(Promise+Promise)\ndelay\n<QP>\n<QQ>\n<QQ><Q/>\n<QQ><Q/></QQ>\n<PP>\n<QP><Promise/>\n<PP><Promise/>\n<PP><Promise/></PP>\n<QP><Promise/></QP>\ntimeout\nkson@ubuntu:~$ nvm ls\n->  v0.11.14\nunstable -> 0.11 (-> v0.11.14) (default)\nkson@ubuntu:~$ nvm install v0.11.13\n######################################################################## 100.0%\nNow using node v0.11.13\nkson@ubuntu:~$ nvm ls\n->  v0.11.13\n    v0.11.14\nunstable -> 0.11 (-> v0.11.14) (default)\nkson@ubuntu:~$ node pt.js\nstart with QP(Q+Promise), QQ(Q+Q), PP(Promise+Promise)\ndelay\n<QP>\n<QQ>\n<QQ><Q/>\n<QQ><Q/></QQ>\n<PP>\n<QP><Promise/>\n<PP><Promise/>\n<PP><Promise/></PP>\ntimeout\n<QP><Promise/></QP>\nkson@ubuntu:~$ nvm install v0.11.12\n######################################################################## 100.0%\nNow using node v0.11.12\nkson@ubuntu:~$ node pt.js\nstart with QP(Q+Promise), QQ(Q+Q), PP(Promise+Promise)\nmodule.js:333\n    throw err;\n          ^\nError: Cannot find module 'es6-promise'\n    at Function.Module._resolveFilename (module.js:331:15)\n    at Function.Module._load (module.js:273:25)\n    at Module.require (module.js:357:17)\n    at require (module.js:373:17)\n    at Object.<anonymous> (/home/kson/pt.js:6:6)\n    at Module._compile (module.js:449:26)\n    at Object.Module._extensions..js (module.js:467:10)\n    at Module.load (module.js:349:32)\n    at Function.Module._load (module.js:305:12)\n    at Function.Module.runMain (module.js:490:10)\n```\n\nIt seems like a very edge case which is from the newly imported feature to Node.js, not about Q.\nSorry.\n. ",
    "bkdotcom": "it appears that notify only works from within `then()` calls\r\n\r\nI'm new to the Q library and I don't see a difference between   `deferred.notify('0');` and `deferred.notify('a');` \r\nSeems like that should both \"dispatch\" their notification\r\n\r\nTo get either to work wrap them like so:\r\n```javascript\r\nQ().then(function(){\r\n\tdeferred.notify('a');\r\n});\r\n```\r\n\r\n> Am I missing something? Or is it the intended behavior?\r\n\r\nditto\r\n. it appears that notify only works from within `then()` calls\r\n\r\nI'm new to the Q library and I don't see a difference between   `deferred.notify('0');` and `deferred.notify('a');` \r\nSeems like that should both \"dispatch\" their notification\r\n\r\nTo get either to work wrap them like so:\r\n```javascript\r\nQ().then(function(){\r\n\tdeferred.notify('a');\r\n});\r\n```\r\n\r\n> Am I missing something? Or is it the intended behavior?\r\n\r\nditto\r\n. ",
    "hege91": "I agree, and I think if we do so, it would be the best to keep the indices in the pool and in the results matching. Something like:\n\n``` JavaScript\nfunction concurrent(task, pool, count) {\n  var workers = [];\n  var results = new Array(pool.length);\n  var needle = 0;\n  while (workers.length < count) {\n    workers.push(workIfAny());\n  }\n  return Q.all(workers).then(function() {\n    return results;\n  });\n  function workIfAny() {\n    if (needle < pool.length) {\n      var index = needle++;\n      return Q.fcall(task, pool[index]).then(function(piece) {\n        results[index] = piece;\n        return workIfAny();\n      });\n    }\n  }\n}\n```\n. I think the snippet you provided would look something like this in a language which supports async/await:\n\n``` JavaScript\nasync function func3() {\n    try {\n        await Q.delay(1);\n        throw null;\n    } finally {\n        console.log('finally');\n    }\n}\n\nQ.spawn(async function() {\n    try {\n        await func3();\n        console.log('is ok');\n    } catch (e) {\n        console.log('rejected');\n    }\n});\n```\n\nAs sync code:\n\n``` JavaScript\nfunction func3() {\n  try {\n    throw 'an error';\n  } finally {\n    console.log('finally');\n  }\n}\n\ntry {\n  func3();\n  console.log('is ok');\n} catch (e) {\n    console.log('rejected');\n}\n// outputs finally, rejected as well\n```\n\nThis way, the output is what I expect to be. Correct me if I'm wrong.\n. I agree, and I think if we do so, it would be the best to keep the indices in the pool and in the results matching. Something like:\n\n``` JavaScript\nfunction concurrent(task, pool, count) {\n  var workers = [];\n  var results = new Array(pool.length);\n  var needle = 0;\n  while (workers.length < count) {\n    workers.push(workIfAny());\n  }\n  return Q.all(workers).then(function() {\n    return results;\n  });\n  function workIfAny() {\n    if (needle < pool.length) {\n      var index = needle++;\n      return Q.fcall(task, pool[index]).then(function(piece) {\n        results[index] = piece;\n        return workIfAny();\n      });\n    }\n  }\n}\n```\n. I think the snippet you provided would look something like this in a language which supports async/await:\n\n``` JavaScript\nasync function func3() {\n    try {\n        await Q.delay(1);\n        throw null;\n    } finally {\n        console.log('finally');\n    }\n}\n\nQ.spawn(async function() {\n    try {\n        await func3();\n        console.log('is ok');\n    } catch (e) {\n        console.log('rejected');\n    }\n});\n```\n\nAs sync code:\n\n``` JavaScript\nfunction func3() {\n  try {\n    throw 'an error';\n  } finally {\n    console.log('finally');\n  }\n}\n\ntry {\n  func3();\n  console.log('is ok');\n} catch (e) {\n    console.log('rejected');\n}\n// outputs finally, rejected as well\n```\n\nThis way, the output is what I expect to be. Correct me if I'm wrong.\n. ",
    "deanshub": "here is what i wrote as a workaround for now...\n\n``` javascript\nvar Q = require('q');\n\nfunction limitedQ(){\n    var methods={};\n\n    methods.limitAll = function(self, method, values, limit){\n        return Q.promise(function(resolve){\n            var limitedPromises =[];\n\n            while(values.length>0 && limitedPromises.length<limit){\n                var args = values.shift();\n                if (args instanceof Array){\n                    limitedPromises.push(method.apply(self,args));\n                }else{\n                    limitedPromises.push(method.apply(self,[args]));\n                }\n            }\n\n            Q.all(limitedPromises).then(function(limitedResults){\n                if (limitedResults.length === 0){\n                    resolve(limitedResults);\n                }else {\n                    methods.limitAll(self,method,values,limit).then(function(results){\n                        resolve(limitedResults.concat(results));\n                    });\n                }\n            });\n        });\n    };\n\n    return methods;\n}\n\nmodule.exports = limitedQ();\n```\n. @piglovesyou your'e absolutely right, any idea when it will be merged?\nGreat name btw :smiley: \n. here is what i wrote as a workaround for now...\n\n``` javascript\nvar Q = require('q');\n\nfunction limitedQ(){\n    var methods={};\n\n    methods.limitAll = function(self, method, values, limit){\n        return Q.promise(function(resolve){\n            var limitedPromises =[];\n\n            while(values.length>0 && limitedPromises.length<limit){\n                var args = values.shift();\n                if (args instanceof Array){\n                    limitedPromises.push(method.apply(self,args));\n                }else{\n                    limitedPromises.push(method.apply(self,[args]));\n                }\n            }\n\n            Q.all(limitedPromises).then(function(limitedResults){\n                if (limitedResults.length === 0){\n                    resolve(limitedResults);\n                }else {\n                    methods.limitAll(self,method,values,limit).then(function(results){\n                        resolve(limitedResults.concat(results));\n                    });\n                }\n            });\n        });\n    };\n\n    return methods;\n}\n\nmodule.exports = limitedQ();\n```\n. @piglovesyou your'e absolutely right, any idea when it will be merged?\nGreat name btw :smiley: \n. ",
    "ramakrishnan": "Hi is parallel task processing with concurrency available in the latest code? \n. @kriskowal I am expecting a function similar to q.all which can take an argument to limit the concurrency limit. Is it available here?\n. Hi is parallel task processing with concurrency available in the latest code? \n. @kriskowal I am expecting a function similar to q.all which can take an argument to limit the concurrency limit. Is it available here?\n. ",
    "heipei": "Hey @piglovesyou any updates on this? This was ages ago, still haven't across an idiomatic way to limit concurrency with Q (or any array of promises for that matter). Suggestions? I saw that your PR is still open.. Hey @piglovesyou any updates on this? This was ages ago, still haven't across an idiomatic way to limit concurrency with Q (or any array of promises for that matter). Suggestions? I saw that your PR is still open.. ",
    "Gennady77": "May you meen a chain of promises?\n. May you meen a chain of promises?\n. ",
    "alexprice1": "Hey guys,\n\nThanks for your feedback. This was due to my lack of understanding of promises. I had an example like this:\n\n```\npromiseThatReturnedError().fail(function(){\n    console.log('this failed');\n}).then(function(){\n    console.log('I thought this would not be called, but is being called');\n});\n```\n\nI believe that my 'then' is being called because the .fail returns a different promise. Is this correct? Thanks guys!\n. Hey guys,\n\nThanks for your feedback. This was due to my lack of understanding of promises. I had an example like this:\n\n```\npromiseThatReturnedError().fail(function(){\n    console.log('this failed');\n}).then(function(){\n    console.log('I thought this would not be called, but is being called');\n});\n```\n\nI believe that my 'then' is being called because the .fail returns a different promise. Is this correct? Thanks guys!\n. ",
    "sqreept": "Thanks a lot for the clarification.\n. Thanks a lot for the clarification.\n. ",
    "chrisbod": "This is proving really annoying- if any async call fails synchronously (as can most in browser e.g. xhr.send(), geolocation requests it means that exceptions fly all over the place since the fail handlers are added when the promise is returned - at the moment I'm just putting empty fail handlers on every single deferred's promise prior to making my 'async' call just to prevent the exceptions being thrown\n. This is proving really annoying- if any async call fails synchronously (as can most in browser e.g. xhr.send(), geolocation requests it means that exceptions fly all over the place since the fail handlers are added when the promise is returned - at the moment I'm just putting empty fail handlers on every single deferred's promise prior to making my 'async' call just to prevent the exceptions being thrown\n. ",
    "nknapp": "Thanks for the pointer. I see, what I mean has already been done, or can at least be achieved by inserting the following snippet into my nodeunit tests.\n\n```\nprocess.on(\"exit\",function() {\n    Q.getUnhandledReasons().forEach(function(item) {\n        console.error(\"Unhandled error in promise: \"+item);\n    });\n});\n```\n\nI agree that this does not help much in a production environment. But when developing with unit-tests, it might save some time.\n\nI might just bundle these few lines into a npm-package, so that they can be included in unit-tests.\n. I have made a small library for this problem: https://www.npmjs.com/package/q-deep\nIt's really tiny and it certainly doesn't work in all cases describe in the discussions here. But it can handle\nthings like  \n\n``` js\ndeep({\n    a: 1, \n    b: [ 2, Q(3) ]\n}).done(console.log); // == {a: 1, b: [2,3]}\n```\n\nand even nested promises, such as \n\n``` js\ndeep({\n    a: 1, \n    b: Q({ c: 2, d: Q(3) })\n}).done(console.log); // == { a: 1, b: { c: 2, d: 3 } }\n```\n\nI wrote it for myself have an easier way handling promises in objects.\n. Thanks for the quick reply. \nIt would have been helpful for me if `Q.all([2,2]).then(fn)` would have called `fn` immediately, because I would then have been able to use temporary data-structures that are cleaned at the end of the calling function.\nBut I have now [found the part in the docs now](https://github.com/kriskowal/q#tutorial) and [in the Promise A+ spec](https://promisesaplus.com/#point-34) that explicitly prohibit this behaviour and I can see why. So I'm closing this issue.\n. Thanks for the pointer. I see, what I mean has already been done, or can at least be achieved by inserting the following snippet into my nodeunit tests.\n\n```\nprocess.on(\"exit\",function() {\n    Q.getUnhandledReasons().forEach(function(item) {\n        console.error(\"Unhandled error in promise: \"+item);\n    });\n});\n```\n\nI agree that this does not help much in a production environment. But when developing with unit-tests, it might save some time.\n\nI might just bundle these few lines into a npm-package, so that they can be included in unit-tests.\n. I have made a small library for this problem: https://www.npmjs.com/package/q-deep\nIt's really tiny and it certainly doesn't work in all cases describe in the discussions here. But it can handle\nthings like  \n\n``` js\ndeep({\n    a: 1, \n    b: [ 2, Q(3) ]\n}).done(console.log); // == {a: 1, b: [2,3]}\n```\n\nand even nested promises, such as \n\n``` js\ndeep({\n    a: 1, \n    b: Q({ c: 2, d: Q(3) })\n}).done(console.log); // == { a: 1, b: { c: 2, d: 3 } }\n```\n\nI wrote it for myself have an easier way handling promises in objects.\n. Thanks for the quick reply. \nIt would have been helpful for me if `Q.all([2,2]).then(fn)` would have called `fn` immediately, because I would then have been able to use temporary data-structures that are cleaned at the end of the calling function.\nBut I have now [found the part in the docs now](https://github.com/kriskowal/q#tutorial) and [in the Promise A+ spec](https://promisesaplus.com/#point-34) that explicitly prohibit this behaviour and I can see why. So I'm closing this issue.\n. ",
    "leoselig": "+1 for this\ndebugging exceptions (or rather detecting where they occured) is a pain atm\n. +1 for this\ndebugging exceptions (or rather detecting where they occured) is a pain atm\n. ",
    "ardumont": "Hello,\n\n> How do we do this ourselves, when the readme gets changed?\n\nas you use a node stack, you could use https://github.com/thlorenz/doctoc.\n\nIf you use emacs, you could use markdown-toc https://github.com/ardumont/markdown-toc...\n\nThere surely exists other means.\n\nCheers,\n. > @arikon I don't think that updates the README though. And http://documentup.com/kriskowal/q/ already has a TOC, so I assume @ardumont is specifically interested in the README.\n\nYes, indeed.\nBut automate this thing is a good idea for you as maintainers.\n. Hello,\n\n> How do we do this ourselves, when the readme gets changed?\n\nas you use a node stack, you could use https://github.com/thlorenz/doctoc.\n\nIf you use emacs, you could use markdown-toc https://github.com/ardumont/markdown-toc...\n\nThere surely exists other means.\n\nCheers,\n. > @arikon I don't think that updates the README though. And http://documentup.com/kriskowal/q/ already has a TOC, so I assume @ardumont is specifically interested in the README.\n\nYes, indeed.\nBut automate this thing is a good idea for you as maintainers.\n. ",
    "jtmarmon": "@piglovesyou thanks so much for this pr. ran into this weird edge case today when dealing with a worker task processing an array of ~28k elements. \n\nhow many concurrent items should I be processing? 5? 10? 100?\n. hmm, it's odd, I tried reducing the number a fair amount and couldn't quite get anything to work. I ended up resorting to async as a temporary replacement\n. no error log, the `.then` simply never gets called.\n\nessentially the program looks like\n\n```\ndoThing()\n.then(function() {\n  return Q.all(R.map(execute, data));\n})\n```\n\nWorks perfectly fine with 50 data points. Not so with 28,000.  I tried it with your code, replacing line 3 with `return Q.consume(execute, data, 50)` to no avail. Again, the .then wrapping this method was never executed \n. @piglovesyou thanks so much for this pr. ran into this weird edge case today when dealing with a worker task processing an array of ~28k elements. \n\nhow many concurrent items should I be processing? 5? 10? 100?\n. hmm, it's odd, I tried reducing the number a fair amount and couldn't quite get anything to work. I ended up resorting to async as a temporary replacement\n. no error log, the `.then` simply never gets called.\n\nessentially the program looks like\n\n```\ndoThing()\n.then(function() {\n  return Q.all(R.map(execute, data));\n})\n```\n\nWorks perfectly fine with 50 data points. Not so with 28,000.  I tried it with your code, replacing line 3 with `return Q.consume(execute, data, 50)` to no avail. Again, the .then wrapping this method was never executed \n. ",
    "CarlosCuevas": "Experiencing the same issue.  Will this be merged anytime soon?\n. Experiencing the same issue.  Will this be merged anytime soon?\n. ",
    "joscha": "after it is:\n\n``` console\n.\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 bower.json\n\u251c\u2500\u2500 q.js\n\u2514\u2500\u2500 queue.js\n```\n. @domenic if you merged that pull request it could be a supported scenario?!\n. unfortunately putting it in the package.json does not work - I guess everyone using it via bower has to exclude the resources in the build step manually then...\n. looks good, the `noConflict` API is broken deliberately (no return any more)? \n. after it is:\n\n``` console\n.\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 bower.json\n\u251c\u2500\u2500 q.js\n\u2514\u2500\u2500 queue.js\n```\n. @domenic if you merged that pull request it could be a supported scenario?!\n. unfortunately putting it in the package.json does not work - I guess everyone using it via bower has to exclude the resources in the build step manually then...\n. looks good, the `noConflict` API is broken deliberately (no return any more)? \n. ",
    "grahamscott": "+1 This is causing us issues in our build step, as we're running everything through uglify, which then pukes on the examples directory. We can work around it, but I dont think these superfluous files should be pulled down by bower.\n. +1 This is causing us issues in our build step, as we're running everything through uglify, which then pukes on the examples directory. We can work around it, but I dont think these superfluous files should be pulled down by bower.\n. ",
    "miketeix": "Hey thanks for outlining this, i believe I have the same problem.\n\nSimilarly, I've created an array of promises, each promise consisting of a long promise chain itself.\n\nQ.all gets through 80% of the promises and then stalls...\n. @cfurst thanks for circling back, it moved me to really comb through each step in the promise chain. Turns out there was a boolean check that was preventing the callback from being called, and so those promises that were failing the check were never being resolved.\n\nThis issue can be closed now, cheers!\n. Hey thanks for outlining this, i believe I have the same problem.\n\nSimilarly, I've created an array of promises, each promise consisting of a long promise chain itself.\n\nQ.all gets through 80% of the promises and then stalls...\n. @cfurst thanks for circling back, it moved me to really comb through each step in the promise chain. Turns out there was a boolean check that was preventing the callback from being called, and so those promises that were failing the check were never being resolved.\n\nThis issue can be closed now, cheers!\n. ",
    "cfurst": "I\u2019ve actually figured it out. It really was a promise that was not resolving or the function was  returning a value instead of a promise and thus the process was \u201ccrashing\".. I forget which..\n\n## Carl Furst\n\nFrom: miketeix <notifications@github.com<mailto:notifications@github.com>>\nReply-To: kriskowal/q <reply@reply.github.com<mailto:reply@reply.github.com>>\nDate: Tuesday, November 3, 2015 at 1:29 PM\nTo: kriskowal/q <q@noreply.github.com<mailto:q@noreply.github.com>>\nCc: Carl Furst <carl.furst@mlb.com<mailto:carl.furst@mlb.com>>\nSubject: Re: [q] problem with Q.all(promises) (#635)\n\nHey thanks for outlining this so well. I've run into this issue as well.\n\nSimilarly, I've created an array of promises, each promise consisting of a long promise chain itself.\n\nQ.all gets through 80% of the promises and then stalls...\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/635#issuecomment-153446394.\n\n---\n\nMLB.com: Where Baseball is Always On\n. Apologies for not posting that sooner.. You\u2019re welcome!\n\n## Carl Furst\n\nFrom: miketeix <notifications@github.com<mailto:notifications@github.com>>\nReply-To: kriskowal/q <reply@reply.github.com<mailto:reply@reply.github.com>>\nDate: Wednesday, November 4, 2015 at 3:54 PM\nTo: kriskowal/q <q@noreply.github.com<mailto:q@noreply.github.com>>\nCc: Carl Furst <carl.furst@mlb.com<mailto:carl.furst@mlb.com>>\nSubject: Re: [q] problem with Q.all(promises) (#635)\n\n@cfursthttps://github.com/cfurst thanks for circling back, it moved me to really comb through each step in the promise chain. Turns out there was a boolean check that was preventing the callback from being called, and so those promises that were failing the check were never being resolved.\n\nI'll close the issue, cheers!\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/635#issuecomment-153862302.\n. I\u2019ve actually figured it out. It really was a promise that was not resolving or the function was  returning a value instead of a promise and thus the process was \u201ccrashing\".. I forget which..\n\n## Carl Furst\n\nFrom: miketeix <notifications@github.com<mailto:notifications@github.com>>\nReply-To: kriskowal/q <reply@reply.github.com<mailto:reply@reply.github.com>>\nDate: Tuesday, November 3, 2015 at 1:29 PM\nTo: kriskowal/q <q@noreply.github.com<mailto:q@noreply.github.com>>\nCc: Carl Furst <carl.furst@mlb.com<mailto:carl.furst@mlb.com>>\nSubject: Re: [q] problem with Q.all(promises) (#635)\n\nHey thanks for outlining this so well. I've run into this issue as well.\n\nSimilarly, I've created an array of promises, each promise consisting of a long promise chain itself.\n\nQ.all gets through 80% of the promises and then stalls...\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/635#issuecomment-153446394.\n\n---\n\nMLB.com: Where Baseball is Always On\n. Apologies for not posting that sooner.. You\u2019re welcome!\n\n## Carl Furst\n\nFrom: miketeix <notifications@github.com<mailto:notifications@github.com>>\nReply-To: kriskowal/q <reply@reply.github.com<mailto:reply@reply.github.com>>\nDate: Wednesday, November 4, 2015 at 3:54 PM\nTo: kriskowal/q <q@noreply.github.com<mailto:q@noreply.github.com>>\nCc: Carl Furst <carl.furst@mlb.com<mailto:carl.furst@mlb.com>>\nSubject: Re: [q] problem with Q.all(promises) (#635)\n\n@cfursthttps://github.com/cfurst thanks for circling back, it moved me to really comb through each step in the promise chain. Turns out there was a boolean check that was preventing the callback from being called, and so those promises that were failing the check were never being resolved.\n\nI'll close the issue, cheers!\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/kriskowal/q/issues/635#issuecomment-153862302.\n. ",
    "reiz": "+1 \n. +1 \n. ",
    "domarmstrong": "The problem is this in flush: \n\n``` javascript\n           try {\n                task();\n\n            } catch (e) {\n                if (isNodeJS) {\n                    // In node, uncaught exceptions are considered fatal errors.\n                    // Re-throw them synchronously to interrupt flushing!\n\n                    // Ensure continuation if the uncaught exception is suppressed\n                    // listening \"uncaughtException\" events (as domains does).\n                    // Continue in next event to avoid tick recursion.\n                    if (domain) {\n                        domain.exit();\n                    }\n                    setTimeout(flush, 0);\n                    if (domain) {\n                        domain.enter();\n                    }\n\n                    throw e;\n\n                } else {\n                    // In browsers, uncaught exceptions are not fatal.\n                    // Re-throw them asynchronously to avoid slow-downs.\n                    setTimeout(function() {\n                       throw e;\n                    }, 0);\n                }\n            }\n```\n\nIt thinks that the browser `isNodeJS` and is therefore throwing errors synchronously instead of async as it would otherwise and flush is not completing.\n. The problem is this in flush: \n\n``` javascript\n           try {\n                task();\n\n            } catch (e) {\n                if (isNodeJS) {\n                    // In node, uncaught exceptions are considered fatal errors.\n                    // Re-throw them synchronously to interrupt flushing!\n\n                    // Ensure continuation if the uncaught exception is suppressed\n                    // listening \"uncaughtException\" events (as domains does).\n                    // Continue in next event to avoid tick recursion.\n                    if (domain) {\n                        domain.exit();\n                    }\n                    setTimeout(flush, 0);\n                    if (domain) {\n                        domain.enter();\n                    }\n\n                    throw e;\n\n                } else {\n                    // In browsers, uncaught exceptions are not fatal.\n                    // Re-throw them asynchronously to avoid slow-downs.\n                    setTimeout(function() {\n                       throw e;\n                    }, 0);\n                }\n            }\n```\n\nIt thinks that the browser `isNodeJS` and is therefore throwing errors synchronously instead of async as it would otherwise and flush is not completing.\n. ",
    "calvinmetcalf": "can confirm Q does some funky stuff in browserify because it thinks it's in node\n. can confirm Q does some funky stuff in browserify because it thinks it's in node\n. ",
    "pho3nixf1re": "This happens with Webpack as well. It's killing our test suite and causing early exits instead of just test failures. It is definitely a bug with the flush in Q and not with the shim's in browserify and webpack.\n. This happens with Webpack as well. It's killing our test suite and causing early exits instead of just test failures. It is definitely a bug with the flush in Q and not with the shim's in browserify and webpack.\n. ",
    "vergara": "@kriskowal \nI thought this method could be useful.\n. How would you implement the same capability using Q.race? I thought about it and couldn't come up with something.\n\nThe problem with Q.race is that it rejects with the first rejected promise, and it's not possible to resolve with the value of a promise resolved later.\n\nIf you use Q.allSettled, then you have to wait for all promises to come out of pending to finally resolve, even though you could have been done much earlier.\n\nMy implementation is the fastest way to resolve with the first resolved promise, and only if everything rejects, then wait for all promises to be done and reject.\n\nI would be happy to work more on improving the documentation or the tests, with help of your feedback.\n. I think that will not do: if the first promise to become not pending with race happens to be rejected, you will have to wait for all promises to become not pending to find the first one that was fulfilled using allSettled. Ideally I would like to finish as soon as I have a resolved promise. Here is a use case: let's say you want to get some data which is the same or similar from many different sources. You would like to finish as soon as you get the first promise resolving with the data you need. If attempts to get the data from other sources fail, just ignore those rejected promises. \n. Yes, exactly that. So, what do you think?\n. @kriskowal \nUpdated.\n\nI was not able to re-open the previous PR.\n\nDo you have any feedback regarding the tests?\n. @kriskowal \nI was not able to replace the for loop with array_reduce: reduce skips the holes in the array and since my counter depends on the length of the array, I was unable to detect undefined and decrease the counter. That made the reject for sparse array test fail.\nAll other comments were addressed.\n. @kriskowal \nUpdated.\n. @kriskowal \nUpdated.\n. @kriskowal \nI thought this method could be useful.\n. How would you implement the same capability using Q.race? I thought about it and couldn't come up with something.\n\nThe problem with Q.race is that it rejects with the first rejected promise, and it's not possible to resolve with the value of a promise resolved later.\n\nIf you use Q.allSettled, then you have to wait for all promises to come out of pending to finally resolve, even though you could have been done much earlier.\n\nMy implementation is the fastest way to resolve with the first resolved promise, and only if everything rejects, then wait for all promises to be done and reject.\n\nI would be happy to work more on improving the documentation or the tests, with help of your feedback.\n. I think that will not do: if the first promise to become not pending with race happens to be rejected, you will have to wait for all promises to become not pending to find the first one that was fulfilled using allSettled. Ideally I would like to finish as soon as I have a resolved promise. Here is a use case: let's say you want to get some data which is the same or similar from many different sources. You would like to finish as soon as you get the first promise resolving with the data you need. If attempts to get the data from other sources fail, just ignore those rejected promises. \n. Yes, exactly that. So, what do you think?\n. @kriskowal \nUpdated.\n\nI was not able to re-open the previous PR.\n\nDo you have any feedback regarding the tests?\n. @kriskowal \nI was not able to replace the for loop with array_reduce: reduce skips the holes in the array and since my counter depends on the length of the array, I was unable to detect undefined and decrease the counter. That made the reject for sparse array test fail.\nAll other comments were addressed.\n. @kriskowal \nUpdated.\n. @kriskowal \nUpdated.\n. ",
    "dhartunian": "When I downgraded to the previous node version that was available via brew: v0.10.36, the problem went away.\n. When I downgraded to the previous node version that was available via brew: v0.10.36, the problem went away.\n. ",
    "VanDalkvist": "+1 It'll be great to get this feature\n. Great solution for me :) But if I understand right, we can write it like:\n\n``` javascript\nQ.superAll = function (obj) {\n    var keys = _.keys(obj);\n    return Q.spread(_.values(obj), function () {\n            return _.zipObject(keys, arguments);\n        });\n};\n```\n\nAm I right?\n. Yep, I understand, works great. Thank you\n. +1 It'll be great to get this feature\n. Great solution for me :) But if I understand right, we can write it like:\n\n``` javascript\nQ.superAll = function (obj) {\n    var keys = _.keys(obj);\n    return Q.spread(_.values(obj), function () {\n            return _.zipObject(keys, arguments);\n        });\n};\n```\n\nAm I right?\n. Yep, I understand, works great. Thank you\n. ",
    "AlicanC": "For now, you can at least get some help from `promise.spread` and [lodash](https://lodash.com/) to make it more convenient:\n\n``` javascript\nQ.all([\n    Article.findById(request.query.id),\n    Comment.find({articleId:request.query.id})\n])\n.spread(function () {\n\n    var result = _.zipObject(['article', 'comments'], arguments);\n\n    response.render(\"article.hbs\", result);\n\n})\n.done();\n```\n\n---\n\nYou could also implement your request like this:\n\n``` javascript\nQ.superAll = function (obj) {\n\n    var keys = _.keys(obj);\n\n    return Q.all(_.values(obj))\n        .spread(function () {\n\n            return _.zipObject(keys, arguments);\n\n        });\n\n};\n```\n\nand use it like:\n\n``` javascript\nQ.superAll({\n    article: Article.findById(request.query.id),\n    comments: Comment.find({articleId:request.query.id})\n})\n.then(function(result){\n    response.render(\"article.hbs\", result);\n})\n.done();\n```\n\nNote 1: I haven't tested the code but even if it doesn't work, I'm sure you all get the idea.\nNote 2: I am not voting for or against this feature.\n. I just find it better to keep things more understandable in discussions like this. You also don't need to assign keys to a variable.\n. This could be a use case in browser with jQuery:\n\n``` javascript\nQ.emitterPromise(jQuery('img.myImage'), 'load')\n    .then(resolveCallback)\n    .catch(rejectCallback);\n```\n\n(It gets resolved when \"load\" fires and rejected when \"error\" fires.)\n. Another use case with Bower's programmatic API:\n\n``` javascript\nQ.emitterPromise(bower.commands.list(), 'end')\n    .then(function (list) {\n        console.dir(list);\n    });\n```\n. For now, you can at least get some help from `promise.spread` and [lodash](https://lodash.com/) to make it more convenient:\n\n``` javascript\nQ.all([\n    Article.findById(request.query.id),\n    Comment.find({articleId:request.query.id})\n])\n.spread(function () {\n\n    var result = _.zipObject(['article', 'comments'], arguments);\n\n    response.render(\"article.hbs\", result);\n\n})\n.done();\n```\n\n---\n\nYou could also implement your request like this:\n\n``` javascript\nQ.superAll = function (obj) {\n\n    var keys = _.keys(obj);\n\n    return Q.all(_.values(obj))\n        .spread(function () {\n\n            return _.zipObject(keys, arguments);\n\n        });\n\n};\n```\n\nand use it like:\n\n``` javascript\nQ.superAll({\n    article: Article.findById(request.query.id),\n    comments: Comment.find({articleId:request.query.id})\n})\n.then(function(result){\n    response.render(\"article.hbs\", result);\n})\n.done();\n```\n\nNote 1: I haven't tested the code but even if it doesn't work, I'm sure you all get the idea.\nNote 2: I am not voting for or against this feature.\n. I just find it better to keep things more understandable in discussions like this. You also don't need to assign keys to a variable.\n. This could be a use case in browser with jQuery:\n\n``` javascript\nQ.emitterPromise(jQuery('img.myImage'), 'load')\n    .then(resolveCallback)\n    .catch(rejectCallback);\n```\n\n(It gets resolved when \"load\" fires and rejected when \"error\" fires.)\n. Another use case with Bower's programmatic API:\n\n``` javascript\nQ.emitterPromise(bower.commands.list(), 'end')\n    .then(function (list) {\n        console.dir(list);\n    });\n```\n. ",
    "TrejGun": "thx to all for your help\n. thx to all for your help\n. ",
    "zanona": "I just spotted that I was doing a great mistake by calling a method inside `thenResolve`.\nThe method will be triggered during runtime and not after the previous declaration.\n. I just spotted that I was doing a great mistake by calling a method inside `thenResolve`.\nThe method will be triggered during runtime and not after the previous declaration.\n. ",
    "lud2k": "same thing here\n. same thing here\n. ",
    "torvalde": "I installed node 0.12.2 and removed longjohn from my app (It is a confirmed problem with that and node 0.12) After this things seems to work again. I believe this issue can be closed.\n. yes\n. I installed node 0.12.2 and removed longjohn from my app (It is a confirmed problem with that and node 0.12) After this things seems to work again. I believe this issue can be closed.\n. yes\n. ",
    "dsiegel": "Are you referring to this: https://github.com/mattinsler/longjohn/issues/37\n. Are you referring to this: https://github.com/mattinsler/longjohn/issues/37\n. ",
    "michipili": "I submitted a PR checking for the argument being an array _and_ its elements being promises. The original code of `Q.all` sometimes checks if elements of the array are promises but does not does this on all its paths.\n\n@nknapp @kriskowal @vingiarrusso @arikon I would be happy to hear your comments about #701! Maybe #700 can be merged with this ticket.\n\nReferences #700, #701.\n. @vingiarrusso I see, I overlooked that `CONTRIBUTE.md` file. The main contribution in my branch is the use of `isPromise` to validate items of the array-like arguments, maybe you would like to build this in your own branch?  The call would then be\n\n```\nArray.prototype.every.call(arrraylike, isPromise)\n```\n\ninstead of\n\n```\ntruearray.every(isPromise)\n```\n\nIn the code, there is a validation [which does not happen on each execution paths](https://github.com/michipili/q/commit/9518c0588469522007d26f5d2ae62fb080c1b536#diff-a148bc52a39c990d02038097d8177455L1568), this should be fixed.\n\nRefs: https://github.com/michipili/q/commit/9518c0588469522007d26f5d2ae62fb080c1b536#diff-a148bc52a39c990d02038097d8177455R1564\n. I submitted a PR checking for the argument being an array _and_ its elements being promises. The original code of `Q.all` sometimes checks if elements of the array are promises but does not does this on all its paths.\n\n@nknapp @kriskowal @vingiarrusso @arikon I would be happy to hear your comments about #701! Maybe #700 can be merged with this ticket.\n\nReferences #700, #701.\n. @vingiarrusso I see, I overlooked that `CONTRIBUTE.md` file. The main contribution in my branch is the use of `isPromise` to validate items of the array-like arguments, maybe you would like to build this in your own branch?  The call would then be\n\n```\nArray.prototype.every.call(arrraylike, isPromise)\n```\n\ninstead of\n\n```\ntruearray.every(isPromise)\n```\n\nIn the code, there is a validation [which does not happen on each execution paths](https://github.com/michipili/q/commit/9518c0588469522007d26f5d2ae62fb080c1b536#diff-a148bc52a39c990d02038097d8177455L1568), this should be fixed.\n\nRefs: https://github.com/michipili/q/commit/9518c0588469522007d26f5d2ae62fb080c1b536#diff-a148bc52a39c990d02038097d8177455R1564\n. ",
    "Havvy": "You're fundamentally failing to understand how promises work. You're basically looking at a screw and asking for it to be changed into a Hammer because you tried to screw in a nail.\n\nPromises will never be resettable. That violates one the invariants - that a promise is only resolved once.\n\nWhat you are describing sounds to me like you want to create a pipeline, probably by using a Stream of some sort. Node.js/io.js has a Stream based on an Event Emitter, and it should work for what you want. I've yet to see an abstraction for pipelines in a similar vein of Promises being an abstraction for an asynchronous return value. The Stream code is itself \"pure\", and there are other Stream implementations too, for client side code. Plus browserify.\n. Yeah, I'm not always very good at putting sympathy first. It's my natural state, but I forget that it's not visible to others. Your link is interesting, and I'm going to read it.\n. You're fundamentally failing to understand how promises work. You're basically looking at a screw and asking for it to be changed into a Hammer because you tried to screw in a nail.\n\nPromises will never be resettable. That violates one the invariants - that a promise is only resolved once.\n\nWhat you are describing sounds to me like you want to create a pipeline, probably by using a Stream of some sort. Node.js/io.js has a Stream based on an Event Emitter, and it should work for what you want. I've yet to see an abstraction for pipelines in a similar vein of Promises being an abstraction for an asynchronous return value. The Stream code is itself \"pure\", and there are other Stream implementations too, for client side code. Plus browserify.\n. Yeah, I'm not always very good at putting sympathy first. It's my natural state, but I forget that it's not visible to others. Your link is interesting, and I'm going to read it.\n. ",
    "dtheodor": "Hey thanks for the feedback.\n\nI had looked both at signals and reactive libraries (streams). The thing is that the Promise API is very close to what I need, because it combines\n1. chaining of post-processing (reactive does this too, and better)\n2. information about whether a request is ongoing (unresolved promise). I could not find any concept of this in a reactive library (maybe I did not look good enough)\n3. the API itself is exactly the API I need to consume, unlike signals or streams where more work needs to be done\n\nI know my use-case can be implemented with signals, which I did.\n\nHowever I opened the issue to ask why can a promise not being reset (and in case I missed the hidden reset API somewhere). Is this the argument against mutability?\n\nNone of the following statements answer the why.\n\n> You're fundamentally failing to understand how promises work. You're basically looking at a screw > and asking for it to be changed into a Hammer because you tried to screw in a nail.\n> \n> Promises will never be resettable. That violates one the invariants - that a promise is only resolved > once.\n. Ok I can see that argument. You treat a promise as an immutable future value, while I wanted to use it more like an event to chain callbacks on.\n. Hey thanks for the feedback.\n\nI had looked both at signals and reactive libraries (streams). The thing is that the Promise API is very close to what I need, because it combines\n1. chaining of post-processing (reactive does this too, and better)\n2. information about whether a request is ongoing (unresolved promise). I could not find any concept of this in a reactive library (maybe I did not look good enough)\n3. the API itself is exactly the API I need to consume, unlike signals or streams where more work needs to be done\n\nI know my use-case can be implemented with signals, which I did.\n\nHowever I opened the issue to ask why can a promise not being reset (and in case I missed the hidden reset API somewhere). Is this the argument against mutability?\n\nNone of the following statements answer the why.\n\n> You're fundamentally failing to understand how promises work. You're basically looking at a screw > and asking for it to be changed into a Hammer because you tried to screw in a nail.\n> \n> Promises will never be resettable. That violates one the invariants - that a promise is only resolved > once.\n. Ok I can see that argument. You treat a promise as an immutable future value, while I wanted to use it more like an event to chain callbacks on.\n. ",
    "joepie91": "@dtheodor This may be useful for your usecase: http://highlandjs.org/\n. @dtheodor This may be useful for your usecase: http://highlandjs.org/\n. ",
    "euwest": "There isn't really a clean way to track the progress of `promiseB` within that chain, whereas `after` allows for:\n\n``` js\n...\npromiseA\n    .after(promiseB, progressOfB)\n    .then(continueWithA, dealWithRejection);\n```\n. Also in your alternative if both promises are rejected `promiseA` will be passed to `dealWithRejection`. With `after`, `promiseB` takes precedence(which--I think--is conveyed semantically when reading the chain `promise.after(otherPromise).then(...)` ). To get this behavior within the confines of `then` and `thenResolve` you would need to have something like this:\n\n``` js\n...\npromiseA\n    .then(function(res) {\n        return promiseB.thenResolve(res);\n    }, function(err) {\n        return promiseB.thenReject(err);\n    })\n    .then(continueWithA, dealWithRejection);\n```\n\n...at which point I feel like it's worthwhile to encapsulate that behavior within a single function.\n. > As such, it might be good to implement after in terms of all in v2.\n\nSounds good. I'll give that a shot and make a pull against v2 for further mulling.\n. There isn't really a clean way to track the progress of `promiseB` within that chain, whereas `after` allows for:\n\n``` js\n...\npromiseA\n    .after(promiseB, progressOfB)\n    .then(continueWithA, dealWithRejection);\n```\n. Also in your alternative if both promises are rejected `promiseA` will be passed to `dealWithRejection`. With `after`, `promiseB` takes precedence(which--I think--is conveyed semantically when reading the chain `promise.after(otherPromise).then(...)` ). To get this behavior within the confines of `then` and `thenResolve` you would need to have something like this:\n\n``` js\n...\npromiseA\n    .then(function(res) {\n        return promiseB.thenResolve(res);\n    }, function(err) {\n        return promiseB.thenReject(err);\n    })\n    .then(continueWithA, dealWithRejection);\n```\n\n...at which point I feel like it's worthwhile to encapsulate that behavior within a single function.\n. > As such, it might be good to implement after in terms of all in v2.\n\nSounds good. I'll give that a shot and make a pull against v2 for further mulling.\n. ",
    "aadamsx": "Thanks a lot Kris.\n\nI think I've almost got things working with your Q library.  One issue I can't get past is that some files can be written in parallel and sometimes I need the files to completely finish writing, as the next function needs access to them.\n\nHere's what I have so far:\n\n```\n  makeDirectory(filebox)\n    .then(writeFile(file1, data))\n    .then(writeFile(file2, data))\n    .then(writeFile(file3, data))\n    .then(ExternalLibrary._DoSomethingWithWrittenFiles(file1))\n    .then(ExternalLibrary._DoSomethingWithWrittenFiles(file2))\n    .then(ExternalLibrary._DoSomethingWithWrittenFiles(file3))\n    .then(ExternalLibrary._PerformAnotherOperationOnFiles(file1, file2))\n    .then(readFile(filel1))\n    .then(function (result) { //output from readFile\n      console.log('after read file', result);\n      res.write(result);\n      res.end();\n    })\n    .catch(function (error) {\n      console.log('catch error', error);\n    })\n    .done(function (result) {\n      console.log('done', result);\n    });\n```\n\nThe writeFile methods can all run in parallel, but the ExternalLibrary functions need these files to finish writing completely before it can perform it's work -- _right now when node gets to the ExternalLibrary calls I get an error stating that the files don't exist_.  \n\nThis is what my deferred functions look like:\n\n```\nwriteFile = function (dst, data) {\n  console.log('desination:', dst);\n  // console.log('data:', data);\n  var fs = Npm.require('fs');\n  var deferred = Q.defer();\n  fs.writeFile(dst, data, function (err, result) {\n    if (err) {\n      deferred.reject(new Error(err));\n    }\n    else {\n      deferred.resolve();\n    }\n  });\n  return deferred.promise;\n}\n\nreadFile = function (src) {\n  var fs = Npm.require('fs');\n  var deferred = Q.defer();\n  fs.readFile(src, function (err, result) {\n    if (err) {\n      deferred.reject(new Error(err));\n    }\n    else {\n      // console.log('readFile method, with result:', result);\n      deferred.resolve(result);\n    }\n  });\n  return deferred.promise;\n}\n\nmakeDirectory = function (dst) {\n  var fs = Npm.require('fs');\n  var deferred = Q.defer();\n  fs.mkdir(dst, function (err, result) {\n    if(!err || err.code === 'EEXIST') {\n      deferred.resolve();\n    }\n    else {\n      deferred.reject(err);\n    }\n  });\n  return deferred.promise;\n}\n```\n\nAnd this is a sample of what the ExternalLibrary looks like:\n\n```\n ExternalLibrary._DoSomethingWithWrittenFiles = function(file) {\n   var deferred = Q.defer();\n   ExternalLibrary.executeCommand([file, 'do_something', 'output ', output], function (error) {\n     if (error) {\n       console.log(error);\n       deferred.reject(new Error(error));\n     }\n     else {\n       deferred.resolve();\n     }\n   });\n   return deferred.promise;\n };\n\nExternalLibrary.executeCommand = function (args, callback) {\n  var command = 'file_command ' + args.join(' ');\n  console.log(command);\n  exec(command, {encoding: 'binary', maxBuffer: 1024 * 1000}, function(err, stdout, stderr) {\n    if(err) return callback(new Error(err));\n    callback(null);\n  });\n};\n```\n. Thanks @arikon, but what I ended up doing was just passing an object around like so:\n\n```\nvar obj = {};\n\npromiseFunction(obj)\n.then(function (obj_returned) {\n  var deferred = Q.defer();\n\n  obj_returned.file = \"filename.txt\";\n  obj_returned.datas = \"data to write\";\n\n  deferred.resolve(obj_returned);\n  return deferred.promise;\n})\n.then(function (obj_returned_again) {\n  var deferred = Q.defer();\n\n  // now I have both values\n  var do_something = obj_returned_again.file;\n  var do_something_else = obj_returned_again.datas;\n\n  deferred.resolve();\n  return deferred.promise;\n})\n.done();\n```\n. I've posted a SO question on this topic: http://stackoverflow.com/questions/28993673/when-to-make-a-function-deferred-using-promises\n. Thanks a lot Kris.\n\nI think I've almost got things working with your Q library.  One issue I can't get past is that some files can be written in parallel and sometimes I need the files to completely finish writing, as the next function needs access to them.\n\nHere's what I have so far:\n\n```\n  makeDirectory(filebox)\n    .then(writeFile(file1, data))\n    .then(writeFile(file2, data))\n    .then(writeFile(file3, data))\n    .then(ExternalLibrary._DoSomethingWithWrittenFiles(file1))\n    .then(ExternalLibrary._DoSomethingWithWrittenFiles(file2))\n    .then(ExternalLibrary._DoSomethingWithWrittenFiles(file3))\n    .then(ExternalLibrary._PerformAnotherOperationOnFiles(file1, file2))\n    .then(readFile(filel1))\n    .then(function (result) { //output from readFile\n      console.log('after read file', result);\n      res.write(result);\n      res.end();\n    })\n    .catch(function (error) {\n      console.log('catch error', error);\n    })\n    .done(function (result) {\n      console.log('done', result);\n    });\n```\n\nThe writeFile methods can all run in parallel, but the ExternalLibrary functions need these files to finish writing completely before it can perform it's work -- _right now when node gets to the ExternalLibrary calls I get an error stating that the files don't exist_.  \n\nThis is what my deferred functions look like:\n\n```\nwriteFile = function (dst, data) {\n  console.log('desination:', dst);\n  // console.log('data:', data);\n  var fs = Npm.require('fs');\n  var deferred = Q.defer();\n  fs.writeFile(dst, data, function (err, result) {\n    if (err) {\n      deferred.reject(new Error(err));\n    }\n    else {\n      deferred.resolve();\n    }\n  });\n  return deferred.promise;\n}\n\nreadFile = function (src) {\n  var fs = Npm.require('fs');\n  var deferred = Q.defer();\n  fs.readFile(src, function (err, result) {\n    if (err) {\n      deferred.reject(new Error(err));\n    }\n    else {\n      // console.log('readFile method, with result:', result);\n      deferred.resolve(result);\n    }\n  });\n  return deferred.promise;\n}\n\nmakeDirectory = function (dst) {\n  var fs = Npm.require('fs');\n  var deferred = Q.defer();\n  fs.mkdir(dst, function (err, result) {\n    if(!err || err.code === 'EEXIST') {\n      deferred.resolve();\n    }\n    else {\n      deferred.reject(err);\n    }\n  });\n  return deferred.promise;\n}\n```\n\nAnd this is a sample of what the ExternalLibrary looks like:\n\n```\n ExternalLibrary._DoSomethingWithWrittenFiles = function(file) {\n   var deferred = Q.defer();\n   ExternalLibrary.executeCommand([file, 'do_something', 'output ', output], function (error) {\n     if (error) {\n       console.log(error);\n       deferred.reject(new Error(error));\n     }\n     else {\n       deferred.resolve();\n     }\n   });\n   return deferred.promise;\n };\n\nExternalLibrary.executeCommand = function (args, callback) {\n  var command = 'file_command ' + args.join(' ');\n  console.log(command);\n  exec(command, {encoding: 'binary', maxBuffer: 1024 * 1000}, function(err, stdout, stderr) {\n    if(err) return callback(new Error(err));\n    callback(null);\n  });\n};\n```\n. Thanks @arikon, but what I ended up doing was just passing an object around like so:\n\n```\nvar obj = {};\n\npromiseFunction(obj)\n.then(function (obj_returned) {\n  var deferred = Q.defer();\n\n  obj_returned.file = \"filename.txt\";\n  obj_returned.datas = \"data to write\";\n\n  deferred.resolve(obj_returned);\n  return deferred.promise;\n})\n.then(function (obj_returned_again) {\n  var deferred = Q.defer();\n\n  // now I have both values\n  var do_something = obj_returned_again.file;\n  var do_something_else = obj_returned_again.datas;\n\n  deferred.resolve();\n  return deferred.promise;\n})\n.done();\n```\n. I've posted a SO question on this topic: http://stackoverflow.com/questions/28993673/when-to-make-a-function-deferred-using-promises\n. ",
    "richzw": "Ok, I got answer from [here](http://stackoverflow.com/questions/28956946/how-to-add-promise-to-event-handler-in-javascript)\n. Ok, I got answer from [here](http://stackoverflow.com/questions/28956946/how-to-add-promise-to-event-handler-in-javascript)\n. ",
    "bpq": "I've wondered about this myself. Quoting from the SO answer:\n- make synchronous functions synchronous - no need for promises\n- make all asynchronous functions always return a promise\n- use deferreds only at the lowest possible level for promisification\n\nI think the right thing is to make all functions deferred like\n\n``` js\ndo_something(variable)\n.then(do_something_else)\n.then(writeData)\n.then(do_something_last)\n.done();\n```\n. I've wondered about this myself. Quoting from the SO answer:\n- make synchronous functions synchronous - no need for promises\n- make all asynchronous functions always return a promise\n- use deferreds only at the lowest possible level for promisification\n\nI think the right thing is to make all functions deferred like\n\n``` js\ndo_something(variable)\n.then(do_something_else)\n.then(writeData)\n.then(do_something_last)\n.done();\n```\n. ",
    "stevekinney": "Whoops. :angel: \n. Whoops. :angel: \n. ",
    "BerkeleyTrue": "Okay sweet. Looking forward to it. I will close this issue.\n. Okay sweet. Looking forward to it. I will close this issue.\n. ",
    "panuhorsmalahti": "Ah, there's already a files array in package.json.\n. Ah, there's already a files array in package.json.\n. ",
    "dmm9": "I thought that rule was of the kind promise2 = ReadMyFiles.\nHowever, from [https://promisesaplus.com/]:\n\n2.2.6 'then' may be called multiple times on the same promise.\n2.2.6.1 If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.\n2.2.6.2 If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.\n. Wheather synchronous or asynchronous, **all respective onRejected callbacks must execute**, and furthermore **must execute in the order of their originating calls to then** (per series nature of the promise.then().then() structure).\nIn my snippet not all the onRejected callbacks are executed. The promise 'ReadMyFiles' is clearly rejected and it executes an onFulfilled callback.\n. OK got it. I will explain it just in case someone gets to the same misunderstanding:\n\nEach promise has ONLY ONE _then_. So in order to chain the _then_ operations (serialize the execution) it must be clear that _then_ returns a promise and consequently:\n\n_promise.then().then()_ is the equivalent of _subpromise(promise.then()).then()_\n\nSo the first (and consecutive) promise.then() should 'throw' the error to keep the chain being rejected. Therefore, in order to serial-execute several commands when one promise has been rejected, this would be the recommended code:\n\n``` javascript\npromise\n.then(\n    function(value) {\n        /* onFulfilled operations here */\n    },\n    function(reason) {\n        /* onRejected operations here */\n        throw reason; // to keep the Rejected status\n)\n.then (\n    function(value) { \n        /* onFulfilled operations here */\n    },\n    function(reason) {\n        /* onRejected operations here */\n        throw reason; // to keep the Rejected status\n)\n...\n```\n\nSorry for posting as an issue. But it wasn't clear in any part of the documentation.\n. I thought that rule was of the kind promise2 = ReadMyFiles.\nHowever, from [https://promisesaplus.com/]:\n\n2.2.6 'then' may be called multiple times on the same promise.\n2.2.6.1 If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.\n2.2.6.2 If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.\n. Wheather synchronous or asynchronous, **all respective onRejected callbacks must execute**, and furthermore **must execute in the order of their originating calls to then** (per series nature of the promise.then().then() structure).\nIn my snippet not all the onRejected callbacks are executed. The promise 'ReadMyFiles' is clearly rejected and it executes an onFulfilled callback.\n. OK got it. I will explain it just in case someone gets to the same misunderstanding:\n\nEach promise has ONLY ONE _then_. So in order to chain the _then_ operations (serialize the execution) it must be clear that _then_ returns a promise and consequently:\n\n_promise.then().then()_ is the equivalent of _subpromise(promise.then()).then()_\n\nSo the first (and consecutive) promise.then() should 'throw' the error to keep the chain being rejected. Therefore, in order to serial-execute several commands when one promise has been rejected, this would be the recommended code:\n\n``` javascript\npromise\n.then(\n    function(value) {\n        /* onFulfilled operations here */\n    },\n    function(reason) {\n        /* onRejected operations here */\n        throw reason; // to keep the Rejected status\n)\n.then (\n    function(value) { \n        /* onFulfilled operations here */\n    },\n    function(reason) {\n        /* onRejected operations here */\n        throw reason; // to keep the Rejected status\n)\n...\n```\n\nSorry for posting as an issue. But it wasn't clear in any part of the documentation.\n. ",
    "augusto-altman": "Regarding your first approach: In my project we are already using AMD (requirejs) and change everything to Browserify (commonjs) is just not possible.\n\nRegarding your second approach: I'm making a library, so I don't know when my code is going to be loaded. So, What would happen If the developer loads more scripts before my library and one of these has defined a window.Q variable? I'm not able to just delete window.Q because I could break  some application.\n. No it doesn't, here is a chunk of code taken from the bottom of the jQuery bundle:\n\n``` JavaScript\n//.................jQuery code......................\n//.................jQuery code......................\n//.................jQuery code......................\nvar\n    // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n\n    // Map over the $ in case of overwrite\n    _$ = window.$;\n\njQuery.noConflict = function( deep ) {\n    if ( window.$ === jQuery ) {\n        window.$ = _$;\n    }\n\n    if ( deep && window.jQuery === jQuery ) {\n        window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n    window.jQuery = window.$ = jQuery;\n}\n```\n\nAs you can see, before exposing the $ and jQuery variables to the global namespace (window object) they check if it was a previous value in window.$ and window.jQuery and (if any) saves them into an internal cache. When you execute the noConflict function it takes those cached values into account and not simply delete the global variable.\n. You can check that in their [repo](https://github.com/jquery/jquery/blob/master/src/exports/global.js) if you want to.\n. It's true, it's a highly antiquated feature. In a world with module systems it's as antiquated as exposing Q in the window object. The thing is, if you are polluting the global namespace, then you should provide a way to de-pollute it, because it could be a poor guy like me out there, that have to work with legacy code and have to avoid namespace conflicts.\n\nThank you very much for taking the time to fix this.\n. Regarding your first approach: In my project we are already using AMD (requirejs) and change everything to Browserify (commonjs) is just not possible.\n\nRegarding your second approach: I'm making a library, so I don't know when my code is going to be loaded. So, What would happen If the developer loads more scripts before my library and one of these has defined a window.Q variable? I'm not able to just delete window.Q because I could break  some application.\n. No it doesn't, here is a chunk of code taken from the bottom of the jQuery bundle:\n\n``` JavaScript\n//.................jQuery code......................\n//.................jQuery code......................\n//.................jQuery code......................\nvar\n    // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n\n    // Map over the $ in case of overwrite\n    _$ = window.$;\n\njQuery.noConflict = function( deep ) {\n    if ( window.$ === jQuery ) {\n        window.$ = _$;\n    }\n\n    if ( deep && window.jQuery === jQuery ) {\n        window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n    window.jQuery = window.$ = jQuery;\n}\n```\n\nAs you can see, before exposing the $ and jQuery variables to the global namespace (window object) they check if it was a previous value in window.$ and window.jQuery and (if any) saves them into an internal cache. When you execute the noConflict function it takes those cached values into account and not simply delete the global variable.\n. You can check that in their [repo](https://github.com/jquery/jquery/blob/master/src/exports/global.js) if you want to.\n. It's true, it's a highly antiquated feature. In a world with module systems it's as antiquated as exposing Q in the window object. The thing is, if you are polluting the global namespace, then you should provide a way to de-pollute it, because it could be a poor guy like me out there, that have to work with legacy code and have to avoid namespace conflicts.\n\nThank you very much for taking the time to fix this.\n. ",
    "japel": "usage:\n\n``` javascript\n   var chain = new PromiseChain();\n   var objects = [...];\n\n    for (var i = 0; i < objects.length; i++) {\n      chain.add(coolFunction, objects[i]);\n    }\n\n    chain.$promise.then(...);\n```\n. usage:\n\n``` javascript\n   var chain = new PromiseChain();\n   var objects = [...];\n\n    for (var i = 0; i < objects.length; i++) {\n      chain.add(coolFunction, objects[i]);\n    }\n\n    chain.$promise.then(...);\n```\n. ",
    "jasson15": "I rule out the factor of MongoDB and narrow down the scope of the problem as follow:\n\n``` javascript\n    var TestClass = function (name){\n    };\n\n    TestClass.prototype.printName = function (callback) {\n        console.log('printName called');\n        return callback(null);\n    };\n\n    var test = new TestClass('test object');\n\n    test.printName(function (err) {\n        test.printName(function (err) {\n            console.log('callback called');\n        });\n    });\n```\n\nIn this case, the output should be:\n\n```\n    $ node q-test.js\n    printName called\n    printName called\n    callback called\n```\n\nBut if I use Q as follow:\n\n``` javascript\n    Q.ninvoke(test, 'printName')\n    .ninvoke(test, 'printName')\n    .then(function(){\n        console.log('callback called');\n    })\n    .done();\n```\n\nIt turns out the output with an error like this:\n\n``` javascript\n    $ node test.js\n    printName called\n\n    /path/to/my/project/node_modules/q/q.js:155\n                    throw e;\n                          ^\n    TypeError: Cannot read property '[object Object]' of undefined\n        at Promise.post (/path/to/my/project/node_modules/q/q.js:1161:29)\n        at Promise.promise.promiseDispatch (/path/to/my/project/node_modules/q/q.js:788:41)\n        at /path/to/my/project/node_modules/q/q.js:556:49\n        at runSingle (/path/to/my/project/node_modules/q/q.js:137:13)\n        at flush (/path/to/my/project/node_modules/q/q.js:125:13)\n        at process._tickCallback (node.js:442:13)\n        at Function.Module.runMain (module.js:499:11)\n        at startup (node.js:119:16)\n        at node.js:929:3\n```\n. I found that's my fault -- I use `ninvoke` in a wrong way.\nHere is the correct use provided by @barry-johnson\n\n``` javascript\nvar TestClass = function (name){ };\n\nTestClass.prototype.printName = function (callback) {\n    console.log('printName called');\n    return callback(null,this);     // node style callback, also return this\n};\n\nvar test = new TestClass('test object');\n\nQ.ninvoke(test, 'printName')\n//  in the lines below, the result of the prior line is the \"implied\" first\n// parameter to ninvoke();\n.ninvoke('printName')\n.ninvoke('printName')   \n.then(function(){\n    console.log('callback called');\n})\n.done();\n```\n\nPlease see the discussion for more detail:\n[discussion on stackoverflow](http://stackoverflow.com/questions/30181026/type-error-when-chaining-q-ninvoke)\n. I rule out the factor of MongoDB and narrow down the scope of the problem as follow:\n\n``` javascript\n    var TestClass = function (name){\n    };\n\n    TestClass.prototype.printName = function (callback) {\n        console.log('printName called');\n        return callback(null);\n    };\n\n    var test = new TestClass('test object');\n\n    test.printName(function (err) {\n        test.printName(function (err) {\n            console.log('callback called');\n        });\n    });\n```\n\nIn this case, the output should be:\n\n```\n    $ node q-test.js\n    printName called\n    printName called\n    callback called\n```\n\nBut if I use Q as follow:\n\n``` javascript\n    Q.ninvoke(test, 'printName')\n    .ninvoke(test, 'printName')\n    .then(function(){\n        console.log('callback called');\n    })\n    .done();\n```\n\nIt turns out the output with an error like this:\n\n``` javascript\n    $ node test.js\n    printName called\n\n    /path/to/my/project/node_modules/q/q.js:155\n                    throw e;\n                          ^\n    TypeError: Cannot read property '[object Object]' of undefined\n        at Promise.post (/path/to/my/project/node_modules/q/q.js:1161:29)\n        at Promise.promise.promiseDispatch (/path/to/my/project/node_modules/q/q.js:788:41)\n        at /path/to/my/project/node_modules/q/q.js:556:49\n        at runSingle (/path/to/my/project/node_modules/q/q.js:137:13)\n        at flush (/path/to/my/project/node_modules/q/q.js:125:13)\n        at process._tickCallback (node.js:442:13)\n        at Function.Module.runMain (module.js:499:11)\n        at startup (node.js:119:16)\n        at node.js:929:3\n```\n. I found that's my fault -- I use `ninvoke` in a wrong way.\nHere is the correct use provided by @barry-johnson\n\n``` javascript\nvar TestClass = function (name){ };\n\nTestClass.prototype.printName = function (callback) {\n    console.log('printName called');\n    return callback(null,this);     // node style callback, also return this\n};\n\nvar test = new TestClass('test object');\n\nQ.ninvoke(test, 'printName')\n//  in the lines below, the result of the prior line is the \"implied\" first\n// parameter to ninvoke();\n.ninvoke('printName')\n.ninvoke('printName')   \n.then(function(){\n    console.log('callback called');\n})\n.done();\n```\n\nPlease see the discussion for more detail:\n[discussion on stackoverflow](http://stackoverflow.com/questions/30181026/type-error-when-chaining-q-ninvoke)\n. ",
    "stramel": "@kriskowal Not seeing this in v2 still. Just curious if this is still a valid bug?\n. @kriskowal Not seeing this in v2 still. Just curious if this is still a valid bug?\n. ",
    "liuxiong332": "Thank you!\n. Thank you!\n. ",
    "tobireif": "I found several solutions, so nevermind :)\n. I found several solutions, so nevermind :)\n. ",
    "AliUz": "Upon further investigation I've noticed that I get the same errors even with a smaller promise chain, for example something along the lines of:\n\n``` javascript\n           app.get('/endpoint', function (req, res) {\n             validator.validate(req.query, {\n                // check query to see if valid\n             }).then(function (query) {\n               // query database for app\n             }).then(function (app) {\n               if (app) {\n                  res.send({code: 100, message: 'SUCCESS', message: \"hooray app found!\"});\n             }).fail(function(err) {\n                  res.send(\"Fail :(\");\n             });\n```\n\nWith Jmeter, if I send 2000 threads with a loop count of 10, the errors will start piling up. (Can't set headers after they are sent following a bunch of timeouts).\n. Nevermind, my issue has nothing to do with the promise structure, the error is a result of express timing out then the promise trying to resolve and attempting to do a res.send after the timeout response causing this error. \n. Upon further investigation I've noticed that I get the same errors even with a smaller promise chain, for example something along the lines of:\n\n``` javascript\n           app.get('/endpoint', function (req, res) {\n             validator.validate(req.query, {\n                // check query to see if valid\n             }).then(function (query) {\n               // query database for app\n             }).then(function (app) {\n               if (app) {\n                  res.send({code: 100, message: 'SUCCESS', message: \"hooray app found!\"});\n             }).fail(function(err) {\n                  res.send(\"Fail :(\");\n             });\n```\n\nWith Jmeter, if I send 2000 threads with a loop count of 10, the errors will start piling up. (Can't set headers after they are sent following a bunch of timeouts).\n. Nevermind, my issue has nothing to do with the promise structure, the error is a result of express timing out then the promise trying to resolve and attempting to do a res.send after the timeout response causing this error. \n. ",
    "vingiarrusso": "@michipili Check out the conversation on my pull request #667.  You have a handful of failing tests with this change (#701), due to strictly checking for an array as the parameter.  Its kind of a weird situation where you know you want an array but even the library itself passes .all() an array-like (see promised decorator fn).\n. @michipili Check out the conversation on my pull request #667.  You have a handful of failing tests with this change (#701), due to strictly checking for an array as the parameter.  Its kind of a weird situation where you know you want an array but even the library itself passes .all() an array-like (see promised decorator fn).\n. ",
    "cefn": "Can I request also that there is a useful failure condition when calling Q.all with 'promises' with the value undefined.\n\n``` javascript\nQ.all([void(0)])\n```\n\nI recently suffered for several days from this bug as Q.all was silently resolving when I did this...\n\n``` javascript\n                    return Q.all(keys.map(function(key){\n                            tree.syncRecursive(getChildTopic(topic, key));\n                        }))\n                        .then(function(){\n                            return tree.getItem(topic);\n                        })\n```\n\n...instead of this...\n\n``` javascript\n                    return Q.all(keys.map(function(key){\n                            return tree.syncRecursive(getChildTopic(topic, key));\n                        }))\n                        .then(function(){\n                            return tree.getItem(topic);\n                        })\n```\n\nSpot the difference ;)\n. Thanks for confirming. Great that a fix is in the mix for next release. Of course a workaround is to clone the array before passing to Q.all so now I've identified the issue it's easy to avoid. However, having this behaviour documented against version 1 would be of value I think.\n. Can I request also that there is a useful failure condition when calling Q.all with 'promises' with the value undefined.\n\n``` javascript\nQ.all([void(0)])\n```\n\nI recently suffered for several days from this bug as Q.all was silently resolving when I did this...\n\n``` javascript\n                    return Q.all(keys.map(function(key){\n                            tree.syncRecursive(getChildTopic(topic, key));\n                        }))\n                        .then(function(){\n                            return tree.getItem(topic);\n                        })\n```\n\n...instead of this...\n\n``` javascript\n                    return Q.all(keys.map(function(key){\n                            return tree.syncRecursive(getChildTopic(topic, key));\n                        }))\n                        .then(function(){\n                            return tree.getItem(topic);\n                        })\n```\n\nSpot the difference ;)\n. Thanks for confirming. Great that a fix is in the mix for next release. Of course a workaround is to clone the array before passing to Q.all so now I've identified the issue it's easy to avoid. However, having this behaviour documented against version 1 would be of value I think.\n. ",
    "schmeic": "Ok, got it.  Thank you for the quick response.\n. Ok, got it.  Thank you for the quick response.\n. ",
    "obastemur": "Actually what SM build does the same. It throws. But unfortunately the modules using 'q' is not expecting it to throw. \n. Can't we remove 'use strict' until there is another solution ? \n. Actually what SM build does the same. It throws. But unfortunately the modules using 'q' is not expecting it to throw. \n. Can't we remove 'use strict' until there is another solution ? \n. ",
    "AndrewHuffman": "Has anyone had a chance to look at this?\n. Has anyone had a chance to look at this?\n. ",
    "orcaman": "oops, didn't mean to send this. \n. oops, didn't mean to send this. \n. ",
    "markcarver": "I almost opened a new issue, but I'm pretty sure I'm having the same issue. I had to add an if statement here since it fails the test otherwise:\nhttps://github.com/unicorn-fail/grunt-promise/blob/master/test/grunt-promise-test.js#L122-L130\n\nPerhaps the issue title should be renamed to \"Q obfuscates object inheritance\" or something?\n\nx-ref: #519\n. I almost opened a new issue, but I'm pretty sure I'm having the same issue. I had to add an if statement here since it fails the test otherwise:\nhttps://github.com/unicorn-fail/grunt-promise/blob/master/test/grunt-promise-test.js#L122-L130\n\nPerhaps the issue title should be renamed to \"Q obfuscates object inheritance\" or something?\n\nx-ref: #519\n. ",
    "JesseChrestler": "+1\n. +1\n. ",
    "extremus": "This error occurs if you try running `npm install` from inside the `node_modules` dir, while you have to `cd ..` and then `npm install q`\n. This error occurs if you try running `npm install` from inside the `node_modules` dir, while you have to `cd ..` and then `npm install q`\n. ",
    "cariseterravion": "Thanks for the quick reply! I'll relax the version and try it.\n. Thanks for the quick reply! I'll relax the version and try it.\n. ",
    "AStoker": "There is no more a 2.0.3 release. There's some confusion at this point about which release to go for (a 2.0 release, or a newer 1.5 release).. \ud83d\udc4d Thanks for the clarification.. There is no more a 2.0.3 release. There's some confusion at this point about which release to go for (a 2.0 release, or a newer 1.5 release).. \ud83d\udc4d Thanks for the clarification.. ",
    "DrMabuse23": "Fixed thx\n. Fixed thx\n. ",
    "sqren": "I support the idea of having a `Q.sequence` method but your implementation looks overly complicated. It can be solved with `Array.prototype.reduce`:\n\n```\nfunction sequence(array, func) {\n    return array.reduce(function(promise, item) {\n        return promise.then(function () {\n            return func(item);\n        });\n    }, Q());\n};\n```\n. I support the idea of having a `Q.sequence` method but your implementation looks overly complicated. It can be solved with `Array.prototype.reduce`:\n\n```\nfunction sequence(array, func) {\n    return array.reduce(function(promise, item) {\n        return promise.then(function () {\n            return func(item);\n        });\n    }, Q());\n};\n```\n. ",
    "JixunMoe": "@sqren I'm not familiar with `reduce`, so I did it alternatively.\n\nYour code indeed looks better than mine, can you post a standalone PR? Then I'll close this one,  thanks.\n. Thanks :D\n. @sqren I'm not familiar with `reduce`, so I did it alternatively.\n\nYour code indeed looks better than mine, can you post a standalone PR? Then I'll close this one,  thanks.\n. Thanks :D\n. ",
    "HaskellZhangSong": "Thanks, worked. ~~\n. Thanks, worked. ~~\n. ",
    "quoo": "I always assumed it was short for queue, which makes sense.\n\n> On Aug 4, 2015, at 3:31 PM, Hugh Guiney notifications@github.com wrote:\n> \n> I know this isn't a bug per se, but I was looking for reasoning in the README and wiki and couldn't find any. Why isn't it called \"P\" for \"Promise\"? Or \"D\" for \"Deferred\"? Is it named after the Star Trek or James Bond characters? Is it arbitrary? I'm confused enough by promises as it is, and the name \"Q\" just makes it seem even more cryptic and intimidating to me. I initially assumed it was a variable name in some sort of mathematical formula. The logo seems to allude to its meaning but it isn't obvious.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. I always assumed it was short for queue, which makes sense.\n\n> On Aug 4, 2015, at 3:31 PM, Hugh Guiney notifications@github.com wrote:\n> \n> I know this isn't a bug per se, but I was looking for reasoning in the README and wiki and couldn't find any. Why isn't it called \"P\" for \"Promise\"? Or \"D\" for \"Deferred\"? Is it named after the Star Trek or James Bond characters? Is it arbitrary? I'm confused enough by promises as it is, and the name \"Q\" just makes it seem even more cryptic and intimidating to me. I initially assumed it was a variable name in some sort of mathematical formula. The logo seems to allude to its meaning but it isn't obvious.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "reddec": "I think that reason is just  42. `//IMHO`\n. I think that reason is just  42. `//IMHO`\n. ",
    "ramongilmoreno": "I find this useful. I have it as a common utility in my projects.. I find this useful. I have it as a common utility in my projects.. ",
    "yetithefoot": "Yep! Everything is OK without Q. I can send you JS function arguments from my code. You will be able to reproduce that.\n. @domenic Also everything is OK if i use `var dfd = Q.defer()` and then `dfd.resolve()/reject()`.\nSo the problem is somwhere inside Q library for this concrete case.\n. Yep! Everything is OK without Q. I can send you JS function arguments from my code. You will be able to reproduce that.\n. @domenic Also everything is OK if i use `var dfd = Q.defer()` and then `dfd.resolve()/reject()`.\nSo the problem is somwhere inside Q library for this concrete case.\n. ",
    "ingochris": ":+1: \n. :+1: \n. ",
    "RiCoTeRoX": "+1, \nplease we need that !!!\n\ninto the 1.x version please\n. +1, \nplease we need that !!!\n\ninto the 1.x version please\n. ",
    "vitaly-t": "Let me know where and when I can have it, and I will re-run all my tests ;)\n. Using 2.0.3:\n\n```\nQ(10): 0\nQ(100): 0\nQ(1,000): 0\nQ(10,000): 62\nQ(100,000): 828\nQ(1,000,000): 13742\nQ(10,000,000): 178386\n```\n\nI'm afraid, I got worse results than before. And when trying to execute 10m sequential requests, the memory consumption went crazy, to about 1.5GB. Normally, NodeJS would die under such memory demand, but the latest 4.1.1 seems a lot more resilient.\n\nJust to give you an idea, when running it against Native or Bluebird, the memory doesn't go above 25MB.\n\n**UPDATE:** You see, when dealing with infinite or very large dynamic sequences, those can only be handled via recursion, which in combination with promises becomes pseudo recursion. I believe that the issue must be there somewhere, so Q gets all overloaded when pseudo-recursion is used. And if that's the case, then it is a big problem, and not in performance optimization, but rather in the implementation concept/approach somewhere.\n. If you consider once-off processing of large packages, like large data imports/exports, then yes, those are real-life usage scenarios.\n\nI didn't realize Q still has dependency on ASAP. It doesn't come up as a dependency on NPM. I noticed that most promise libraries dumped ASAP in favour of their own internal implementation, and perhaps not without a good reason.\n. Let me know where and when I can have it, and I will re-run all my tests ;)\n. Using 2.0.3:\n\n```\nQ(10): 0\nQ(100): 0\nQ(1,000): 0\nQ(10,000): 62\nQ(100,000): 828\nQ(1,000,000): 13742\nQ(10,000,000): 178386\n```\n\nI'm afraid, I got worse results than before. And when trying to execute 10m sequential requests, the memory consumption went crazy, to about 1.5GB. Normally, NodeJS would die under such memory demand, but the latest 4.1.1 seems a lot more resilient.\n\nJust to give you an idea, when running it against Native or Bluebird, the memory doesn't go above 25MB.\n\n**UPDATE:** You see, when dealing with infinite or very large dynamic sequences, those can only be handled via recursion, which in combination with promises becomes pseudo recursion. I believe that the issue must be there somewhere, so Q gets all overloaded when pseudo-recursion is used. And if that's the case, then it is a big problem, and not in performance optimization, but rather in the implementation concept/approach somewhere.\n. If you consider once-off processing of large packages, like large data imports/exports, then yes, those are real-life usage scenarios.\n\nI didn't realize Q still has dependency on ASAP. It doesn't come up as a dependency on NPM. I noticed that most promise libraries dumped ASAP in favour of their own internal implementation, and perhaps not without a good reason.\n. ",
    "DerekDomino": "Strangely, all tests are passing: 243 passing (6 seconds). As well as in jasmine: 194 specs.\n. Strangely, all tests are passing: 243 passing (6 seconds). As well as in jasmine: 194 specs.\n. ",
    "aletc1": "Yep, Q.emit will do the job.\n. Yep, Q.emit will do the job.\n. ",
    "janpieterz": "Apologies, browsing around more I see that this is a duplicate of #64\n. Apologies, browsing around more I see that this is a duplicate of #64\n. ",
    "robgarrett": "Issue turned out to be a blocking EventSource.\n. Issue turned out to be a blocking EventSource.\n. ",
    "igorsechyn": "+1\n. +1\n. ",
    "jbunton-atlassian": "Good idea, thanks. I've pushed a new commit.\n. Hi @domenic,\n\nI don't suppose you have some time to have a look at this PR?\n\nThanks :)\n. I have added a comment which hopefully clarifies it.\n\nThe old stopping condition was to simply check if the \"From previous event\" string existed in the stack trace. The test cases I added demonstrate that this is not sufficient to produce useful long stacks in all cases. Removing the stopping condition altogether results in duplicate entries in the long stack and/or entries which simply should not be there.\n\nThe counter approach allows q to stop at exactly the correct stack :)\n. Thanks for merging! Is anybody able to publish this as a new version on npmjs.com?. I think you're just using the API wrong. You shouldn't need `apply`. `Q.all()` takes one argument which must be an array of promises.\r\n\r\n```\r\nQ.all([promise1, promise2])\r\n```. Nice :). +1\r\n\r\nI think it'd be great to do an npm release of v1 as well.. :). It seems like it would be at least worth mentioning native promises in the README. Personally I wouldn't recommend them over Q though.\r\n\r\nIn my apps I do `global.Promise = q.Promise` so that I can use the improved debugging features, primarily long stack traces. I also use extensively use some Q APIs like `nfcall` which have no equivalent to the native promises.. I'm not a fan of promisifyAll, I've seen it break with a semver compatible upgrade when libraries add new methods. But of course you're right that `nfcall` and friends are easily replaceable.\r\n\r\nI'm interested in getting better stack traces for the builtin Node promises. Is this some hidden Node flag, or an npm module that does some magic? In particular can they pass [this test](https://github.com/kriskowal/q/blob/master/spec/q-spec.js#L2770) ?. I don't think this has anything to do with `q`. It's caused by one of your other dependencies, `eslint-config-airbnb`.. It looks like this was broken by me in c340b2d05241330674697705a5e4b00c7ac1443b. Previously q did propagate a generic 'all rejected' error. However this turns out to make debugging issues difficult.\r\n\r\n@ivanetchart, I think your fix makes sense, I've added some minor feedback to your PR.. Good idea, thanks. I've pushed a new commit.\n. Hi @domenic,\n\nI don't suppose you have some time to have a look at this PR?\n\nThanks :)\n. I have added a comment which hopefully clarifies it.\n\nThe old stopping condition was to simply check if the \"From previous event\" string existed in the stack trace. The test cases I added demonstrate that this is not sufficient to produce useful long stacks in all cases. Removing the stopping condition altogether results in duplicate entries in the long stack and/or entries which simply should not be there.\n\nThe counter approach allows q to stop at exactly the correct stack :)\n. Thanks for merging! Is anybody able to publish this as a new version on npmjs.com?. I think you're just using the API wrong. You shouldn't need `apply`. `Q.all()` takes one argument which must be an array of promises.\r\n\r\n```\r\nQ.all([promise1, promise2])\r\n```. Nice :). +1\r\n\r\nI think it'd be great to do an npm release of v1 as well.. :). It seems like it would be at least worth mentioning native promises in the README. Personally I wouldn't recommend them over Q though.\r\n\r\nIn my apps I do `global.Promise = q.Promise` so that I can use the improved debugging features, primarily long stack traces. I also use extensively use some Q APIs like `nfcall` which have no equivalent to the native promises.. I'm not a fan of promisifyAll, I've seen it break with a semver compatible upgrade when libraries add new methods. But of course you're right that `nfcall` and friends are easily replaceable.\r\n\r\nI'm interested in getting better stack traces for the builtin Node promises. Is this some hidden Node flag, or an npm module that does some magic? In particular can they pass [this test](https://github.com/kriskowal/q/blob/master/spec/q-spec.js#L2770) ?. I don't think this has anything to do with `q`. It's caused by one of your other dependencies, `eslint-config-airbnb`.. It looks like this was broken by me in c340b2d05241330674697705a5e4b00c7ac1443b. Previously q did propagate a generic 'all rejected' error. However this turns out to make debugging issues difficult.\r\n\r\n@ivanetchart, I think your fix makes sense, I've added some minor feedback to your PR.. ",
    "dimichgh": "it is really confusing how to add tests in PR for the module.\nHere's the possible fix:\nhttps://github.com/dimichgh/q/commit/e9d3fec5dcfd8503e68ad089b9a5e93f35692f16\nYou can integrate the above tests into the spec.\n. it is really confusing how to add tests in PR for the module.\nHere's the possible fix:\nhttps://github.com/dimichgh/q/commit/e9d3fec5dcfd8503e68ad089b9a5e93f35692f16\nYou can integrate the above tests into the spec.\n. ",
    "ThomasCrevoisier": "Yep, that's it @mj1856. It's would be also clearer and more obvious for devs when watching tags of the repo.\n. I close the issue as we agree on the problem, thanks for your answer :)\n. Yep, that's it @mj1856. It's would be also clearer and more obvious for devs when watching tags of the repo.\n. I close the issue as we agree on the problem, thanks for your answer :)\n. ",
    "ccorcos": "interesting... thanks for the quick response\n. interesting... thanks for the quick response\n. ",
    "slushie": "You need to use `Q.all([deferred1.promise, deferred2.promise])...` here. \n\nBecause `all()` takes an array of promises, any values that aren't promises (ie, the `deferred` objects) will be converted to promises. In this case, you are effectively calling `Q.all([Q(deferred1), Q(deferred2)])` which ends up resolved because all the values passed to `all()` are resolved.\n. You need to use `Q.all([deferred1.promise, deferred2.promise])...` here. \n\nBecause `all()` takes an array of promises, any values that aren't promises (ie, the `deferred` objects) will be converted to promises. In this case, you are effectively calling `Q.all([Q(deferred1), Q(deferred2)])` which ends up resolved because all the values passed to `all()` are resolved.\n. ",
    "philkunz": "@slushie  True, sorry for my confusion there.\n. @slushie  True, sorry for my confusion there.\n. ",
    "longouyang": "Even though this got merged, it's not reflected on documentup.com... I think you might need to pull the commit into the `gh-pages` branch for this?\n. Ah, yes -- better now. Thanks!\n. Even though this got merged, it's not reflected on documentup.com... I think you might need to pull the commit into the `gh-pages` branch for this?\n. Ah, yes -- better now. Thanks!\n. ",
    "joaumg": "There is already a pull request: https://github.com/kriskowal/q/pull/750\n. There is already a pull request: https://github.com/kriskowal/q/pull/750\n. ",
    "denised": "I will change the variable names and look for any place I have squished operators.\nI didn't know you could assign to array lengths, I will make that change as well.\n. Just to be clear, what currently happens is that if you omit a trailing argument, the call breaks with a TypeError, because the handler gets moved to an earlier argument position and is thus not available when called.   Is it truly the case that this is intentional semantics ?\nI think this is adding functionality in an edge case, rather than backwords incompatibility (it is hard for me to imagine anyone relying on a TypeError for anything).   The value, I think, is the principle of \"least surprise\" for callers that may not be aware that a function was defined via nfbind.\nI can't comment as to the reliability of fn.length, though.  If you think it would really be likely to be incompatible between different implementations, then I would agree that it would be even _more_ surprising to have it fail sometimes but not others.\n. Ah, yes I can see how that might cause problems.\u00a0\u00a0 I leave it in your\nhands to decide whether on balance it is an improvement or not.\n\n## \n\n\u00a0 Denise Draper\n\u00a0 draperd@acm.org\n\nOn Sun, Jan 3, 2016, at 04:39 PM, Domenic Denicola wrote:\n\n> Right, those are intentional semantics currently, because they are the simplest thing that can be done without any magic guessing that might e.g. hide bugs. Magic guessing is OK to add, but it's a major semantic change and deserves 2.0 only.\n> \n> fn.length is not incompatible between implementations, but it's just not always useful. For example, many core functions in the Node.js standard library have fn.lengths that mismatch their actual call signature, since they switch on arguments[n] where n > fn.length.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub[1]. \n\nLinks:\n1. https://github.com/kriskowal/q/pull/753#issuecomment-168558381\n. I will change the variable names and look for any place I have squished operators.\nI didn't know you could assign to array lengths, I will make that change as well.\n. Just to be clear, what currently happens is that if you omit a trailing argument, the call breaks with a TypeError, because the handler gets moved to an earlier argument position and is thus not available when called.   Is it truly the case that this is intentional semantics ?\nI think this is adding functionality in an edge case, rather than backwords incompatibility (it is hard for me to imagine anyone relying on a TypeError for anything).   The value, I think, is the principle of \"least surprise\" for callers that may not be aware that a function was defined via nfbind.\nI can't comment as to the reliability of fn.length, though.  If you think it would really be likely to be incompatible between different implementations, then I would agree that it would be even _more_ surprising to have it fail sometimes but not others.\n. Ah, yes I can see how that might cause problems.\u00a0\u00a0 I leave it in your\nhands to decide whether on balance it is an improvement or not.\n\n## \n\n\u00a0 Denise Draper\n\u00a0 draperd@acm.org\n\nOn Sun, Jan 3, 2016, at 04:39 PM, Domenic Denicola wrote:\n\n> Right, those are intentional semantics currently, because they are the simplest thing that can be done without any magic guessing that might e.g. hide bugs. Magic guessing is OK to add, but it's a major semantic change and deserves 2.0 only.\n> \n> fn.length is not incompatible between implementations, but it's just not always useful. For example, many core functions in the Node.js standard library have fn.lengths that mismatch their actual call signature, since they switch on arguments[n] where n > fn.length.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub[1]. \n\nLinks:\n1. https://github.com/kriskowal/q/pull/753#issuecomment-168558381\n. ",
    "stoplion": "Chrome 47.0.2526.106\nQ version ~2.0.2\n\nQ is install via Bower. I'm using Sprockets for asset pipeline..in `all.js` I have:\n`//=require q/q`\n\nand `all.js` is included via a script tag in the head\n. Thanks. Changed to stable version and no error.\n. Chrome 47.0.2526.106\nQ version ~2.0.2\n\nQ is install via Bower. I'm using Sprockets for asset pipeline..in `all.js` I have:\n`//=require q/q`\n\nand `all.js` is included via a script tag in the head\n. Thanks. Changed to stable version and no error.\n. ",
    "pawurb": ":+1: \n. :+1: \n. ",
    "timmfin": "Note, I deal with this issue with a different approach in https://github.com/kriskowal/q/pull/817. Looks like ^ comment on v1.5.1 is accidental? (The PR isn\u2019t merged and I don\u2019t see any other commits in 1.5.1 related to this) \u00af\\\\\\_(\u30c4)\\_/\u00af. Note, I deal with this issue with a different approach in https://github.com/kriskowal/q/pull/817. Looks like ^ comment on v1.5.1 is accidental? (The PR isn\u2019t merged and I don\u2019t see any other commits in 1.5.1 related to this) \u00af\\\\\\_(\u30c4)\\_/\u00af. ",
    "bruun": "I have started on a simple implementation here: https://github.com/bruun/q/commit/2c4980944287c773e91c12c5143ef21dcc62be4a\n\nI see two problems with this approach so far: \n1. Those who already have a mechanism for listening to unhandled rejections, like calling `Q.getUnhandledReasons` on an interval, will have their current mechanism no longer work as expected. The function will always return an empty array.\n2. The unhandled rejection tracking is starting to be hard to reason about. You need a rejection handler, but you can also stop and start tracking, ask for the list of all unhandled reasons, and clear the internal list of rejections you have already been informed about in the rejection handler.\n\nAnother way to tackle this is to let the consumers decide for themselves how to deal with unhandled rejections. In other words _only_ invoke the unhandled rejection function with the promise and reason. The downside of this is of course that it is not a backwards compatible change.\n. I have started on a simple implementation here: https://github.com/bruun/q/commit/2c4980944287c773e91c12c5143ef21dcc62be4a\n\nI see two problems with this approach so far: \n1. Those who already have a mechanism for listening to unhandled rejections, like calling `Q.getUnhandledReasons` on an interval, will have their current mechanism no longer work as expected. The function will always return an empty array.\n2. The unhandled rejection tracking is starting to be hard to reason about. You need a rejection handler, but you can also stop and start tracking, ask for the list of all unhandled reasons, and clear the internal list of rejections you have already been informed about in the rejection handler.\n\nAnother way to tackle this is to let the consumers decide for themselves how to deal with unhandled rejections. In other words _only_ invoke the unhandled rejection function with the promise and reason. The downside of this is of course that it is not a backwards compatible change.\n. ",
    "amZotti": "**lgtm**\n. LGTM. @valderra-jpl What version of npm and node are you running?\r\n\r\nI am running npm 3.10.10 and node v7.3.0 - I don't see any of those warnings.. **lgtm**\n. LGTM. @valderra-jpl What version of npm and node are you running?\r\n\r\nI am running npm 3.10.10 and node v7.3.0 - I don't see any of those warnings.. ",
    "Juljan": "I would also appreciate such feature. \n\nIn my code, I call `.done();` on all promises, this makes stacktraces visible without polluting the code like the try-catch solution.  \n. I would also appreciate such feature. \n\nIn my code, I call `.done();` on all promises, this makes stacktraces visible without polluting the code like the try-catch solution.  \n. ",
    "seiyria": "I don't see why it can't. Maybe it'd require a major version change, but surely it's possible. That said, I'm not super invested in this anymore - I dropped q in favor of ES6 promises due to concerns over #731.\n. I don't see why it can't. Maybe it'd require a major version change, but surely it's possible. That said, I'm not super invested in this anymore - I dropped q in favor of ES6 promises due to concerns over #731.\n. ",
    "DeusExLibris": "I just started seeing this issue as well in a section of code that has not been touched in months.  It doesn't happen in my development environment - only in my staging environment.  It doesn't look like any of my module dependencies have changed either.  If I find a solution I will post back here.\n. Here is the relevant part of my package.json:\n  \"dependencies\": {\n    \"apn\": \"^1.7.5\",\n    \"binaryjs\": \"^0.2.1\",\n    \"body-parser\": \"^1.14.0\",\n    \"bufferutil\": \"^1.2.1\",\n    \"compression\": \"^1.6.0\",\n    \"connect-mongodb-session\": \"^1.0.6\",\n    \"cookie-parser\": \"^1.4.0\",\n    \"ejs\": \"^2.3.4\",\n    \"express\": \"^4.13.3\",\n    \"express-session\": \"^1.12.1\",\n    \"express-stormpath\": \"^2.1.0\",\n    \"express-ws\": \"^0.2.6\",\n    \"fluent-ffmpeg\": \"^2.0.1\",\n    \"moment\": \"^2.10.6\",\n    \"moment-timezone\": \"^0.5.0\",\n    \"mongodb\": \"^2.0.47\",\n    \"mongoose\": \"^4.2.4\",\n    \"multer\": \"^1.1.0\",\n    \"newrelic\": \"^1.23.0\",\n    \"numeral\": \"^1.5.3\",\n    \"q\": \"^1.4.1\",\n    \"sharp\": \"^0.11.4\",\n    \"stormpath\": \"^0.13.4\",\n    \"twitter\": \"^1.2.5\",\n    \"winston\": \"^2.1.0\",\n    \"winston-mongodb\": \"~1.2.0\",\n    \"xml2js\": \"^0.4.15\"\n  },\n  \"engines\": {\n    \"node\": \"^5.0.0\",\n    \"npm\": \"^3.3.10\"\n  }\n. Interestingly, I only have this problem on a single (virtual) machine.  Even when I deploy the same setup to a different server (i.e, my qa server), it works fine.\n\nAlso, not sure what you mean when you say \"There are no direct references to nextTick.runAfter in Q.\"  It is defined in q.js line 240, making it all the stranger that it doesn't find it.\n. BTW, thanks for such a quick response.\n. I have fixed my issue.  In copying and pasting my package.json, I realized there were a couple of modules that I wasn't using any longer and removed them (grunt-git, grunt-spritesmith, throttle and signal-master).  I also removed a \"require\" reference to one of the modules which was never being called (throttle).  When I redeployed to the server that was reporting this error, the problem went away.\n\nNot sure if this helps @nikolay211 or not, but I thought I would at least report how I resolved it.\n\nThanks again for the response.\n. I just started seeing this issue as well in a section of code that has not been touched in months.  It doesn't happen in my development environment - only in my staging environment.  It doesn't look like any of my module dependencies have changed either.  If I find a solution I will post back here.\n. Here is the relevant part of my package.json:\n  \"dependencies\": {\n    \"apn\": \"^1.7.5\",\n    \"binaryjs\": \"^0.2.1\",\n    \"body-parser\": \"^1.14.0\",\n    \"bufferutil\": \"^1.2.1\",\n    \"compression\": \"^1.6.0\",\n    \"connect-mongodb-session\": \"^1.0.6\",\n    \"cookie-parser\": \"^1.4.0\",\n    \"ejs\": \"^2.3.4\",\n    \"express\": \"^4.13.3\",\n    \"express-session\": \"^1.12.1\",\n    \"express-stormpath\": \"^2.1.0\",\n    \"express-ws\": \"^0.2.6\",\n    \"fluent-ffmpeg\": \"^2.0.1\",\n    \"moment\": \"^2.10.6\",\n    \"moment-timezone\": \"^0.5.0\",\n    \"mongodb\": \"^2.0.47\",\n    \"mongoose\": \"^4.2.4\",\n    \"multer\": \"^1.1.0\",\n    \"newrelic\": \"^1.23.0\",\n    \"numeral\": \"^1.5.3\",\n    \"q\": \"^1.4.1\",\n    \"sharp\": \"^0.11.4\",\n    \"stormpath\": \"^0.13.4\",\n    \"twitter\": \"^1.2.5\",\n    \"winston\": \"^2.1.0\",\n    \"winston-mongodb\": \"~1.2.0\",\n    \"xml2js\": \"^0.4.15\"\n  },\n  \"engines\": {\n    \"node\": \"^5.0.0\",\n    \"npm\": \"^3.3.10\"\n  }\n. Interestingly, I only have this problem on a single (virtual) machine.  Even when I deploy the same setup to a different server (i.e, my qa server), it works fine.\n\nAlso, not sure what you mean when you say \"There are no direct references to nextTick.runAfter in Q.\"  It is defined in q.js line 240, making it all the stranger that it doesn't find it.\n. BTW, thanks for such a quick response.\n. I have fixed my issue.  In copying and pasting my package.json, I realized there were a couple of modules that I wasn't using any longer and removed them (grunt-git, grunt-spritesmith, throttle and signal-master).  I also removed a \"require\" reference to one of the modules which was never being called (throttle).  When I redeployed to the server that was reporting this error, the problem went away.\n\nNot sure if this helps @nikolay211 or not, but I thought I would at least report how I resolved it.\n\nThanks again for the response.\n. ",
    "mdressman": "We've just been bitten by this issue as well, after an upgrade to node v4 and latest versions of React, etc.  We've not yet found a solution.\n. looks like it was the [`node-newrelic`](https://github.com/newrelic/node-newrelic) module. they just released a fix today. https://github.com/newrelic/node-newrelic/commit/8042f18e65cdbfa9c1acf13e39f28483741a3944\n. We've just been bitten by this issue as well, after an upgrade to node v4 and latest versions of React, etc.  We've not yet found a solution.\n. looks like it was the [`node-newrelic`](https://github.com/newrelic/node-newrelic) module. they just released a fix today. https://github.com/newrelic/node-newrelic/commit/8042f18e65cdbfa9c1acf13e39f28483741a3944\n. ",
    "zamb3zi": "Any news on this? I would also like to change the scheduler for use with Angular where I would require all handlers to execute within the digest cycle.\nThis is done in [angular-bluebird-promises](https://github.com/mattlewis92/angular-bluebird-promises) using bluebird's `setScheduler` as follows.\n\n``` #!javascript\n  ...\n  .run(function($rootScope, Bluebird) {\n    Bluebird.setScheduler((cb) => $rootScope.$evalAsync(cb));\n  });\n```\n\nThanks.\n. In the meantime, the following appears to work for Angular:\n\n``` javascript\n// monkey-patch Q so that it schedules tasks during the digest cycle.\nconst angularNextTick = task => () => $rootScope.$evalAsync(task);\nconst {nextTick} = Q;\nQ.nextTick = task => nextTick(angularNextTick(task));\nconst {runAfter} = nextTick;\nQ.nextTick.runAfter = task => runAfter(angularNextTick(task));\n```\n\nAnd here is a simple test to confirm that it's always `$digest` phase:\n\n``` javascript\nsetInterval(() => {\n    Q.delay(10).then(() => console.log('$$phase =', $rootScope.$$phase));\n}, 100);\n```\n. Any news on this? I would also like to change the scheduler for use with Angular where I would require all handlers to execute within the digest cycle.\nThis is done in [angular-bluebird-promises](https://github.com/mattlewis92/angular-bluebird-promises) using bluebird's `setScheduler` as follows.\n\n``` #!javascript\n  ...\n  .run(function($rootScope, Bluebird) {\n    Bluebird.setScheduler((cb) => $rootScope.$evalAsync(cb));\n  });\n```\n\nThanks.\n. In the meantime, the following appears to work for Angular:\n\n``` javascript\n// monkey-patch Q so that it schedules tasks during the digest cycle.\nconst angularNextTick = task => () => $rootScope.$evalAsync(task);\nconst {nextTick} = Q;\nQ.nextTick = task => nextTick(angularNextTick(task));\nconst {runAfter} = nextTick;\nQ.nextTick.runAfter = task => runAfter(angularNextTick(task));\n```\n\nAnd here is a simple test to confirm that it's always `$digest` phase:\n\n``` javascript\nsetInterval(() => {\n    Q.delay(10).then(() => console.log('$$phase =', $rootScope.$$phase));\n}, 100);\n```\n. ",
    "landonpoch": "@zamb3zi , Attempting your workaround, runAfter comes back as undefined when destructuring nextTick after reassignment.  I'm using q@1.4.1.. @zamb3zi , Attempting your workaround, runAfter comes back as undefined when destructuring nextTick after reassignment.  I'm using q@1.4.1.. ",
    "AnD010": "Thanks so match @ForbesLindesay , I made a stupid fail.... change outside to client deferred and work fine now....I'm so rookie with node...\n@benjamingr , you have absolutely right, I will chek how make with .query  conexion with postgres db.\nThis is my first time with node...Always, I only make android and Ios code(front)... now, I make backend too.\nthanks to both \n. @gitoverflow thanks so much for you answer .\n@panzerdp The next time,  I will write my problem in stackoverflow , thanks\n. Thanks so match @ForbesLindesay , I made a stupid fail.... change outside to client deferred and work fine now....I'm so rookie with node...\n@benjamingr , you have absolutely right, I will chek how make with .query  conexion with postgres db.\nThis is my first time with node...Always, I only make android and Ios code(front)... now, I make backend too.\nthanks to both \n. @gitoverflow thanks so much for you answer .\n@panzerdp The next time,  I will write my problem in stackoverflow , thanks\n. ",
    "mdlavin": "@kriskowal  any thoughts on this change?\n. @kriskowal  any thoughts on this change?\n. ",
    "orbatschow": "Note that this function does process every item after the previous one, same with delete and send functions. Send is executed when delete has finished.\n\n```\nvar daoFunction = function () {\n\n  var rootDeffered = Q.defer();\n\n  var getData = function () {\n\n    var deferred = Q.defer();\n    // your async stuff\n\n    setTimeout(function () {\n\n      var data = [];\n\n      var i = 0;\n      while (i < 10) {\n        data.push(i);\n        i++\n      }\n\n      console.log(\"data fetched\");\n\n      //resolved when data is fetched\n      deferred.resolve(data);\n    }, 3000);\n\n    // return promise\n    return deferred.promise;\n\n  };\n\n  var deleteItem = function (data, index) {\n\n    // call sendFunction after deleteItem finishes\n    sendFunction(data, index);\n\n  };\n\n  var sendFunction = function (data, index) {\n\n    // call this, when your sendFunction is done\n    if (data.length !== index + 1) {\n      deleteItem(data, index + 1)\n    }\n\n    if (data.length === index + 1) {\n\n      rootDeffered.resolve(data);\n\n    }\n\n  };\n\n  getData()\n    .then(function (data) {\n\n      deleteItem(data, 0);\n\n    })\n    .catch(function (err) {\n      console.log(err)\n    });\n\n  return rootDeffered.promise;\n\n};\n\ndaoFunction()\n  .then(function (data) {\n    console.log(data)\n  })\n  .catch(function (err) {\n    // whatever\n  });\n\n```\n\nThis code snippet does process every item in parallel, but executes the delete and send function after each other.\n\n```\nvar daoFunction = function () {\n\n  var rootDeffered = Q.defer();\n\n  var getData = function () {\n\n    var deferred = Q.defer();\n    // your async stuff\n\n    setTimeout(function () {\n\n      var data = [];\n\n      var i = 0;\n      while (i < 10) {\n        data.push(i);\n        i++\n      }\n\n      console.log(\"data fetched\");\n\n      //resolved when data is fetched\n      deferred.resolve(data);\n    }, 3000);\n\n    // return promise\n    return deferred.promise;\n\n  };\n\n  var deleteItem = function (item, deferred) {\n\n    // call sendFunction after deleteItem finishes\n    sendFunction(item, deferred);\n\n  };\n\n  var sendFunction = function (item, deferred) {\n\n    // call this, when your sendFunction is done\n    deferred.resolve(item/* or whatever you want to return*/);\n\n  };\n\n  getData()\n    .then(function (data) {\n\n      var chain = [];\n\n      _.each(data, function (item) {\n\n        var chainDeferred = Q.defer();\n        chain.push(chainDeferred.promise);\n\n        deleteItem(item, chainDeferred);\n      });\n\n      // you should look up all settled\n      Q.all(chain)\n        .then(function (result) {\n          console.log(result)\n        })\n\n\n    })\n    .catch(function (err) {\n      console.log(err)\n    });\n\n  return rootDeffered.promise;\n\n};\n\ndaoFunction()\n  .then(function (data) {\n    console.log(data)\n  })\n  .catch(function (err) {\n    // whatever\n  });\n\n```\n. Note that this function does process every item after the previous one, same with delete and send functions. Send is executed when delete has finished.\n\n```\nvar daoFunction = function () {\n\n  var rootDeffered = Q.defer();\n\n  var getData = function () {\n\n    var deferred = Q.defer();\n    // your async stuff\n\n    setTimeout(function () {\n\n      var data = [];\n\n      var i = 0;\n      while (i < 10) {\n        data.push(i);\n        i++\n      }\n\n      console.log(\"data fetched\");\n\n      //resolved when data is fetched\n      deferred.resolve(data);\n    }, 3000);\n\n    // return promise\n    return deferred.promise;\n\n  };\n\n  var deleteItem = function (data, index) {\n\n    // call sendFunction after deleteItem finishes\n    sendFunction(data, index);\n\n  };\n\n  var sendFunction = function (data, index) {\n\n    // call this, when your sendFunction is done\n    if (data.length !== index + 1) {\n      deleteItem(data, index + 1)\n    }\n\n    if (data.length === index + 1) {\n\n      rootDeffered.resolve(data);\n\n    }\n\n  };\n\n  getData()\n    .then(function (data) {\n\n      deleteItem(data, 0);\n\n    })\n    .catch(function (err) {\n      console.log(err)\n    });\n\n  return rootDeffered.promise;\n\n};\n\ndaoFunction()\n  .then(function (data) {\n    console.log(data)\n  })\n  .catch(function (err) {\n    // whatever\n  });\n\n```\n\nThis code snippet does process every item in parallel, but executes the delete and send function after each other.\n\n```\nvar daoFunction = function () {\n\n  var rootDeffered = Q.defer();\n\n  var getData = function () {\n\n    var deferred = Q.defer();\n    // your async stuff\n\n    setTimeout(function () {\n\n      var data = [];\n\n      var i = 0;\n      while (i < 10) {\n        data.push(i);\n        i++\n      }\n\n      console.log(\"data fetched\");\n\n      //resolved when data is fetched\n      deferred.resolve(data);\n    }, 3000);\n\n    // return promise\n    return deferred.promise;\n\n  };\n\n  var deleteItem = function (item, deferred) {\n\n    // call sendFunction after deleteItem finishes\n    sendFunction(item, deferred);\n\n  };\n\n  var sendFunction = function (item, deferred) {\n\n    // call this, when your sendFunction is done\n    deferred.resolve(item/* or whatever you want to return*/);\n\n  };\n\n  getData()\n    .then(function (data) {\n\n      var chain = [];\n\n      _.each(data, function (item) {\n\n        var chainDeferred = Q.defer();\n        chain.push(chainDeferred.promise);\n\n        deleteItem(item, chainDeferred);\n      });\n\n      // you should look up all settled\n      Q.all(chain)\n        .then(function (result) {\n          console.log(result)\n        })\n\n\n    })\n    .catch(function (err) {\n      console.log(err)\n    });\n\n  return rootDeffered.promise;\n\n};\n\ndaoFunction()\n  .then(function (data) {\n    console.log(data)\n  })\n  .catch(function (err) {\n    // whatever\n  });\n\n```\n. ",
    "panzerdp": "@AnD010 Post your question to stackoverflow. This section is more for issues/tasks/planning/discussions.\n. @AnD010 Post your question to stackoverflow. This section is more for issues/tasks/planning/discussions.\n. ",
    "markusmauch": "As far as I can see, the existing notification is one for each individual promise. What I suggest is to introduce a progress notification for the fulfillment of all promises. This does not exist so far and therefore I don't see any danger with regard to existing implementations. \n. As far as I can see, the existing notification is one for each individual promise. What I suggest is to introduce a progress notification for the fulfillment of all promises. This does not exist so far and therefore I don't see any danger with regard to existing implementations. \n. ",
    "chigur": "I may have explained myself badly when I said that promises are a special case of streams. What I meant was that a stream is a sequence of values in the future while a promise is a single value in the future. This analogy also links a number and an array of numbers together albeit with a different link. The spatial link. Please have a look the table in [this](https://github.com/kriskowal/gtor#concepts) paragraph for broader framework under which my statements fall.\n\n``` js\nQ.spawn(function* () {\n  yield fs.createReadStream('x.txt')\n    .pipe(fs.createWriteStream('y.txt'));\n});\n```\n\nThis is what yielding a stream would look like. In the above example execution is halted until the stream ends. The `spawn` function would attach a event handler on event `end` or `finish` and call the next method (I don't know whether it should call it with a concatenated value of stream chunks or nothing).\n\nI've come up with above example based on a recent use case. I don't have enough experience with streams, iterators or generators to suggest the precise behavior but if the aim of using `spawn` is to write async code that looks synchronous then streams must be handled too. If there is no support for yielding a stream then I have to yield a promise that resolves when the stream ends.\n\n``` js\nQ.spawn(function* () {\n  let fromStream = fs.createReadStream('x.txt');\n  let toStream = fs.createWriteStream('y.txt');\n\n  yield new Promise(resolve => {\n    toStream.on('end', () => resolve());\n    fromStream.pipe(toStream);\n  });\n});\n```\n\nIf I end up using a lot of streams this way then I might consider some helper that converts the end of a stream into a promise.\n. I may have explained myself badly when I said that promises are a special case of streams. What I meant was that a stream is a sequence of values in the future while a promise is a single value in the future. This analogy also links a number and an array of numbers together albeit with a different link. The spatial link. Please have a look the table in [this](https://github.com/kriskowal/gtor#concepts) paragraph for broader framework under which my statements fall.\n\n``` js\nQ.spawn(function* () {\n  yield fs.createReadStream('x.txt')\n    .pipe(fs.createWriteStream('y.txt'));\n});\n```\n\nThis is what yielding a stream would look like. In the above example execution is halted until the stream ends. The `spawn` function would attach a event handler on event `end` or `finish` and call the next method (I don't know whether it should call it with a concatenated value of stream chunks or nothing).\n\nI've come up with above example based on a recent use case. I don't have enough experience with streams, iterators or generators to suggest the precise behavior but if the aim of using `spawn` is to write async code that looks synchronous then streams must be handled too. If there is no support for yielding a stream then I have to yield a promise that resolves when the stream ends.\n\n``` js\nQ.spawn(function* () {\n  let fromStream = fs.createReadStream('x.txt');\n  let toStream = fs.createWriteStream('y.txt');\n\n  yield new Promise(resolve => {\n    toStream.on('end', () => resolve());\n    fromStream.pipe(toStream);\n  });\n});\n```\n\nIf I end up using a lot of streams this way then I might consider some helper that converts the end of a stream into a promise.\n. ",
    "thinkingmedia": "I'm finding the `@types/q` library does not define a compatible Promise with JavaScript Promises.\r\n\r\nhttps://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/q\r\n\r\nAs a result, I get TypeScript returns when trying to cast to a regular Promise.. I'm finding the `@types/q` library does not define a compatible Promise with JavaScript Promises.\r\n\r\nhttps://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/q\r\n\r\nAs a result, I get TypeScript returns when trying to cast to a regular Promise.. ",
    "grushler": "@vilic I was working on an app in my local machine (OSX) and i didn't get any error with this. However, when i tried to push it to IBM Bluemix (which is linux based cloud env), it was throwing an error stating -\n\n`ERR Error: Cannot find module 'Q'`\n\nSo shouldn't it be case sensitive and uniform across platforms? Let me know if my approach or comment is incorrect. I am still learning. Thanks!\n. @vilic I was working on an app in my local machine (OSX) and i didn't get any error with this. However, when i tried to push it to IBM Bluemix (which is linux based cloud env), it was throwing an error stating -\n\n`ERR Error: Cannot find module 'Q'`\n\nSo shouldn't it be case sensitive and uniform across platforms? Let me know if my approach or comment is incorrect. I am still learning. Thanks!\n. ",
    "pedro93": "@benjamingr This is untested but a synchronous version with callback hell would be the following:\n\n``` js\nreaddirp({ root: 'data' }).on('data', (entry) => {\n    enderer.execute(entry.fullPath, \"chrome\", (err, file) => {\n        if(err){\n            console.error(\"Error rendering file\",entry.name,\"in chrome skipping comparison.\");\n            return err; //chain break;\n        } else {\n            fs.writeFile(\"./result/chrome-\"+entry.name, file, (err) => {\n                if(err){\n                    console.error(\"Failed saving file\",\"./result/chrome-\"+entry.name,\"skipping comparison.\");\n                    return err; //chain break;\n                }\n                renderer.execute(entry.fullPath,\"phantom\", (err, file) =>{\n                    if(err){\n                        console.error(\"Error rendering file\",entry.name,\"in phantom skipping comparison.\");\n                        return err; //chain break;\n                    }\n                    fs.writeFile(\"./result/phantom-\"+entry.name, file, (err) => {\n                        if(err){\n                            console.error(\"Failed saving file\",\"./result/phantom-\"+entry.name,\"skipping comparison.\");\n                            return err; //chain break;\n                        }\n                        compare(\"./result/chrome-\"+entry.name,\"./result/phantom-\"+entry.name, function(err, result){\n                            if(err){\n                                console.error(\"Comparison failed\", err);\n                            }\n                            //work with result;\n                        });\n                    });\n                });\n            });\n        }\n    });\n});\n```\n\nI am not sure but bluebird 3.0 appears to offer a functionality akin to this.\nhttp://bluebirdjs.com/docs/api/cancellation.html\nhttps://github.com/petkaantonov/bluebird/blob/5bffd55f20f1df5361603612867f286fa13e56e3/test/mocha/cancel.js#L284\n\n@vilic I did not understand, could you elaborate?\n. The log handling was merely representative, there are stages in the chain where I want a through error handler which in the end will \"crash\" the chain to allow for graceful degradation after this part of the code has been processed.\n\n@vilic I did not understand your second paragraph, could you elaborate?\n. @benjamingr This is untested but a synchronous version with callback hell would be the following:\n\n``` js\nreaddirp({ root: 'data' }).on('data', (entry) => {\n    enderer.execute(entry.fullPath, \"chrome\", (err, file) => {\n        if(err){\n            console.error(\"Error rendering file\",entry.name,\"in chrome skipping comparison.\");\n            return err; //chain break;\n        } else {\n            fs.writeFile(\"./result/chrome-\"+entry.name, file, (err) => {\n                if(err){\n                    console.error(\"Failed saving file\",\"./result/chrome-\"+entry.name,\"skipping comparison.\");\n                    return err; //chain break;\n                }\n                renderer.execute(entry.fullPath,\"phantom\", (err, file) =>{\n                    if(err){\n                        console.error(\"Error rendering file\",entry.name,\"in phantom skipping comparison.\");\n                        return err; //chain break;\n                    }\n                    fs.writeFile(\"./result/phantom-\"+entry.name, file, (err) => {\n                        if(err){\n                            console.error(\"Failed saving file\",\"./result/phantom-\"+entry.name,\"skipping comparison.\");\n                            return err; //chain break;\n                        }\n                        compare(\"./result/chrome-\"+entry.name,\"./result/phantom-\"+entry.name, function(err, result){\n                            if(err){\n                                console.error(\"Comparison failed\", err);\n                            }\n                            //work with result;\n                        });\n                    });\n                });\n            });\n        }\n    });\n});\n```\n\nI am not sure but bluebird 3.0 appears to offer a functionality akin to this.\nhttp://bluebirdjs.com/docs/api/cancellation.html\nhttps://github.com/petkaantonov/bluebird/blob/5bffd55f20f1df5361603612867f286fa13e56e3/test/mocha/cancel.js#L284\n\n@vilic I did not understand, could you elaborate?\n. The log handling was merely representative, there are stages in the chain where I want a through error handler which in the end will \"crash\" the chain to allow for graceful degradation after this part of the code has been processed.\n\n@vilic I did not understand your second paragraph, could you elaborate?\n. ",
    "terinjokes": "@pedro93 In your then blocks, if you throw the error, it will fall through the promise chain to the first `.catch` (or catch handler).\n\nSince those look like node callbacks, you can simply use Q's promisication features, which will automatically do this.\n. In the next section we list all of the places that you can use Q from, including npm:\n\n> - A Node.js and CommonJS module, available in npm as the q package\n\nIf we add an installation section for one, there's temptation to having them for the others as well.\n. @pedro93 In your then blocks, if you throw the error, it will fall through the promise chain to the first `.catch` (or catch handler).\n\nSince those look like node callbacks, you can simply use Q's promisication features, which will automatically do this.\n. In the next section we list all of the places that you can use Q from, including npm:\n\n> - A Node.js and CommonJS module, available in npm as the q package\n\nIf we add an installation section for one, there's temptation to having them for the others as well.\n. ",
    "cdhowie": "If I'm understanding this right, you want to write out a specific error message based on the step that failed and then abort the whole process.  You can do this by attaching your `catch` continuations only to the specific promises they belong to, then re-rejecting with the same error, which will cause the outer chain to fall to the end.\n\nReading the following code, you should clearly be able to see based on the indentation where the `catch` continuations will apply.  Note that the outer chain doesn't have any `catch` continuations at all, which is why a rejection in one of the inner chains will fall to the end of the chain.\n\n(I refactored your arrow functions where possible, and wrapped a few calls in `Q.try()` since I wasn't sure if those functions returned a promise or a value.)\n\n``` js\nreaddirp({ root: 'data' }).on('data', (entry) => {\n    renderer.execute(entry.fullPath, \"chrome\")\n    .then(file =>\n        Q.nfcall(fs.writeFile, \"./result/chrome-\"+entry.name, file)\n        .catch(err => {\n            console.error(\"Failed saving file\",\"./result/chrome-\"+entry.name,\"skipping comparison.\");\n            // The following line passes the rejection through.  The outer\n            // chain of \"then\"s will by entirely bypassed.\n            return Q.reject(err);\n        })\n    )\n    .then(() =>\n        Q.try(() => renderer.execute(entry.fullPath,\"phantom\"))\n        .catch(err => {\n            console.error(\"phantom renderer failed\", err);\n            return Q.reject(err);\n        })\n    )\n    .then(file =>\n        Q.nfcall(fs.writeFile, \"./result/phantom-\"+entry.name, file)\n        .catch(err => {\n            console.error(\"Failed saving file\",\"./result/phantom-\"+entry.name,\"skipping comparison.\");\n            return Q.reject(err);\n        })\n    )\n    .then(() =>\n        Q.try(() => compare(\"./result/chrome-\"+entry.name,\"./result/phantom-\"+entry.name))\n        .catch(err => {\n            console.error(\"Comparison failed\");\n            return Q.reject(err);\n        })\n    )\n    .done();\n});\n```\n\nThis annotated version shows how the first error would flow:\n\n``` js\n    readdirp({ root: 'data' }).on('data', (entry) => {\n        renderer.execute(entry.fullPath, \"chrome\")\n        .then(file =>\n            Q.nfcall(fs.writeFile, \"./result/chrome-\"+entry.name, file)\n            .catch(err => {\n                console.error(\"Failed saving file\",\"./result/chrome-\"+entry.name,\"skipping comparison.\");\n                // The following line passes the rejection through.  The outer\n                // chain of \"then\"s will by entirely bypassed.\n/* /-------- */ return Q.reject(err);\n/* | */     })\n/* | */ )\n/* | */ .then(() =>\n/* | */     renderer.execute(entry.fullPath,\"phantom\")\n/* | */     .catch(err => {\n/* | */         console.error(\"phantom renderer failed\", err);\n/* | */         return Q.reject(err);\n/* | */     })\n/* | */ )\n/* | */ .then(file =>\n/* | */     Q.nfcall(fs.writeFile, \"./result/phantom-\"+entry.name, file)\n/* | */     .catch(err => {\n/* | */         console.error(\"Failed saving file\",\"./result/phantom-\"+entry.name,\"skipping comparison.\");\n/* | */         return Q.reject(err);\n/* | */     })\n/* | */ )\n/* | */ .then(() =>\n/* | */     compare(\"./result/chrome-\"+entry.name,\"./result/phantom-\"+entry.name)\n/* | */     .catch(err => {\n/* | */         console.error(\"Comparison failed\");\n/* | */         return Q.reject(err);\n/* | */     })\n/* | */ )\n/* \\> */.done();\n    });\n```\n. If you don't need the results from all of the `createUser()` calls, this pattern does the trick:\n\n``` js\nusers.map(user => () => createUser(user)).reduce(Q.when, Q())\n.then(/* all users created */)\n```\n\nIf you do need the results, you can use this helper:\n\n``` js\nfunction accumulateResults(prior, next) {\n    return prior.then(results =>\n        Q(next()).then(r => (results.push(r), results))\n    );\n}\n\nusers.map(user => () => createUser(user)).reduce(accumulateResults, Q([]))\n.then(/* all users created; fulfilled value is array of createUser() return values */)\n```\n. It looks like the editor doesn't understand ES6 syntax like arrow functions.  Have you tried using only ES5 syntax?  (Replace `(err) =>` with `function (err)` in this case.  If your callback function doesn't reference `this` then `(a,b,c) => { ... }` syntax is semantically equivalent to `function (a,b,c) { ... }`.)\n. If I'm understanding this right, you want to write out a specific error message based on the step that failed and then abort the whole process.  You can do this by attaching your `catch` continuations only to the specific promises they belong to, then re-rejecting with the same error, which will cause the outer chain to fall to the end.\n\nReading the following code, you should clearly be able to see based on the indentation where the `catch` continuations will apply.  Note that the outer chain doesn't have any `catch` continuations at all, which is why a rejection in one of the inner chains will fall to the end of the chain.\n\n(I refactored your arrow functions where possible, and wrapped a few calls in `Q.try()` since I wasn't sure if those functions returned a promise or a value.)\n\n``` js\nreaddirp({ root: 'data' }).on('data', (entry) => {\n    renderer.execute(entry.fullPath, \"chrome\")\n    .then(file =>\n        Q.nfcall(fs.writeFile, \"./result/chrome-\"+entry.name, file)\n        .catch(err => {\n            console.error(\"Failed saving file\",\"./result/chrome-\"+entry.name,\"skipping comparison.\");\n            // The following line passes the rejection through.  The outer\n            // chain of \"then\"s will by entirely bypassed.\n            return Q.reject(err);\n        })\n    )\n    .then(() =>\n        Q.try(() => renderer.execute(entry.fullPath,\"phantom\"))\n        .catch(err => {\n            console.error(\"phantom renderer failed\", err);\n            return Q.reject(err);\n        })\n    )\n    .then(file =>\n        Q.nfcall(fs.writeFile, \"./result/phantom-\"+entry.name, file)\n        .catch(err => {\n            console.error(\"Failed saving file\",\"./result/phantom-\"+entry.name,\"skipping comparison.\");\n            return Q.reject(err);\n        })\n    )\n    .then(() =>\n        Q.try(() => compare(\"./result/chrome-\"+entry.name,\"./result/phantom-\"+entry.name))\n        .catch(err => {\n            console.error(\"Comparison failed\");\n            return Q.reject(err);\n        })\n    )\n    .done();\n});\n```\n\nThis annotated version shows how the first error would flow:\n\n``` js\n    readdirp({ root: 'data' }).on('data', (entry) => {\n        renderer.execute(entry.fullPath, \"chrome\")\n        .then(file =>\n            Q.nfcall(fs.writeFile, \"./result/chrome-\"+entry.name, file)\n            .catch(err => {\n                console.error(\"Failed saving file\",\"./result/chrome-\"+entry.name,\"skipping comparison.\");\n                // The following line passes the rejection through.  The outer\n                // chain of \"then\"s will by entirely bypassed.\n/* /-------- */ return Q.reject(err);\n/* | */     })\n/* | */ )\n/* | */ .then(() =>\n/* | */     renderer.execute(entry.fullPath,\"phantom\")\n/* | */     .catch(err => {\n/* | */         console.error(\"phantom renderer failed\", err);\n/* | */         return Q.reject(err);\n/* | */     })\n/* | */ )\n/* | */ .then(file =>\n/* | */     Q.nfcall(fs.writeFile, \"./result/phantom-\"+entry.name, file)\n/* | */     .catch(err => {\n/* | */         console.error(\"Failed saving file\",\"./result/phantom-\"+entry.name,\"skipping comparison.\");\n/* | */         return Q.reject(err);\n/* | */     })\n/* | */ )\n/* | */ .then(() =>\n/* | */     compare(\"./result/chrome-\"+entry.name,\"./result/phantom-\"+entry.name)\n/* | */     .catch(err => {\n/* | */         console.error(\"Comparison failed\");\n/* | */         return Q.reject(err);\n/* | */     })\n/* | */ )\n/* \\> */.done();\n    });\n```\n. If you don't need the results from all of the `createUser()` calls, this pattern does the trick:\n\n``` js\nusers.map(user => () => createUser(user)).reduce(Q.when, Q())\n.then(/* all users created */)\n```\n\nIf you do need the results, you can use this helper:\n\n``` js\nfunction accumulateResults(prior, next) {\n    return prior.then(results =>\n        Q(next()).then(r => (results.push(r), results))\n    );\n}\n\nusers.map(user => () => createUser(user)).reduce(accumulateResults, Q([]))\n.then(/* all users created; fulfilled value is array of createUser() return values */)\n```\n. It looks like the editor doesn't understand ES6 syntax like arrow functions.  Have you tried using only ES5 syntax?  (Replace `(err) =>` with `function (err)` in this case.  If your callback function doesn't reference `this` then `(a,b,c) => { ... }` syntax is semantically equivalent to `function (a,b,c) { ... }`.)\n. ",
    "darkdragon-001": "@kriskowal I removed the {index: i, value: v} notifications so that one does not have to check which notification type is currently thrown. I think the number of resolved elements is way more meaningful than the progress of every single element.\r\n\r\nWhen I readd them, the old notifications will still be thrown the same way as before, but the original tests will still fail since additional notifications are thrown.\r\n\r\nWhich behavior do you prefer? What do you suggest?. ... since the current version of tests compares all received notifications with an expected result, there is no way of adding additional notifications since it won't be equal to the previously expected list any more!?. @kriskowal I removed the {index: i, value: v} notifications so that one does not have to check which notification type is currently thrown. I think the number of resolved elements is way more meaningful than the progress of every single element.\r\n\r\nWhen I readd them, the old notifications will still be thrown the same way as before, but the original tests will still fail since additional notifications are thrown.\r\n\r\nWhich behavior do you prefer? What do you suggest?. ... since the current version of tests compares all received notifications with an expected result, there is no way of adding additional notifications since it won't be equal to the previously expected list any more!?. ",
    "gabrielliwerant": "You can get the minified file by running the `grunt default` task in the project folder. See the `Gruntfile.js` file for more information.\n. You can get the minified file by running the `grunt default` task in the project folder. See the `Gruntfile.js` file for more information.\n. ",
    "tyler-kearney": "Since someone is confused.. An easy way to use a minified version of Q is to use a CDN link, for example\r\n[https://cdnjs.cloudflare.com/ajax/libs/q.js/2.0.3/q.min.js](https://cdnjs.cloudflare.com/ajax/libs/q.js/2.0.3/q.min.js)\r\nor download it from this location. Since someone is confused.. An easy way to use a minified version of Q is to use a CDN link, for example\r\n[https://cdnjs.cloudflare.com/ajax/libs/q.js/2.0.3/q.min.js](https://cdnjs.cloudflare.com/ajax/libs/q.js/2.0.3/q.min.js)\r\nor download it from this location. ",
    "amilajack": "I see. I guess I'm just used to seeing install methods as examples in the readme.\n. I see. I guess I'm just used to seeing install methods as examples in the readme.\n. ",
    "jdnichollsc": "For example: http://caolan.github.io/async/docs.html#.series\n\nTo avoid the following code:\n\n``` javascript\nvar users = [user1, user2, user3];\nvar result = Q();\nusers.forEach(function (user) {\n  result = result.then(function(){\n    return createUser(user);\n  });\n});\n```\n\nRegards, Nicholls\n. For example: http://caolan.github.io/async/docs.html#.series\n\nTo avoid the following code:\n\n``` javascript\nvar users = [user1, user2, user3];\nvar result = Q();\nusers.forEach(function (user) {\n  result = result.then(function(){\n    return createUser(user);\n  });\n});\n```\n\nRegards, Nicholls\n. ",
    "abartomeu": "Hi @domenic,\n\nAny progress on this? \n\nThanks\n. Hi @domenic,\n\nAny progress on this? \n\nThanks\n. ",
    "Exagram": "I'd vote for this.. I'd vote for this.. ",
    "kennynaoh": "My pleasure. My pleasure. ",
    "ErroneousFatality": "I'm sorry, I acted too quickly, so I misread.\r\nBut there's no harm in putting the 2.0.3-experimental up on Nuget, so at least this issue isn't completely useless.. I'm sorry, I acted too quickly, so I misread.\r\nBut there's no harm in putting the 2.0.3-experimental up on Nuget, so at least this issue isn't completely useless.. ",
    "lukaszprus": "Thanks for immediate response.\r\n\r\nSo the API documentation isn't right then?\r\n> Returns a promise that will have the same result as promise, but will only be fulfilled **or rejected after at least ms milliseconds have passed**.\r\n. It's the \"or rejected\" part that needs to be removed really.\r\n\r\nI just updated wiki:\r\n\r\nhttps://github.com/kriskowal/q/wiki/API-Reference#promisedelayms\r\n\r\nAlso added an extra sentence there.\r\n\r\nBy the way, I don't think I should be allowed to do this? I don't have any special permissions to this project.\r\n\r\nhttps://help.github.com/articles/changing-access-permissions-for-wikis/\r\n. Thanks for immediate response.\r\n\r\nSo the API documentation isn't right then?\r\n> Returns a promise that will have the same result as promise, but will only be fulfilled **or rejected after at least ms milliseconds have passed**.\r\n. It's the \"or rejected\" part that needs to be removed really.\r\n\r\nI just updated wiki:\r\n\r\nhttps://github.com/kriskowal/q/wiki/API-Reference#promisedelayms\r\n\r\nAlso added an extra sentence there.\r\n\r\nBy the way, I don't think I should be allowed to do this? I don't have any special permissions to this project.\r\n\r\nhttps://help.github.com/articles/changing-access-permissions-for-wikis/\r\n. ",
    "hifall": "What actually happens? Care to add some explanation on it?. What actually happens? Care to add some explanation on it?. ",
    "mariotsi": "https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback is what you are looking for. https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback is what you are looking for. ",
    "ivanetchart": "Agree. Thanks for the feedback, I will update it with your comment. Let you know. @jbunton-atlassian sorry for the delay. Please let me know if there's something else to improve. Thanks. @kriskowal make sense, I did some some improvements, hope you like them. . No problem at all, all comments make sense. . Agree. Thanks for the feedback, I will update it with your comment. Let you know. @jbunton-atlassian sorry for the delay. Please let me know if there's something else to improve. Thanks. @kriskowal make sense, I did some some improvements, hope you like them. . No problem at all, all comments make sense. . ",
    "Jabokoe": "Hmm the docs first paragraph sais `Q.when(X,Y)` is equivalent to `Q(X).then(Y)`. That is slighly different from saying `Q.when(X)` is equivalent to `Q(X)`. It also states:\r\n\r\n> which will accept either a promise or a non-promise, and in the latter case create a **fulfilled** promise first\r\n\r\nMaybe you can help me understand: If it is known that `.then(Y)` is fulfilled on the next tick then that means` Q(X)` has to be instantanious? So the behaviour can't change under those conditions? Because in my limited understanding making `Q.(X)` pending would make `Q(X).then(Y)` take two ticks... I'm not sure if that is accurate or if that is even breaking any expectations.\r\n\r\nHave you checked whether `Q(X).then()` behaves equivalent to `Q.when(X)`?\r\n\r\nI agree a clarification would be in order because neither the main readme nor the wiki docs are clear on the expected behaviour of `when(X)`, only `when(X,Y)` is clearly defined right now.. Hello\r\n\r\nCan you clarify for yourself why your code has an if-block for the error but no else block for logging success? In this case you are breaking the flow by returning in your if block. However otherwise you call `deffered.resolve`, which you are not returning. Instead you return your promise later, as expected but this makes your returning of deferred.reject less logical. The example for accessing filesystems with deffered has clearer control flow. Anyway assuming that part of the code is valid...\r\n\r\nYou have a .then stating a `data `argument but then try to use an undefined `err `and vice versa your .catch sais `err `but they you tried to use `data`. So you switched up success and failure. In the case of success your console will log \"succesfully read\" when actually executing that part but then it will try to read an undefined `err` while resolving the last bit of the promise, causing it to not even print the \"invoking\" message and no adittional data will be visible.\r\n\r\nYou can catch most kinds of undefined variable errors by using a [javascript linter](http://jslint.com/) and a \"use strict\" pragma. A lot of text editors or coding tools either have linters built in or plug-ins available.\r\n\r\nPS: You can format your code as code with the backtick \\` or by using the \"Insert Code\" button that has a **<>** Icon.. Hmm the docs first paragraph sais `Q.when(X,Y)` is equivalent to `Q(X).then(Y)`. That is slighly different from saying `Q.when(X)` is equivalent to `Q(X)`. It also states:\r\n\r\n> which will accept either a promise or a non-promise, and in the latter case create a **fulfilled** promise first\r\n\r\nMaybe you can help me understand: If it is known that `.then(Y)` is fulfilled on the next tick then that means` Q(X)` has to be instantanious? So the behaviour can't change under those conditions? Because in my limited understanding making `Q.(X)` pending would make `Q(X).then(Y)` take two ticks... I'm not sure if that is accurate or if that is even breaking any expectations.\r\n\r\nHave you checked whether `Q(X).then()` behaves equivalent to `Q.when(X)`?\r\n\r\nI agree a clarification would be in order because neither the main readme nor the wiki docs are clear on the expected behaviour of `when(X)`, only `when(X,Y)` is clearly defined right now.. Hello\r\n\r\nCan you clarify for yourself why your code has an if-block for the error but no else block for logging success? In this case you are breaking the flow by returning in your if block. However otherwise you call `deffered.resolve`, which you are not returning. Instead you return your promise later, as expected but this makes your returning of deferred.reject less logical. The example for accessing filesystems with deffered has clearer control flow. Anyway assuming that part of the code is valid...\r\n\r\nYou have a .then stating a `data `argument but then try to use an undefined `err `and vice versa your .catch sais `err `but they you tried to use `data`. So you switched up success and failure. In the case of success your console will log \"succesfully read\" when actually executing that part but then it will try to read an undefined `err` while resolving the last bit of the promise, causing it to not even print the \"invoking\" message and no adittional data will be visible.\r\n\r\nYou can catch most kinds of undefined variable errors by using a [javascript linter](http://jslint.com/) and a \"use strict\" pragma. A lot of text editors or coding tools either have linters built in or plug-ins available.\r\n\r\nPS: You can format your code as code with the backtick \\` or by using the \"Insert Code\" button that has a **<>** Icon.. ",
    "jQrgen": "The issue seems to be unrelated to q and instead related to error handling in my node-express server.. The issue seems to be unrelated to q and instead related to error handling in my node-express server.. ",
    "addaleax": "Nice, thank you both!. Nice, thank you both!. "
}