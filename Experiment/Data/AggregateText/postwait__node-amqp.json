{
    "postwait": "The vast majority of the diff is code format changes.  Format changes and function/feature changes should be kept in separate commits.  Can you surgically add your changes based on a clean branch of master?\n. So, I've cleaned the patch and fixed it so that it passes the test suite.  However, no new tests were added to test the features you implemented.  Can you write some tests for the stuff you added?\n\nPlease work from the cleandt branch: https://github.com/postwait/node-amqp/tree/cleandt\n\nOnce we have tests -- I'll pull this back into master.\n. I've pulled the test stuff into cleandt branch.\n\nHave you tested interoperability with a client not in node.js?  Java? Perl? Python?\n. pulled into master.\n. done\n. Did it work with 0.0.6?  I can't repeat the problem.  Which version of Rabbit is that?\n. I created a pristine-message branch to work on while getting this right...\n\nI've made some modifications to make thing a bit easier for those needing backward compatibility.\n\nWhat do you think?\n. How's 5c769835289501d913668997ba890732977718c3 look?  It seems to find balance.\n\nFor old behavior, add a second createConnection(..., 'amq.topic').\n. The reason for adding it was because the options for connection are defined in AMQP and a \"defaultExchange\" is no defined anywhere.  Other APIs require explicit statement of exchange in each publish call.  Perhaps making the second option implementation options (a hash) instead of a only the defaultExchange?\n. how about this 62ac3150032c70b79ef478165e184c3e568e03f1 ?\n. amqp's publish is asynchronous. You do not know when it is complete. You could try explicitly closing he channel on which you published.  If the channel closes, you know that the publish was ahead of it in line, so it has also completed.  If the publish fails for some reason (mandatory w/o a route) you will be notified asynchronously -- if you aren't there listening, you won't know.  This is pub/sub.\n. unbind is what you want.  There is a test for unbind.  You should be able to unbind your queue from the exchange/routing key and then messages will stop being distributed to it.\n. Chances are good.  squaremo: can you send a clean pull request against master?\n. So, AMQP is commonly used to talk between systems and you can't send the methods themselves over the wire.\n\nYour feature request would make sending of those objects tied to the implementation in Javascript.\n\nI'm inclined to think that this is the responsibility of a node module that leverages node-amqp instead of a feature in node-amqp itself.  Do you have a good argument why this should be done inside the AMQP protocol driver itself?\n. This should be added by another system layered atop node-amqp.  This module is about the protocol.\n. null as the JSON response and both the original payload and error in the the deliveryInfo sounds good.\n. yes. new pull request please.\n. changed.\n. With your Queue.js, it sounds like it might be the problem.  Create a repeatable test case using only node-amqp and we'll take a look.\n. Pass { ack: false } into the subscribe call.  Doesn't that work? \n. Can you please write a test for these changes?\n. I can't get your test to finish on my box against dev.rabbitmq.com:5672\n\nIt just hangs. Presumably creating both queues without error.\n. I am running against dev.rabbitmq.com\n. Am I supposed to be looking at codingforce or floorplanner for the pull?  It's unclear.\n. I get:\n\nAssertionError: queue should not have been created\n\nWhen running the tests against dev.rabbitmq.com (fixing the createConnection in the test to use the harness params)\n. I'm determined to make sure support email about tests failing is as low as possible.  So, when you checkout the code from github and run tests is should \"just work\"... for this we use dev.rabbitmq.com because it has a good track record of being available.  If we default to localhost, people will run the tests and submit issues that it fails due to the fact that they have no AMQP server running.  Lesson learned from the Perl AMQP driver.\n\nAs for AMQP compatibility... I don't test on other platforms, but will certainly accept patches that increase interoperability. The node-amqp driver should be about AMQP, not Rabbit. Running tests against a different server is as easy as:\n\nmake test SERVER=server:port\n. I'm fine skipping the asserts it vendor isn't RabbitMQ or the version is < 2.6.1 (or whatever the minimum version required)\n. This doesn't appear to be a bug in the implementation; closing.\n. There as no code in place to do that.  Try master, you can now do an:\n\nexchange.on('basic-return', function(x) .....);\n. Doesn't merge cleanly, please create a new pull request from current master.\n. No specific reason, no one implemented it.\n. Hiding channels is indeed problematic.  If you see a way to expose them, but not increase the complexity for the current use cases, I'm all for it.  The majority of node-amqp users (AFAICT) make very simplistic use of AMQP itself and I'd rather not confuse them (read: more support requests).\n\n## \n\nTheo Schlossnagle\nhttp://lethargy.org/~jesus/\n\nOn Friday, December 30, 2011 at 12:04 PM, Michael Bridgen wrote:\n\n> This is a problem resulting from caching queues and hiding channels: message prefetch is defined per channel, but a queue (= one channel) may have more than one consumer. If `queue.subscribe` and the option `autoAck: false` are used, it sets the prefetch to `1`, meaning that another message won't be sent until the previous has been acknowledged.\n> \n> If there's more than one consumer, then it's easy for one of them to unjustly starve the others by not acknowledging a message. Say, for example, each consumer is piping messages through a stream, and only acknowledging them once the message has successfully written; if the stream is paused, the acknowledgment won't be made, and no other consumer will receive a message either, because they are all sharing the channel and thus the prefetch.\n> \n> One possible solution to this is to unhide channels, so to allow a channel per consumer. The API as is can be kept as a convenience, and channel exposed for when more fine-grained control is needed. Thoughts? (or would you prefer to wait for a pull request ..)\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/60\n. cherry-picked the non-indentations stuff.\n. Can you rebase this off current master and give me a single commit with the changeset?\n. Now... can you rebase this off current master, it won't merge cleanly.\n. Sorry, this just isn't worth it.  The code is readable as is and introducing changes that are coding style is disruptive to finding regressions.\n. this looks fairly straightforward, would you mind adding some tests for the new multi-hop message and traces?\n. You can't use {ack: true} to do what you want.\n. The test suite fails in flames with this pull request.  This needs to be resolved before it can be pulled.\n. Merged manually.\n. I think this all went in with 8d57d929f33f39cc70eaa95445b9403a4b2af10b\n. This is the correct behavior. In AMQP you publish with a routing key.  In order for that message to go anywhere you need to have a queue explicitly created and subscribed to the messages.\n. Have you benchmarked the code there to make sure you had no regressions in performance?\n. merged\n. I already see these changes in my repo.\n. alternative implementation selected.\n. I'm on vacaction, so it will be a few weeks...\n\nunless someone wants to verify the test suite all passes (and if it doesn't fix the issues).\n. merged\n. merged manually\n. I don't think transaction support is implemented in node-amqp.... I'd need to look.  So, IIRC all message sent are done so non-transactionally: no need to commit, not possibility of rollback.\n. Docs and tests please.\n. Test case please.\n. Someone willing to whip up a short test case on this to make sure we don't have this regression in the future?\n. The test suite expects a server running on the local machine.\n\nmake test\n\nwill run the rest suite... if you'd like to run a specific test alone:\n\nnode test/test-simple.js\n\nIf you'd like to use a server other than localhost:5762 then\n\nmake test SERVER=otherserver:port\n\nor\n\nnode test/test-simple.js otherserver:port\n\nThe NODE_DEBUG_AMQP=1 environment variable can also be useful for debugging this stuff.\n. I guess when someone gets around to doing this again, they'll bother writing a test for it.\n. This doesn't apply to the current code base.\n. can you issue a pull request for this fix?\n\n## \n\nTheo Schlossnagle\nhttp://lethargy.org/~jesus/\n\nOn Thursday, May 23, 2013 at 11:55 PM, humanchimp wrote:\n\n> As a hobby, I am writing a cleaner AMQP driver for node. I am going to use the node-amqp library as one of my reference implementations. During the process of digging thru the source code, I discovered something that is bad, that can be easily fixed, e.g. https://github.com/postwait/node-amqp/blob/master/amqp.js#L229-L236\n> Here, we are greedily converting the data to a hex string that we don't ever need unless we are in debug mode. This is a hot code path. I think you should guard that with and if condition today, and probably look into a more elegant solution going forward.\n> You might want to cherry-pick this commit from my fork of this project. It would solve that problem, and can't do any harm: https://github.com/postwait/node-amqp/blob/master/amqp.js#L229-L236\n> br\n> \n> \u2014\n> Reply to this email directly or view it on GitHub (https://github.com/postwait/node-amqp/issues/192).\n. Can you create a test for this? (one that fails without the change and passes with it)\n.    make test SERVER=\"hostname:5672\"\n. If this is an issue, please reopen a PR against a current master\n. Great work.  Thanks.\n. took 284\n. Can you rebase interactive and force push this as a single commit?\n. This is fixed.\n. merged a combo of this and #295 \n. I can't repeat this.  Please resubmit with a test case that fails prior to your change and succeeds afterward your change.\n. Looks to be once for exchange in the current README.\n. Manually cherry-picked.\n. I have no particular issues with this change, but unless there is measured speedup, I'm disinclined to take it.\n\nHow did you measure speedup and what were your results?\n. There shouldn't be a change in default behavior.  I've adopted and adapted your documentation.\n. A default of 10s would change current behavior which isn't acceptable in this case.  Taken, but the default is 0 so that current (no timeout) behavior is maintained.\n. Added you to the contributors in package.json :-)\n. We can't change the defaults. That will cause havoc.\n. You can specify the autoDelete explicitly if you require a behavior different from the default.  Changing defaults in systems make them very hard to reuse and maintain.\n. This was cherry-picked in 9138d83bf33702693025b2351b1780057307d4ff\n. Can you try this:\n\n```\ndiff --git a/lib/connection.js b/lib/connection.js\nindex 24aed64..023ca3c 100644\n--- a/lib/connection.js\n+++ b/lib/connection.js\n@@ -248,6 +248,8 @@ Connection.prototype.addAllListeners = function() {\n         }, backoffTime);\n       } else {\n         self.removeListener('error', backoff);\n+        var listeners = self.listeners('error');\n+        if(listeners === null || listeners.length === 0) throw(e);\n       }\n     }\n   });\n```\n. I'll try to get to it next week. I'm traveling this week.\n. I don't believe anyone is working on this.\n. Can you describe how you've tested this?\n. Can you write a test case that demonstrates the problem and show that the fix addresses it?\n. Can you update the docs?. Don't create the exchange each time you publish.. The vast majority of the diff is code format changes.  Format changes and function/feature changes should be kept in separate commits.  Can you surgically add your changes based on a clean branch of master?\n. So, I've cleaned the patch and fixed it so that it passes the test suite.  However, no new tests were added to test the features you implemented.  Can you write some tests for the stuff you added?\n\nPlease work from the cleandt branch: https://github.com/postwait/node-amqp/tree/cleandt\n\nOnce we have tests -- I'll pull this back into master.\n. I've pulled the test stuff into cleandt branch.\n\nHave you tested interoperability with a client not in node.js?  Java? Perl? Python?\n. pulled into master.\n. done\n. Did it work with 0.0.6?  I can't repeat the problem.  Which version of Rabbit is that?\n. I created a pristine-message branch to work on while getting this right...\n\nI've made some modifications to make thing a bit easier for those needing backward compatibility.\n\nWhat do you think?\n. How's 5c769835289501d913668997ba890732977718c3 look?  It seems to find balance.\n\nFor old behavior, add a second createConnection(..., 'amq.topic').\n. The reason for adding it was because the options for connection are defined in AMQP and a \"defaultExchange\" is no defined anywhere.  Other APIs require explicit statement of exchange in each publish call.  Perhaps making the second option implementation options (a hash) instead of a only the defaultExchange?\n. how about this 62ac3150032c70b79ef478165e184c3e568e03f1 ?\n. amqp's publish is asynchronous. You do not know when it is complete. You could try explicitly closing he channel on which you published.  If the channel closes, you know that the publish was ahead of it in line, so it has also completed.  If the publish fails for some reason (mandatory w/o a route) you will be notified asynchronously -- if you aren't there listening, you won't know.  This is pub/sub.\n. unbind is what you want.  There is a test for unbind.  You should be able to unbind your queue from the exchange/routing key and then messages will stop being distributed to it.\n. Chances are good.  squaremo: can you send a clean pull request against master?\n. So, AMQP is commonly used to talk between systems and you can't send the methods themselves over the wire.\n\nYour feature request would make sending of those objects tied to the implementation in Javascript.\n\nI'm inclined to think that this is the responsibility of a node module that leverages node-amqp instead of a feature in node-amqp itself.  Do you have a good argument why this should be done inside the AMQP protocol driver itself?\n. This should be added by another system layered atop node-amqp.  This module is about the protocol.\n. null as the JSON response and both the original payload and error in the the deliveryInfo sounds good.\n. yes. new pull request please.\n. changed.\n. With your Queue.js, it sounds like it might be the problem.  Create a repeatable test case using only node-amqp and we'll take a look.\n. Pass { ack: false } into the subscribe call.  Doesn't that work? \n. Can you please write a test for these changes?\n. I can't get your test to finish on my box against dev.rabbitmq.com:5672\n\nIt just hangs. Presumably creating both queues without error.\n. I am running against dev.rabbitmq.com\n. Am I supposed to be looking at codingforce or floorplanner for the pull?  It's unclear.\n. I get:\n\nAssertionError: queue should not have been created\n\nWhen running the tests against dev.rabbitmq.com (fixing the createConnection in the test to use the harness params)\n. I'm determined to make sure support email about tests failing is as low as possible.  So, when you checkout the code from github and run tests is should \"just work\"... for this we use dev.rabbitmq.com because it has a good track record of being available.  If we default to localhost, people will run the tests and submit issues that it fails due to the fact that they have no AMQP server running.  Lesson learned from the Perl AMQP driver.\n\nAs for AMQP compatibility... I don't test on other platforms, but will certainly accept patches that increase interoperability. The node-amqp driver should be about AMQP, not Rabbit. Running tests against a different server is as easy as:\n\nmake test SERVER=server:port\n. I'm fine skipping the asserts it vendor isn't RabbitMQ or the version is < 2.6.1 (or whatever the minimum version required)\n. This doesn't appear to be a bug in the implementation; closing.\n. There as no code in place to do that.  Try master, you can now do an:\n\nexchange.on('basic-return', function(x) .....);\n. Doesn't merge cleanly, please create a new pull request from current master.\n. No specific reason, no one implemented it.\n. Hiding channels is indeed problematic.  If you see a way to expose them, but not increase the complexity for the current use cases, I'm all for it.  The majority of node-amqp users (AFAICT) make very simplistic use of AMQP itself and I'd rather not confuse them (read: more support requests).\n\n## \n\nTheo Schlossnagle\nhttp://lethargy.org/~jesus/\n\nOn Friday, December 30, 2011 at 12:04 PM, Michael Bridgen wrote:\n\n> This is a problem resulting from caching queues and hiding channels: message prefetch is defined per channel, but a queue (= one channel) may have more than one consumer. If `queue.subscribe` and the option `autoAck: false` are used, it sets the prefetch to `1`, meaning that another message won't be sent until the previous has been acknowledged.\n> \n> If there's more than one consumer, then it's easy for one of them to unjustly starve the others by not acknowledging a message. Say, for example, each consumer is piping messages through a stream, and only acknowledging them once the message has successfully written; if the stream is paused, the acknowledgment won't be made, and no other consumer will receive a message either, because they are all sharing the channel and thus the prefetch.\n> \n> One possible solution to this is to unhide channels, so to allow a channel per consumer. The API as is can be kept as a convenience, and channel exposed for when more fine-grained control is needed. Thoughts? (or would you prefer to wait for a pull request ..)\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/60\n. cherry-picked the non-indentations stuff.\n. Can you rebase this off current master and give me a single commit with the changeset?\n. Now... can you rebase this off current master, it won't merge cleanly.\n. Sorry, this just isn't worth it.  The code is readable as is and introducing changes that are coding style is disruptive to finding regressions.\n. this looks fairly straightforward, would you mind adding some tests for the new multi-hop message and traces?\n. You can't use {ack: true} to do what you want.\n. The test suite fails in flames with this pull request.  This needs to be resolved before it can be pulled.\n. Merged manually.\n. I think this all went in with 8d57d929f33f39cc70eaa95445b9403a4b2af10b\n. This is the correct behavior. In AMQP you publish with a routing key.  In order for that message to go anywhere you need to have a queue explicitly created and subscribed to the messages.\n. Have you benchmarked the code there to make sure you had no regressions in performance?\n. merged\n. I already see these changes in my repo.\n. alternative implementation selected.\n. I'm on vacaction, so it will be a few weeks...\n\nunless someone wants to verify the test suite all passes (and if it doesn't fix the issues).\n. merged\n. merged manually\n. I don't think transaction support is implemented in node-amqp.... I'd need to look.  So, IIRC all message sent are done so non-transactionally: no need to commit, not possibility of rollback.\n. Docs and tests please.\n. Test case please.\n. Someone willing to whip up a short test case on this to make sure we don't have this regression in the future?\n. The test suite expects a server running on the local machine.\n\nmake test\n\nwill run the rest suite... if you'd like to run a specific test alone:\n\nnode test/test-simple.js\n\nIf you'd like to use a server other than localhost:5762 then\n\nmake test SERVER=otherserver:port\n\nor\n\nnode test/test-simple.js otherserver:port\n\nThe NODE_DEBUG_AMQP=1 environment variable can also be useful for debugging this stuff.\n. I guess when someone gets around to doing this again, they'll bother writing a test for it.\n. This doesn't apply to the current code base.\n. can you issue a pull request for this fix?\n\n## \n\nTheo Schlossnagle\nhttp://lethargy.org/~jesus/\n\nOn Thursday, May 23, 2013 at 11:55 PM, humanchimp wrote:\n\n> As a hobby, I am writing a cleaner AMQP driver for node. I am going to use the node-amqp library as one of my reference implementations. During the process of digging thru the source code, I discovered something that is bad, that can be easily fixed, e.g. https://github.com/postwait/node-amqp/blob/master/amqp.js#L229-L236\n> Here, we are greedily converting the data to a hex string that we don't ever need unless we are in debug mode. This is a hot code path. I think you should guard that with and if condition today, and probably look into a more elegant solution going forward.\n> You might want to cherry-pick this commit from my fork of this project. It would solve that problem, and can't do any harm: https://github.com/postwait/node-amqp/blob/master/amqp.js#L229-L236\n> br\n> \n> \u2014\n> Reply to this email directly or view it on GitHub (https://github.com/postwait/node-amqp/issues/192).\n. Can you create a test for this? (one that fails without the change and passes with it)\n.    make test SERVER=\"hostname:5672\"\n. If this is an issue, please reopen a PR against a current master\n. Great work.  Thanks.\n. took 284\n. Can you rebase interactive and force push this as a single commit?\n. This is fixed.\n. merged a combo of this and #295 \n. I can't repeat this.  Please resubmit with a test case that fails prior to your change and succeeds afterward your change.\n. Looks to be once for exchange in the current README.\n. Manually cherry-picked.\n. I have no particular issues with this change, but unless there is measured speedup, I'm disinclined to take it.\n\nHow did you measure speedup and what were your results?\n. There shouldn't be a change in default behavior.  I've adopted and adapted your documentation.\n. A default of 10s would change current behavior which isn't acceptable in this case.  Taken, but the default is 0 so that current (no timeout) behavior is maintained.\n. Added you to the contributors in package.json :-)\n. We can't change the defaults. That will cause havoc.\n. You can specify the autoDelete explicitly if you require a behavior different from the default.  Changing defaults in systems make them very hard to reuse and maintain.\n. This was cherry-picked in 9138d83bf33702693025b2351b1780057307d4ff\n. Can you try this:\n\n```\ndiff --git a/lib/connection.js b/lib/connection.js\nindex 24aed64..023ca3c 100644\n--- a/lib/connection.js\n+++ b/lib/connection.js\n@@ -248,6 +248,8 @@ Connection.prototype.addAllListeners = function() {\n         }, backoffTime);\n       } else {\n         self.removeListener('error', backoff);\n+        var listeners = self.listeners('error');\n+        if(listeners === null || listeners.length === 0) throw(e);\n       }\n     }\n   });\n```\n. I'll try to get to it next week. I'm traveling this week.\n. I don't believe anyone is working on this.\n. Can you describe how you've tested this?\n. Can you write a test case that demonstrates the problem and show that the fix addresses it?\n. Can you update the docs?. Don't create the exchange each time you publish.. ",
    "vsviridov": "Sorry, my editor reformats the indentation and stuff. I'll try to do that in a munite.\n. I hope you find this to your liking.\n. The purpose of the patch was to facilitate rebroadcasting certain\npackets sent from C# client.\nImplementation itself was partially based on ruby client.\n\nI also tested it with the AMQP checking proxy from the java client\npackage (as suggested by devs from #ejabberd channel on freenode).\n\nV.\n\nOn 02/06/2011 02:07, postwait wrote:\n\n> I've pulled the test stuff into cleandt branch.\n> \n> Have you tested interoperability with a client not in node.js?  Java? Perl? Python?\n. Nice. Is it gonna be repackaged for npm any time soon?\n. Sorry, my editor reformats the indentation and stuff. I'll try to do that in a munite.\n. I hope you find this to your liking.\n. The purpose of the patch was to facilitate rebroadcasting certain\npackets sent from C# client.\nImplementation itself was partially based on ruby client.\n\nI also tested it with the AMQP checking proxy from the java client\npackage (as suggested by devs from #ejabberd channel on freenode).\n\nV.\n\nOn 02/06/2011 02:07, postwait wrote:\n\n> I've pulled the test stuff into cleandt branch.\n> \n> Have you tested interoperability with a client not in node.js?  Java? Perl? Python?\n. Nice. Is it gonna be repackaged for npm any time soon?\n. ",
    "michaelklishin": "Well done, guys. Nice to see that Node-based client is not left to rot.\n. node-amqp seems to be modelled (at least initially) after [Ruby amqp gem](https://github.com/ruby-amqp/amqp). Here is [how message metadata is used](https://github.com/ruby-amqp/amqp/blob/master/examples/queues/accessing_message_metadata.rb) there, Java client is very similar.\n. I would say, node-amqp is still at an early development stage, now is the time to do drastic API changes. Being similar to Ruby and Java clients in this regard certainly is nothing to be ashamed of. Ruby gem is actually fully asynchronous, many objects implement what in the Node land is known as EventEmitter, if I remember correctly. Checkout its [Getting Started guide](http://bit.ly/jcuACj) and [examples](http://bit.ly/ljTkyr) (I hope bit.ly bundles won't annoy people).\n\nAlso, why don't Node client contributors drop by #rabbitmq? It's nice to see this library not being left to rot in the end. Get in touch with other AMQP client developers ;)\n. @bkw looks good to me\n. Note that channel-level exceptions are not \"fatal\" and can be recovered from. Exceptions usually integrate poorly into 100% asynchronous code that Node.js enforces. [amqp gem](http://github.com/ruby-amqp/amqp) (that this library was originally designed from) uses callbacks instead of exceptions for everything but initial authentication failure.\n\n@glenjamin just use wireshark GUI with filtering by \"amqp\"\n. I recommend associating that event with channels (because this is `channel.close` AMQP method, after all) and maybe call it `close` (for the same reason). amqp gem still has AMQP::Channel#on_error, but this is because we need to preserve backwards compatibility.\n. Oh, so there is event propagation going on, right? This is exactly what amqp gem and the Java client do (although in different ways). [This amqp gem guide](http://rubydoc.info/github/ruby-amqp/amqp/master/file/docs/ErrorHandling.textile) describes how error handling works and why. I hope this will be helpful to authors of other clients, especially asynchronous ones. (I hope I do not annoy you with constant references to the amqp gem but it is a 3 years old codebase and we learned a lot with it). \n. Interoperability was [one of the two key goals of AMQP](http://bit.ly/amqp-model-explained). Adding JavaScript or Node.js specific features to the client itself is wrong in many ways.\n. I probably did not explain what I mean very well, sorry. As amqp gem documentation guides explain, payload is almost always serialized and JSON is indeed a very common and practical choice. However, enforcing it (or some other \"string format\") to be the only choice by assuming it is used everywhere is not an option for preserving compatibility.\n\nHigher-level libraries that assume Node.js-to-Node.js communication certainly can (and probably should) add features that assume JSON serialization for message bodies.\n. channel.close should not result in connection error events (if it does, it is a serious client design issue): it should result in a channel-level exception event.\n. Re-declaration of entities with different properties should result in a channel-level exception.\n. @skrat not sure who you are referring to, I happen to (co)maintain 3 Ruby AMQP clients and 1 Clojure one. So I am simply trying to explain how other clients work (or AMQP 0.9.1 in general). I don't mean to demotivate anyone, just don't want node-amqp (which is originally designed after Ruby amqp gem) to repeat well known mistakes in amqp gem design.\n\n@bkw amqp gem has been doing a similar thing since very early days. If I could, I would drop it. It is an idea that does not really improve anything but keeps confusing developers.\n. @skrat looks good to me\n. Try `x-message-ttl`, I am not sure why `x-expire` does not work out but per-queue message TTL has been supported for a long time. dev.rabbitmq.com installation probably deletes all entities every few hours or so so it may be set up to ignore some of related arguments like queue leases.\n. I am not sure I understand what you expectations of manual acknowledgements are. Acknowledgements play role when consumer crashes (or network connection goes down): AMQP broker will then re-queue all unacknowledged messages. [amqp gem documentation guide on queues](http://rubydoc.info/github/ruby-amqp/amqp/master/file/docs/Queues.textile#Message_acknowledgements) provides an example.\n\nAlso, acknowledgements are per-channel and take message delivery tag as an argument so associating method(s) for ack-ing a message with queues sounds like a bad idea: it will seriously mislead people and it is not how Java, Ruby, C# and Python clients work.\n. @fordox31: your use case is exactly what explicit acknowledgements were designed for. Should the broker crash, if message was published as persistent, it should be available in the queue again after restart. Ordering should be preserved except for cases when consumers re-queue messages (using basic.reject or basic.nack) and there is more than one consumer on the queue.\n. Well done, guys. Nice to see that Node-based client is not left to rot.\n. node-amqp seems to be modelled (at least initially) after [Ruby amqp gem](https://github.com/ruby-amqp/amqp). Here is [how message metadata is used](https://github.com/ruby-amqp/amqp/blob/master/examples/queues/accessing_message_metadata.rb) there, Java client is very similar.\n. I would say, node-amqp is still at an early development stage, now is the time to do drastic API changes. Being similar to Ruby and Java clients in this regard certainly is nothing to be ashamed of. Ruby gem is actually fully asynchronous, many objects implement what in the Node land is known as EventEmitter, if I remember correctly. Checkout its [Getting Started guide](http://bit.ly/jcuACj) and [examples](http://bit.ly/ljTkyr) (I hope bit.ly bundles won't annoy people).\n\nAlso, why don't Node client contributors drop by #rabbitmq? It's nice to see this library not being left to rot in the end. Get in touch with other AMQP client developers ;)\n. @bkw looks good to me\n. Note that channel-level exceptions are not \"fatal\" and can be recovered from. Exceptions usually integrate poorly into 100% asynchronous code that Node.js enforces. [amqp gem](http://github.com/ruby-amqp/amqp) (that this library was originally designed from) uses callbacks instead of exceptions for everything but initial authentication failure.\n\n@glenjamin just use wireshark GUI with filtering by \"amqp\"\n. I recommend associating that event with channels (because this is `channel.close` AMQP method, after all) and maybe call it `close` (for the same reason). amqp gem still has AMQP::Channel#on_error, but this is because we need to preserve backwards compatibility.\n. Oh, so there is event propagation going on, right? This is exactly what amqp gem and the Java client do (although in different ways). [This amqp gem guide](http://rubydoc.info/github/ruby-amqp/amqp/master/file/docs/ErrorHandling.textile) describes how error handling works and why. I hope this will be helpful to authors of other clients, especially asynchronous ones. (I hope I do not annoy you with constant references to the amqp gem but it is a 3 years old codebase and we learned a lot with it). \n. Interoperability was [one of the two key goals of AMQP](http://bit.ly/amqp-model-explained). Adding JavaScript or Node.js specific features to the client itself is wrong in many ways.\n. I probably did not explain what I mean very well, sorry. As amqp gem documentation guides explain, payload is almost always serialized and JSON is indeed a very common and practical choice. However, enforcing it (or some other \"string format\") to be the only choice by assuming it is used everywhere is not an option for preserving compatibility.\n\nHigher-level libraries that assume Node.js-to-Node.js communication certainly can (and probably should) add features that assume JSON serialization for message bodies.\n. channel.close should not result in connection error events (if it does, it is a serious client design issue): it should result in a channel-level exception event.\n. Re-declaration of entities with different properties should result in a channel-level exception.\n. @skrat not sure who you are referring to, I happen to (co)maintain 3 Ruby AMQP clients and 1 Clojure one. So I am simply trying to explain how other clients work (or AMQP 0.9.1 in general). I don't mean to demotivate anyone, just don't want node-amqp (which is originally designed after Ruby amqp gem) to repeat well known mistakes in amqp gem design.\n\n@bkw amqp gem has been doing a similar thing since very early days. If I could, I would drop it. It is an idea that does not really improve anything but keeps confusing developers.\n. @skrat looks good to me\n. Try `x-message-ttl`, I am not sure why `x-expire` does not work out but per-queue message TTL has been supported for a long time. dev.rabbitmq.com installation probably deletes all entities every few hours or so so it may be set up to ignore some of related arguments like queue leases.\n. I am not sure I understand what you expectations of manual acknowledgements are. Acknowledgements play role when consumer crashes (or network connection goes down): AMQP broker will then re-queue all unacknowledged messages. [amqp gem documentation guide on queues](http://rubydoc.info/github/ruby-amqp/amqp/master/file/docs/Queues.textile#Message_acknowledgements) provides an example.\n\nAlso, acknowledgements are per-channel and take message delivery tag as an argument so associating method(s) for ack-ing a message with queues sounds like a bad idea: it will seriously mislead people and it is not how Java, Ruby, C# and Python clients work.\n. @fordox31: your use case is exactly what explicit acknowledgements were designed for. Should the broker crash, if message was published as persistent, it should be available in the queue again after restart. Ordering should be preserved except for cases when consumers re-queue messages (using basic.reject or basic.nack) and there is more than one consumer on the queue.\n. ",
    "kulpreet": "Hi,\n\nI am now on amqp@0.0.6, rabbit 2.3.1 (ubuntu) and node v0.4.6\n\nI am now getting some other error. [I had it all working last night,\ntill I decided to upgrade amqp - so I think]\n\n=ERROR REPORT==== 3-Jun-2011::12:26:31 ===\nconnection <0.2337.0> (running), channel 4 - error:\n{amqp_error,not_found,\"no queue '09675841918215156' in vhost '/'\",\n            'queue.bind'}\n\nMy sequence of calls is\n-  amqp.createConnection\n- amqp_conn.on('ready'\n- exchange = amqp_conn.exchange('pvp updates', {'passive' : false,\n  'type' : 'topic', 'durable' : true, 'autoDelete' : false});\n- exchange.addListener('open'\n- io.on('connection'\n- client.on('message'\n-  amqp_conn.queue(client.sessionId)\n- queue.bind(exchange, 'MyRoutingKey')\n\nThey queues were all binding and I was able to use\nexchange.publish(queue, 'MyRoutingKey').\n\nHas there been a change lately in the way queues should be declared\nand bound using amqp?\n\nAlso I am using require('amqp') as opposed to require('amqp-091')\nwhich the readme seems to suggest (I think that came in while you\nmerged branches?)\n\nHope I provided some info that shows where I might be making a mistake.\n\nThanks again\n\nOn 3 June 2011 12:10, postwait\nreply@reply.github.com\nwrote:\n\n> Did it work with 0.0.6? \u00a0I can't repeat the problem. \u00a0Which version of Rabbit is that?\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/3#comment_1295294\n. Apologies. I re-read the updated README. I didn't realise that 'bind' should be called from within the callback from 'queue' declaration.\n\nSorry to bother you!\n\nNow I'll go back to the staging server and see what caused the initial problem.\n\nThanks a million again for the excellent package.\n. Hi,\n\nI am now on amqp@0.0.6, rabbit 2.3.1 (ubuntu) and node v0.4.6\n\nI am now getting some other error. [I had it all working last night,\ntill I decided to upgrade amqp - so I think]\n\n=ERROR REPORT==== 3-Jun-2011::12:26:31 ===\nconnection <0.2337.0> (running), channel 4 - error:\n{amqp_error,not_found,\"no queue '09675841918215156' in vhost '/'\",\n            'queue.bind'}\n\nMy sequence of calls is\n-  amqp.createConnection\n- amqp_conn.on('ready'\n- exchange = amqp_conn.exchange('pvp updates', {'passive' : false,\n  'type' : 'topic', 'durable' : true, 'autoDelete' : false});\n- exchange.addListener('open'\n- io.on('connection'\n- client.on('message'\n-  amqp_conn.queue(client.sessionId)\n- queue.bind(exchange, 'MyRoutingKey')\n\nThey queues were all binding and I was able to use\nexchange.publish(queue, 'MyRoutingKey').\n\nHas there been a change lately in the way queues should be declared\nand bound using amqp?\n\nAlso I am using require('amqp') as opposed to require('amqp-091')\nwhich the readme seems to suggest (I think that came in while you\nmerged branches?)\n\nHope I provided some info that shows where I might be making a mistake.\n\nThanks again\n\nOn 3 June 2011 12:10, postwait\nreply@reply.github.com\nwrote:\n\n> Did it work with 0.0.6? \u00a0I can't repeat the problem. \u00a0Which version of Rabbit is that?\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/3#comment_1295294\n. Apologies. I re-read the updated README. I didn't realise that 'bind' should be called from within the callback from 'queue' declaration.\n\nSorry to bother you!\n\nNow I'll go back to the staging server and see what caused the initial problem.\n\nThanks a million again for the excellent package.\n. ",
    "bkw": "Thanks, nice find! That looks much cleaner (and more complete). Shall we go this route? That would mean changing the signature of the subscribe-callback once more. But we'd get complete metadata goodness and headers nicely encapsulated.\n+1 from me.\n. Agreed, here we go: Alternative version, returning metadata array, which has keys \"routingKey\", \"deliveryTag\", and \"headers\" (also being an array), along with other stuff that might be found in the message object (priority, exchange, etc..)\nIn one sentence: routingKey and deliveryTag have moved to metadata, headers have moved one down into the key \"headers\" within metadata. Message is deepEqual to the one put in.\n\nBranch: codingforce/node-amqp@d7c4c7ab85c8b\n. me likey!\n\nSome additions in my cloned branch pristine-message: codingforce/node-amqp@b21668b6\n. Now we finally can make use of message properties. I added support for all missing ones in my branch \"properties\":\ncodingforce/node-amqp@d58e5964\nIt's a pretty small change. What Do you think?\n. landed in mainline. Thanks everybody!\n. test.js is ancient and no longer updated. It probably should be removed.\nThe real tests live in the test subdirectory. To run them, have a couchdb in admin-party mode running on localhost and run \"make test\".\n. Remember that in node every communication with external resources is asynchronous and is being handled by the eventloop. Using a tight loop like `while(true)` in your code will keep node busy adding asynchronous tasks to the eventloop, but it also keeps it from actually performing any of them, because there is always something to do immediately - namely adding another task, and so on.\n\nYou'll find it works when you limit the loop iterations to - say 1000, or even better, actually respond to other events in an asynchronous way, and let these events trigger the publishing. This way there will always be enough waiting for other things to actually get around to send these messages.\n\nUnrelated, but your `if(e)` will never be true, because there is no e.\n. I just noticed postwait/node-amqp@b471cc1 which handles channel closes. Does this mean this pr gets a new chance?\nAny objections to pulling this now?\n\nI've been hacking something along the same lines to support x-ha-policy (http://www.rabbitmq.com/ha.html), my most anticipated rabbitmq feature ever. \n. Noticed while playing with skrats test: Declaring a new queue twice with different arguments within the same connection seems to work ok, while redeclaring one that existed before the current connection throws if the arguments don't match. Does amqp somehow optimize out the second request? Tested with rabbitmq-2.6.1\n. That's what I thought. But in line 1205 of amqp.js we have a check wether the queue is already registered, in which case we don't create another instance. That's why skrats test does not work as expected.\n. @skrat: By all means: Nooo! Sorry, if this came across rejective, must have been language barrier, perhaps? Please accept my apologies, that was not at all my intention.\n\nInstead, I'm trying to help, I'm playing with the same stuff right now, trying to construct a testcase that works together with Theos channel close event.\n. @michaelklishin:  I created an experimental branch that removes the check and shortcut for existing queues and exchanges. With this we should be able to build a decent testcase without reconnecting. I'll prepare a pullreq, I wonder what Theo thinks, this might be controversial.\n\nupdate: PR #29\n. I've taken the liberty to clean up the patch an testcase to make it easier to merge into mainline.\n\n@skrat: Please don't be offended, my only intention is to make merging easier. Also I added some more asserts to Your test. I'm not trying to snatch any credit here, I just want to help get this into mainline, since I also depend on it.\n\nBranch: https://github.com/codingforce/node-amqp/commits/queue-arguments\n\nChanges: https://github.com/codingforce/node-amqp/compare/dfcee382d413ccc38d03374bf6aeeae36fb4cf5f...queue-arguments\n\n[updated to rebase Changes link]\n. codingforce/queue-arguments is the newer and cleaned up version, sorry for the confusion.\n. I see You also pulled pr 29 (also from the codingforce repository). Fine with me (Thanks!), I just hope You didn't confuse the branches, this one here is queue-arguments, the branch for pr 29 (the one you already pulled) is allow_redeclare.\n. Indeed. Sorry, I did my tests against my local 2.6.1 only. Must investigate. \n. @skrat: Strange indeed. \n\nI updated the codingforce branch:\n- Since Theo pulled #29, we no longer need multiple connections for the test.\n- I added your export in harness.js anyway, that might come in handy later.\n- I fixed a scoping error I had introduced when deleting an exiting queue.\n- I switched to using 'x-ha-policy' instead of 'x-expire' as an argument, since that works also in dev.rabbitmq.com\n\nBut! Now we can only test successfully on the latest release - Me no likey.\nWhat to do? Skip when testing against dev.rabbitmq.com? Skip it when testing against < 2.6.1? \n\nMaybe we should try to find out what magic configuration dev.rabbitmq.com uses first. I sent an inquiry to rabbitmq-discuss.\n. ha, good catch skrat! Thanks for digging this out. Still courious, the server did accept (and confirm) these low values, did You find any documentation about a threshold that changes this behaviour? Is changing low values for x-confirm acceptable? I don't get it...\n\nAnyway...\n\nI updated the codingforce branch according to Your suggestion, and I think (drumroll): we are ready for merging.\n. Good Lord! I was under the impression these were seconds and not milliseconds! That explains a lot ;-) Thanks.\n. (very terse) example:\n\n```\nconnection.queue(queueName, queueOpts, callback).on('queueDeclareOk', console.log);\n```\n\nQueues emit an event named after every amqp method they receive, so you have events like channelOpenOK, queueDeclareOK, queueBindOK and so on. queueDeclareOK happens to carry the number of messages in the arguments of that event, along with queue name and number of consumers.\nYou can find it in Queue.prototype._onMethod, amqp.js line 1661.\n. The current number of messages is just an added bonus of information that amqp returns along with the response to declaring a queue (and also when fetching messages), I wouldn't use it for monitoring.\n\nThe management console of rabbitmq makes use of the statistics database, which can be queried very nicely via http when the plugin is installed. This is a completely different thing and has nothing to do with amqp messaging, which is what this library is build for. \n\nTake a look at http://hg.rabbitmq.com/rabbitmq-management/raw-file/rabbitmq_v2_6_1/priv/www/api/index.html and You'll see, that all kinds of monitoring metrics can be queried trivially with just an http call. It should be easy to get the information You need. Or have a look at the various monitoring solutions listed at http://www.rabbitmq.com/how.html .\n. Glad to help.\nI think we could close this issue now. ashwinphatak?\n. In Your example queue.bind() will be executed too early. Since amqp is asyncronous, you should nest code that depends on prior declarations into callbacks. Your above example would then read something like this:\n\n```\nconnection.on('ready', function(){\n    var exchange = connection.exchange('echo-exchange', {}, function(ex) {\n        console.log('exchange created:', ex.name);\n        var queue = connection.queue('echo-queue', function (q) {\n            console.log('queue created:', q.name);\n            queue.bind('echo-exchange', 'foo.*');\n            queue.subscribe( {ack:true}, function(message){\n                console.log('received message', message);\n                queue.shift();\n            });\n        });\n    });\n});\n```\n. The philosophy of amqp is to always declare the stuff you will be using (configuration lives with the application). Nobody can decide for you, whether it is ok for your application to work with an existing queue with a different configuration.\n\nThe queue should emit an error 406 with PRECONDITION_FAILED, though. Take a look at test/test-queue-args.js for an example how to catch these. You are then free to ignore them, if You really want to.\n. In AMQP there generally is no acknowledgement for the method basic.publish. Returning a promise from exchange.publish() is more of a habit than actual documented behavior.\nWe probably could make the promise report the outcome of writing the message body to the stream, but I doubt that this would be worthwhile, since all one would be interested in are errors on the connection anyway, and these are handled elsewhere.\n\nThink \"no news is good news\".\n. I suggest You open up a pull request with Your modifications and see what Theo and the others think about it.\nA clean patch together with tests showing the use case should help getting Your point across.\n. Thanks, nice find! That looks much cleaner (and more complete). Shall we go this route? That would mean changing the signature of the subscribe-callback once more. But we'd get complete metadata goodness and headers nicely encapsulated.\n+1 from me.\n. Agreed, here we go: Alternative version, returning metadata array, which has keys \"routingKey\", \"deliveryTag\", and \"headers\" (also being an array), along with other stuff that might be found in the message object (priority, exchange, etc..)\nIn one sentence: routingKey and deliveryTag have moved to metadata, headers have moved one down into the key \"headers\" within metadata. Message is deepEqual to the one put in.\n\nBranch: codingforce/node-amqp@d7c4c7ab85c8b\n. me likey!\n\nSome additions in my cloned branch pristine-message: codingforce/node-amqp@b21668b6\n. Now we finally can make use of message properties. I added support for all missing ones in my branch \"properties\":\ncodingforce/node-amqp@d58e5964\nIt's a pretty small change. What Do you think?\n. landed in mainline. Thanks everybody!\n. test.js is ancient and no longer updated. It probably should be removed.\nThe real tests live in the test subdirectory. To run them, have a couchdb in admin-party mode running on localhost and run \"make test\".\n. Remember that in node every communication with external resources is asynchronous and is being handled by the eventloop. Using a tight loop like `while(true)` in your code will keep node busy adding asynchronous tasks to the eventloop, but it also keeps it from actually performing any of them, because there is always something to do immediately - namely adding another task, and so on.\n\nYou'll find it works when you limit the loop iterations to - say 1000, or even better, actually respond to other events in an asynchronous way, and let these events trigger the publishing. This way there will always be enough waiting for other things to actually get around to send these messages.\n\nUnrelated, but your `if(e)` will never be true, because there is no e.\n. I just noticed postwait/node-amqp@b471cc1 which handles channel closes. Does this mean this pr gets a new chance?\nAny objections to pulling this now?\n\nI've been hacking something along the same lines to support x-ha-policy (http://www.rabbitmq.com/ha.html), my most anticipated rabbitmq feature ever. \n. Noticed while playing with skrats test: Declaring a new queue twice with different arguments within the same connection seems to work ok, while redeclaring one that existed before the current connection throws if the arguments don't match. Does amqp somehow optimize out the second request? Tested with rabbitmq-2.6.1\n. That's what I thought. But in line 1205 of amqp.js we have a check wether the queue is already registered, in which case we don't create another instance. That's why skrats test does not work as expected.\n. @skrat: By all means: Nooo! Sorry, if this came across rejective, must have been language barrier, perhaps? Please accept my apologies, that was not at all my intention.\n\nInstead, I'm trying to help, I'm playing with the same stuff right now, trying to construct a testcase that works together with Theos channel close event.\n. @michaelklishin:  I created an experimental branch that removes the check and shortcut for existing queues and exchanges. With this we should be able to build a decent testcase without reconnecting. I'll prepare a pullreq, I wonder what Theo thinks, this might be controversial.\n\nupdate: PR #29\n. I've taken the liberty to clean up the patch an testcase to make it easier to merge into mainline.\n\n@skrat: Please don't be offended, my only intention is to make merging easier. Also I added some more asserts to Your test. I'm not trying to snatch any credit here, I just want to help get this into mainline, since I also depend on it.\n\nBranch: https://github.com/codingforce/node-amqp/commits/queue-arguments\n\nChanges: https://github.com/codingforce/node-amqp/compare/dfcee382d413ccc38d03374bf6aeeae36fb4cf5f...queue-arguments\n\n[updated to rebase Changes link]\n. codingforce/queue-arguments is the newer and cleaned up version, sorry for the confusion.\n. I see You also pulled pr 29 (also from the codingforce repository). Fine with me (Thanks!), I just hope You didn't confuse the branches, this one here is queue-arguments, the branch for pr 29 (the one you already pulled) is allow_redeclare.\n. Indeed. Sorry, I did my tests against my local 2.6.1 only. Must investigate. \n. @skrat: Strange indeed. \n\nI updated the codingforce branch:\n- Since Theo pulled #29, we no longer need multiple connections for the test.\n- I added your export in harness.js anyway, that might come in handy later.\n- I fixed a scoping error I had introduced when deleting an exiting queue.\n- I switched to using 'x-ha-policy' instead of 'x-expire' as an argument, since that works also in dev.rabbitmq.com\n\nBut! Now we can only test successfully on the latest release - Me no likey.\nWhat to do? Skip when testing against dev.rabbitmq.com? Skip it when testing against < 2.6.1? \n\nMaybe we should try to find out what magic configuration dev.rabbitmq.com uses first. I sent an inquiry to rabbitmq-discuss.\n. ha, good catch skrat! Thanks for digging this out. Still courious, the server did accept (and confirm) these low values, did You find any documentation about a threshold that changes this behaviour? Is changing low values for x-confirm acceptable? I don't get it...\n\nAnyway...\n\nI updated the codingforce branch according to Your suggestion, and I think (drumroll): we are ready for merging.\n. Good Lord! I was under the impression these were seconds and not milliseconds! That explains a lot ;-) Thanks.\n. (very terse) example:\n\n```\nconnection.queue(queueName, queueOpts, callback).on('queueDeclareOk', console.log);\n```\n\nQueues emit an event named after every amqp method they receive, so you have events like channelOpenOK, queueDeclareOK, queueBindOK and so on. queueDeclareOK happens to carry the number of messages in the arguments of that event, along with queue name and number of consumers.\nYou can find it in Queue.prototype._onMethod, amqp.js line 1661.\n. The current number of messages is just an added bonus of information that amqp returns along with the response to declaring a queue (and also when fetching messages), I wouldn't use it for monitoring.\n\nThe management console of rabbitmq makes use of the statistics database, which can be queried very nicely via http when the plugin is installed. This is a completely different thing and has nothing to do with amqp messaging, which is what this library is build for. \n\nTake a look at http://hg.rabbitmq.com/rabbitmq-management/raw-file/rabbitmq_v2_6_1/priv/www/api/index.html and You'll see, that all kinds of monitoring metrics can be queried trivially with just an http call. It should be easy to get the information You need. Or have a look at the various monitoring solutions listed at http://www.rabbitmq.com/how.html .\n. Glad to help.\nI think we could close this issue now. ashwinphatak?\n. In Your example queue.bind() will be executed too early. Since amqp is asyncronous, you should nest code that depends on prior declarations into callbacks. Your above example would then read something like this:\n\n```\nconnection.on('ready', function(){\n    var exchange = connection.exchange('echo-exchange', {}, function(ex) {\n        console.log('exchange created:', ex.name);\n        var queue = connection.queue('echo-queue', function (q) {\n            console.log('queue created:', q.name);\n            queue.bind('echo-exchange', 'foo.*');\n            queue.subscribe( {ack:true}, function(message){\n                console.log('received message', message);\n                queue.shift();\n            });\n        });\n    });\n});\n```\n. The philosophy of amqp is to always declare the stuff you will be using (configuration lives with the application). Nobody can decide for you, whether it is ok for your application to work with an existing queue with a different configuration.\n\nThe queue should emit an error 406 with PRECONDITION_FAILED, though. Take a look at test/test-queue-args.js for an example how to catch these. You are then free to ignore them, if You really want to.\n. In AMQP there generally is no acknowledgement for the method basic.publish. Returning a promise from exchange.publish() is more of a habit than actual documented behavior.\nWe probably could make the promise report the outcome of writing the message body to the stream, but I doubt that this would be worthwhile, since all one would be interested in are errors on the connection anyway, and these are handled elsewhere.\n\nThink \"no news is good news\".\n. I suggest You open up a pull request with Your modifications and see what Theo and the others think about it.\nA clean patch together with tests showing the use case should help getting Your point across.\n. ",
    "nilsga": "Sometimes you need to post an issue just to figure out what one self has done wrong... This error was due to incorrect asynchronous setup in my code. Apologies.\n. Actually, I think it's already handled in queueDeclareOk\n\n``` javascript\ncase methods.queueDeclareOk:\n      this.state = 'open';\n      this.name = args.queue;\n      this.connection.queues[this.name] = this;\n```\n. Sometimes you need to post an issue just to figure out what one self has done wrong... This error was due to incorrect asynchronous setup in my code. Apologies.\n. Actually, I think it's already handled in queueDeclareOk\n\n``` javascript\ncase methods.queueDeclareOk:\n      this.state = 'open';\n      this.name = args.queue;\n      this.connection.queues[this.name] = this;\n```\n. ",
    "squaremo": "I thought I fixed this in changeset https://github.com/squaremo/node-amqp/commit/1538db12edf8f7c8c46500d5ff8ed022a8d77de9, which was (indirectly) merged a while ago.\n. I posted the text above more or less verbatim to the Node.JS mailing list:\nhttp://groups.google.com/group/nodejs/browse_thread/thread/829952483478cabd\n\nBut, not a squeak in reply. Perhaps I'll just submit a pull request.\n. Yes, I think that's a good balance -- nice idea. Any reason to privilege defaultExchange over other options in the constructor? It could be part of the optjons object e.g.\n\nI think the README needs a bit more straightening out (I think it'd still be inconsistent wrt default exchange), relatively minor thing though.\n\nCheers, thanks for looking into it!\n. I see, yes that makes sense. Perhaps then two object arguments, as you suggest:\n\n```\namqp.createConnection(connectionArgs, options)\n```\n\ne.g.,\n\n```\namqp.createConnection({url: \"amqp://localhost:5555\"}, {defaultExchange: 'amq.fanout'})\n```\n\nAMQP has plenty of scope for other such options I should think.\n. Looks good to me. One thing I noticed is that setImplOptions isn't cumulative, e.g., each use will wipe out previous options supplied. I don't think it matters much at the minute though.\n. It looks like you have already declared that queue (in the Python code probably) but with different properties. You can check with rabbitmqctl or if you're using the management plugin, the web UI, and adapt the node code to fit (e.g., by passing the option in as a second argument:\n\n```\nconnection.queue('hello', {durable: true});\n```\n. I doubt this has anything to do with this issue.\n\nBut anyway: it is entirely possible that node-amqp uses different defaults for those properties. In this case, possibly node defaults to durable: true (or auto_delete: true I guess). So set both to false explicitly, as the rabbitmqctl output indicates.\n. > it's because python pika just doesn't send them?\n\nProbably.\n. Well, node-amqp is a bit abstracted from AMQP -- acknowledgements are exposed as Queue.shift(), channels are hidden away, etc. Exposing basicQos (even if it's attached to a queue rather than a channel) seems a bit odd.\n\n(BTW I think subscribe{{ack: true}) automatically sets the prefetch_count to 1, so that would tend to override any prefetch you sent before.)\n\nWhat is your rationale for using prefetch? Perhaps there is a more suitable abstraction.\n. No, it's not. A binding from an exchange is multicast -- all matching queues get the message. A subscription (basic.consume in AMQP) is round-robin -- one of the consumers to the queue gets the message. The corresponding AMQP method is basic.cancel, not queue.unbind.\n\nThere's a couple of solutions that suggest themselves. One is to not cache queues -- create a new channel every time a queue is requested through connection.queue().  Closing (but not destroying) the queue would close the AMQP channel, and the subscription, and thereby have the correct effect.  By and large this would work, but in some cases it would give surprising results, because the detail of channels is hidden in node-amqp.\n\nThe second solution is to return a token from subscribe that can be used to unsubscribe. In AMQP, there is a \"consumer tag\" that is exactly suited to this purpose. There are some details to figure out, but I think this is probably the way to go. I will have a crack at it.\n. Probably the best thing to do is put a protocol trace in a gist. You can obtain one with wireshark, or using the tracer that comes with the RabbitMQ Java client: http://www.rabbitmq.com/releases/rabbitmq-java-client/v2.6.1/rabbitmq-java-client-javadoc-2.6.1/com/rabbitmq/tools/Tracer.html\n. > The second solution is to return a token from subscribe that can be used to unsubscribe. In AMQP, there is a \"consumer \n> tag\" that is exactly suited to this purpose.\n\nExcept that subscribe already returns a promise, and this is relied on in e.g., the tests.\n\nThis 'one channel per queue' design is troublesome.\n. Marek, there is already a Queue.close. It inherits it from Channel (which itself is not exposed -- it's used as the prototype of Queue and Exchange). It even removes the queue from the connection's cache.\n\nHowever, this doesn't solve my problem, since it will remove all subscribers; and there is no way to have subscribers on different channels since the queues are cached.\n. I've implemented unsubscribe in my fork, branch 'unsubscribe', if anyone wants to try it.\n. > Or does subscribe return something that contains the consumerTag?\n\nIt doesn't but it can be made to quite easily: https://github.com/squaremo/node-amqp/commit/a3d33a54ace4e3a409e08096044a14bd61b6ff2d\n. > I think unsubscribing is also usefull when you want to exit the consumer process (i.e. because you need to upgrade the \n> software), but you don't want to loose any messages in between.\n\nJust closing the connection will have this effect, so long as you have not declared the queue as exclusive (to the connection). That is, it will requeue any unacked messages and not tear down the queue or its binding.\n. basic.recover is a bit of a weird fish. It says to the channel \"please redeliver unacked messages to the consumers you first delivered them to\". So it supposes that those consumers have somehow lost the messages, but not crashed -- how often do you think that is the case?\n\nIn previous RabbitMQ releases currently available messages will be requeued at the end of the queue. In the next release they will be requeued at the front of the queue; i.e., to be the next delivered.\n. I am worried that the prefetch being 1 can lead to deadlocks among consumers. But this is a problem anyway, with or without unsubscribe.\n. kevinlieb:\n\nYou probably don't want to unbind the queue, if you are doing a work-sharing thing -- in that case, it could stop other workers getting messages too.\n\nIf you are using acknowledgement, then just not acknowledging something until you are done with it will effectively throttle that worker. The server won't send you another message until you acknowledge the last.\n\nThis is what is going on: AMQP has a setting called 'prefetch' that limits the number of unacknowledged messages a client is allowed to have at any one time; node-amqp sets this to 1 if you choose to use acknowledgements (i.e., use {ack: true} in the options when subscribing).\n. (Closing since unsubscribe was fixed in pull request of issue 38)\n. See issue 37. This isn't ideal -- node-amqp is hiding some details which may cause surprises -- but it will be fine in most situations.\n. > The majority of node-amqp users (AFAICT) make very simplistic use of AMQP itself and I'd rather not confuse them (read: \n> more support requests).\n\nRoger that. I'll work it through in a branch and see what I can come up with.\n. Theo, \n\nI've started a branch `api_cleanup` which has a channel interface as well as keeping the connection.queue, connection.exchange etc. methods.\n\nThe main changes (mostly in https://github.com/squaremo/node-amqp/commit/6d9f27aabb87396586ca148aa031e4aa13c5bcf8) are:\n- queues and exchanges no longer inherit from Channel, but delegate to it;\n- Channel gets two methods for sending AMQP methods (one for when it should expect a reply, e.g., queue.bind, and one for when it shouldn't e.g., basic.publish), two special-purpose methods for registering and unregistering consumers, and one for publishing (which takes content as well as the method); everything else is then implemented using those\n- connection has a createChannel method, making Channel effectively public.\n\nI have also got rid of the events named for AMQP methods, which I always found a bit weird (e.g., subscribe is done when the 'basicQosOk' event fires?). The same effect can be had using the promise returned from the channel (and thereby the queue and exchange) methods.\n\nHere's an example of a test that I've rewritten:\nhttps://github.com/squaremo/node-amqp/blob/api_cleanup/test/test-simple.js\n\nAs you can see not much has changed, really just the means of synchronising on AMQP commands (now using the promise return value, as described above).\n. I think I will go ahead and rewrite the rest of the tests and the README. I'm also thinking adding some methods to Channel for the various AMQP operations (notably channel.flow, basic.qos, basic.reject, and Rabbit's extensions like confirmations). \n\nDo shout if you think this is, er .. divergent ..\n. Some tests (and presumably application code) rely on events such as 'queueDeclareOk'; this is distinct from a callback, which receives the \"completed\" queue rather than the queueDeclareOk sent by the server (which has a message count).\n\nI can see three options:\n1. **Consistency**: queue() and exchange() return promises for the queueDeclareOk and exchangeDeclareOk objects sent back by the server, and take a callback which is given the 'completed' queue or exchange. This would preclude some race conditions that are currently easy to create, since the queue or exchange would not be available until it had been successfully declared.\n2. **Least change** (for present users): queue() and exchange() return 'incomplete' queues and exchanges as before, and e.g., queues emit 'queueDeclareOk' events as before.\n3. **For the sake of completeness**: queues and exchanges are returned as before, and are also promises, with addCallback() giving access to e.g., queueDeclareOk. Queues and exchanges don't emit these events.\n\nPersonally I favour consistency. One-off events should be represented in the API as callbacks (or promises) rather than events.\n. @ivolo Ops, I think I must have put this down somewhere and forgotten about it. It's somewhat behind the state of the art, now; on the other had, the changes were not drastic in the first place and could probably be recapitulated on master.\n\nThe difficulty is really that I don't think, present company excepted, it would be a welcome change. To do it properly would likely be a breaking change (I would speculate that many applications using node-amqp accidentally depend on the quirks these changes are intended to eliminate).\n\nI'm more inclined to start again (hey, hey, stop booing!)\n. Hmm, pull requests don't really work for global cosmetic changes. Retracting. I would like to see the whitespace sorted out though.\n. That'll be my recent changes to parsing, let me take a look.\n. The fix for this, and test cases, have been merged into master -- please do try.\n. > Yes, it fixs this issue, thanks !\n> and\n> Fixes it for me too.\n\nGreat! Sorry about the interruption in service.\n\n> When could we expect to see this fix released? :)\n\nI didn't realise it had made it into a release. Ops, now I feel extra bad.\n. @michaelplaing @FGRibreau 0.1.1 does not have the bug, and neither lacks any features so far as I can tell.\nYou shall have to petition Theo for a 0.1.3 release -- he and Ryan are the maintainers (`npm info amqp`).\n. @michaelplaing Test case? (Does it pass with the head of master?)\n. @michaelplaing What are you expecting to see that didn't happen? I get the same output regardless of the size of the file `test/test` (well, up to 1MB approx.). I also verified that the both the queues output1 and output2 have a message pending at the end of the run (and the queue `input` has no message pending, since it's been consumed and acked).\n. I traced this to the commit fc2625bd5af0028944cb4d8650cd7101d18798ab, which pre-allocates (and reuses) the method sending frame buffer. It's reverted in my issue 65 branch, for which I'll issue a pull request.\n\nMeanwhile I discovered a couple of things:\n- All the methods for sending frames ignore the return value from `WritableStream.write`. In the test case it so happens that with a particular content size, the publish to output2 reliably exceeds the kernel buffer\n- `Connection._sendBody` ignores the maximum frame size negotiated with the server. (As it happens RabbitMQ is understanding about this)\n\nNow the most interesting thing: it appears that when the method send buffer is reused, and `WritableStream.write` returns false, the buffer is never written to the socket. When a new buffer is allocated each send, it is eventually written even if it overflows the kernel buffer.\n\nAnyway the reverted commit goes back to allocating a buffer of maxFrameSize for each method send. This is pretty wasteful -- maxFrameSize is well over the threshold for allocation from the pool. Possibly a better solution is to use a single buffer for assembling frames but copy them to (likely much smaller) fresh buffers before sending.\n. Actually forget about this one. There's a similar mistake in header() that is much more difficult to provoke.\n. That is likely to be because of reusing buffers (then writing over the contents before they are written to the socket), or perhaps frame interleaving. If you see it again please save the logs!\n. > At least RabbitMQ expects the vhost to always start with '/'.\n\nNo, it doesn't. But conventions are confusing in this regard.\n\nIn general AMQP clients, and specifically the Node.JS client, expect a vhost in the path part of the connection URL. This is either empty (nothing after the host), meaning the \"default vhost\"; or, it starts with a slash -- however the slash is _not_ counted as part of the vhost name, which means that any leading slash in the name has to be included in addition to the slash beginning the path. For example, if I have a vhost '/foo' then the URL should be something like 'amqp://host:port//foo'.\n\nAnother source of confusion is that RabbitMQ uses '/' as the default (as in pre-installed) vhost, prompting the convention of prefixing a slash.\n\nAffixing a slash removes the possibility of addressing vhosts without it.\n. > I'm trying to get amqp working with a Solace hardware router (http://solacesystems.com/products/unified-api-and-open-source/), which implements amqp.\n\nI don't think it does implement AMQP, or at least not AMQP 0.9.1. I'm pretty sure Solace kit uses its own proprietary protocol.\n\n\"Unsupported Protocol Version\" suggests it doesn't. I suspect the oversized frame error is just because the parser hasn't been told to stop trying to interpret the incoming bytes as AMQP frames.\n. The main things people seem to miss, coming from node-amqp to amqplib, are callbacks (rather than promises) and some variety of auto-recovery. I relented on the former and added a callback-oriented API not long ago.\n\nAuto-recovery I have always thought of as a misfeature, but people have reported that it works OK for what they're doing. And I've seen AMQP clients in other languages with auto-recovery working in practice, so I am more accustomed to the idea now, even if I still think it's very tricky (maybe impossible) to get right.\n\nOf course, moving across, there is a bit of porting work to do, since amqplib is not that similar to node-amqp's API (which I believe to be mistaken).\n. I thought I fixed this in changeset https://github.com/squaremo/node-amqp/commit/1538db12edf8f7c8c46500d5ff8ed022a8d77de9, which was (indirectly) merged a while ago.\n. I posted the text above more or less verbatim to the Node.JS mailing list:\nhttp://groups.google.com/group/nodejs/browse_thread/thread/829952483478cabd\n\nBut, not a squeak in reply. Perhaps I'll just submit a pull request.\n. Yes, I think that's a good balance -- nice idea. Any reason to privilege defaultExchange over other options in the constructor? It could be part of the optjons object e.g.\n\nI think the README needs a bit more straightening out (I think it'd still be inconsistent wrt default exchange), relatively minor thing though.\n\nCheers, thanks for looking into it!\n. I see, yes that makes sense. Perhaps then two object arguments, as you suggest:\n\n```\namqp.createConnection(connectionArgs, options)\n```\n\ne.g.,\n\n```\namqp.createConnection({url: \"amqp://localhost:5555\"}, {defaultExchange: 'amq.fanout'})\n```\n\nAMQP has plenty of scope for other such options I should think.\n. Looks good to me. One thing I noticed is that setImplOptions isn't cumulative, e.g., each use will wipe out previous options supplied. I don't think it matters much at the minute though.\n. It looks like you have already declared that queue (in the Python code probably) but with different properties. You can check with rabbitmqctl or if you're using the management plugin, the web UI, and adapt the node code to fit (e.g., by passing the option in as a second argument:\n\n```\nconnection.queue('hello', {durable: true});\n```\n. I doubt this has anything to do with this issue.\n\nBut anyway: it is entirely possible that node-amqp uses different defaults for those properties. In this case, possibly node defaults to durable: true (or auto_delete: true I guess). So set both to false explicitly, as the rabbitmqctl output indicates.\n. > it's because python pika just doesn't send them?\n\nProbably.\n. Well, node-amqp is a bit abstracted from AMQP -- acknowledgements are exposed as Queue.shift(), channels are hidden away, etc. Exposing basicQos (even if it's attached to a queue rather than a channel) seems a bit odd.\n\n(BTW I think subscribe{{ack: true}) automatically sets the prefetch_count to 1, so that would tend to override any prefetch you sent before.)\n\nWhat is your rationale for using prefetch? Perhaps there is a more suitable abstraction.\n. No, it's not. A binding from an exchange is multicast -- all matching queues get the message. A subscription (basic.consume in AMQP) is round-robin -- one of the consumers to the queue gets the message. The corresponding AMQP method is basic.cancel, not queue.unbind.\n\nThere's a couple of solutions that suggest themselves. One is to not cache queues -- create a new channel every time a queue is requested through connection.queue().  Closing (but not destroying) the queue would close the AMQP channel, and the subscription, and thereby have the correct effect.  By and large this would work, but in some cases it would give surprising results, because the detail of channels is hidden in node-amqp.\n\nThe second solution is to return a token from subscribe that can be used to unsubscribe. In AMQP, there is a \"consumer tag\" that is exactly suited to this purpose. There are some details to figure out, but I think this is probably the way to go. I will have a crack at it.\n. Probably the best thing to do is put a protocol trace in a gist. You can obtain one with wireshark, or using the tracer that comes with the RabbitMQ Java client: http://www.rabbitmq.com/releases/rabbitmq-java-client/v2.6.1/rabbitmq-java-client-javadoc-2.6.1/com/rabbitmq/tools/Tracer.html\n. > The second solution is to return a token from subscribe that can be used to unsubscribe. In AMQP, there is a \"consumer \n> tag\" that is exactly suited to this purpose.\n\nExcept that subscribe already returns a promise, and this is relied on in e.g., the tests.\n\nThis 'one channel per queue' design is troublesome.\n. Marek, there is already a Queue.close. It inherits it from Channel (which itself is not exposed -- it's used as the prototype of Queue and Exchange). It even removes the queue from the connection's cache.\n\nHowever, this doesn't solve my problem, since it will remove all subscribers; and there is no way to have subscribers on different channels since the queues are cached.\n. I've implemented unsubscribe in my fork, branch 'unsubscribe', if anyone wants to try it.\n. > Or does subscribe return something that contains the consumerTag?\n\nIt doesn't but it can be made to quite easily: https://github.com/squaremo/node-amqp/commit/a3d33a54ace4e3a409e08096044a14bd61b6ff2d\n. > I think unsubscribing is also usefull when you want to exit the consumer process (i.e. because you need to upgrade the \n> software), but you don't want to loose any messages in between.\n\nJust closing the connection will have this effect, so long as you have not declared the queue as exclusive (to the connection). That is, it will requeue any unacked messages and not tear down the queue or its binding.\n. basic.recover is a bit of a weird fish. It says to the channel \"please redeliver unacked messages to the consumers you first delivered them to\". So it supposes that those consumers have somehow lost the messages, but not crashed -- how often do you think that is the case?\n\nIn previous RabbitMQ releases currently available messages will be requeued at the end of the queue. In the next release they will be requeued at the front of the queue; i.e., to be the next delivered.\n. I am worried that the prefetch being 1 can lead to deadlocks among consumers. But this is a problem anyway, with or without unsubscribe.\n. kevinlieb:\n\nYou probably don't want to unbind the queue, if you are doing a work-sharing thing -- in that case, it could stop other workers getting messages too.\n\nIf you are using acknowledgement, then just not acknowledging something until you are done with it will effectively throttle that worker. The server won't send you another message until you acknowledge the last.\n\nThis is what is going on: AMQP has a setting called 'prefetch' that limits the number of unacknowledged messages a client is allowed to have at any one time; node-amqp sets this to 1 if you choose to use acknowledgements (i.e., use {ack: true} in the options when subscribing).\n. (Closing since unsubscribe was fixed in pull request of issue 38)\n. See issue 37. This isn't ideal -- node-amqp is hiding some details which may cause surprises -- but it will be fine in most situations.\n. > The majority of node-amqp users (AFAICT) make very simplistic use of AMQP itself and I'd rather not confuse them (read: \n> more support requests).\n\nRoger that. I'll work it through in a branch and see what I can come up with.\n. Theo, \n\nI've started a branch `api_cleanup` which has a channel interface as well as keeping the connection.queue, connection.exchange etc. methods.\n\nThe main changes (mostly in https://github.com/squaremo/node-amqp/commit/6d9f27aabb87396586ca148aa031e4aa13c5bcf8) are:\n- queues and exchanges no longer inherit from Channel, but delegate to it;\n- Channel gets two methods for sending AMQP methods (one for when it should expect a reply, e.g., queue.bind, and one for when it shouldn't e.g., basic.publish), two special-purpose methods for registering and unregistering consumers, and one for publishing (which takes content as well as the method); everything else is then implemented using those\n- connection has a createChannel method, making Channel effectively public.\n\nI have also got rid of the events named for AMQP methods, which I always found a bit weird (e.g., subscribe is done when the 'basicQosOk' event fires?). The same effect can be had using the promise returned from the channel (and thereby the queue and exchange) methods.\n\nHere's an example of a test that I've rewritten:\nhttps://github.com/squaremo/node-amqp/blob/api_cleanup/test/test-simple.js\n\nAs you can see not much has changed, really just the means of synchronising on AMQP commands (now using the promise return value, as described above).\n. I think I will go ahead and rewrite the rest of the tests and the README. I'm also thinking adding some methods to Channel for the various AMQP operations (notably channel.flow, basic.qos, basic.reject, and Rabbit's extensions like confirmations). \n\nDo shout if you think this is, er .. divergent ..\n. Some tests (and presumably application code) rely on events such as 'queueDeclareOk'; this is distinct from a callback, which receives the \"completed\" queue rather than the queueDeclareOk sent by the server (which has a message count).\n\nI can see three options:\n1. **Consistency**: queue() and exchange() return promises for the queueDeclareOk and exchangeDeclareOk objects sent back by the server, and take a callback which is given the 'completed' queue or exchange. This would preclude some race conditions that are currently easy to create, since the queue or exchange would not be available until it had been successfully declared.\n2. **Least change** (for present users): queue() and exchange() return 'incomplete' queues and exchanges as before, and e.g., queues emit 'queueDeclareOk' events as before.\n3. **For the sake of completeness**: queues and exchanges are returned as before, and are also promises, with addCallback() giving access to e.g., queueDeclareOk. Queues and exchanges don't emit these events.\n\nPersonally I favour consistency. One-off events should be represented in the API as callbacks (or promises) rather than events.\n. @ivolo Ops, I think I must have put this down somewhere and forgotten about it. It's somewhat behind the state of the art, now; on the other had, the changes were not drastic in the first place and could probably be recapitulated on master.\n\nThe difficulty is really that I don't think, present company excepted, it would be a welcome change. To do it properly would likely be a breaking change (I would speculate that many applications using node-amqp accidentally depend on the quirks these changes are intended to eliminate).\n\nI'm more inclined to start again (hey, hey, stop booing!)\n. Hmm, pull requests don't really work for global cosmetic changes. Retracting. I would like to see the whitespace sorted out though.\n. That'll be my recent changes to parsing, let me take a look.\n. The fix for this, and test cases, have been merged into master -- please do try.\n. > Yes, it fixs this issue, thanks !\n> and\n> Fixes it for me too.\n\nGreat! Sorry about the interruption in service.\n\n> When could we expect to see this fix released? :)\n\nI didn't realise it had made it into a release. Ops, now I feel extra bad.\n. @michaelplaing @FGRibreau 0.1.1 does not have the bug, and neither lacks any features so far as I can tell.\nYou shall have to petition Theo for a 0.1.3 release -- he and Ryan are the maintainers (`npm info amqp`).\n. @michaelplaing Test case? (Does it pass with the head of master?)\n. @michaelplaing What are you expecting to see that didn't happen? I get the same output regardless of the size of the file `test/test` (well, up to 1MB approx.). I also verified that the both the queues output1 and output2 have a message pending at the end of the run (and the queue `input` has no message pending, since it's been consumed and acked).\n. I traced this to the commit fc2625bd5af0028944cb4d8650cd7101d18798ab, which pre-allocates (and reuses) the method sending frame buffer. It's reverted in my issue 65 branch, for which I'll issue a pull request.\n\nMeanwhile I discovered a couple of things:\n- All the methods for sending frames ignore the return value from `WritableStream.write`. In the test case it so happens that with a particular content size, the publish to output2 reliably exceeds the kernel buffer\n- `Connection._sendBody` ignores the maximum frame size negotiated with the server. (As it happens RabbitMQ is understanding about this)\n\nNow the most interesting thing: it appears that when the method send buffer is reused, and `WritableStream.write` returns false, the buffer is never written to the socket. When a new buffer is allocated each send, it is eventually written even if it overflows the kernel buffer.\n\nAnyway the reverted commit goes back to allocating a buffer of maxFrameSize for each method send. This is pretty wasteful -- maxFrameSize is well over the threshold for allocation from the pool. Possibly a better solution is to use a single buffer for assembling frames but copy them to (likely much smaller) fresh buffers before sending.\n. Actually forget about this one. There's a similar mistake in header() that is much more difficult to provoke.\n. That is likely to be because of reusing buffers (then writing over the contents before they are written to the socket), or perhaps frame interleaving. If you see it again please save the logs!\n. > At least RabbitMQ expects the vhost to always start with '/'.\n\nNo, it doesn't. But conventions are confusing in this regard.\n\nIn general AMQP clients, and specifically the Node.JS client, expect a vhost in the path part of the connection URL. This is either empty (nothing after the host), meaning the \"default vhost\"; or, it starts with a slash -- however the slash is _not_ counted as part of the vhost name, which means that any leading slash in the name has to be included in addition to the slash beginning the path. For example, if I have a vhost '/foo' then the URL should be something like 'amqp://host:port//foo'.\n\nAnother source of confusion is that RabbitMQ uses '/' as the default (as in pre-installed) vhost, prompting the convention of prefixing a slash.\n\nAffixing a slash removes the possibility of addressing vhosts without it.\n. > I'm trying to get amqp working with a Solace hardware router (http://solacesystems.com/products/unified-api-and-open-source/), which implements amqp.\n\nI don't think it does implement AMQP, or at least not AMQP 0.9.1. I'm pretty sure Solace kit uses its own proprietary protocol.\n\n\"Unsupported Protocol Version\" suggests it doesn't. I suspect the oversized frame error is just because the parser hasn't been told to stop trying to interpret the incoming bytes as AMQP frames.\n. The main things people seem to miss, coming from node-amqp to amqplib, are callbacks (rather than promises) and some variety of auto-recovery. I relented on the former and added a callback-oriented API not long ago.\n\nAuto-recovery I have always thought of as a misfeature, but people have reported that it works OK for what they're doing. And I've seen AMQP clients in other languages with auto-recovery working in practice, so I am more accustomed to the idea now, even if I still think it's very tricky (maybe impossible) to get right.\n\nOf course, moving across, there is a bit of porting work to do, since amqplib is not that similar to node-amqp's API (which I believe to be mistaken).\n. ",
    "dimik": "it seem's still doesn't work with defaultExchange = ''\nor show me how to do right\ni use simple python publisher send.py from the rabbitMQ first tutorial\nhttp://www.rabbitmq.com/tutorials/tutorial-one-python.html\nthe node.js receiver part looks like:\n\n``` javascript\n    var amqp = require('amqp');\n    var connection = amqp.createConnection({ host : \"localhost\" }, { defaultExchange : \"\"  });                                                                                                                                                                                                                                                                                                          \n    connection.on('ready', function () {\n        console.log(\"connected to \" + connection.serverProperties.product);\n        var q = connection.queue('hello');\n        ...\n    });\n```\n\nand it falling down on `var q = connection.queue('hello');`\n*\ndimik@mini:~/ria# node dispatcher.js\nconnected to RabbitMQ\n\nevents.js:48\n        throw arguments[1]; // Unhandled 'error' event\n                       ^\nError: PRECONDITION_FAILED - parameters for queue 'hello' in vhost '/' not equivalent\n    at Queue._onMethod (/Users/dimik/ria/node_modules/amqp/amqp.js:1703:15)\n    at Queue._onChannelMethod (/Users/dimik/ria/node_modules/amqp/amqp.js:1348:14)\n    at Connection._onMethod (/Users/dimik/ria/node_modules/amqp/amqp.js:917:28)\n    at AMQPParser.onMethod (/Users/dimik/ria/node_modules/amqp/amqp.js:792:12)\n    at AMQPParser._parseMethodFrame (/Users/dimik/ria/node_modules/amqp/amqp.js:441:10)\n    at frameEnd (/Users/dimik/ria/node_modules/amqp/amqp.js:186:16)\n    at frame (/Users/dimik/ria/node_modules/amqp/amqp.js:171:14)\n    at AMQPParser.header as parse (/Users/dimik/ria/node_modules/amqp/amqp.js:159:14)\n    at AMQPParser.execute (/Users/dimik/ria/node_modules/amqp/amqp.js:230:21)\n    at Connection.<anonymous> (/Users/dimik/ria/node_modules/amqp/amqp.js:832:12)\n*\n. No special properties\nlike in tutorial it use only name in constructor\n`channel.queue_declare(queue='hello')`\nrabbitctl say:\n`sudo rabbitmqctl list_queues name durable auto_delete           \nListing queues ...\nhello   false   false`\n. Thanks, Michael\nYou was right, and all works now\nThis is the strange node-amqp defaults.\n\nBTW\ni try console.log incoming message and was surprised by undefined contentType instead of something like \"octet/stream\"\n{ data: <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64 21>,\n  contentType: undefined }\nit's because python pika just doesn't send them?\n. it seem's still doesn't work with defaultExchange = ''\nor show me how to do right\ni use simple python publisher send.py from the rabbitMQ first tutorial\nhttp://www.rabbitmq.com/tutorials/tutorial-one-python.html\nthe node.js receiver part looks like:\n\n``` javascript\n    var amqp = require('amqp');\n    var connection = amqp.createConnection({ host : \"localhost\" }, { defaultExchange : \"\"  });                                                                                                                                                                                                                                                                                                          \n    connection.on('ready', function () {\n        console.log(\"connected to \" + connection.serverProperties.product);\n        var q = connection.queue('hello');\n        ...\n    });\n```\n\nand it falling down on `var q = connection.queue('hello');`\n*\ndimik@mini:~/ria# node dispatcher.js\nconnected to RabbitMQ\n\nevents.js:48\n        throw arguments[1]; // Unhandled 'error' event\n                       ^\nError: PRECONDITION_FAILED - parameters for queue 'hello' in vhost '/' not equivalent\n    at Queue._onMethod (/Users/dimik/ria/node_modules/amqp/amqp.js:1703:15)\n    at Queue._onChannelMethod (/Users/dimik/ria/node_modules/amqp/amqp.js:1348:14)\n    at Connection._onMethod (/Users/dimik/ria/node_modules/amqp/amqp.js:917:28)\n    at AMQPParser.onMethod (/Users/dimik/ria/node_modules/amqp/amqp.js:792:12)\n    at AMQPParser._parseMethodFrame (/Users/dimik/ria/node_modules/amqp/amqp.js:441:10)\n    at frameEnd (/Users/dimik/ria/node_modules/amqp/amqp.js:186:16)\n    at frame (/Users/dimik/ria/node_modules/amqp/amqp.js:171:14)\n    at AMQPParser.header as parse (/Users/dimik/ria/node_modules/amqp/amqp.js:159:14)\n    at AMQPParser.execute (/Users/dimik/ria/node_modules/amqp/amqp.js:230:21)\n    at Connection.<anonymous> (/Users/dimik/ria/node_modules/amqp/amqp.js:832:12)\n*\n. No special properties\nlike in tutorial it use only name in constructor\n`channel.queue_declare(queue='hello')`\nrabbitctl say:\n`sudo rabbitmqctl list_queues name durable auto_delete           \nListing queues ...\nhello   false   false`\n. Thanks, Michael\nYou was right, and all works now\nThis is the strange node-amqp defaults.\n\nBTW\ni try console.log incoming message and was surprised by undefined contentType instead of something like \"octet/stream\"\n{ data: <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64 21>,\n  contentType: undefined }\nit's because python pika just doesn't send them?\n. ",
    "TonySullivan": "I'm still having problems with the Exhange call back not executing. My code is below. Any ideas?\n\nvar conn = amqp.createConnection({ url: connectionUrl() });\nconn.on('ready', function () {\n\n```\nconsole.log('Connected to ' + connectionUrl()); //<= this works\nconn.exchange('test', function (exchange) {\n    console.log('Exchange ready.'); // <=this never gets called\n});\n```\n\n});\n. I'm still having problems with the Exhange call back not executing. My code is below. Any ideas?\n\nvar conn = amqp.createConnection({ url: connectionUrl() });\nconn.on('ready', function () {\n\n```\nconsole.log('Connected to ' + connectionUrl()); //<= this works\nconn.exchange('test', function (exchange) {\n    console.log('Exchange ready.'); // <=this never gets called\n});\n```\n\n});\n. ",
    "rbochenski": "I have made some patch for this. With this you have also possibility to ack message later, just have to remember object with getLastMessage instead of doing queue.shift() .\n\n--- /Users/bochen/ExDownloads/postwait-node-amqp-81febcc/amqp.js    2011-07-30 06:46:36.000000000 +0200\n+++ amqp.js 2011-10-10 11:36:18.000000000 +0200\n@@ -1438,6 +1438,22 @@\n };\n\n+Queue.prototype.changeQuos = function (setPrefetchCount) {\n-   var self = this;\n-   self.connection._sendMethod(self.channel, methods.basicQos,\n-       { reserved1: 0\n-       , prefetchSize: 0\n-       , prefetchCount: setPrefetchCount\n-       , global: false\n-       });\n  +}\n  +\n  +// Options\n  +// - ack (boolean)\n  +// - prefetchSize (boolean)\n  +// - routingKeyInPayload\n  +// - routingKeyInPayload\n  +\n  Queue.prototype.subscribe = function (/\\* options, messageListener */) {\n   var self = this;\n\n@@ -1449,6 +1465,7 @@\n                   deliveryTagInPayload: self.connection.options.deliveryTagInPayload };\n   if (typeof arguments[0] == 'object') {\n     if (arguments[0].ack) options.ack = true;\n-   if (arguments[0].prefetchSize) options.prefetchSize = arguments[0].prefetchSize;\n   if (arguments[0].routingKeyInPayload)\n     options.routingKeyInPayload = arguments[0].routingKeyInPayload;\n   if (arguments[0].deliveryTagInPayload)\n  @@ -1456,12 +1473,7 @@\n  }\n  \n  if (options.ack) {\n-    self.connection._sendMethod(self.channel, methods.basicQos,\n-        { reserved1: 0\n-        , prefetchSize: 0\n-        , prefetchCount: 1\n-        , global: false\n-        });\n- ```\n  this.changeQuos ((options.prefetchSize ? options.prefetchSize : 1));\n  ```\n  \n  }\n  \n  // basic consume\n  @@ -1535,6 +1547,11 @@\n  };\n\n+Queue.prototype.lastMessage = function () {\n-   return this._lastMessage;\n  +}\n  +\n  +\n  Queue.prototype.bind = function (/\\* [exchange,] routingKey */) {\n   var self = this;\n. I have made some patch for this. With this you have also possibility to ack message later, just have to remember object with getLastMessage instead of doing queue.shift() .\n\n--- /Users/bochen/ExDownloads/postwait-node-amqp-81febcc/amqp.js    2011-07-30 06:46:36.000000000 +0200\n+++ amqp.js 2011-10-10 11:36:18.000000000 +0200\n@@ -1438,6 +1438,22 @@\n };\n\n+Queue.prototype.changeQuos = function (setPrefetchCount) {\n-   var self = this;\n-   self.connection._sendMethod(self.channel, methods.basicQos,\n-       { reserved1: 0\n-       , prefetchSize: 0\n-       , prefetchCount: setPrefetchCount\n-       , global: false\n-       });\n  +}\n  +\n  +// Options\n  +// - ack (boolean)\n  +// - prefetchSize (boolean)\n  +// - routingKeyInPayload\n  +// - routingKeyInPayload\n  +\n  Queue.prototype.subscribe = function (/\\* options, messageListener */) {\n   var self = this;\n\n@@ -1449,6 +1465,7 @@\n                   deliveryTagInPayload: self.connection.options.deliveryTagInPayload };\n   if (typeof arguments[0] == 'object') {\n     if (arguments[0].ack) options.ack = true;\n-   if (arguments[0].prefetchSize) options.prefetchSize = arguments[0].prefetchSize;\n   if (arguments[0].routingKeyInPayload)\n     options.routingKeyInPayload = arguments[0].routingKeyInPayload;\n   if (arguments[0].deliveryTagInPayload)\n  @@ -1456,12 +1473,7 @@\n  }\n  \n  if (options.ack) {\n-    self.connection._sendMethod(self.channel, methods.basicQos,\n-        { reserved1: 0\n-        , prefetchSize: 0\n-        , prefetchCount: 1\n-        , global: false\n-        });\n- ```\n  this.changeQuos ((options.prefetchSize ? options.prefetchSize : 1));\n  ```\n  \n  }\n  \n  // basic consume\n  @@ -1535,6 +1547,11 @@\n  };\n\n+Queue.prototype.lastMessage = function () {\n-   return this._lastMessage;\n  +}\n  +\n  +\n  Queue.prototype.bind = function (/\\* [exchange,] routingKey */) {\n   var self = this;\n. ",
    "ivolo": "Sorry, shouldn't have used language like fixes #14 since this is a bit different from the queue.shift() abstraction. Please refer to my pull request. I added the message object to queue subscribe callback, so that the subscriber can call message.acknowledge(). This, I believe, allows to have a bigger window than prefetchCount=1, and allow proper acking. \n\nThis is quite important for high traffic conditions, because on localhost, I can get at most 25 messages / second with prefetchCount = 1. Increasing the window would be necessary for high volume API calls for example. \n. If you want to increase the QoS window, you need to be able to ack past the _lastMessage, so I added the message object to the queue subscribe callback to allow for QoS>1 windows and acknowledgements. Like this: \n\nq.subscribe({ack: true,  prefetchCount: 0 }, function (json, headers, deliveryInfo, message) {\n       message.acknowledge();\n});\n. Hmm, that means that the message has already been acked (given that you have set ack to true in the options). Are you using shift() and acknowledge() together, or acking twice for some reason?\n. So, if you tell AMQP that you want to ack your messages, it won't send you more than prefetchCount pending messages before you have to ack. This library, prior to this pull request, supposes that prefetchCount == 1, which means that you only get one message, and won't get the next one until you ack it. That's what shift() does, it acks the last message you got. \n\nIf you want to increase prefetchCount to larger than 1 (or 0 for unlimited), you won't be able to use shift() anymore. This is because every time you get a message, its marked as the \"last message\", and shift will only ack the \"last message\". So suppose you are delivered ten messages m0, m1 ... m9 before you get a chance to ack any of them. Then you call shift() per each message, but that will send acks for m9 only since its marked as \"last message\". \n\nThat's why I added the message object as the last argument in the subscribe callback. You can acknowledge each messge object specifically using message.acknowledge() and without using shift() at all. Here's an example:\n\nvar q = connection.queue('MyQueue', {passive: true, autodelete: false}, function(queue) { \n    console.log(\"Queue \" + queue.name + \" is open\");\n    q.subscribe({ack: true,  prefetchCount: 10 }, function (json, headers, deliveryInfo, message) {\n        console.log(\"Received message : \" + json);\n        message.acknowledge();\n    });\n});\n\nThis will ack m0, m1, m2, etc...\n. @squaremo, I wanted to thank you for all your work in this direction. I was wondering if there could be more movement to finish this up, and merge in the last year's changes to node-amqp.\n\nWe have a thousands of queues (which AFAIK is a normal use case), and having a channel per queue results in hundreds of MB of extra overhead for the server. Here's a reference RabbitMQ thread about this: http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/2013-April/026486.html . In addition, setting a prefetchCount that spans multiple subscriptions becomes impossible. \n\nThanks again!\n. I was hoping that the global flag being set to true would allow me to get the prefetchCount across subscriptions, but it turns out thats global connection limits is one of the features that RabbitMQ [does not implement from the AMQP standard](https://github.com/postwait/node-amqp/blob/master/amqp.js#L1609).\n\nSo without a layered channel API, it's impossible to tell the server that you only want X messages at a time across multiple subscriptions. \n. @squaremo thanks for the explanation. we might try our hand at an alternative library with channel APIs exposed. I'll let you know!\n. I just unpublished it - really sorry about that, It was a mistake. \n. Sorry, shouldn't have used language like fixes #14 since this is a bit different from the queue.shift() abstraction. Please refer to my pull request. I added the message object to queue subscribe callback, so that the subscriber can call message.acknowledge(). This, I believe, allows to have a bigger window than prefetchCount=1, and allow proper acking. \n\nThis is quite important for high traffic conditions, because on localhost, I can get at most 25 messages / second with prefetchCount = 1. Increasing the window would be necessary for high volume API calls for example. \n. If you want to increase the QoS window, you need to be able to ack past the _lastMessage, so I added the message object to the queue subscribe callback to allow for QoS>1 windows and acknowledgements. Like this: \n\nq.subscribe({ack: true,  prefetchCount: 0 }, function (json, headers, deliveryInfo, message) {\n       message.acknowledge();\n});\n. Hmm, that means that the message has already been acked (given that you have set ack to true in the options). Are you using shift() and acknowledge() together, or acking twice for some reason?\n. So, if you tell AMQP that you want to ack your messages, it won't send you more than prefetchCount pending messages before you have to ack. This library, prior to this pull request, supposes that prefetchCount == 1, which means that you only get one message, and won't get the next one until you ack it. That's what shift() does, it acks the last message you got. \n\nIf you want to increase prefetchCount to larger than 1 (or 0 for unlimited), you won't be able to use shift() anymore. This is because every time you get a message, its marked as the \"last message\", and shift will only ack the \"last message\". So suppose you are delivered ten messages m0, m1 ... m9 before you get a chance to ack any of them. Then you call shift() per each message, but that will send acks for m9 only since its marked as \"last message\". \n\nThat's why I added the message object as the last argument in the subscribe callback. You can acknowledge each messge object specifically using message.acknowledge() and without using shift() at all. Here's an example:\n\nvar q = connection.queue('MyQueue', {passive: true, autodelete: false}, function(queue) { \n    console.log(\"Queue \" + queue.name + \" is open\");\n    q.subscribe({ack: true,  prefetchCount: 10 }, function (json, headers, deliveryInfo, message) {\n        console.log(\"Received message : \" + json);\n        message.acknowledge();\n    });\n});\n\nThis will ack m0, m1, m2, etc...\n. @squaremo, I wanted to thank you for all your work in this direction. I was wondering if there could be more movement to finish this up, and merge in the last year's changes to node-amqp.\n\nWe have a thousands of queues (which AFAIK is a normal use case), and having a channel per queue results in hundreds of MB of extra overhead for the server. Here's a reference RabbitMQ thread about this: http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/2013-April/026486.html . In addition, setting a prefetchCount that spans multiple subscriptions becomes impossible. \n\nThanks again!\n. I was hoping that the global flag being set to true would allow me to get the prefetchCount across subscriptions, but it turns out thats global connection limits is one of the features that RabbitMQ [does not implement from the AMQP standard](https://github.com/postwait/node-amqp/blob/master/amqp.js#L1609).\n\nSo without a layered channel API, it's impossible to tell the server that you only want X messages at a time across multiple subscriptions. \n. @squaremo thanks for the explanation. we might try our hand at an alternative library with channel APIs exposed. I'll let you know!\n. I just unpublished it - really sorry about that, It was a mistake. \n. ",
    "ashwinphatak": "I needed this functionality too, but for a different reason. I maintain a connection pool and a particular connection needs to serve different queues at different time, hence the need to unsubscribe from an older queue. Closing the queue works well  for the most part.\n\nHowever, I'm seeing a strange issue at high concurrencies. \n\nRabbitMQ log:\n=ERROR REPORT==== 4-Oct-2011::10:25:39 ===\nconnection <0.11602.1> (running), channel 65 - error:\n{amqp_error,channel_error,\"expected 'channel.open'\",'basic.qos'}\n\nAnd, in node-amqp:\nUnhandled connection error: CHANNEL_ERROR - expected 'channel.open'\n\nRabbitMQ seems to be complaining that it received a basic.qos before channel.open, but looking at the node-amqp code, I can't see how this can happen. Any ideas or pointers?\n. I'll try this out, thanks a lot!\n. Are there plans to merge this?\n. @mattbornski I want to try out your changes. Would you recommend using your fork directly or merging your changes into a copy of the main repo?\n. I tried using your fork, but even when I turn on reconnect, I get an error when I take down RabbitMQ. What am I doing wrong?\n\nvar connection = amqp.createConnection({ host: 'localhost' }, { reconnect: true });\n\nevents.js:48\n        throw arguments[1]; // Unhandled 'error' event\n                       ^\nError: CONNECTION_FORCED - broker forced connection closure with reason 'shutdown'\n\nand the process gets killed\n. I don't have any special setup - I killed the server using /etc/init.d/rabbitmq-server stop\n. Why is the node process getting killed? I thought the 'reconnect' logic would take care of waiting and reconnecting back?\n. Thanks, I got it working after adding a handler for uncaughtException.\n. With the reconnect patch, sometimes I'm seeing duplicate messages getting delivered via queue.subscribe after RabbitMQ stop/start. Anyone else seen this?\n. How do we gracefully close a connection which has reconnect set to 'true'? When I do connection.end(), it's connecting back.\n. Thanks for confirming. Yesterday I ended up doing the same thing, after I couldn't see any other way of achieving the same effect.\n\nconn.implOptions.reconnect = false;\nconn.end()\n. I needed this functionality too, but for a different reason. I maintain a connection pool and a particular connection needs to serve different queues at different time, hence the need to unsubscribe from an older queue. Closing the queue works well  for the most part.\n\nHowever, I'm seeing a strange issue at high concurrencies. \n\nRabbitMQ log:\n=ERROR REPORT==== 4-Oct-2011::10:25:39 ===\nconnection <0.11602.1> (running), channel 65 - error:\n{amqp_error,channel_error,\"expected 'channel.open'\",'basic.qos'}\n\nAnd, in node-amqp:\nUnhandled connection error: CHANNEL_ERROR - expected 'channel.open'\n\nRabbitMQ seems to be complaining that it received a basic.qos before channel.open, but looking at the node-amqp code, I can't see how this can happen. Any ideas or pointers?\n. I'll try this out, thanks a lot!\n. Are there plans to merge this?\n. @mattbornski I want to try out your changes. Would you recommend using your fork directly or merging your changes into a copy of the main repo?\n. I tried using your fork, but even when I turn on reconnect, I get an error when I take down RabbitMQ. What am I doing wrong?\n\nvar connection = amqp.createConnection({ host: 'localhost' }, { reconnect: true });\n\nevents.js:48\n        throw arguments[1]; // Unhandled 'error' event\n                       ^\nError: CONNECTION_FORCED - broker forced connection closure with reason 'shutdown'\n\nand the process gets killed\n. I don't have any special setup - I killed the server using /etc/init.d/rabbitmq-server stop\n. Why is the node process getting killed? I thought the 'reconnect' logic would take care of waiting and reconnecting back?\n. Thanks, I got it working after adding a handler for uncaughtException.\n. With the reconnect patch, sometimes I'm seeing duplicate messages getting delivered via queue.subscribe after RabbitMQ stop/start. Anyone else seen this?\n. How do we gracefully close a connection which has reconnect set to 'true'? When I do connection.end(), it's connecting back.\n. Thanks for confirming. Yesterday I ended up doing the same thing, after I couldn't see any other way of achieving the same effect.\n\nconn.implOptions.reconnect = false;\nconn.end()\n. ",
    "majek": "> There's a couple of solutions that suggest themselves. One is to not cache queues -- create a new channel every time a queue is requested through connection.queue(). Closing (but not destroying) the queue would close the AMQP channel, and the subscription, and thereby have the correct effect. By and large this would work, but in some cases it would give surprising results, because the detail of channels is hidden in node-amqp.\n\nCan we avoid changing the semantics of `Queues` (ie: don't change caching) and just add a command like `Queue.close` which will:\n1. remove the queue from cache\n2. unsubscribe all subscribers\n3. kill channel\n. Simple benchmark: https://gist.github.com/3787602\n\nOn default (80fc04991ab90ccb7b50d459809ba5db26c69627): \n$ time node t.js 1   > 0.408s\n$ time node t.js 2   > 0.348s\n$ time node t.js 3   > 0.349s\n\nOn my branch (1b322a591646be065386790cd7e3dee411419b98) + hardcoded max frame size for outgoing messages to 1024 bytes (ie: very small frame):\n$ time node t.js 1   > 0.458s\n$ time node t.js 2   > 0.391s\n$ time node t.js 3   > 0.395s\n\nI can't benchmark it for larger messages / larger number of messages because node-amqp breaks when the outgoing buffer is large (for my benchmark - it looks like all messages are being sent to `meta` queue rather than `test`)\n. > There's a couple of solutions that suggest themselves. One is to not cache queues -- create a new channel every time a queue is requested through connection.queue(). Closing (but not destroying) the queue would close the AMQP channel, and the subscription, and thereby have the correct effect. By and large this would work, but in some cases it would give surprising results, because the detail of channels is hidden in node-amqp.\n\nCan we avoid changing the semantics of `Queues` (ie: don't change caching) and just add a command like `Queue.close` which will:\n1. remove the queue from cache\n2. unsubscribe all subscribers\n3. kill channel\n. Simple benchmark: https://gist.github.com/3787602\n\nOn default (80fc04991ab90ccb7b50d459809ba5db26c69627): \n$ time node t.js 1   > 0.408s\n$ time node t.js 2   > 0.348s\n$ time node t.js 3   > 0.349s\n\nOn my branch (1b322a591646be065386790cd7e3dee411419b98) + hardcoded max frame size for outgoing messages to 1024 bytes (ie: very small frame):\n$ time node t.js 1   > 0.458s\n$ time node t.js 2   > 0.391s\n$ time node t.js 3   > 0.395s\n\nI can't benchmark it for larger messages / larger number of messages because node-amqp breaks when the outgoing buffer is large (for my benchmark - it looks like all messages are being sent to `meta` queue rather than `test`)\n. ",
    "japj": "I think unsubscribing is also usefull when you want to exit the consumer process (i.e. because you need to upgrade the software), but you don't want to loose any messages in between.\n\nSo that means the queue and the binding needs to keep exist, but you want to temporarily stop subscription of the consumer so you can safely exit the process.\n\nI look at the current amqp code, and was wondering.. is the consumerTag only known in the rawMessage/deliveryInfo (when subscription has been done)?\nOr does subscribe return something that contains the consumerTag?\n. @squaremo I did not find any use of http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.recover in node-amqp.\nSo tthis is slightly confuses me.\n\nWhen an consumer closes the connection and the queue autoDelete = false, will unacked messages be send first when a new consumer connects to the same queue?\n\nOr does a consumer need to explicitly call the basic.recover mechanism?\n. @squaremo  thanks for the additional info and sorry for using this issue a bit like a forum\n\nIf I understand correctly, using connection.end/reconnect is a safe way to 'suspend' delivery of all messages to a consumer?\ni.e. \n1) consume messages for x seconds\n2) end the connection, sleep y seconds (now it is safe to exit the consumer while the amqp queue will still receive new messages)\n3) reconnect connection and go to 1)\n\nSo connection.end/reconnect could be used for the whole consumer (and is available in the 'master tree' at the moment), but if you want to unsubscribe to a single queue while other queues are still processed you actually need to use basicCancelOk like you implemented in your branch?\n. ok, it seems closing the actual connection at some point is not robust enough for me because there can actually be still a message being processed for which I need to call queue.shift() (and that consequently fails due to the socket connection being already closed).\n\nI will have a look at using the unsubscribe implementation mentioned at https://github.com/squaremo/node-amqp/commit/a3d33a54ace4e3a409e08096044a14bd61b6ff2d\n. just a heads up that I've been using the unsubscribe patch without any issues (doing repeated/stress subscribe/unsubscribe and checking the deliveryTag on messages for consistency).\n\nAny chance the unsubscribe change will get integrated into the 'main' node-amqp repository soon?\n. @fordox31 the callback passed to subscribe will use the following parameters: json, headers, deliveryInfo.\nThe callback passed to subscribeRaw will actually be a Message object (containing those additional functions).\n\nthe json parameter for subscribe callbacks will be the json representation of the actual message data if it was of contentType test/json or application/json.\n\nPerhaps a Queue acknowledge function that accepts the message deliveryInfo as input would be helpfull here (apparently the deliveryTag is needed to acknowledge a message)?\n. @postwait any eta on when a new version of node-amqp will be published on npm?\n. I think unsubscribing is also usefull when you want to exit the consumer process (i.e. because you need to upgrade the software), but you don't want to loose any messages in between.\n\nSo that means the queue and the binding needs to keep exist, but you want to temporarily stop subscription of the consumer so you can safely exit the process.\n\nI look at the current amqp code, and was wondering.. is the consumerTag only known in the rawMessage/deliveryInfo (when subscription has been done)?\nOr does subscribe return something that contains the consumerTag?\n. @squaremo I did not find any use of http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.recover in node-amqp.\nSo tthis is slightly confuses me.\n\nWhen an consumer closes the connection and the queue autoDelete = false, will unacked messages be send first when a new consumer connects to the same queue?\n\nOr does a consumer need to explicitly call the basic.recover mechanism?\n. @squaremo  thanks for the additional info and sorry for using this issue a bit like a forum\n\nIf I understand correctly, using connection.end/reconnect is a safe way to 'suspend' delivery of all messages to a consumer?\ni.e. \n1) consume messages for x seconds\n2) end the connection, sleep y seconds (now it is safe to exit the consumer while the amqp queue will still receive new messages)\n3) reconnect connection and go to 1)\n\nSo connection.end/reconnect could be used for the whole consumer (and is available in the 'master tree' at the moment), but if you want to unsubscribe to a single queue while other queues are still processed you actually need to use basicCancelOk like you implemented in your branch?\n. ok, it seems closing the actual connection at some point is not robust enough for me because there can actually be still a message being processed for which I need to call queue.shift() (and that consequently fails due to the socket connection being already closed).\n\nI will have a look at using the unsubscribe implementation mentioned at https://github.com/squaremo/node-amqp/commit/a3d33a54ace4e3a409e08096044a14bd61b6ff2d\n. just a heads up that I've been using the unsubscribe patch without any issues (doing repeated/stress subscribe/unsubscribe and checking the deliveryTag on messages for consistency).\n\nAny chance the unsubscribe change will get integrated into the 'main' node-amqp repository soon?\n. @fordox31 the callback passed to subscribe will use the following parameters: json, headers, deliveryInfo.\nThe callback passed to subscribeRaw will actually be a Message object (containing those additional functions).\n\nthe json parameter for subscribe callbacks will be the json representation of the actual message data if it was of contentType test/json or application/json.\n\nPerhaps a Queue acknowledge function that accepts the message deliveryInfo as input would be helpfull here (apparently the deliveryTag is needed to acknowledge a message)?\n. @postwait any eta on when a new version of node-amqp will be published on npm?\n. ",
    "kevinlieb": "So I am a bit of a newbee here and not sure where this issue left off:\nIf I want a busy worker to stop getting messages temporarily, until it \"catches up\" is it better to unsubscribe, unbind or just disconnect?\n. Thanks so much for the info. \n\nSo is there a way to set the number of unack'd messages in node-amqp to more than 1, like 20?\n. This is exactly what I needed.  But I tried this but I am getting an error like:\n\nError: PRECONDITION_FAILED - unknown delivery tag 30\n    at Queue._onMethod (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:1718:15)\n    at Queue._onChannelMethod (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:1367:14)\n    at Connection._onMethod (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:936:28)\n    at AMQPParser.onMethod (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:811:12)\n    at AMQPParser._parseMethodFrame (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:456:10)\n    at AMQPParser.execute (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:206:20)\n    at Connection.<anonymous> (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:851:12)\n    at Connection.emit (events.js:67:17)\n    at TCP.onread (net.js:327:14)\n\nwhen setting prefetchCount to 10\n\nAny ideas what could be going wrong?\n. I set up the queue like:\n\nvar q = connection.queue('MyQueue', {passive: true, autodelete: false},function(queue) { console.log(\"Queue \" + queue.name + \" is open\");});\n\nand:\n q.shift();\nwhen I am done with the message.  \n\nI don't have a q.acknowledge() in there.\n. That makes sense now, thanks Ivolo!  I implemented this and it works well.\n. Anyone have any ideas on how to fix this?\n. So I am a bit of a newbee here and not sure where this issue left off:\nIf I want a busy worker to stop getting messages temporarily, until it \"catches up\" is it better to unsubscribe, unbind or just disconnect?\n. Thanks so much for the info. \n\nSo is there a way to set the number of unack'd messages in node-amqp to more than 1, like 20?\n. This is exactly what I needed.  But I tried this but I am getting an error like:\n\nError: PRECONDITION_FAILED - unknown delivery tag 30\n    at Queue._onMethod (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:1718:15)\n    at Queue._onChannelMethod (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:1367:14)\n    at Connection._onMethod (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:936:28)\n    at AMQPParser.onMethod (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:811:12)\n    at AMQPParser._parseMethodFrame (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:456:10)\n    at AMQPParser.execute (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:206:20)\n    at Connection.<anonymous> (/dailydeploy/trunk/node.js.source/node_modules/amqp/amqp.js:851:12)\n    at Connection.emit (events.js:67:17)\n    at TCP.onread (net.js:327:14)\n\nwhen setting prefetchCount to 10\n\nAny ideas what could be going wrong?\n. I set up the queue like:\n\nvar q = connection.queue('MyQueue', {passive: true, autodelete: false},function(queue) { console.log(\"Queue \" + queue.name + \" is open\");});\n\nand:\n q.shift();\nwhen I am done with the message.  \n\nI don't have a q.acknowledge() in there.\n. That makes sense now, thanks Ivolo!  I implemented this and it works well.\n. Anyone have any ideas on how to fix this?\n. ",
    "glenjamin": "The main issue was that the queue was emitting a \"close\" event due to the server informing it of an error, but this wasn't being listened for.\n\nThe general node way of handling this would, I believe, be to fire off an \"error\" event. EventEmitter will release an exception if no handler is defined for the \"error\" event.\n. The channel close event is already fired, although it's currently defined on queue and exchange separately (although the exchange prints the error to stdout, while queue swallows).\n\nIMO, the most useful approach would be:\n- Move the close event firing code to the Channel class so the logic is shared\n- If the close comes from the server with an error, emit an error event\n\nThe key points to this are that you can choose to capture the error and handle it gracefully by reconnecting, and if you do not capture the error event - either due to the fact it's not documented or by choice - the fatal exception kills your program and you find out about it. Firing off identical events for controlled and exceptional channel closing is not particularly useful.\n. I've just run into this, looks like there's an issue in the code to do with comparison of 64bit integers.\n\nThis seems to be \"fixed\" in master by casting the value down to a 32 bit for comparison - I guess as long as you don't try to confirm more than MAXINT messages this will work.\n\nAny idea when there might be another release to npm, anything I can do to help?\n. Can you confirm what client & server versions you are seeing this behaviour on?\n. The code at https://github.com/postwait/node-amqp/blob/master/lib/exchange.js certainly looks like it should respect the confirm option, however it appears that when used with noDeclare that code path isn't hit.\n. Ah, I had a go at finding an existing PR but must have missed that one.\n\nI'll probably flesh this out like you suggest so both options are available to merge - cheers for the feedback.\n. Whenever a bind is completed, a bindOk event is emitted on the queue object, you should be able to use this to achieve what you're after without having to patch node-amqp, 4 binds would emit 4 bindOk events for example.\n\nI'm on a phone right now, so please double-check the code/docs on this - the advice should be sound but the details may be slightly incorrect.\n\n> On 8 Apr 2014, at 04:18, Tom Erik St\u00f8wer notifications@github.com wrote:\n> \n> The problem of running multiple bind operations in parallell with their own callbacks will not be fixed by this, am I right?\n> \n> I would like some pointers of best practice. I need to wait for a binding to complete before polling for data through it, and much of this happens in parallell all the way back to the client. But if there is already a binding operation in progress, issuing another one will replace the callback.\n> \n> If I would like to patch node-amqp to support a separate callback for each binding operation, how would I proceed?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. The best docs I know of are here: https://www.rabbitmq.com/amqp-0-9-1-reference.html#class.queue\n\nIt doesn't look like the info is there, but you can try using the NODE_DEBUG_AMQP environment variable to see the protocol communication, or just subscribe to the event and see what comes out.\n\nIf the info isn't there you could achieve this by only doing one bind at a time on any given channel, perhaps using something like async.queue as the throttle. You can use multiple channels if you need higher throughput.\n\n> On 10 Apr 2014, at 11:02, Tom Erik St\u00f8wer notifications@github.com wrote:\n> \n> The problem is that I need to know which particular binding completed. Do you have any suggestions for how to achieve that? I can't find any documentation on the bindOk event though.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. My branch doesn't stop other bits of the system from trying to send data once the socket is closed - I was a bit lazy there.\n\nSay you have a continuous publish(), then you trigger a close - the publish that happens after socket.end() / connectionCloseOk will cause the exception described above.\n\nPossible Solutions:\n1. Make sure your app stops trying to send data after a close\n2. Extend the branch to make node-amqp throw a more obvious error in this scenario\n3. Call socket.end() _and_ socket.destroy() in the handler - this should stop data being sent after the close think.\n. You can do this using `queue.subscribeRaw`, but unfortunately you lose a bit more than just json parsing. This is currently the simplest way to achieve this as far as I can tell.\n. It's not the cleanest, but you can do it, see https://github.com/postwait/node-amqp/blob/master/lib/queue.js#L51\n\n``` javascript\nvar methods = require('amqp/lib/definitions').methods;\nqueue.connection._sendMethod(queue.channel, methods.basicQos,\n        { reserved1: 0\n        , prefetchSize: 0\n        , prefetchCount: 1234\n        , global: false\n        });\n```\n\nIt wouldn't be too hard to extract this method and add it to the queue prototype if there's an appetite for it.\n. You just need to call `queue.destroy()` when you're done.\n\nhttps://github.com/postwait/node-amqp#queuedestroyoptions\n. Cheers for the quick response.\n\nThat solves the `reconnect: false` case, although the error source ends up looking a touch odd:\n\n```\n> node silent.js\nConnecting to amqp://guest:guest@192.168.73.133/conglomerate\nConnected to server\nExchange declared, publishing...\n\n/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/connection.js:252\n        if(listeners === null || listeners.length === 0) throw(e);\n                                                               ^\nTypeError: Object #<Exchange> has no method 'pubilsh'\n    at Exchange._openCallback (/Users/gma08/Development/GitHub/conglomerate-node-client/silent.js:15:11)\n    at Exchange._onMethod (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/exchange.js:99:16)\n    at Exchange.Channel._onChannelMethod (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/channel.js:85:12)\n    at Connection._onMethod (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/connection.js:424:28)\n    at AMQPParser.self.parser.onMethod (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/connection.js:133:12)\n    at AMQPParser._parseMethodFrame (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:360:10)\n    at frameEnd (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:93:16)\n    at frame (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:78:14)\n    at AMQPParser.header [as parse] (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:64:14)\n    at AMQPParser.execute (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:137:21)\n```\n\nHowever there's no change to the reconnection behaviour.\n\n```\n> AMQP_RECONNECT=1 node silent.js\nConnecting to amqp://guest:guest@192.168.73.133/conglomerate\nConnected to server\nExchange declared, publishing...\nConnected to server\nExchange declared, publishing...\nConnected to server\nExchange declared, publishing...\nConnected to server\nExchange declared, publishing...\nConnected to server\nExchange declared, publishing...\nConnected to server\n```\n\nWith the fix about, it still feels like there's a couple of issues here:\n- non-amqp-related errors being bundled into the connection object due to try..catch\n- auto-reconnect triggering on application errors as well as connection errors\n\nFor example, if I try and declare an exchange with a different type to the server's I get the following error:\n\n```\nError: PRECONDITION_FAILED - cannot redeclare exchange 'test' in vhost 'conglomerate' with different type, durable, internal or autodelete value\n```\n\nWhich is of course, correct.\n\nHowever, if i enable reconnection, the app continually retries the connection, which always results in the same failure.\n\nI'm not really sure what the \"correct\" behaviour should be!\n. The main issue was that the queue was emitting a \"close\" event due to the server informing it of an error, but this wasn't being listened for.\n\nThe general node way of handling this would, I believe, be to fire off an \"error\" event. EventEmitter will release an exception if no handler is defined for the \"error\" event.\n. The channel close event is already fired, although it's currently defined on queue and exchange separately (although the exchange prints the error to stdout, while queue swallows).\n\nIMO, the most useful approach would be:\n- Move the close event firing code to the Channel class so the logic is shared\n- If the close comes from the server with an error, emit an error event\n\nThe key points to this are that you can choose to capture the error and handle it gracefully by reconnecting, and if you do not capture the error event - either due to the fact it's not documented or by choice - the fatal exception kills your program and you find out about it. Firing off identical events for controlled and exceptional channel closing is not particularly useful.\n. I've just run into this, looks like there's an issue in the code to do with comparison of 64bit integers.\n\nThis seems to be \"fixed\" in master by casting the value down to a 32 bit for comparison - I guess as long as you don't try to confirm more than MAXINT messages this will work.\n\nAny idea when there might be another release to npm, anything I can do to help?\n. Can you confirm what client & server versions you are seeing this behaviour on?\n. The code at https://github.com/postwait/node-amqp/blob/master/lib/exchange.js certainly looks like it should respect the confirm option, however it appears that when used with noDeclare that code path isn't hit.\n. Ah, I had a go at finding an existing PR but must have missed that one.\n\nI'll probably flesh this out like you suggest so both options are available to merge - cheers for the feedback.\n. Whenever a bind is completed, a bindOk event is emitted on the queue object, you should be able to use this to achieve what you're after without having to patch node-amqp, 4 binds would emit 4 bindOk events for example.\n\nI'm on a phone right now, so please double-check the code/docs on this - the advice should be sound but the details may be slightly incorrect.\n\n> On 8 Apr 2014, at 04:18, Tom Erik St\u00f8wer notifications@github.com wrote:\n> \n> The problem of running multiple bind operations in parallell with their own callbacks will not be fixed by this, am I right?\n> \n> I would like some pointers of best practice. I need to wait for a binding to complete before polling for data through it, and much of this happens in parallell all the way back to the client. But if there is already a binding operation in progress, issuing another one will replace the callback.\n> \n> If I would like to patch node-amqp to support a separate callback for each binding operation, how would I proceed?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. The best docs I know of are here: https://www.rabbitmq.com/amqp-0-9-1-reference.html#class.queue\n\nIt doesn't look like the info is there, but you can try using the NODE_DEBUG_AMQP environment variable to see the protocol communication, or just subscribe to the event and see what comes out.\n\nIf the info isn't there you could achieve this by only doing one bind at a time on any given channel, perhaps using something like async.queue as the throttle. You can use multiple channels if you need higher throughput.\n\n> On 10 Apr 2014, at 11:02, Tom Erik St\u00f8wer notifications@github.com wrote:\n> \n> The problem is that I need to know which particular binding completed. Do you have any suggestions for how to achieve that? I can't find any documentation on the bindOk event though.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. My branch doesn't stop other bits of the system from trying to send data once the socket is closed - I was a bit lazy there.\n\nSay you have a continuous publish(), then you trigger a close - the publish that happens after socket.end() / connectionCloseOk will cause the exception described above.\n\nPossible Solutions:\n1. Make sure your app stops trying to send data after a close\n2. Extend the branch to make node-amqp throw a more obvious error in this scenario\n3. Call socket.end() _and_ socket.destroy() in the handler - this should stop data being sent after the close think.\n. You can do this using `queue.subscribeRaw`, but unfortunately you lose a bit more than just json parsing. This is currently the simplest way to achieve this as far as I can tell.\n. It's not the cleanest, but you can do it, see https://github.com/postwait/node-amqp/blob/master/lib/queue.js#L51\n\n``` javascript\nvar methods = require('amqp/lib/definitions').methods;\nqueue.connection._sendMethod(queue.channel, methods.basicQos,\n        { reserved1: 0\n        , prefetchSize: 0\n        , prefetchCount: 1234\n        , global: false\n        });\n```\n\nIt wouldn't be too hard to extract this method and add it to the queue prototype if there's an appetite for it.\n. You just need to call `queue.destroy()` when you're done.\n\nhttps://github.com/postwait/node-amqp#queuedestroyoptions\n. Cheers for the quick response.\n\nThat solves the `reconnect: false` case, although the error source ends up looking a touch odd:\n\n```\n> node silent.js\nConnecting to amqp://guest:guest@192.168.73.133/conglomerate\nConnected to server\nExchange declared, publishing...\n\n/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/connection.js:252\n        if(listeners === null || listeners.length === 0) throw(e);\n                                                               ^\nTypeError: Object #<Exchange> has no method 'pubilsh'\n    at Exchange._openCallback (/Users/gma08/Development/GitHub/conglomerate-node-client/silent.js:15:11)\n    at Exchange._onMethod (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/exchange.js:99:16)\n    at Exchange.Channel._onChannelMethod (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/channel.js:85:12)\n    at Connection._onMethod (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/connection.js:424:28)\n    at AMQPParser.self.parser.onMethod (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/connection.js:133:12)\n    at AMQPParser._parseMethodFrame (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:360:10)\n    at frameEnd (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:93:16)\n    at frame (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:78:14)\n    at AMQPParser.header [as parse] (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:64:14)\n    at AMQPParser.execute (/Users/gma08/Development/GitHub/conglomerate-node-client/node_modules/amqp/lib/parser.js:137:21)\n```\n\nHowever there's no change to the reconnection behaviour.\n\n```\n> AMQP_RECONNECT=1 node silent.js\nConnecting to amqp://guest:guest@192.168.73.133/conglomerate\nConnected to server\nExchange declared, publishing...\nConnected to server\nExchange declared, publishing...\nConnected to server\nExchange declared, publishing...\nConnected to server\nExchange declared, publishing...\nConnected to server\nExchange declared, publishing...\nConnected to server\n```\n\nWith the fix about, it still feels like there's a couple of issues here:\n- non-amqp-related errors being bundled into the connection object due to try..catch\n- auto-reconnect triggering on application errors as well as connection errors\n\nFor example, if I try and declare an exchange with a different type to the server's I get the following error:\n\n```\nError: PRECONDITION_FAILED - cannot redeclare exchange 'test' in vhost 'conglomerate' with different type, durable, internal or autodelete value\n```\n\nWhich is of course, correct.\n\nHowever, if i enable reconnection, the app continually retries the connection, which always results in the same failure.\n\nI'm not really sure what the \"correct\" behaviour should be!\n. ",
    "fordox31": "The class I did in ruby for the startup where I work was able to send every type of instance with every methods or attributes too. Now I have to work with CoffeeScript and Node.js so I wanted to do the same work.\nBut, in fact, I need only to send instances' attributes so I have no more problem for my issue.\n\n---\n\nBut for information, the trick in ruby (with RabbitMQ) was only to make a serialization to a kind of string before passing the instance to the queue, and strip the serialization when the instance was received in order to get the full instance.\n\nI think maybe there is simplier method that could do it for us. Not necessarily a module, but I am not sure.\n\nWhen I started with ruby I read this in a book :\n\n\"When we publish a message to our queue using the publish\nmethod, the to_s method on that message is called to make sure that the message is\na String. The reason for this is because RabbitMQ is not a Ruby-based library;\nAMQP needs to be able to consistently send \u201csafe\u201d messages to it that will easily read\nwhen they come back again. String is definitely the easiest way to achieve that goal.\nSo how do we get around this problem? The answer is pretty simple and not\noverly complex. We need to serialize our HelloWorld instance to a String before we\ncall the publish method. Then, when we retrieve the message from the queue again,\nwe need to deserialize it and reconstitute our HelloWorld instance.\"\n\n(From : Addison Wesley Distributed Programming with Ruby Nov 2009-01) - Page 176\n\nThen, in the example of the book, it was possible to call the method say_hi() of the HelloWorld instance which displayed a \"Hello\" message.\n\n---\n\nSo maybe a simple string serialization could be efficient. Anyway my problem is solved because I don't really need to send methods. But in the book I read for Ruby, there were a way to send a method, but no good reason for doing it. So I don't know if it is really useful or not ^^\n\nThank you, your answer was useful for me.\n. Thank you Michael for your answer.\nActually, this is exactly to prevent any loss during a crash that I'm doing this.\n\nConsider this scenario:\n\n1- I publish two messages, that are tasks to be executed: messageA and then messageB\n2- my consumer gets messageA, executes the task contained in this message, but while the task is running, the server crashes\n\nMy question is: when the server is restarted, will messageA be requeued, and will it be requeued before messageB (same order than before the crash)?\n\nFor what I understand, messageA would be lost if the server was to crash, because my consumer has acknowledged it by default, upon reception of the message.\n\nSo my idea is to consume and acknowledge message separately: consume first, run the task, and then acknowledge the message when the task has been executed successfully. \n\nDo you see a problem with this approach? Would you advise me to do anything else?\n\nThanks :)\n. The class I did in ruby for the startup where I work was able to send every type of instance with every methods or attributes too. Now I have to work with CoffeeScript and Node.js so I wanted to do the same work.\nBut, in fact, I need only to send instances' attributes so I have no more problem for my issue.\n\n---\n\nBut for information, the trick in ruby (with RabbitMQ) was only to make a serialization to a kind of string before passing the instance to the queue, and strip the serialization when the instance was received in order to get the full instance.\n\nI think maybe there is simplier method that could do it for us. Not necessarily a module, but I am not sure.\n\nWhen I started with ruby I read this in a book :\n\n\"When we publish a message to our queue using the publish\nmethod, the to_s method on that message is called to make sure that the message is\na String. The reason for this is because RabbitMQ is not a Ruby-based library;\nAMQP needs to be able to consistently send \u201csafe\u201d messages to it that will easily read\nwhen they come back again. String is definitely the easiest way to achieve that goal.\nSo how do we get around this problem? The answer is pretty simple and not\noverly complex. We need to serialize our HelloWorld instance to a String before we\ncall the publish method. Then, when we retrieve the message from the queue again,\nwe need to deserialize it and reconstitute our HelloWorld instance.\"\n\n(From : Addison Wesley Distributed Programming with Ruby Nov 2009-01) - Page 176\n\nThen, in the example of the book, it was possible to call the method say_hi() of the HelloWorld instance which displayed a \"Hello\" message.\n\n---\n\nSo maybe a simple string serialization could be efficient. Anyway my problem is solved because I don't really need to send methods. But in the book I read for Ruby, there were a way to send a method, but no good reason for doing it. So I don't know if it is really useful or not ^^\n\nThank you, your answer was useful for me.\n. Thank you Michael for your answer.\nActually, this is exactly to prevent any loss during a crash that I'm doing this.\n\nConsider this scenario:\n\n1- I publish two messages, that are tasks to be executed: messageA and then messageB\n2- my consumer gets messageA, executes the task contained in this message, but while the task is running, the server crashes\n\nMy question is: when the server is restarted, will messageA be requeued, and will it be requeued before messageB (same order than before the crash)?\n\nFor what I understand, messageA would be lost if the server was to crash, because my consumer has acknowledged it by default, upon reception of the message.\n\nSo my idea is to consume and acknowledge message separately: consume first, run the task, and then acknowledge the message when the task has been executed successfully. \n\nDo you see a problem with this approach? Would you advise me to do anything else?\n\nThanks :)\n. ",
    "mateodelnorte": "A little additional information: \n\nWhat I've basically found is that messages are only publishing correctly if the publisher is subscribed to its own message, which is not something you'd want to do in most cases. Create the following two files and npm install amqp for the directory. Start up two instance of worker.js and then start up publisher.js. You'll see the two messages go to the two clients, one each. \n\nIf you comment out the subscription (q.subscribe) in publisher.js you'll see that messages are no longer received by either worker.js instance:\n\nhttps://gist.github.com/7a202e0f563496448d29\n\nMatt\n. My mistake. Didn't realize the client connected event only triggered with a local connection. \n\nThanks. \n. It seems like the use of this method, for instance to provide monitoring of throughput, would result in doubling the number of messages passing through a software system - one message to express some business intent, and one message to signify a message went out. \n\nIs there no way to simply poll a queue every n seconds to determine the amount of messages on the queue at that time? The RabbitMQ web management console does this. Does node-amqp not support it?\n\nThanks,\n\nMatt Walters\n. Awesome info. \n\nThanks!\n\nMatt\n. Yup. Looks like they don't fully support it yet. :( Thanks. \n. A little additional information: \n\nWhat I've basically found is that messages are only publishing correctly if the publisher is subscribed to its own message, which is not something you'd want to do in most cases. Create the following two files and npm install amqp for the directory. Start up two instance of worker.js and then start up publisher.js. You'll see the two messages go to the two clients, one each. \n\nIf you comment out the subscription (q.subscribe) in publisher.js you'll see that messages are no longer received by either worker.js instance:\n\nhttps://gist.github.com/7a202e0f563496448d29\n\nMatt\n. My mistake. Didn't realize the client connected event only triggered with a local connection. \n\nThanks. \n. It seems like the use of this method, for instance to provide monitoring of throughput, would result in doubling the number of messages passing through a software system - one message to express some business intent, and one message to signify a message went out. \n\nIs there no way to simply poll a queue every n seconds to determine the amount of messages on the queue at that time? The RabbitMQ web management console does this. Does node-amqp not support it?\n\nThanks,\n\nMatt Walters\n. Awesome info. \n\nThanks!\n\nMatt\n. Yup. Looks like they don't fully support it yet. :( Thanks. \n. ",
    "novemberborn": "Do you want a new pull request for that?\n. It emits an error event, and there is no listener for it. Without a listener for error events Node emits an `uncaughtException` and will normally exit.\n. Do you want a new pull request for that?\n. It emits an error event, and there is no listener for it. Without a listener for error events Node emits an `uncaughtException` and will normally exit.\n. ",
    "kongelaks": "You should create two small example files (producer/consumer) which reproduce the problem you're having. Put them in a gist and maybe I can help you out.\n. You should create two small example files (producer/consumer) which reproduce the problem you're having. Put them in a gist and maybe I can help you out.\n. ",
    "floorplanner": "Okay, I reverted the first commit, and put the arguments on the right place. It works now.\n. Flame on! :)\n\nOp 23 sep. 2011 om 16:48 heeft Du\u0161an Maliarikreply@reply.github.com het volgende geschreven:\n\n> Language indeed :) This one should work.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/pull/25#issuecomment-2179279\n. Okay, I reverted the first commit, and put the arguments on the right place. It works now.\n. Flame on! :)\n\nOp 23 sep. 2011 om 16:48 heeft Du\u0161an Maliarikreply@reply.github.com het volgende geschreven:\n\n> Language indeed :) This one should work.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/pull/25#issuecomment-2179279\n. ",
    "skrat": "I'm trying, the idea is to expect \"NOT_ALLOWED - inequivalent arg...\" when I try to declare the same queue with different arguments. Unfortunately I'm failing to catch this. It borks with:\n\n```\nconnected to RabbitMQ\n\nnode.js:134\n        throw e; // process.nextTick error, or 'error' event on first tick\n        ^\nError: NOT_ALLOWED - inequivalent arg 'x-expires' for queue 'node-queue-args-queue' in vhost '/':  required {signedint,3600000}, received undefined\n    at Connection._onMethod (/Users/skrat/Workspace/node-amqp/amqp.js:995:15)\n...\n```\n\n...but I don't know how, any ideas? I tried various `on('error')` and `try ... catch` but no luck.\n. Got it, unfortunately I still can't test using error handling because of line 19 in test/harness.js\n. Hi Theo, I was wondering what do you think about my changes? I'd like to use this in production.\n. What version of RabbitMQ are you running? x-expires was introduced in 2.1.1 I believe. Perhaps the concept of it is wrong and I should test for queue presence after it expires. However this is one particular argument. I'm not sure how to make generic queue arguments test. Check the serialised output of node-amqp? \n. I see, I upgraded node.js and RabbitMQ and it hangs too. That's rather strange because expected behavior as of AMQP would be 530 method not allowed, since we are trying to declare a queue with the same name, but different arguments. Is that right?\n. Sniffing the AMQP traffic I can see that server responds with channel.close 406 precondition failed, as expected. No connection error handler is fired though\n. that's correct, unless there is a reply code, corresponding to hard, or soft error. 406 precondition failed is classified as a soft error, and as such the user should be notified. using connection error event is of course inappropriate. IMHO the API for handling this scenario should be similar to:\n\n```\ntry {\n  connection.queue('node-queue-args-queue', {\n      'arguments': {'x-expires': 360}\n  }, myCallback);\n} catch (e) {\n  assert.equal(e.code, 406);\n}\n```\n\nhow can I handle this error with current implementation?\n. You have quite demotivating and rejective attitude to this (obviously useful) pull request, stating the obvious etc. I'm going to try a test using channel close event.\n. Language indeed :) This one should work.\n. Trollolololon and on and on..\nOn Sep 23, 2011 4:54 PM, \"Gert-Jan van der Wel\" <\nreply@reply.github.com>\nwrote:\n\n> Flame on! :)\n> \n> Op 23 sep. 2011 om 16:48 heeft Du\u0161an Maliarikreply@reply.github.com het\n> volgende geschreven:\n> \n> > Language indeed :) This one should work.\n> > \n> > ## \n> > \n> > Reply to this email directly or view it on GitHub:\n> > https://github.com/postwait/node-amqp/pull/25#issuecomment-2179279\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/pull/25#issuecomment-2179351\n. I think that's a good idea. Caching of entities shouldn't be enforced by client library, users should have the freedom to choose, and manage this themselves. \n. @bkw: looks good to me, @michaelklishin, @postwait what do you guys think? mergeable? \n. Just wondering, you're very determined to make it work with dev. version of RabbitMQ, it's also written in the README, but ultimately the name you chose is node-amqp. Are you testing with http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol#Implementations ?\n. @bkw look at the following changes https://gist.github.com/1243458, I'm not sure about `autoDelete` and `durable`, but the connection stuff should be there to test using foreign server. @postwait I built latest RabbitMQ from Mercurial sources, and it passes locally. My only thought is that `dev.rabbitmq.com` somehow deletes the queue no matter the options.\n. `x-expires` didn't work for you because the values you used were too low. You used 300 and 301, try using 30000 and 30001 and it will pass.\n. Well the idea was that the connection to `dev.rabbitmq.com` is slow, and the delay between queue redeclaration is probably longer than 300ms.\n. Why isn't this merged? The tests are there, do you need anything else?\n. That would be in queue.declareOk method, I couldn't figure out how to get it though.\n. I might be facing the same issue. I noticed that RabbitMQ memory usage is steadily increasing without any change to load (no we didn't get 300% more popular and more users :( . Same number of queues and messages, so I checked number of channels and I've tens of thousands of channels. After restarting my node app, they disappeared and mem. usage dropped from 700M to 200M. Using this code: https://github.com/skrat/celery.js/blob/master/celery.js\n. Nice to have you back :) I've bee looking into this myself, but without much success so far.\n. I'm trying, the idea is to expect \"NOT_ALLOWED - inequivalent arg...\" when I try to declare the same queue with different arguments. Unfortunately I'm failing to catch this. It borks with:\n\n```\nconnected to RabbitMQ\n\nnode.js:134\n        throw e; // process.nextTick error, or 'error' event on first tick\n        ^\nError: NOT_ALLOWED - inequivalent arg 'x-expires' for queue 'node-queue-args-queue' in vhost '/':  required {signedint,3600000}, received undefined\n    at Connection._onMethod (/Users/skrat/Workspace/node-amqp/amqp.js:995:15)\n...\n```\n\n...but I don't know how, any ideas? I tried various `on('error')` and `try ... catch` but no luck.\n. Got it, unfortunately I still can't test using error handling because of line 19 in test/harness.js\n. Hi Theo, I was wondering what do you think about my changes? I'd like to use this in production.\n. What version of RabbitMQ are you running? x-expires was introduced in 2.1.1 I believe. Perhaps the concept of it is wrong and I should test for queue presence after it expires. However this is one particular argument. I'm not sure how to make generic queue arguments test. Check the serialised output of node-amqp? \n. I see, I upgraded node.js and RabbitMQ and it hangs too. That's rather strange because expected behavior as of AMQP would be 530 method not allowed, since we are trying to declare a queue with the same name, but different arguments. Is that right?\n. Sniffing the AMQP traffic I can see that server responds with channel.close 406 precondition failed, as expected. No connection error handler is fired though\n. that's correct, unless there is a reply code, corresponding to hard, or soft error. 406 precondition failed is classified as a soft error, and as such the user should be notified. using connection error event is of course inappropriate. IMHO the API for handling this scenario should be similar to:\n\n```\ntry {\n  connection.queue('node-queue-args-queue', {\n      'arguments': {'x-expires': 360}\n  }, myCallback);\n} catch (e) {\n  assert.equal(e.code, 406);\n}\n```\n\nhow can I handle this error with current implementation?\n. You have quite demotivating and rejective attitude to this (obviously useful) pull request, stating the obvious etc. I'm going to try a test using channel close event.\n. Language indeed :) This one should work.\n. Trollolololon and on and on..\nOn Sep 23, 2011 4:54 PM, \"Gert-Jan van der Wel\" <\nreply@reply.github.com>\nwrote:\n\n> Flame on! :)\n> \n> Op 23 sep. 2011 om 16:48 heeft Du\u0161an Maliarikreply@reply.github.com het\n> volgende geschreven:\n> \n> > Language indeed :) This one should work.\n> > \n> > ## \n> > \n> > Reply to this email directly or view it on GitHub:\n> > https://github.com/postwait/node-amqp/pull/25#issuecomment-2179279\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/pull/25#issuecomment-2179351\n. I think that's a good idea. Caching of entities shouldn't be enforced by client library, users should have the freedom to choose, and manage this themselves. \n. @bkw: looks good to me, @michaelklishin, @postwait what do you guys think? mergeable? \n. Just wondering, you're very determined to make it work with dev. version of RabbitMQ, it's also written in the README, but ultimately the name you chose is node-amqp. Are you testing with http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol#Implementations ?\n. @bkw look at the following changes https://gist.github.com/1243458, I'm not sure about `autoDelete` and `durable`, but the connection stuff should be there to test using foreign server. @postwait I built latest RabbitMQ from Mercurial sources, and it passes locally. My only thought is that `dev.rabbitmq.com` somehow deletes the queue no matter the options.\n. `x-expires` didn't work for you because the values you used were too low. You used 300 and 301, try using 30000 and 30001 and it will pass.\n. Well the idea was that the connection to `dev.rabbitmq.com` is slow, and the delay between queue redeclaration is probably longer than 300ms.\n. Why isn't this merged? The tests are there, do you need anything else?\n. That would be in queue.declareOk method, I couldn't figure out how to get it though.\n. I might be facing the same issue. I noticed that RabbitMQ memory usage is steadily increasing without any change to load (no we didn't get 300% more popular and more users :( . Same number of queues and messages, so I checked number of channels and I've tens of thousands of channels. After restarting my node app, they disappeared and mem. usage dropped from 700M to 200M. Using this code: https://github.com/skrat/celery.js/blob/master/celery.js\n. Nice to have you back :) I've bee looking into this myself, but without much success so far.\n. ",
    "GraemeF": "Is it possible to read these parameters from the queue? I see them in the RabbitMQ management UI but I'd like to use them from my code.\n. This looks fixed to me - 0.1.3 is in npm now.\n. That's the last version that didn't specify a compatible version of Node - if you are running Node 0.8 then it is the last compatible release until the package.json is updated to say it works with 0.8. Because 0.0.2 doesn't say which versions of Node it is compatible with it is assumed to be compatible with all versions of Node.\n. I guess not - didn't know it was there in the repo! In the meantime you can change your package.json to reference amqp with its Github repo URI instead of the version number and npm will fetch it from there instead.\n. Is it possible to read these parameters from the queue? I see them in the RabbitMQ management UI but I'd like to use them from my code.\n. This looks fixed to me - 0.1.3 is in npm now.\n. That's the last version that didn't specify a compatible version of Node - if you are running Node 0.8 then it is the last compatible release until the package.json is updated to say it works with 0.8. Because 0.0.2 doesn't say which versions of Node it is compatible with it is assumed to be compatible with all versions of Node.\n. I guess not - didn't know it was there in the repo! In the meantime you can change your package.json to reference amqp with its Github repo URI instead of the version number and npm will fetch it from there instead.\n. ",
    "sclausen": "I'm currently stuck with this scenario too. I have multiple consumers, but want to have a concurrent processing of each message.\nHas anybody implemented such behavior and can give me an example with node-amqp to do so?\n. I'm currently stuck with this scenario too. I have multiple consumers, but want to have a concurrent processing of each message.\nHas anybody implemented such behavior and can give me an example with node-amqp to do so?\n. ",
    "acacio": "I'd like to r-open this issue, as I don't think it was addressed: the event was being handled and it still gets issues twice (once uncaught).\n\nI have the same problem:\nI'm writing a small test and, when there are no subscribers in the exchange while using mandatory delivery mode, I get an an uncaught exception, despite me catching that event.\n\nCode snippets\n\n``` javascript\nvar msgDeliveryOptions = {\n    mandatory: true,\n    deliveryMode: 2          // persistent = 2, non-persistent = 1\n};\n\nvar exchange = connection.exchange('acacio.topic', null, function(e) { util.puts(e.name); });\nexchange.publish('test', msg, msgDeliveryOptions);\nexchange.on('basicReturn', exchangeError);\n\nfunction exchangeError(err) {\n  util.puts(JSON.stringify(err, null, 2));\n  util.puts('I got it!');\n}\n```\n\n## OUTPUT:\n\n```\n{\n  \"replyCode\": 312,\n  \"replyText\": \"NO_ROUTE\",\n  \"exchange\": \"acacio.topic\",\n  \"routingKey\": \"test\"\n}\nI got it!\nWarning: Uncaught basicReturn: {\"replyCode\":312,\"replyText\":\"NO_ROUTE\",\"exchange\":\"acacio.topic\",\"routingKey\":\"test\"}\n```\n. +1 on this change. \n. +1 to get this into the mainline.\n. I'd like to r-open this issue, as I don't think it was addressed: the event was being handled and it still gets issues twice (once uncaught).\n\nI have the same problem:\nI'm writing a small test and, when there are no subscribers in the exchange while using mandatory delivery mode, I get an an uncaught exception, despite me catching that event.\n\nCode snippets\n\n``` javascript\nvar msgDeliveryOptions = {\n    mandatory: true,\n    deliveryMode: 2          // persistent = 2, non-persistent = 1\n};\n\nvar exchange = connection.exchange('acacio.topic', null, function(e) { util.puts(e.name); });\nexchange.publish('test', msg, msgDeliveryOptions);\nexchange.on('basicReturn', exchangeError);\n\nfunction exchangeError(err) {\n  util.puts(JSON.stringify(err, null, 2));\n  util.puts('I got it!');\n}\n```\n\n## OUTPUT:\n\n```\n{\n  \"replyCode\": 312,\n  \"replyText\": \"NO_ROUTE\",\n  \"exchange\": \"acacio.topic\",\n  \"routingKey\": \"test\"\n}\nI got it!\nWarning: Uncaught basicReturn: {\"replyCode\":312,\"replyText\":\"NO_ROUTE\",\"exchange\":\"acacio.topic\",\"routingKey\":\"test\"}\n```\n. +1 on this change. \n. +1 to get this into the mainline.\n. ",
    "funston": "is there a way for basic-return/basic-ack to identify which message was not delivered. reading the spec, it seems to say, if a basic-return comes in, the next basic-ack will include the sequence number of the message not delivered. \n\nthat is working for me for small batches of messages, but under load testing, i'm seeing messages delivered but the basic-return/basic-ack sequence numbers not matching.\n. Is this working? Neither of the two tests work,\n test/test-publish-confirms-emitter.js \n. I'm seeing this alot when I ssh tunnel to a server, but not much when I run against my local rabbit server. Any updates on when 0.1.3 is available? thanks\n. /nm i'm an idiot\n\nq.on('error') works.\n. Running the following, I'm seeing  something unexpected. I setup a single exchange, a single queue which binds to two different routing keys. However, if I bind to routing key \"FOOBAR\" and publish, the 2nd instance which is bound to \"BARFOO\" sees the \"FOOBAR\" routing key message delivered.\n\n% node test.js FOOBAR\n\n% node test.js BARFOO\n\nvar amqp = require('amqp');\n\nvar connection = amqp.createConnection({ host: 'localhost' });\n\nconnection.addListener('ready', function(){\n    var exchange = connection.exchange('some-exchange');\n    var options =  {'durable':true, 'autoDelete':false};\n    var queue = connection.queue('queueZ', options,function(queue){\n        queue.subscribe( {ack:true}, function(message){\n            console.log(\"got message\");\n            console.log(message);\n            queue.shift()\n        });\n        var rk = process.argv[2];\n        console.log(\"routing key: \" + rk);\n        queue.bind('some-exchange', rk);\n        var msg = {msg:\"MATCH \"+rk};\n        exchange.publish(process.argv[2],msg);\n        exchange.publish(process.argv[2],msg);\n        msg = {msg:\"NO MATCH: key.a.b\"};\n        exchange.publish(\"key.a.b\", msg);\n        exchange.publish(\"key.a.b\", msg);\n\n```\n});\n```\n\n});\n. still happening, is there any example of how to use topic exchanges and routing keys with this npm?\n. Looking at line 836 of amqp.js, shouldn't that emit end or error/closed at least as well??\n\nself.emit(\"end\") ?? self.emit(\"error\", \"stream closed\") ?? self.emit(\"closed\")\n\nself.addListener('end', function () {\n    self.end();\n    // in order to allow reconnects, have to clear the\n    // state.\n    parser = null;\n  });\n\nRich\n. For what it's worth, adding this to amqp.js , at line 848 in the connection init, catches the error. To be clear though, my user code that does a connection.on('error') is not catching this ETIMEOUTD......\n\nself.addListener('error', function(e){\n        console.log(\"*****_AMQP caught error ***_******\");\n        console.log(e);\n        console.log(e.stack);\n    });\n. I had to rewrite the entire reconnect logic. Autoconnect = true was not\nsafe for production in my view.\n\nOn Sun, Nov 17, 2013 at 10:27 PM, Andrew Seddon notifications@github.comwrote:\n\n> We get the exact same issue under high cpu.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/202#issuecomment-28677816\n> .\n. let me try to clean it up. it's not very modular and was just built for one\nspecific use case of using rabbit.\n\nOn Wed, Nov 20, 2013 at 8:46 AM, Wyatt notifications@github.com wrote:\n\n> @rschiavi https://github.com/rschiavi please do share your code :)\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/202#issuecomment-28905845\n> .\n. /nm, looks like it's connection.socket now.\n. is there a way for basic-return/basic-ack to identify which message was not delivered. reading the spec, it seems to say, if a basic-return comes in, the next basic-ack will include the sequence number of the message not delivered. \n\nthat is working for me for small batches of messages, but under load testing, i'm seeing messages delivered but the basic-return/basic-ack sequence numbers not matching.\n. Is this working? Neither of the two tests work,\n test/test-publish-confirms-emitter.js \n. I'm seeing this alot when I ssh tunnel to a server, but not much when I run against my local rabbit server. Any updates on when 0.1.3 is available? thanks\n. /nm i'm an idiot\n\nq.on('error') works.\n. Running the following, I'm seeing  something unexpected. I setup a single exchange, a single queue which binds to two different routing keys. However, if I bind to routing key \"FOOBAR\" and publish, the 2nd instance which is bound to \"BARFOO\" sees the \"FOOBAR\" routing key message delivered.\n\n% node test.js FOOBAR\n\n% node test.js BARFOO\n\nvar amqp = require('amqp');\n\nvar connection = amqp.createConnection({ host: 'localhost' });\n\nconnection.addListener('ready', function(){\n    var exchange = connection.exchange('some-exchange');\n    var options =  {'durable':true, 'autoDelete':false};\n    var queue = connection.queue('queueZ', options,function(queue){\n        queue.subscribe( {ack:true}, function(message){\n            console.log(\"got message\");\n            console.log(message);\n            queue.shift()\n        });\n        var rk = process.argv[2];\n        console.log(\"routing key: \" + rk);\n        queue.bind('some-exchange', rk);\n        var msg = {msg:\"MATCH \"+rk};\n        exchange.publish(process.argv[2],msg);\n        exchange.publish(process.argv[2],msg);\n        msg = {msg:\"NO MATCH: key.a.b\"};\n        exchange.publish(\"key.a.b\", msg);\n        exchange.publish(\"key.a.b\", msg);\n\n```\n});\n```\n\n});\n. still happening, is there any example of how to use topic exchanges and routing keys with this npm?\n. Looking at line 836 of amqp.js, shouldn't that emit end or error/closed at least as well??\n\nself.emit(\"end\") ?? self.emit(\"error\", \"stream closed\") ?? self.emit(\"closed\")\n\nself.addListener('end', function () {\n    self.end();\n    // in order to allow reconnects, have to clear the\n    // state.\n    parser = null;\n  });\n\nRich\n. For what it's worth, adding this to amqp.js , at line 848 in the connection init, catches the error. To be clear though, my user code that does a connection.on('error') is not catching this ETIMEOUTD......\n\nself.addListener('error', function(e){\n        console.log(\"*****_AMQP caught error ***_******\");\n        console.log(e);\n        console.log(e.stack);\n    });\n. I had to rewrite the entire reconnect logic. Autoconnect = true was not\nsafe for production in my view.\n\nOn Sun, Nov 17, 2013 at 10:27 PM, Andrew Seddon notifications@github.comwrote:\n\n> We get the exact same issue under high cpu.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/202#issuecomment-28677816\n> .\n. let me try to clean it up. it's not very modular and was just built for one\nspecific use case of using rabbit.\n\nOn Wed, Nov 20, 2013 at 8:46 AM, Wyatt notifications@github.com wrote:\n\n> @rschiavi https://github.com/rschiavi please do share your code :)\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/202#issuecomment-28905845\n> .\n. /nm, looks like it's connection.socket now.\n. ",
    "gwilym": "The \"execute:\" line you've noted is pertinent to this. See, it's attempting to parse the four ASCII \"AMQP\" bytes as frame header information, but that's part of the version negotiation.\n\nI couldn't nail down the fix in the little time I spent looking at it. I'm not that great with parsers in this kind of language, but I need to get something going for R&D so I'll give it another shot sometime.\n\nI'm on NodeJS v0.6.8\nRabbitMQ is v1.8.1 with defaults on Debian.\n\n<pre>\nevents.js:50\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n              ^\nError: Uncaught, unspecified 'error' event.\n    at Connection.emit (events.js:50:15)\n    at AMQPParser.onError (./node_modules/rabbit.js/node_modules/amqp/amqp.js:821:12)\n    at AMQPParser.throwError (./node_modules/rabbit.js/node_modules/amqp/amqp.js:221:25)\n    at AMQPParser.header [as parse] (./node_modules/rabbit.js/node_modules/amqp/amqp.js:155:14)\n    at AMQPParser.execute (./node_modules/rabbit.js/node_modules/amqp/amqp.js:231:21)\n    at Connection.<anonymous> (./node_modules/rabbit.js/node_modules/amqp/amqp.js:833:12)\n    at Connection.emit (events.js:67:17)\n    at TCP.onread (net.js:347:14)\n</pre>\n. Well the workaround for me was to run a newer version of RabbitMQ since the latest is 2.7.1 ;) 1.8.1 was just the one provided with my seemingly old Debian distro\n. The \"execute:\" line you've noted is pertinent to this. See, it's attempting to parse the four ASCII \"AMQP\" bytes as frame header information, but that's part of the version negotiation.\n\nI couldn't nail down the fix in the little time I spent looking at it. I'm not that great with parsers in this kind of language, but I need to get something going for R&D so I'll give it another shot sometime.\n\nI'm on NodeJS v0.6.8\nRabbitMQ is v1.8.1 with defaults on Debian.\n\n<pre>\nevents.js:50\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n              ^\nError: Uncaught, unspecified 'error' event.\n    at Connection.emit (events.js:50:15)\n    at AMQPParser.onError (./node_modules/rabbit.js/node_modules/amqp/amqp.js:821:12)\n    at AMQPParser.throwError (./node_modules/rabbit.js/node_modules/amqp/amqp.js:221:25)\n    at AMQPParser.header [as parse] (./node_modules/rabbit.js/node_modules/amqp/amqp.js:155:14)\n    at AMQPParser.execute (./node_modules/rabbit.js/node_modules/amqp/amqp.js:231:21)\n    at Connection.<anonymous> (./node_modules/rabbit.js/node_modules/amqp/amqp.js:833:12)\n    at Connection.emit (events.js:67:17)\n    at TCP.onread (net.js:347:14)\n</pre>\n. Well the workaround for me was to run a newer version of RabbitMQ since the latest is 2.7.1 ;) 1.8.1 was just the one provided with my seemingly old Debian distro\n. ",
    "anroOfCode": "I can confirm that updating to newer versions of RabbitMQ solve the problem. Don't use the ones in Canonical's repos.\n. I can confirm that updating to newer versions of RabbitMQ solve the problem. Don't use the ones in Canonical's repos.\n. ",
    "clearbucketLabs": "Yup, new version is good.\n\nOn 12-03-07 09:42 PM, ab500 wrote:\n\n> I can confirm that updating to newer versions of RabbitMQ solve the problem. Don't use the ones in Canonical's repos.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/32#issuecomment-4383694\n. Yup, new version is good.\n\nOn 12-03-07 09:42 PM, ab500 wrote:\n\n> I can confirm that updating to newer versions of RabbitMQ solve the problem. Don't use the ones in Canonical's repos.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/32#issuecomment-4383694\n. ",
    "esk525": "I can confirm this as well.\n\nFYI:  To get callbacks to work, I had to use the .addListener method via chaining.\n\ne.g. connection.exchange(...).addListener('error\",logError).addListener('open',doStuff).\n. My understanding from the Readme was that the passive option allowed one to check to see if the queue exists, not create it if it does not exists.  From the readme, \"The client can use this to check whether a queue exists without modifying the server state\".\n\nWhen I did some testing, I created the queue if I did not get one using the passive: true option; and that seemed to work.\n. It worked fine for me.  The passive option just checks to see if the queue already exists; it will not create the queue.  I used something like the following:\n\n``` javascript\n\n    function createQueue (conn,qname,opts,cb){\n        if ( _.isFunction(opts)){\n            cb = opts;\n            opts = {};          \n        }\n        var f = Futures.future({error: function(){}});\n        f.when(function(){\n            cb.apply(cb,arguments);\n        });\n        var ncb = f.fulfill;\n        var me = this;\n        var q = conn.queue(qname, {passive: true}, function(queue){\n                ncb(false,queue);\n        }).on('error', function(){\n            doCreateQueue(conn,qname,opts,ncb);\n        })      \n    }\n    function doCreateQueue(conn,qname,opts,cb){\n        conn.queue(qname,opts,function(queue){\n            cb,(false,queue);\n        }).on('error',function(err){\n            cb(err,null);\n        });\n    }\n\n```\n\nTo be fair, I forked this project and made some modifications, but I do not think any of them changed this behavior.\n. If it can, I'd like to see some documentation too or at least a response stating yes or no.  I have a fork where I altered the Connection class so I could do AMQP over SSL, but I think things here have progressed to a point where the changes can't be simple merged back in... and I don't have time right now to redo the changes.\n. Definately... my repo is at https://github.com/esk525/node-amqp.  I double-check and make sure I have it up to date tonight.\n. I can confirm this as well.\n\nFYI:  To get callbacks to work, I had to use the .addListener method via chaining.\n\ne.g. connection.exchange(...).addListener('error\",logError).addListener('open',doStuff).\n. My understanding from the Readme was that the passive option allowed one to check to see if the queue exists, not create it if it does not exists.  From the readme, \"The client can use this to check whether a queue exists without modifying the server state\".\n\nWhen I did some testing, I created the queue if I did not get one using the passive: true option; and that seemed to work.\n. It worked fine for me.  The passive option just checks to see if the queue already exists; it will not create the queue.  I used something like the following:\n\n``` javascript\n\n    function createQueue (conn,qname,opts,cb){\n        if ( _.isFunction(opts)){\n            cb = opts;\n            opts = {};          \n        }\n        var f = Futures.future({error: function(){}});\n        f.when(function(){\n            cb.apply(cb,arguments);\n        });\n        var ncb = f.fulfill;\n        var me = this;\n        var q = conn.queue(qname, {passive: true}, function(queue){\n                ncb(false,queue);\n        }).on('error', function(){\n            doCreateQueue(conn,qname,opts,ncb);\n        })      \n    }\n    function doCreateQueue(conn,qname,opts,cb){\n        conn.queue(qname,opts,function(queue){\n            cb,(false,queue);\n        }).on('error',function(err){\n            cb(err,null);\n        });\n    }\n\n```\n\nTo be fair, I forked this project and made some modifications, but I do not think any of them changed this behavior.\n. If it can, I'd like to see some documentation too or at least a response stating yes or no.  I have a fork where I altered the Connection class so I could do AMQP over SSL, but I think things here have progressed to a point where the changes can't be simple merged back in... and I don't have time right now to redo the changes.\n. Definately... my repo is at https://github.com/esk525/node-amqp.  I double-check and make sure I have it up to date tonight.\n. ",
    "a--hoang": "Is this fixed? . Is this fixed? . ",
    "rshelley": "Ah, then it's my fault.  I'll try this again.  Thanks!\n. Ah, then it's my fault.  I'll try this again.  Thanks!\n. ",
    "jamescarr": "Thanks... the event was what I should have been listening for. \n. ``` javascript\nconn.on('error', function(err){\n  // here be errors\n});\n\n```\n. I'll update the documentation on this. I've been using error handlers to implement retries when connections fail\n. FYI the linked repo reproduces the error. Simply start both nodes, run npm install and run the app.coffee file. \n. Is the root cause that it cannot handle headers with array values?\n. I'll push out a modified version of node-amqp I am using with mixed success. Basically instead of throwing the exception and making everything die I simply emit the error event instead so I can capture the error in a separate listener. \n\nThat way it still works, albeit with broken windows. \n. By mixed success I mean that headers added by x-federation aren't in the message consumed but for me this is fine as I get the message body, which is all that matters in my case.\n. I changed this back. \n. Thanks... the event was what I should have been listening for. \n. ``` javascript\nconn.on('error', function(err){\n  // here be errors\n});\n\n```\n. I'll update the documentation on this. I've been using error handlers to implement retries when connections fail\n. FYI the linked repo reproduces the error. Simply start both nodes, run npm install and run the app.coffee file. \n. Is the root cause that it cannot handle headers with array values?\n. I'll push out a modified version of node-amqp I am using with mixed success. Basically instead of throwing the exception and making everything die I simply emit the error event instead so I can capture the error in a separate listener. \n\nThat way it still works, albeit with broken windows. \n. By mixed success I mean that headers added by x-federation aren't in the message consumed but for me this is fine as I get the message body, which is all that matters in my case.\n. I changed this back. \n. ",
    "danhowitt": "Anyone have a work around for this? I have a number of remove clients that receive the message via STOMP, and in some scenarios the ack is dropped back to the server. In this case I want the server to replay the message to the client when I call recover.\n\nThe only way I can get this to work is to drop the amqp connection and reconnect again.\n. +1\n. +1\n. Anyone have a work around for this? I have a number of remove clients that receive the message via STOMP, and in some scenarios the ack is dropped back to the server. In this case I want the server to replay the message to the client when I call recover.\n\nThe only way I can get this to work is to drop the amqp connection and reconnect again.\n. +1\n. +1\n. ",
    "ahildoer": "For most cases the no news is good news pattern works well, but there is an edge case where I am using it more for timing than confirmation. I have an RPC architecture with acknowledgement. So, system A sends a persistent message(1) to a group of worker systems. System B gets the job from the worker queue. B does the work and sends a reply message(2) to A on the RPC exchange. B then acknowledges message(1) on the worker queue. I want to wait until I am sure message(2) is at least buffered in the network interface (or is anywhere safe from the node process crashing) before I acknowledge message(1). In my scenario it is OK if an RPC call is processed twice and a reply sent twice, but it is not OK if the RPC never runs or runs and no reply ever sent. \n\nIn my environment, the rabbitmq servers are EXTREMELY dependable as are the OSes running them and the worker nodes. But, what is not dependable is the nodeJS processes themselves. This is mainly due to the fact that I am very familiar with AMQP setups and Linux setups for other web environments, like a LAMP stack, but I am relatively new to nodeJS. \n\nA stop gap I implemented since my initial post: I am satisfied calling a publish a success once the write stream for the connection has flushed to the kernel (write() returns true or `drain` event called on connection). so, i added som code to trigger success on promise when this flush occurs. I believe that once kernel has the data it will make it to rabbitmq if the only thing that happens is the nodeJS process dies.\n\nMaybe there is a better way, but given the raw AMQP protocol which has no publish-ok event, I think this is the closest thing that will work for my durability requirements. I have also considered doing a publish on the RPC message, then doing a settimeout on the ack of 10 minutes with the idea that publishing messages never takes longer than a minute so I am almost guaranteed to ack only after the RPC is received.\n. Done. Issue #42 has the pull request.\n. For most cases the no news is good news pattern works well, but there is an edge case where I am using it more for timing than confirmation. I have an RPC architecture with acknowledgement. So, system A sends a persistent message(1) to a group of worker systems. System B gets the job from the worker queue. B does the work and sends a reply message(2) to A on the RPC exchange. B then acknowledges message(1) on the worker queue. I want to wait until I am sure message(2) is at least buffered in the network interface (or is anywhere safe from the node process crashing) before I acknowledge message(1). In my scenario it is OK if an RPC call is processed twice and a reply sent twice, but it is not OK if the RPC never runs or runs and no reply ever sent. \n\nIn my environment, the rabbitmq servers are EXTREMELY dependable as are the OSes running them and the worker nodes. But, what is not dependable is the nodeJS processes themselves. This is mainly due to the fact that I am very familiar with AMQP setups and Linux setups for other web environments, like a LAMP stack, but I am relatively new to nodeJS. \n\nA stop gap I implemented since my initial post: I am satisfied calling a publish a success once the write stream for the connection has flushed to the kernel (write() returns true or `drain` event called on connection). so, i added som code to trigger success on promise when this flush occurs. I believe that once kernel has the data it will make it to rabbitmq if the only thing that happens is the nodeJS process dies.\n\nMaybe there is a better way, but given the raw AMQP protocol which has no publish-ok event, I think this is the closest thing that will work for my durability requirements. I have also considered doing a publish on the RPC message, then doing a settimeout on the ack of 10 minutes with the idea that publishing messages never takes longer than a minute so I am almost guaranteed to ack only after the RPC is received.\n. Done. Issue #42 has the pull request.\n. ",
    "GICodeWarrior": "Is it possible to use this functionality now?  It doesn't look like this request was merged.  :-/\n. Is it possible to use this functionality now?  It doesn't look like this request was merged.  :-/\n. ",
    "kg4lod": "How does it work for something like Queue.subscribe() or Queue.destroy() ?\n. How does it work for something like Queue.subscribe() or Queue.destroy() ?\n. ",
    "charlyz": "*bump. In 0.1.4, subscribe() would trigger an uncaught exception in case of error. In the last version 0.1.7, it triggers the error handler passed to the connection object. It doesn't make sense to me but I might miss something. How would you handle an error triggered by subscribe() in order to retry few seconds later? thanks\n. *bump. In 0.1.4, subscribe() would trigger an uncaught exception in case of error. In the last version 0.1.7, it triggers the error handler passed to the connection object. It doesn't make sense to me but I might miss something. How would you handle an error triggered by subscribe() in order to retry few seconds later? thanks\n. ",
    "jgato": "I have some design doubts about that. How could I response to an error managed by an event handler that only receives one parameter, actually the error?.\n\nConnection.on('error', handler(error));\n\nconnection.queue(name, options,  function(queue ){ console.log(\"ok\")  })\n\nif there is some kind of issue, handler(error) will be raised but I dont know anything about who provoked? If I need to response (For example an http request) I cannot do it... Which request provoked the error in order to make the response?\n\nHow could I implement something like that:\n\nconnection.queue(....., function (error, queue){\n\n  if (error)\n     create_response(...., next());\n  else\n     ......\n\n}\n. I am hitting the same issue. In my case, with exclusive queues. Thanks to your fix, when we try a second connection to an exclusive queue, this raises and error and your  closeOK() closes the queue in the server. But, we are not deleting the reference to that queue in the connection.channels, actually, we only delete connection.queues.\n\nSo, when reconnecting, node-amqp try to re-open the queue. The result is that now we have two opened queues, instead of one.\n\n@jameskeane @postwait could you take a look to that commit trying to fix it: https://github.com/jgato/node-amqp/commit/8f2d1d00ef793d9add4dde497fdd1fd33143f7d2\n\nI guess, there could be better ways to delete the channel (to avoid re-connections). For me, now it is working.\n. I also have the same issue with 0.1.7. The same issue, if the server is down each attempt to reconnect attach new listeners... :(\n. Ok, the issue is solved in Master but not in 0.1.7. I guess I will wait for a new release \n. Is this path merged? I am having this same issue. With exclusive queue, after re-connecting for any error the queue is not re-subscribed.\n. I will make more depth tests, but the first attempt is not solving my issue :(\n\nMy scenarios is: \n- One connection to the server\n- One connection to a queue\n- First client using the queue to subscribe exclusive\n- Second client using the queue to subscribe exclusive\n- Queue Exclusive error, so... connection error, connection close\n- Reconnect does not re-subscribe\n\nI guess the issue is this line:\n\n```\n case methods.channelClose:\n      this.state = \"closed\";\n      this.closeOK();\n      this.connection.queueClosed(this.name);\n     ...\n```\n\nBecause of the error the queue is closed, I guess it would not re-connect.\n. Is there any place where we could see all the supported events?\n. Is this issue related to that? https://github.com/postwait/node-amqp/pull/170\n\nI have the same issue and I see this is critical. I need to automatic re-subscribe clients after something went wrong. \n. Great, this is what I have in mind as a future solution :( Maybe I will\nhave to priorize that...\n\nBut still, it is extrange I dont receive and error after publising on a\nclosed channel...\n\nOn Fri, Oct 4, 2013 at 8:02 AM, Carl H\u00f6rberg notifications@github.comwrote:\n\n> the key is to only declare the exchange once, and then reuse it, this is\n> because node-amqp implicitly opens a \"channel\" each time you call\n> connection.exchange. Channels should be semi-long-lived, not opened and\n> closed over and over again, if you want any kind of performance..\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/247#issuecomment-25678090\n> .\n. @bakkerthehacker I will follow your project. I am pretty interested, especially if you use the node-amqp API to wrap your library. I see that you solve most of the problems that we are having now.\n. Hacking a little bit into the code I have found that basicQosOk event is managed but never emmited:\n\nQueue.prototype._onMethod\n ...\n    case methods.basicQosOk:\n      break;\n\n...\n\nI guess it would not be as easy as just this.emmit(\"basicQosOk\"), right?\n. @ayoung l am finding two issues. \n\nIf I subscribe to the queue with ack:false the prefethCount is ignored (no matter the value), so I will never execute the sendMethod with basicQos.\n\nBut, if I subscribe with {ack:true, prefetchCount:0} the sendMethod with basicQos is executed but this does not emit anything because of this code:\n\n![queue.js _onMethod](https://github.com/postwait/node-amqp/blob/master/lib/queue.js#L435-L436)\n\nThere is no emit. \n. No, I have tried but I dont receive the event :(\n\nOn Tue, Jan 14, 2014 at 6:49 PM, Andrew Young notifications@github.comwrote:\n\n> Does my closed pull request fix that for you?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/264#issuecomment-32288586\n> .\n. I have solved the problem after learning that queue.subscribe implements a promise callback. So now what I do is the next:\n\nqueue.subscribe(config.QUEUE_SUBSCRIBE, function(message, headers, deliveryInfo) {\n        deliverMessage(message);\n    }).once('error', function(error) {\n     logger.error(error.code);\n    }).once('basicQosOk', function() {\n        //it is supposed it is emmited when subscription is ready, but...\n        //it seems is not working :(\n    }).addCallback(function subscribed(ok){\n        logger.info(\"Great, subscription done it\");\n      });\n. I fear that stringify does not resolve the issue, the function receives an string and does not understand the parameters. \n. Great to know exists the possibility. Any workaround to solve this issue in the consumers side?\n. Sorry @gjohnson it is not a matter of exiting the process. For example, in my case... inside the connection I have a socket.io server sending messages to clients, so, I cannot exit the process if something goes wrong. \nThis is a bug, because a wrong call to connection.queue provoke an infinite loop. \n. Really cool feature, thanks @cmoesel I wish this will be included into a new version soon. \n. This patch is not working because passed clientProperties are never assigned. If you see the code on Connection:\n\n```\n var Connection = module.exports = function Connection (connectionArgs, options,  readyCallback) {\n   EventEmitter.call(this);\n   this.setOptions(connectionArgs);\n   ....\n}\n```\n\nSo options passed with clientProperties are ignored and always use the default... I would try a pull request.\n. This should solve the problem: https://github.com/jgato/node-amqp/commit/c8555361bc31cb50bd05a41cf272f1bbff5ea722\n. Could I help you? This should be a really cool feature.\n. Please, could you give us a little more details on that? If a client is subscribed in a queue and this die without a clean close, the server is not aware and continue sending messages, isn't it? \nWith the heartbeat the server is aware and thus, it will not send more messages? \n. For sure, we need this patch. Many thanks!!\n\nOn Wed, Jan 15, 2014 at 9:19 AM, ssafejava notifications@github.com wrote:\n\n> Yes exactly that - if the client dies, or the connection between the\n> client & server is interrupted, the server will _not_ detect this the\n> previous default of heartbeat: 0 and unacked messages will stay unacked\n> for eternity.\n> \n> When a heartbeat is set, the server will send messages to the client &\n> expect a response every heartbeat seconds, the RabbitMQ default being 580\n> seconds. In that case, if the connection were interrupted, the old\n> connection would be reaped at some time within the next ~10min.\n> \n> What really necessitates this patch is that even a small connection\n> interruption can have disastrous results on the queue. Connected clients\n> will reconnect (thus creating a new connection) but the old connections\n> will live on indefinitely, holding their unacked messages in purgatory\n> along with them.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/pull/287#issuecomment-32342160\n> .\n. I have a similar issue using node v0.10.X but it disappears if I use node 0.8. I am not saying this is a solution, but...\n. I am traying to solve this problem with that commits:\n\nhttps://github.com/jgato/node-amqp/commit/579e7a2d5032c186285ef744ba44e3f4f7171cf6\nhttps://github.com/jgato/node-amqp/commit/77b44cb0adc152e84b5e86a352f21babdd192588\n\nMainly, it seems to work. Now you can have references to connections of queues with the same name. \n@postwait  do you think this idea could be ok?\n. Something new about this? \n. I am not sure about your question. Could you put some code and the error?\n\nOn Wed, Apr 2, 2014 at 9:35 PM, Dani Chankhour notifications@github.comwrote:\n\n> I'm creating additional Connection to RabbitMQ and creating Queue on those\n> additonal RabbitMq Connections for each User in my application. However,\n> i'm trying to clean those connections and channels when the user closes the\n> application, but it seems i'm only able to Destroy the queues i have\n> created with no issue. Clearing those connections using connection.end will\n> cause an error in my application in regard to amqp.\\* although i'm sending\n> an empty string '' to create the queues.\n> \n> Is there an option or a way i can clear Connections/Channels when a user\n> closes or refreshes the application?\n> \n> ## \n> \n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/324\n> .\n. I would recommend you to have only one connection, and then create\nexchanges, queues through it. In any case... I guess you clear the qeueue\nwith queue.destroy() and the connection with tempConn.end(), isnt it? which\nerror do you have?\n\nOn Wed, Apr 2, 2014 at 11:05 PM, Dani Chankhour notifications@github.comwrote:\n\n> I currently have my global RabbitMQ connection:\n> \n> var conn = amqp.createConnection({\n> url: config.rabbit.url[app.get('env')]\n> },\n> {\n> defaultExchangeName: 'AppServerWorkExchange',\n> defaultExchangeAutoDelete: false,\n> reconnect: false\n> });\n> \n> Once the user logs in, i need to create a new queue from a new connection:\n> \n> var tempConn = amqp.createConnection({\n> url: brokers[x].Uri\n> });\n> \n> ```\n>             tempConn.on('ready', function() {\n> \n>                 tempConn.exchange(brokers[x].ExchangeName, {\n>                     type: 'topic',\n>                     autoDelete: false\n>                 }, function(exch) {\n> \n>                     //Create Private Queue\n>                     var eventQueue = tempConn.queue('', {\n>                         exclusive: true\n>                     }, function(q2) {\n> ```\n> \n> Once the user logs out, i want to clear the connection and the queue.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/324#issuecomment-39383560\n> .\n. I have some design doubts about that. How could I response to an error managed by an event handler that only receives one parameter, actually the error?.\n\nConnection.on('error', handler(error));\n\nconnection.queue(name, options,  function(queue ){ console.log(\"ok\")  })\n\nif there is some kind of issue, handler(error) will be raised but I dont know anything about who provoked? If I need to response (For example an http request) I cannot do it... Which request provoked the error in order to make the response?\n\nHow could I implement something like that:\n\nconnection.queue(....., function (error, queue){\n\n  if (error)\n     create_response(...., next());\n  else\n     ......\n\n}\n. I am hitting the same issue. In my case, with exclusive queues. Thanks to your fix, when we try a second connection to an exclusive queue, this raises and error and your  closeOK() closes the queue in the server. But, we are not deleting the reference to that queue in the connection.channels, actually, we only delete connection.queues.\n\nSo, when reconnecting, node-amqp try to re-open the queue. The result is that now we have two opened queues, instead of one.\n\n@jameskeane @postwait could you take a look to that commit trying to fix it: https://github.com/jgato/node-amqp/commit/8f2d1d00ef793d9add4dde497fdd1fd33143f7d2\n\nI guess, there could be better ways to delete the channel (to avoid re-connections). For me, now it is working.\n. I also have the same issue with 0.1.7. The same issue, if the server is down each attempt to reconnect attach new listeners... :(\n. Ok, the issue is solved in Master but not in 0.1.7. I guess I will wait for a new release \n. Is this path merged? I am having this same issue. With exclusive queue, after re-connecting for any error the queue is not re-subscribed.\n. I will make more depth tests, but the first attempt is not solving my issue :(\n\nMy scenarios is: \n- One connection to the server\n- One connection to a queue\n- First client using the queue to subscribe exclusive\n- Second client using the queue to subscribe exclusive\n- Queue Exclusive error, so... connection error, connection close\n- Reconnect does not re-subscribe\n\nI guess the issue is this line:\n\n```\n case methods.channelClose:\n      this.state = \"closed\";\n      this.closeOK();\n      this.connection.queueClosed(this.name);\n     ...\n```\n\nBecause of the error the queue is closed, I guess it would not re-connect.\n. Is there any place where we could see all the supported events?\n. Is this issue related to that? https://github.com/postwait/node-amqp/pull/170\n\nI have the same issue and I see this is critical. I need to automatic re-subscribe clients after something went wrong. \n. Great, this is what I have in mind as a future solution :( Maybe I will\nhave to priorize that...\n\nBut still, it is extrange I dont receive and error after publising on a\nclosed channel...\n\nOn Fri, Oct 4, 2013 at 8:02 AM, Carl H\u00f6rberg notifications@github.comwrote:\n\n> the key is to only declare the exchange once, and then reuse it, this is\n> because node-amqp implicitly opens a \"channel\" each time you call\n> connection.exchange. Channels should be semi-long-lived, not opened and\n> closed over and over again, if you want any kind of performance..\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/247#issuecomment-25678090\n> .\n. @bakkerthehacker I will follow your project. I am pretty interested, especially if you use the node-amqp API to wrap your library. I see that you solve most of the problems that we are having now.\n. Hacking a little bit into the code I have found that basicQosOk event is managed but never emmited:\n\nQueue.prototype._onMethod\n ...\n    case methods.basicQosOk:\n      break;\n\n...\n\nI guess it would not be as easy as just this.emmit(\"basicQosOk\"), right?\n. @ayoung l am finding two issues. \n\nIf I subscribe to the queue with ack:false the prefethCount is ignored (no matter the value), so I will never execute the sendMethod with basicQos.\n\nBut, if I subscribe with {ack:true, prefetchCount:0} the sendMethod with basicQos is executed but this does not emit anything because of this code:\n\n![queue.js _onMethod](https://github.com/postwait/node-amqp/blob/master/lib/queue.js#L435-L436)\n\nThere is no emit. \n. No, I have tried but I dont receive the event :(\n\nOn Tue, Jan 14, 2014 at 6:49 PM, Andrew Young notifications@github.comwrote:\n\n> Does my closed pull request fix that for you?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/264#issuecomment-32288586\n> .\n. I have solved the problem after learning that queue.subscribe implements a promise callback. So now what I do is the next:\n\nqueue.subscribe(config.QUEUE_SUBSCRIBE, function(message, headers, deliveryInfo) {\n        deliverMessage(message);\n    }).once('error', function(error) {\n     logger.error(error.code);\n    }).once('basicQosOk', function() {\n        //it is supposed it is emmited when subscription is ready, but...\n        //it seems is not working :(\n    }).addCallback(function subscribed(ok){\n        logger.info(\"Great, subscription done it\");\n      });\n. I fear that stringify does not resolve the issue, the function receives an string and does not understand the parameters. \n. Great to know exists the possibility. Any workaround to solve this issue in the consumers side?\n. Sorry @gjohnson it is not a matter of exiting the process. For example, in my case... inside the connection I have a socket.io server sending messages to clients, so, I cannot exit the process if something goes wrong. \nThis is a bug, because a wrong call to connection.queue provoke an infinite loop. \n. Really cool feature, thanks @cmoesel I wish this will be included into a new version soon. \n. This patch is not working because passed clientProperties are never assigned. If you see the code on Connection:\n\n```\n var Connection = module.exports = function Connection (connectionArgs, options,  readyCallback) {\n   EventEmitter.call(this);\n   this.setOptions(connectionArgs);\n   ....\n}\n```\n\nSo options passed with clientProperties are ignored and always use the default... I would try a pull request.\n. This should solve the problem: https://github.com/jgato/node-amqp/commit/c8555361bc31cb50bd05a41cf272f1bbff5ea722\n. Could I help you? This should be a really cool feature.\n. Please, could you give us a little more details on that? If a client is subscribed in a queue and this die without a clean close, the server is not aware and continue sending messages, isn't it? \nWith the heartbeat the server is aware and thus, it will not send more messages? \n. For sure, we need this patch. Many thanks!!\n\nOn Wed, Jan 15, 2014 at 9:19 AM, ssafejava notifications@github.com wrote:\n\n> Yes exactly that - if the client dies, or the connection between the\n> client & server is interrupted, the server will _not_ detect this the\n> previous default of heartbeat: 0 and unacked messages will stay unacked\n> for eternity.\n> \n> When a heartbeat is set, the server will send messages to the client &\n> expect a response every heartbeat seconds, the RabbitMQ default being 580\n> seconds. In that case, if the connection were interrupted, the old\n> connection would be reaped at some time within the next ~10min.\n> \n> What really necessitates this patch is that even a small connection\n> interruption can have disastrous results on the queue. Connected clients\n> will reconnect (thus creating a new connection) but the old connections\n> will live on indefinitely, holding their unacked messages in purgatory\n> along with them.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/pull/287#issuecomment-32342160\n> .\n. I have a similar issue using node v0.10.X but it disappears if I use node 0.8. I am not saying this is a solution, but...\n. I am traying to solve this problem with that commits:\n\nhttps://github.com/jgato/node-amqp/commit/579e7a2d5032c186285ef744ba44e3f4f7171cf6\nhttps://github.com/jgato/node-amqp/commit/77b44cb0adc152e84b5e86a352f21babdd192588\n\nMainly, it seems to work. Now you can have references to connections of queues with the same name. \n@postwait  do you think this idea could be ok?\n. Something new about this? \n. I am not sure about your question. Could you put some code and the error?\n\nOn Wed, Apr 2, 2014 at 9:35 PM, Dani Chankhour notifications@github.comwrote:\n\n> I'm creating additional Connection to RabbitMQ and creating Queue on those\n> additonal RabbitMq Connections for each User in my application. However,\n> i'm trying to clean those connections and channels when the user closes the\n> application, but it seems i'm only able to Destroy the queues i have\n> created with no issue. Clearing those connections using connection.end will\n> cause an error in my application in regard to amqp.\\* although i'm sending\n> an empty string '' to create the queues.\n> \n> Is there an option or a way i can clear Connections/Channels when a user\n> closes or refreshes the application?\n> \n> ## \n> \n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/324\n> .\n. I would recommend you to have only one connection, and then create\nexchanges, queues through it. In any case... I guess you clear the qeueue\nwith queue.destroy() and the connection with tempConn.end(), isnt it? which\nerror do you have?\n\nOn Wed, Apr 2, 2014 at 11:05 PM, Dani Chankhour notifications@github.comwrote:\n\n> I currently have my global RabbitMQ connection:\n> \n> var conn = amqp.createConnection({\n> url: config.rabbit.url[app.get('env')]\n> },\n> {\n> defaultExchangeName: 'AppServerWorkExchange',\n> defaultExchangeAutoDelete: false,\n> reconnect: false\n> });\n> \n> Once the user logs in, i need to create a new queue from a new connection:\n> \n> var tempConn = amqp.createConnection({\n> url: brokers[x].Uri\n> });\n> \n> ```\n>             tempConn.on('ready', function() {\n> \n>                 tempConn.exchange(brokers[x].ExchangeName, {\n>                     type: 'topic',\n>                     autoDelete: false\n>                 }, function(exch) {\n> \n>                     //Create Private Queue\n>                     var eventQueue = tempConn.queue('', {\n>                         exclusive: true\n>                     }, function(q2) {\n> ```\n> \n> Once the user logs out, i want to clear the connection and the queue.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/324#issuecomment-39383560\n> .\n. ",
    "thomas-riccardi": "Related to this uncommon and unpractical api: currently `promise` are returned from many methods, but they only emit success, never error, as nowhere in the code `promise.emitError` are called. This will lead to broken async chaining in case of error.\n\nThe issue is that the amqp protocol returns an error by closing the channel, with a replyCode if I understand it correctly, and I don't know if it's easy to correlate the error with a previous amqp request (I don't know if we can send multiple amqp requests before receiving the first response, I'm not familiar with the protocol.).\n\nMaybe we could look at what the other amqp client do for error handling.\n\nRelated issue: #282: invalid parameters in queue declaration can lead to infinite loop reconnection / redeclaration as we don't have proper error handling.\n. This is a part of the issue #221 : queue to exchange binding is now correctly re-applied on reconnection, but other bindings exists (at least exchange to exchange binding).\n. What about exchange to exchange binding? This seems to only cover queue to exchange binding.\nSee #221.\n. Related to this uncommon and unpractical api: currently `promise` are returned from many methods, but they only emit success, never error, as nowhere in the code `promise.emitError` are called. This will lead to broken async chaining in case of error.\n\nThe issue is that the amqp protocol returns an error by closing the channel, with a replyCode if I understand it correctly, and I don't know if it's easy to correlate the error with a previous amqp request (I don't know if we can send multiple amqp requests before receiving the first response, I'm not familiar with the protocol.).\n\nMaybe we could look at what the other amqp client do for error handling.\n\nRelated issue: #282: invalid parameters in queue declaration can lead to infinite loop reconnection / redeclaration as we don't have proper error handling.\n. This is a part of the issue #221 : queue to exchange binding is now correctly re-applied on reconnection, but other bindings exists (at least exchange to exchange binding).\n. What about exchange to exchange binding? This seems to only cover queue to exchange binding.\nSee #221.\n. ",
    "ionull": "hmmm, just found it that current amqp module support node v0.2.3 (and yes, we can do something interesting on webOS 2.x now)..lol\nIt's not v0.4.0 +..lol\n. hmmm, just found it that current amqp module support node v0.2.3 (and yes, we can do something interesting on webOS 2.x now)..lol\nIt's not v0.4.0 +..lol\n. ",
    "liamks": "Bump. I can confirm this error.\n. Bump. I can confirm this error.\n. ",
    "danmilon": "Sigh, just saw the same pull request by @whizz. Anyway, i grabbed and changed just now, so there should be no line conflicts.\n. Same here. @postwait any update on this? Thank you.\n. Sigh, just saw the same pull request by @whizz. Anyway, i grabbed and changed just now, so there should be no line conflicts.\n. Same here. @postwait any update on this? Thank you.\n. ",
    "sugendran": "Could we get the package.json updated so that this comes through please.\n. Could we get the package.json updated so that this comes through please.\n. ",
    "ilyail3": "Anyone actually solving this? \nthere's no way to catch this error, nothing I could think of, rendering passive completely useless\n. Anyone actually solving this? \nthere's no way to catch this error, nothing I could think of, rendering passive completely useless\n. ",
    "bergman": "I experience the same in testing. Printing process.memoryUsage() makes it really obvious. I don't know if this is something to worry about at all in production, but it is peculiar.\n\n```\nbefore: { rss:  15081472, heapTotal:  6131200, heapUsed:  3915368 }\nafter:  { rss: 102629376, heapTotal: 64406784, heapUsed: 35432280 }\n```\n\n``` javascript\n\nvar amqp = require('amqp');\nvar connection = amqp.createConnection({url: \"amqp://localhost\"});\n\nvar queue = 'test';\nvar msg = 'foo';\nconnection.on('ready', function () {\n    console.log('before:', process.memoryUsage());\n\n    for (var i = 1; i <= 9000; i++) {\n        connection.publish(queue, msg);\n    }\n\n    setTimeout(function() {\n        console.log('after: ', process.memoryUsage());\n        connection.end();\n    }, 1000);\n});\n```\n. @prystupa did you ever solve this problem? I think it might be related to #57. Did you watch the memory usage in both the javascript and python publisher? I did and found that the javascript version went up from ~40 mb to ~400 mb while the python version stayed at ~15 mb throughout.\n. @hmeerlo is correct, I see the same thing. I wrote a short script to demonstrate:\n\n``` javascript\nvar amqp = require(\"amqp\"),\n    EventEmitter = require(\"events\").EventEmitter;\n\nvar conn = amqp.createConnection({ url: \"amqp://nonexistinghost\" });\n\nsetInterval(function() {\n  console.log(\"error:\", EventEmitter.listenerCount(conn, \"error\"));\n  console.log(\"end:\",   EventEmitter.listenerCount(conn, \"end\"));\n  console.log(\"ready:\", EventEmitter.listenerCount(conn, \"ready\"));\n  console.log(\"\");\n}, 1000);\n```\n\nEvery time node-amqp tries to reconnect it sets up new event listeners for \"end\" and \"ready\" (possibly more, didn't test for any others).\n\nResult:\n\n```\n$ node ta.js\nerror: 1\nend: 2\nready: 2\n\nerror: 1\nend: 3\nready: 3\n\nerror: 1\nend: 4\nready: 4\n\nerror: 1\nend: 5\nready: 5\n\nerror: 1\nend: 6\nready: 6\n\nerror: 1\nend: 7\nready: 7\n\nerror: 1\nend: 8\nready: 8\n\nerror: 1\nend: 9\nready: 9\n\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:179:8)\n    at Connection.onSocketFinish (net.js:199:17)\n    at Connection.EventEmitter.emit (events.js:92:17)\n    at finishMaybe (_stream_writable.js:352:12)\n    at endWritable (_stream_writable.js:359:3)\n    at Connection.Writable.end (_stream_writable.js:337:5)\n    at Connection.Socket.end (net.js:397:31)\n    at Connection.backoff (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:835:12)\n    at Connection.EventEmitter.emit (events.js:95:17)\nerror: 1\nend: 10\nready: 10\n\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.connect (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:1083:8)\n    at Connection.reconnect (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:179:8)\n    at Connection.connect (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:1084:8)\n    at Connection.reconnect (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\nerror: 1\nend: 11\nready: 11\n\nerror: 1\nend: 12\nready: 12\n\nerror: 1\nend: 13\nready: 13\n\n^C\n```\n. I experience the same in testing. Printing process.memoryUsage() makes it really obvious. I don't know if this is something to worry about at all in production, but it is peculiar.\n\n```\nbefore: { rss:  15081472, heapTotal:  6131200, heapUsed:  3915368 }\nafter:  { rss: 102629376, heapTotal: 64406784, heapUsed: 35432280 }\n```\n\n``` javascript\n\nvar amqp = require('amqp');\nvar connection = amqp.createConnection({url: \"amqp://localhost\"});\n\nvar queue = 'test';\nvar msg = 'foo';\nconnection.on('ready', function () {\n    console.log('before:', process.memoryUsage());\n\n    for (var i = 1; i <= 9000; i++) {\n        connection.publish(queue, msg);\n    }\n\n    setTimeout(function() {\n        console.log('after: ', process.memoryUsage());\n        connection.end();\n    }, 1000);\n});\n```\n. @prystupa did you ever solve this problem? I think it might be related to #57. Did you watch the memory usage in both the javascript and python publisher? I did and found that the javascript version went up from ~40 mb to ~400 mb while the python version stayed at ~15 mb throughout.\n. @hmeerlo is correct, I see the same thing. I wrote a short script to demonstrate:\n\n``` javascript\nvar amqp = require(\"amqp\"),\n    EventEmitter = require(\"events\").EventEmitter;\n\nvar conn = amqp.createConnection({ url: \"amqp://nonexistinghost\" });\n\nsetInterval(function() {\n  console.log(\"error:\", EventEmitter.listenerCount(conn, \"error\"));\n  console.log(\"end:\",   EventEmitter.listenerCount(conn, \"end\"));\n  console.log(\"ready:\", EventEmitter.listenerCount(conn, \"ready\"));\n  console.log(\"\");\n}, 1000);\n```\n\nEvery time node-amqp tries to reconnect it sets up new event listeners for \"end\" and \"ready\" (possibly more, didn't test for any others).\n\nResult:\n\n```\n$ node ta.js\nerror: 1\nend: 2\nready: 2\n\nerror: 1\nend: 3\nready: 3\n\nerror: 1\nend: 4\nready: 4\n\nerror: 1\nend: 5\nready: 5\n\nerror: 1\nend: 6\nready: 6\n\nerror: 1\nend: 7\nready: 7\n\nerror: 1\nend: 8\nready: 8\n\nerror: 1\nend: 9\nready: 9\n\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:179:8)\n    at Connection.onSocketFinish (net.js:199:17)\n    at Connection.EventEmitter.emit (events.js:92:17)\n    at finishMaybe (_stream_writable.js:352:12)\n    at endWritable (_stream_writable.js:359:3)\n    at Connection.Writable.end (_stream_writable.js:337:5)\n    at Connection.Socket.end (net.js:397:31)\n    at Connection.backoff (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:835:12)\n    at Connection.EventEmitter.emit (events.js:95:17)\nerror: 1\nend: 10\nready: 10\n\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.connect (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:1083:8)\n    at Connection.reconnect (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:179:8)\n    at Connection.connect (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:1084:8)\n    at Connection.reconnect (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/Users/joab/Kod/oldsnowroller/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\nerror: 1\nend: 11\nready: 11\n\nerror: 1\nend: 12\nready: 12\n\nerror: 1\nend: 13\nready: 13\n\n^C\n```\n. ",
    "zuk": "I ran into this as well. The problem seems to be that the current implementation is sending `.write()`s to the underlying TCP socket without checking whether the socket is ready to receive more data. This causes the socket to start buffering data in memory, and that buffer can balloon very quickly. \n\nThe following pull request exposes an `isBackedUp` property on the `Connection` that lets you check whether its safe to keep sending data without growing the in-memory buffer: https://github.com/postwait/node-amqp/pull/253\n\nBasically if `queue.connection.isBackedUp` is true, you (the node-amqp user) have to stop sending messages and either discard them or buffer them in some safe, manageable way.\n\nThe pull request also adds the ability to specify a max memory buffer size (e.g. `amqp.createConnection({..., maxWriteBuffer: 1e6})` for a 1 MB buffer). \n\nNot sure if this is the best way to deal with this problem, but it does seem to resolve the memory growth issues I've been seeing.\n. Ran into the FRAME_ERROR issue today as well when under high load. Would be nice to get this merged.\n. I ran into this as well. The problem seems to be that the current implementation is sending `.write()`s to the underlying TCP socket without checking whether the socket is ready to receive more data. This causes the socket to start buffering data in memory, and that buffer can balloon very quickly. \n\nThe following pull request exposes an `isBackedUp` property on the `Connection` that lets you check whether its safe to keep sending data without growing the in-memory buffer: https://github.com/postwait/node-amqp/pull/253\n\nBasically if `queue.connection.isBackedUp` is true, you (the node-amqp user) have to stop sending messages and either discard them or buffer them in some safe, manageable way.\n\nThe pull request also adds the ability to specify a max memory buffer size (e.g. `amqp.createConnection({..., maxWriteBuffer: 1e6})` for a 1 MB buffer). \n\nNot sure if this is the best way to deal with this problem, but it does seem to resolve the memory growth issues I've been seeing.\n. Ran into the FRAME_ERROR issue today as well when under high load. Would be nice to get this merged.\n. ",
    "jamuhl": "closing to cleanup my own issue list\n. closing to cleanup my own issue list\n. ",
    "mab-work": "I am happy to write a test case for this, if it will help get it merged.\n. Didn't see the point in them, since I changed the call to the constructor to include both of them, and the constructor calls the setters anyway.\n\nLeft them commented out just in case there was a side-effect of passing them in the constructor I was not aware of (I'm still new to node / js, and its event loop).\n\nIf there is a side-effect I can't see, happy to be educated!\n. I am happy to write a test case for this, if it will help get it merged.\n. Didn't see the point in them, since I changed the call to the constructor to include both of them, and the constructor calls the setters anyway.\n\nLeft them commented out just in case there was a side-effect of passing them in the constructor I was not aware of (I'm still new to node / js, and its event loop).\n\nIf there is a side-effect I can't see, happy to be educated!\n. ",
    "khrome": "That would be fantastic, I'm currently at a new startup and haven't put a queue in our stack yet, until that happens, I won't have the bandwidth to do a test case. If you'd like to implement it, that'd be great!\n. That would be fantastic, I'm currently at a new startup and haven't put a queue in our stack yet, until that happens, I won't have the bandwidth to do a test case. If you'd like to implement it, that'd be great!\n. ",
    "chaliy": "Any chance to get this in trunk?\n. Any chance to get this in trunk?\n. ",
    "humanchimp": "@squaremo I for one would love to see channels exposed.  I think you mean that you would want to do a complete rewrite rather than trying to introduce breaking changes to the current, somewhat cobbled-together module.  I concur.\n. https://github.com/postwait/node-amqp/issues/100\n. No reason to address this in any way during the last 4 months?  It's as valid today as it ever was.\n\nSilent failure costs many people a lot of time.  It is a bug.  Yet there is not so much as a comment on either this issue, or it's duplicates.\n\nI think this project should bear a big, red warning: UNMAINTAINED.\n. Do you see authentication errors when you attempt to connect with invalid credentials?  I don't\n\nWhen I posted this issue months ago, I suggested that perhaps it was my daftness, maybe there is a way to handle this error, and I am just doing it wrong.  I never heard anything about that.  But since this issue has duplicates, I think it has affected many people.  I know that it has affected many people on my own team.\n\nAnd my experience about the pull requests is, no they don't get merged.  For instance there are currently two open pull requests implementing E2E bindings.\n. I have to admit that, regardless of this issue, and its future hopes of being merged with master some day, it is was truly awesome to see some sensible pull-requests merged with master today!\n\nI deeply appreciate that, and it completely reverts my previous statements about the vitality of this project.\n\nI confess to reacting from a sense of helplessness, since I have lately had the added responsibility of maintaining a divergent branch of this project, during which time I have been several times frustrated, and wishing that I was not all alone in maintaining this piece of junk!\n\nThat said, I don't think that RabbitMQ is bad, although from what I can tell it has an uncertain future, even though its implementation seems very solid to me.\n\nI think that ultimately, there are salvageable parts of this project, but that there is a significant amount of maintenance that would better be done sooner, rather than later.\n\nPlease don't be offended by me, and I think I was wrong about the attitude that I have previously expressed.  But I still want to help fix this project.  In my defense, I have been very frustrated with it many times.\n. It seems to me that if the connection ends before the \"ready\" event, that would normally be some sort of reportable error.  So I think this should be an OK fix.  While it's true there will be false positives potentially, I think it's still good to emit the error, because that means that the connection was never ready.\n\nI arrived at this solution after looking into the way that other drivers solved it.  I saw a similar approach in the Go driver, the Ruby driver and the Java driver.  So I was informed by that.\n. thanks!\n. You can use the NODE_DEBUG_AMQP environment variable in order to see (among other junk) the raw output of the socket.\n\nHeartbeats can be configured on the server, but it is only advisory.  The client can specify a heartbeat interval using the \"heartbeat\" option (go figure ;)\n\nAlso, this is not an \"issue\", AFAICT, and I don't think that the issue tracker should be used as a support forum.\n. I've tentatively decided that this is not going to be practical.  Within the library, I am not in a position to make assumptions about the application, and once I start replaying queue bindings, then events start firing, which may lead to double listeners being added, and broken behavior.  Closing.\n. I can, and will, but it is a bit inconvenient for me at the moment, because I already have a fork that I'm actively working on, that has many other unrelated commits.\n. ISTM that a better fix for this would make sure that the end event always fires when the connection closes, since that will clean up the listeners\n. I am somewhat closer to figuring out the ACTUAL cause of this error, after quite a lot of debugging.  I will try to post my findings soon.  Suffice it to say, it has to do with utterly botched reconnection logic.  Basically, after any error, the driver goes into a vicious cycle of \"reconnecting\", which causes the \"end\" handler to be added again and again (hence the memory leak).  More to follow...\n. One problem with throwing is, you never ever want to throw in a node application, unless you can actually catch the error.  Asynchronous control flow makes knowing when you can catch the error unintuitive, because you can only actually catch an error that was thrown in the same call stack.  And knowing exactly where the call stacks begin and end requires a great deal of cognitive overhead.  Also, wrapping everything with try-catch blocks is slow, bad style and anti-pattern\u2014and the library can't do that for you because there's no way to know about anything ansynchronous in your handler.  So it's much, much better in node to emit error events than to throw errors.  Error handling in this library still leaves something to be desired, but you should have better luck by using `#emit` rather than `throw`\n. @squaremo I for one would love to see channels exposed.  I think you mean that you would want to do a complete rewrite rather than trying to introduce breaking changes to the current, somewhat cobbled-together module.  I concur.\n. https://github.com/postwait/node-amqp/issues/100\n. No reason to address this in any way during the last 4 months?  It's as valid today as it ever was.\n\nSilent failure costs many people a lot of time.  It is a bug.  Yet there is not so much as a comment on either this issue, or it's duplicates.\n\nI think this project should bear a big, red warning: UNMAINTAINED.\n. Do you see authentication errors when you attempt to connect with invalid credentials?  I don't\n\nWhen I posted this issue months ago, I suggested that perhaps it was my daftness, maybe there is a way to handle this error, and I am just doing it wrong.  I never heard anything about that.  But since this issue has duplicates, I think it has affected many people.  I know that it has affected many people on my own team.\n\nAnd my experience about the pull requests is, no they don't get merged.  For instance there are currently two open pull requests implementing E2E bindings.\n. I have to admit that, regardless of this issue, and its future hopes of being merged with master some day, it is was truly awesome to see some sensible pull-requests merged with master today!\n\nI deeply appreciate that, and it completely reverts my previous statements about the vitality of this project.\n\nI confess to reacting from a sense of helplessness, since I have lately had the added responsibility of maintaining a divergent branch of this project, during which time I have been several times frustrated, and wishing that I was not all alone in maintaining this piece of junk!\n\nThat said, I don't think that RabbitMQ is bad, although from what I can tell it has an uncertain future, even though its implementation seems very solid to me.\n\nI think that ultimately, there are salvageable parts of this project, but that there is a significant amount of maintenance that would better be done sooner, rather than later.\n\nPlease don't be offended by me, and I think I was wrong about the attitude that I have previously expressed.  But I still want to help fix this project.  In my defense, I have been very frustrated with it many times.\n. It seems to me that if the connection ends before the \"ready\" event, that would normally be some sort of reportable error.  So I think this should be an OK fix.  While it's true there will be false positives potentially, I think it's still good to emit the error, because that means that the connection was never ready.\n\nI arrived at this solution after looking into the way that other drivers solved it.  I saw a similar approach in the Go driver, the Ruby driver and the Java driver.  So I was informed by that.\n. thanks!\n. You can use the NODE_DEBUG_AMQP environment variable in order to see (among other junk) the raw output of the socket.\n\nHeartbeats can be configured on the server, but it is only advisory.  The client can specify a heartbeat interval using the \"heartbeat\" option (go figure ;)\n\nAlso, this is not an \"issue\", AFAICT, and I don't think that the issue tracker should be used as a support forum.\n. I've tentatively decided that this is not going to be practical.  Within the library, I am not in a position to make assumptions about the application, and once I start replaying queue bindings, then events start firing, which may lead to double listeners being added, and broken behavior.  Closing.\n. I can, and will, but it is a bit inconvenient for me at the moment, because I already have a fork that I'm actively working on, that has many other unrelated commits.\n. ISTM that a better fix for this would make sure that the end event always fires when the connection closes, since that will clean up the listeners\n. I am somewhat closer to figuring out the ACTUAL cause of this error, after quite a lot of debugging.  I will try to post my findings soon.  Suffice it to say, it has to do with utterly botched reconnection logic.  Basically, after any error, the driver goes into a vicious cycle of \"reconnecting\", which causes the \"end\" handler to be added again and again (hence the memory leak).  More to follow...\n. One problem with throwing is, you never ever want to throw in a node application, unless you can actually catch the error.  Asynchronous control flow makes knowing when you can catch the error unintuitive, because you can only actually catch an error that was thrown in the same call stack.  And knowing exactly where the call stacks begin and end requires a great deal of cognitive overhead.  Also, wrapping everything with try-catch blocks is slow, bad style and anti-pattern\u2014and the library can't do that for you because there's no way to know about anything ansynchronous in your handler.  So it's much, much better in node to emit error events than to throw errors.  Error handling in this library still leaves something to be desired, but you should have better luck by using `#emit` rather than `throw`\n. ",
    "alexyoung": "They could be represented as a `String`:\n\nhttps://github.com/broofa/node-int64\n. They could be represented as a `String`:\n\nhttps://github.com/broofa/node-int64\n. ",
    "alfonsoabad": "I'm having a  'connection_closed_abruptly' message in the rabbitmq log, I'm gonna try @dathan  suggestion, to see if this solves the issue.\n\n@dathan : About the \"social commit\" , I think you meant \"pull request\" you can learn more in https://help.github.com/articles/using-pull-requests is about how contributors send commits from their forks to the main repository.\n. I'm having a  'connection_closed_abruptly' message in the rabbitmq log, I'm gonna try @dathan  suggestion, to see if this solves the issue.\n\n@dathan : About the \"social commit\" , I think you meant \"pull request\" you can learn more in https://help.github.com/articles/using-pull-requests is about how contributors send commits from their forks to the main repository.\n. ",
    "FGRibreau": "Yep, I got the same error\n. Yes, it fixs this issue, thanks !\n. @prystupa The fix isn't available in 0.1.2, we have to wait for 0.1.3 I think.\n. I still get the bug it's so inconvenient, please, publish 0.1.3.\n. I can't go back to 0.1.1 because 0.1.1 requires node 0.4 || 0.5 and I'm using node 0.6.12.\n\n``` shell\nremote: npm WARN amqp@0.1.0 package.json: bugs['web'] should probably be bugs['url']\nremote: npm ERR! Unsupported\nremote: npm ERR! Not compatible with your version of node/npm: amqp@0.1.0\nremote: npm ERR! Required: {\"node\":\"0.4 || 0.5\"}\nremote: npm ERR! Actual:   {\"npm\":\"1.0.106\",\"node\":\"0.6.12\"}\n```\n. Where are amqp@0.1.5 & @0.1.6? There is a tag for 0.1.6 but nothing about them on npm\n\n``` javascript\n{ name: 'amqp',\n  description: 'AMQP driver for node',\n  'dist-tags': { latest: '0.1.4' },\n  versions: \n   [ '0.0.1',\n     '0.0.2-squaremo01.184010',\n     '0.0.2',\n     '0.0.6',\n     '0.0.7',\n     '0.1.0',\n     '0.1.1',\n     '0.1.2',\n     '0.1.3',\n     '0.1.4' ],\n  maintainers: [ 'ry <ry@tinyclouds.org>', 'postwait <jesus@omniti.com>' ],\n  author: 'Ryan Dahl',\n  time: \n   { '0.0.1': '2011-05-26T17:36:58.769Z',\n     '0.0.2': '2011-05-26T17:36:58.769Z',\n     '0.0.2-squaremo01.184010': '2011-05-26T17:36:58.769Z',\n     '0.0.6': '2011-05-26T17:38:23.766Z',\n     '0.0.7': '2011-06-02T21:41:24.522Z',\n     '0.1.0': '2011-07-30T13:48:49.682Z',\n     '0.1.1': '2011-11-09T10:13:16.126Z',\n     '0.1.2': '2012-02-03T21:06:40.789Z',\n     '0.1.3': '2012-04-17T13:35:29.358Z',\n     '0.1.4': '2012-10-05T01:20:30.154Z' },\n```\n. Same issue here\n. Its a regression, the same code works well with `amqp@0.1.3`.\n. :+1: \n. @podviaznikov could you copy/paste more code please?\n. Yep, I got the same error\n. Yes, it fixs this issue, thanks !\n. @prystupa The fix isn't available in 0.1.2, we have to wait for 0.1.3 I think.\n. I still get the bug it's so inconvenient, please, publish 0.1.3.\n. I can't go back to 0.1.1 because 0.1.1 requires node 0.4 || 0.5 and I'm using node 0.6.12.\n\n``` shell\nremote: npm WARN amqp@0.1.0 package.json: bugs['web'] should probably be bugs['url']\nremote: npm ERR! Unsupported\nremote: npm ERR! Not compatible with your version of node/npm: amqp@0.1.0\nremote: npm ERR! Required: {\"node\":\"0.4 || 0.5\"}\nremote: npm ERR! Actual:   {\"npm\":\"1.0.106\",\"node\":\"0.6.12\"}\n```\n. Where are amqp@0.1.5 & @0.1.6? There is a tag for 0.1.6 but nothing about them on npm\n\n``` javascript\n{ name: 'amqp',\n  description: 'AMQP driver for node',\n  'dist-tags': { latest: '0.1.4' },\n  versions: \n   [ '0.0.1',\n     '0.0.2-squaremo01.184010',\n     '0.0.2',\n     '0.0.6',\n     '0.0.7',\n     '0.1.0',\n     '0.1.1',\n     '0.1.2',\n     '0.1.3',\n     '0.1.4' ],\n  maintainers: [ 'ry <ry@tinyclouds.org>', 'postwait <jesus@omniti.com>' ],\n  author: 'Ryan Dahl',\n  time: \n   { '0.0.1': '2011-05-26T17:36:58.769Z',\n     '0.0.2': '2011-05-26T17:36:58.769Z',\n     '0.0.2-squaremo01.184010': '2011-05-26T17:36:58.769Z',\n     '0.0.6': '2011-05-26T17:38:23.766Z',\n     '0.0.7': '2011-06-02T21:41:24.522Z',\n     '0.1.0': '2011-07-30T13:48:49.682Z',\n     '0.1.1': '2011-11-09T10:13:16.126Z',\n     '0.1.2': '2012-02-03T21:06:40.789Z',\n     '0.1.3': '2012-04-17T13:35:29.358Z',\n     '0.1.4': '2012-10-05T01:20:30.154Z' },\n```\n. Same issue here\n. Its a regression, the same code works well with `amqp@0.1.3`.\n. :+1: \n. @podviaznikov could you copy/paste more code please?\n. ",
    "jimeh": "Fixes it for me too. When could we expect to see this fix released? :)\n. There's a lot people running into this issue. Personally I got around it by pointing my `package.json` dependency directly at `https://github.com/postwait/node-amqp.git#master` instead of a specific version number.\n. Fixes it for me too. When could we expect to see this fix released? :)\n. There's a lot people running into this issue. Personally I got around it by pointing my `package.json` dependency directly at `https://github.com/postwait/node-amqp.git#master` instead of a specific version number.\n. ",
    "pijewski": "I ran into the same issue as orlandov and can also report that this change fixed the issue.  Thanks!\n. I ran into the same issue as orlandov and can also report that this change fixed the issue.  Thanks!\n. ",
    "prystupa": "@squaremo Did the fix make it to latest npm release? I'm still getting this with 0.1.2. Thanks!\n. +1 I'm getting this one too\n. Hi Edward, would you be able to share your fork with me? I'd like to see what's involved and if I am able to adopt it to the latest code base. \n\nThanks!\n\nSent from my iPhone\n\nOn Apr 14, 2012, at 1:50 PM, Edward Klinereply@reply.github.com wrote:\n\n> If it can, I'd like to see some documentation too or at least a response stating yes or no.  I have a fork where I altered the Connection class so I could do AMQP over SSL, but I think things here have progressed to a point where the changes can't be simple merged back in... and I don't have time right now to redo the changes.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/89#issuecomment-5133130\n. @squaremo Did the fix make it to latest npm release? I'm still getting this with 0.1.2. Thanks!\n. +1 I'm getting this one too\n. Hi Edward, would you be able to share your fork with me? I'd like to see what's involved and if I am able to adopt it to the latest code base. \n\nThanks!\n\nSent from my iPhone\n\nOn Apr 14, 2012, at 1:50 PM, Edward Klinereply@reply.github.com wrote:\n\n> If it can, I'd like to see some documentation too or at least a response stating yes or no.  I have a fork where I altered the Connection class so I could do AMQP over SSL, but I think things here have progressed to a point where the changes can't be simple merged back in... and I don't have time right now to redo the changes.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/89#issuecomment-5133130\n. ",
    "michaelplaing": "This a blocker for me. Is there any update on 0.1.3? Or is there a 'version' to back into?\n. Thanks. I found I had to go back to 0.1.0 because I was generating too many\nmalformed frames with 0.1.1 and rabbitmq would drop the connection. :-/ ml\n\nOn Tue, Mar 13, 2012 at 17:23, Michael Bridgen <\nreply@reply.github.com\n\n> wrote:\n> \n> @michaelplaing @FGRibreau 0.1.1 does not have the bug, and neither lacks\n> any features so far as I can tell.\n> You shall have to petition Theo for a 0.1.3 release -- he and Ryan are the\n> maintainers (`npm info amqp`).\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/65#issuecomment-4486637\n. Multiple publishes of moderately sized messages (400K) to a direct exchange fail silently on the 2nd one - queue.shift() fails as well for the input queue which was the source of the message. I think this is related and that internal structures are being overwritten. Workaround is to revert back to v0.1.0\n. This stripped-down test in coffeescript passes in master with a small message but fails with a larger one. No errors are reported but in this case the publish to queue 'output2' does not occur although the ack succeeds. My test file is 341KB of JSON.\n\n```\nfs = require 'fs'\namqp = require 'amqp'\n\ndo_message = (message) ->\n    console.log \"got message\"\n    default_exchange.publish \"output1\", JSON.stringify(message), contentType:'application/json'\n    console.log \"published to output1\"\n    default_exchange.publish \"output2\", JSON.stringify(message), contentType:'application/json'\n    console.log \"published to output2\"\n    input_queue.shift() # acknowledge\n    console.log \"acked\"\n\ninput_message = JSON.parse(fs.readFileSync('./test/test'))\nconsole.log \"read input_message?: #{input_message.data?}; length: #{input_message.data.length}\"\namqp_connection = amqp.createConnection()\n\ndefault_exchange = {}\ninput_queue = {}\namqp_connection.on 'ready', () -> \n    default_exchange = amqp_connection.exchange()\n    queue_args = durable:true, autoDelete: false\n\n    amqp_connection.queue 'input', queue_args, (queue) ->\n        input_queue = queue\n        queue.subscribe ack:true, (message) -> do_message message\n        console.log \"listening...\"\n\n        amqp_connection.queue 'output1', queue_args, (queue) ->\n            console.log \"output1\"\n\n            amqp_connection.queue 'output2', queue_args, (queue) ->\n                console.log \"output2\"\n                default_exchange.publish 'input', JSON.stringify(input_message), contentType:'application/json'\n                console.log \"published to input\"\n```\n. I am expecting to see a message in output2. None appears for messages larger than about 70KB. I'm running the latest node, rabbitmq, and erlang on OSX Lion.\n. Thanks Michael!\n\nOn Tue, Mar 27, 2012 at 10:50, Michael Bridgen <\nreply@reply.github.com\n\n> wrote:\n> \n> I traced this to the commit fc2625bd5af0028944cb4d8650cd7101d18798ab,\n> which pre-allocates (and reuses) the method sending frame buffer. It's\n> reverted in my issue 65 branch, for which I'll issue a pull request.\n> \n> Meanwhile I discovered a couple of things:\n> - All the methods for sending frames ignore the return value from\n>   `WritableStream.write`. In the test case it so happens that with a\n>   particular content size, the publish to output2 reliably exceeds the kernel\n>   buffer\n> - `Connection._sendBody` ignores the maximum frame size negotiated with\n>   the server. (As it happens RabbitMQ is understanding about this)\n> \n> Now the most interesting thing: it appears that when the method send\n> buffer is reused, and `WritableStream.write` returns false, the buffer is\n> never written to the socket. When a new buffer is allocated each send, it\n> is eventually written even if it overflows the kernel buffer.\n> \n> Anyway the reverted commit goes back to allocating a buffer of\n> maxFrameSize for each method send. This is pretty wasteful -- maxFrameSize\n> is well over the threshold for allocation from the pool. Possibly a better\n> solution is to use a single buffer for assembling frames but copy them to\n> (likely much smaller) fresh buffers before sending.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/65#issuecomment-4718026\n. Actually when rapidly pushing messages a few weeks ago the rabbit reported framing errors and then died causing me to back off of master. I didn't have time then to investigate.\n. This is the same root cause as issue #83.\n. I'm not sure now that I look at it again. For certain I cannot subscribe to\nfirehouse messages without error, but I am not certain why.\n\nOn Mon, Apr 2, 2012 at 08:57, James Carr <\nreply@reply.github.com\n\n> wrote:\n> \n> Is the root cause that it cannot handle headers with array values?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/86#issuecomment-4877800\n. This is related to issues #83 and #86\n. Sure I'll give it a try.\n. This a blocker for me. Is there any update on 0.1.3? Or is there a 'version' to back into?\n. Thanks. I found I had to go back to 0.1.0 because I was generating too many\nmalformed frames with 0.1.1 and rabbitmq would drop the connection. :-/ ml\n\nOn Tue, Mar 13, 2012 at 17:23, Michael Bridgen <\nreply@reply.github.com\n\n> wrote:\n> \n> @michaelplaing @FGRibreau 0.1.1 does not have the bug, and neither lacks\n> any features so far as I can tell.\n> You shall have to petition Theo for a 0.1.3 release -- he and Ryan are the\n> maintainers (`npm info amqp`).\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/65#issuecomment-4486637\n. Multiple publishes of moderately sized messages (400K) to a direct exchange fail silently on the 2nd one - queue.shift() fails as well for the input queue which was the source of the message. I think this is related and that internal structures are being overwritten. Workaround is to revert back to v0.1.0\n. This stripped-down test in coffeescript passes in master with a small message but fails with a larger one. No errors are reported but in this case the publish to queue 'output2' does not occur although the ack succeeds. My test file is 341KB of JSON.\n\n```\nfs = require 'fs'\namqp = require 'amqp'\n\ndo_message = (message) ->\n    console.log \"got message\"\n    default_exchange.publish \"output1\", JSON.stringify(message), contentType:'application/json'\n    console.log \"published to output1\"\n    default_exchange.publish \"output2\", JSON.stringify(message), contentType:'application/json'\n    console.log \"published to output2\"\n    input_queue.shift() # acknowledge\n    console.log \"acked\"\n\ninput_message = JSON.parse(fs.readFileSync('./test/test'))\nconsole.log \"read input_message?: #{input_message.data?}; length: #{input_message.data.length}\"\namqp_connection = amqp.createConnection()\n\ndefault_exchange = {}\ninput_queue = {}\namqp_connection.on 'ready', () -> \n    default_exchange = amqp_connection.exchange()\n    queue_args = durable:true, autoDelete: false\n\n    amqp_connection.queue 'input', queue_args, (queue) ->\n        input_queue = queue\n        queue.subscribe ack:true, (message) -> do_message message\n        console.log \"listening...\"\n\n        amqp_connection.queue 'output1', queue_args, (queue) ->\n            console.log \"output1\"\n\n            amqp_connection.queue 'output2', queue_args, (queue) ->\n                console.log \"output2\"\n                default_exchange.publish 'input', JSON.stringify(input_message), contentType:'application/json'\n                console.log \"published to input\"\n```\n. I am expecting to see a message in output2. None appears for messages larger than about 70KB. I'm running the latest node, rabbitmq, and erlang on OSX Lion.\n. Thanks Michael!\n\nOn Tue, Mar 27, 2012 at 10:50, Michael Bridgen <\nreply@reply.github.com\n\n> wrote:\n> \n> I traced this to the commit fc2625bd5af0028944cb4d8650cd7101d18798ab,\n> which pre-allocates (and reuses) the method sending frame buffer. It's\n> reverted in my issue 65 branch, for which I'll issue a pull request.\n> \n> Meanwhile I discovered a couple of things:\n> - All the methods for sending frames ignore the return value from\n>   `WritableStream.write`. In the test case it so happens that with a\n>   particular content size, the publish to output2 reliably exceeds the kernel\n>   buffer\n> - `Connection._sendBody` ignores the maximum frame size negotiated with\n>   the server. (As it happens RabbitMQ is understanding about this)\n> \n> Now the most interesting thing: it appears that when the method send\n> buffer is reused, and `WritableStream.write` returns false, the buffer is\n> never written to the socket. When a new buffer is allocated each send, it\n> is eventually written even if it overflows the kernel buffer.\n> \n> Anyway the reverted commit goes back to allocating a buffer of\n> maxFrameSize for each method send. This is pretty wasteful -- maxFrameSize\n> is well over the threshold for allocation from the pool. Possibly a better\n> solution is to use a single buffer for assembling frames but copy them to\n> (likely much smaller) fresh buffers before sending.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/65#issuecomment-4718026\n. Actually when rapidly pushing messages a few weeks ago the rabbit reported framing errors and then died causing me to back off of master. I didn't have time then to investigate.\n. This is the same root cause as issue #83.\n. I'm not sure now that I look at it again. For certain I cannot subscribe to\nfirehouse messages without error, but I am not certain why.\n\nOn Mon, Apr 2, 2012 at 08:57, James Carr <\nreply@reply.github.com\n\n> wrote:\n> \n> Is the root cause that it cannot handle headers with array values?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/86#issuecomment-4877800\n. This is related to issues #83 and #86\n. Sure I'll give it a try.\n. ",
    "seosh81": "Did it fix?\n. Did it fix?\n. ",
    "psla": "I've got same error today on version 0.2.0 of rabbit.js (amqp 0.1.2) (installed yesterday)\n\n```\nbuffer.js:494\n    throw new Error('sourceEnd out of bounds');\n          ^\nError: sourceEnd out of bounds\n    at Buffer.copy (buffer.js:494:11)\n    at frame (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:169:10)\n    at header (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:159:14)\n    at frameEnd (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:204:16)\n    at frame (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:171:14)\n    at header (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:159:14)\n    at frameEnd (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:204:16)\n    at frame (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:171:14)\n    at header (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:159:14)\n    at frameEnd (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:204:16)\n```\n\nany workaround for this issue? any plans of releasing new version without this bug?\n. I've got same error today on version 0.2.0 of rabbit.js (amqp 0.1.2) (installed yesterday)\n\n```\nbuffer.js:494\n    throw new Error('sourceEnd out of bounds');\n          ^\nError: sourceEnd out of bounds\n    at Buffer.copy (buffer.js:494:11)\n    at frame (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:169:10)\n    at header (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:159:14)\n    at frameEnd (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:204:16)\n    at frame (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:171:14)\n    at header (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:159:14)\n    at frameEnd (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:204:16)\n    at frame (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:171:14)\n    at header (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:159:14)\n    at frameEnd (/srv/scripts/node_modules/rabbit.js/node_modules/amqp/amqp.js:204:16)\n```\n\nany workaround for this issue? any plans of releasing new version without this bug?\n. ",
    "marcab": "Same here.\n. Same here.\n. ",
    "ericbarch": "Seeing this as well (amqp 0.1.2 from npm). Node 0.6.15. Only seems to happen under high load.\n. Seeing this as well (amqp 0.1.2 from npm). Node 0.6.15. Only seems to happen under high load.\n. ",
    "onyxrev": "Pulled 0.1.6 and am running it in production.  I have a daemon that picks up 37,000+ messages in a batch every ten minutes that was falling over on itself with this issue.  Haven't seen it since upgrading to 0.1.6.\n. Pulled 0.1.6 and am running it in production.  I have a daemon that picks up 37,000+ messages in a batch every ten minutes that was falling over on itself with this issue.  Haven't seen it since upgrading to 0.1.6.\n. ",
    "shimaore": "I suspect there is a disconnect between how RabbitMQ wants vhosts and how node-amqp is handling them (for example in its URL parsing).\nIn RabbitMQ (2.8.4 in my case) the vhosts are clearly labelled with a starting slash: `/dev` would be correct in the example above.\n. Argh ouch ya. The `Vhost` section of [AMQP URI Specs](http://www.rabbitmq.com/uri-spec.html) is pretty clear about this, but I didn't pay attention my installation script was doing\n\n```\nrabbitmqctl add_vhost /foo \n# ... creates  amqp://host:port/%2Ffoo\n```\n\ninstead of\n\n```\nrabbitmqctl add_vhost foo\n# ... creates  amqp://host:port/foo\n```\n\nPutting this baby to rest.\n. I suspect there is a disconnect between how RabbitMQ wants vhosts and how node-amqp is handling them (for example in its URL parsing).\nIn RabbitMQ (2.8.4 in my case) the vhosts are clearly labelled with a starting slash: `/dev` would be correct in the example above.\n. Argh ouch ya. The `Vhost` section of [AMQP URI Specs](http://www.rabbitmq.com/uri-spec.html) is pretty clear about this, but I didn't pay attention my installation script was doing\n\n```\nrabbitmqctl add_vhost /foo \n# ... creates  amqp://host:port/%2Ffoo\n```\n\ninstead of\n\n```\nrabbitmqctl add_vhost foo\n# ... creates  amqp://host:port/foo\n```\n\nPutting this baby to rest.\n. ",
    "sbellone": "Hi, I did the same mistake than you and Google redirected me here.\nIt could have saved me few minutes if you had explained your mistake, so I'm doing it in case other people arrive here too :)\nWhat you have to do to catch the error is simply:\n\n```\nconn.queue(\"foo2\", {'passive':true},function(q){\n  console.log(q);\n}).on('error', function(err) {\n      console.log('Got you: ' + err);\n    });\n```\n. Hi,\nTo delete a queue, just recreate it with the exact same parameters.\nThen call `queue.destroy()`. I just tested, it works fine.\n\nTo check if a queue already exists, the API provide the possibility to declare a passive queue: http://www.rabbitmq.com/amqp-0-9-1-reference.html#queue.declare.passive\nBut I encountered some issues with its implementation in node-amqp. (I proposed a patch about that: https://github.com/postwait/node-amqp/pull/170)\n. Unfortunately I never had feedback for this, but it was working very fine in our env.\nIt's a shame because the patch is very little and it fixes (at least for me) critical issues.\n. Ok, so this is not the same scenario, on my side I was getting a proper 'close' event due to a proxy timeout.\n. Hello.\nTo delete a queue, you have this method: `queue.destroy` (see https://github.com/postwait/node-amqp#queuedestroyoptions)\nTo close the channels, just create your queue with `closeChannelOnUnsubscribe` argument. The code will eventually pass through `delete this.connection.channels[this.channel]` (l. 1552 of the current amqp.js) when it will receive the 'channelCloseOk' callback.\n. Ah ok, you don't want to delete it on the server.\nMaybe calling `queue.close()` is what you need? It will close the channel without deleting the queue on server.\n. Hi, I did the same mistake than you and Google redirected me here.\nIt could have saved me few minutes if you had explained your mistake, so I'm doing it in case other people arrive here too :)\nWhat you have to do to catch the error is simply:\n\n```\nconn.queue(\"foo2\", {'passive':true},function(q){\n  console.log(q);\n}).on('error', function(err) {\n      console.log('Got you: ' + err);\n    });\n```\n. Hi,\nTo delete a queue, just recreate it with the exact same parameters.\nThen call `queue.destroy()`. I just tested, it works fine.\n\nTo check if a queue already exists, the API provide the possibility to declare a passive queue: http://www.rabbitmq.com/amqp-0-9-1-reference.html#queue.declare.passive\nBut I encountered some issues with its implementation in node-amqp. (I proposed a patch about that: https://github.com/postwait/node-amqp/pull/170)\n. Unfortunately I never had feedback for this, but it was working very fine in our env.\nIt's a shame because the patch is very little and it fixes (at least for me) critical issues.\n. Ok, so this is not the same scenario, on my side I was getting a proper 'close' event due to a proxy timeout.\n. Hello.\nTo delete a queue, you have this method: `queue.destroy` (see https://github.com/postwait/node-amqp#queuedestroyoptions)\nTo close the channels, just create your queue with `closeChannelOnUnsubscribe` argument. The code will eventually pass through `delete this.connection.channels[this.channel]` (l. 1552 of the current amqp.js) when it will receive the 'channelCloseOk' callback.\n. Ah ok, you don't want to delete it on the server.\nMaybe calling `queue.close()` is what you need? It will close the channel without deleting the queue on server.\n. ",
    "cpsubrian": "Would love more action on this problem.  Has performance been an issue for others?  Any app or OS level tweaks to improve response time?\n. Would love more action on this problem.  Has performance been an issue for others?  Any app or OS level tweaks to improve response time?\n. ",
    "life0fun": "I second this issue....I have python version and node version.  I can only do about 400 publishes per second with this lib while python version is faster.\nThe avg size of my json string is about around 200 bytes. \nDo we ever have any performance benchmark anywhere ?\n. I second this issue....I have python version and node version.  I can only do about 400 publishes per second with this lib while python version is faster.\nThe avg size of my json string is about around 200 bytes. \nDo we ever have any performance benchmark anywhere ?\n. ",
    "alswl": "It seems it was fixed.\n. It seems it was fixed.\n. ",
    "dokie": "You still need to install the module locally too with npm install amqp\n. You still need to install the module locally too with npm install amqp\n. ",
    "fernandomm": "Hi,\n\nI tried installing locally but it still can't find the module.\n\nOutput:\n\n```\n$  npm install amqp\nnpm http GET https://registry.npmjs.org/amqp\nnpm http 304 https://registry.npmjs.org/amqp\n$ node server.js \n\nnode.js:201\n        throw e; // process.nextTick error, or 'error' event on first tick\n              ^\nError: Cannot find module 'amqp'\n    at Function._resolveFilename (module.js:332:11)\n    at Function._load (module.js:279:25)\n    at Module.require (module.js:354:17)\n    at require (module.js:370:17)\n    at Object.<anonymous> (/Applications/MAMP/htdocs/example/server.js:2:12)\n    at Module._compile (module.js:441:26)\n    at Object..js (module.js:459:10)\n    at Module.load (module.js:348:31)\n    at Function._load (module.js:308:12)\n    at Array.0 (module.js:479:10)\n```\n. Hi,\n\nI tried installing locally but it still can't find the module.\n\nOutput:\n\n```\n$  npm install amqp\nnpm http GET https://registry.npmjs.org/amqp\nnpm http 304 https://registry.npmjs.org/amqp\n$ node server.js \n\nnode.js:201\n        throw e; // process.nextTick error, or 'error' event on first tick\n              ^\nError: Cannot find module 'amqp'\n    at Function._resolveFilename (module.js:332:11)\n    at Function._load (module.js:279:25)\n    at Module.require (module.js:354:17)\n    at require (module.js:370:17)\n    at Object.<anonymous> (/Applications/MAMP/htdocs/example/server.js:2:12)\n    at Module._compile (module.js:441:26)\n    at Object..js (module.js:459:10)\n    at Module.load (module.js:348:31)\n    at Function._load (module.js:308:12)\n    at Array.0 (module.js:479:10)\n```\n. ",
    "naholyr": "At that point, q.shift() will even totally fail if you use a prefetchCount > 1 !\n\nI use this workaround:\n\n```\nq.subscribe(function (...) {\n  var msg = q.currentMessage; // you can later use \"msg.acknowledge()\"\n  ...\n}\n```\n\nIt's a real bug in case of prefetchCount != 1 (especially if > 1) so I may propose a pull request very soon.\n. In reality, it's not documented but original Message object is available in the callback since 22 Nov 2011...\n\n``` javascript\nq.subscribe(function (message, headers, info, originalMessageObject) {\n  ...\n  originalMessageObject.acknowledge();\n  ...\n});\n```\n\nI would love a confirmation that this is really stable, but as it's been here for more than 6 months I think we can count on it ;)\n. We at @Dijiwan use it on production. You can use it, it's working fine.\n\nI'd rather see some documentation about it, so that we're absolutely certain this API won't change without notifications.\n. OK call me stupid :) I was using \"node-amqp\" module from NPM, at version 0.1.2, from author \"ivolo\".\n\nThis is fixed in \"amqp\" version 0.1.3 (authors ry and postwait).\n\nYou should definitely contact this \"ivolo\" to make him remove his corrupted copy.\n. Note: I contacted `ivolo` to make him remove his version\n. At that point, q.shift() will even totally fail if you use a prefetchCount > 1 !\n\nI use this workaround:\n\n```\nq.subscribe(function (...) {\n  var msg = q.currentMessage; // you can later use \"msg.acknowledge()\"\n  ...\n}\n```\n\nIt's a real bug in case of prefetchCount != 1 (especially if > 1) so I may propose a pull request very soon.\n. In reality, it's not documented but original Message object is available in the callback since 22 Nov 2011...\n\n``` javascript\nq.subscribe(function (message, headers, info, originalMessageObject) {\n  ...\n  originalMessageObject.acknowledge();\n  ...\n});\n```\n\nI would love a confirmation that this is really stable, but as it's been here for more than 6 months I think we can count on it ;)\n. We at @Dijiwan use it on production. You can use it, it's working fine.\n\nI'd rather see some documentation about it, so that we're absolutely certain this API won't change without notifications.\n. OK call me stupid :) I was using \"node-amqp\" module from NPM, at version 0.1.2, from author \"ivolo\".\n\nThis is fixed in \"amqp\" version 0.1.3 (authors ry and postwait).\n\nYou should definitely contact this \"ivolo\" to make him remove his corrupted copy.\n. Note: I contacted `ivolo` to make him remove his version\n. ",
    "baio": "Hi!\nAny update of this issue? Can I still use it as solution for my project?\nThanks.\n. Ok, thanks!\n. Hi!\nAny update of this issue? Can I still use it as solution for my project?\nThanks.\n. Ok, thanks!\n. ",
    "CrisFavero": "I just wanted to say think you to pointing out this hidden parameter As i was wondering the same thing.  It is one serious flaw of this library i have found that many things are undocumented.\n. I just wanted to say think you to pointing out this hidden parameter As i was wondering the same thing.  It is one serious flaw of this library i have found that many things are undocumented.\n. ",
    "xissy": "It occurs same to me.\n. It occurs same to me.\n. ",
    "zeeraw": "I encountered the exact same problem.\n. I encountered the exact same problem.\n. ",
    "batazor": ":+1:\n. I received a reply [http://stackoverflow.com](http://stackoverflow.com/questions/33081379/how-to-use-x-message-ttl-in-node-amqp/33084522#33084522)\n. :+1:\n. I received a reply [http://stackoverflow.com](http://stackoverflow.com/questions/33081379/how-to-use-x-message-ttl-in-node-amqp/33084522#33084522)\n. ",
    "rade": "AFAICT this is meant to have been fixed by issue #105. So can this be closed?\n. As squaremo points out above, the RabbitMQ broker admits oversize frames. But that is a DoS vector and therefore we are planning to change the broker to reject such frames. So this should really be fixed.\n\nNB: the negotiated frame_max limits the _total_ frame size, including header and end marker, which add up to 8 octets in total. Hence body fragmentation should occur in chunks of frame_max-8.\n. AFAICT this is meant to have been fixed by issue #105. So can this be closed?\n. AFAICT this is meant to have been fixed by issue #105. So can this be closed?\n. AFAICT this is meant to have been fixed by issue #105, which got merged a month ago. So can this be closed?\n. AFAICT this is meant to have been fixed by issue #105. So can this be closed?\n. As squaremo points out above, the RabbitMQ broker admits oversize frames. But that is a DoS vector and therefore we are planning to change the broker to reject such frames. So this should really be fixed.\n\nNB: the negotiated frame_max limits the _total_ frame size, including header and end marker, which add up to 8 octets in total. Hence body fragmentation should occur in chunks of frame_max-8.\n. AFAICT this is meant to have been fixed by issue #105. So can this be closed?\n. AFAICT this is meant to have been fixed by issue #105. So can this be closed?\n. AFAICT this is meant to have been fixed by issue #105, which got merged a month ago. So can this be closed?\n. ",
    "jameskeane": "I believe you are running into the same problem as I was, the problem is to do with node-amqp not properly closing channels on error as in #136.\n\nI have a work flow that was very 404 heavy, and would accumulate tens of thousands of channels every few hours, eating memory and destroying our servers.  After implementing the fix in #137, we have seen no issues.\n\nGood luck :)\n. fixes #136 #85\n. @jondot this patch only addresses channels that stay open after an error.  If you are not erroring on your channels it may be a case of unclean shutdown.\n\nYou may need to call `channel.close` explicitly or pass in the new `closeChannelOnUnsubscribe` option to `connection.queue`.\n. Not sure why this hasn't been merged yet.\n\nHere is the conversation I had with the RabbitMQ maintainer about proper usage, in which he states this is a bug: http://dev.rabbitmq.com/irclog/index.php?date=2012-10-11\n. Are you  looking for something like this?  I'm not sure I completely understand, but you can implement something like this yourself.\n\n```\nqueue.subscribe(...).addCallback(function(ok) { \n    mq.emit('consume', queue, ok.consumerTag);\n});\n\n// then use it\nmq.on('consume', function(queue, ctag) {\n});\n```\n. addCallback is documented here: https://github.com/postwait/node-amqp#queueunsubscribeconsumertag\n\nI am not sure I follow, how is this not what you want?  The code I have posted is working code.\n. Upon further inspection, I think I understand what you are saying in that there is not a perfect mapping between consume messages going out and consumeOk's coming in. \n\nI don't think that use case warrants so much added complexity, in that the simplest way to handle this is to call connection.queue then queue.subscribe, for every 'parallel' subscription you want to achieve, although I'm not sure why you would want to do this. \n\nWith that method every basicConsume message will be sent on it's own channel.  Every 'queue' object gets it's own channel, there is no 'control' channel.\n. I believe you are running into the same problem as I was, the problem is to do with node-amqp not properly closing channels on error as in #136.\n\nI have a work flow that was very 404 heavy, and would accumulate tens of thousands of channels every few hours, eating memory and destroying our servers.  After implementing the fix in #137, we have seen no issues.\n\nGood luck :)\n. fixes #136 #85\n. @jondot this patch only addresses channels that stay open after an error.  If you are not erroring on your channels it may be a case of unclean shutdown.\n\nYou may need to call `channel.close` explicitly or pass in the new `closeChannelOnUnsubscribe` option to `connection.queue`.\n. Not sure why this hasn't been merged yet.\n\nHere is the conversation I had with the RabbitMQ maintainer about proper usage, in which he states this is a bug: http://dev.rabbitmq.com/irclog/index.php?date=2012-10-11\n. Are you  looking for something like this?  I'm not sure I completely understand, but you can implement something like this yourself.\n\n```\nqueue.subscribe(...).addCallback(function(ok) { \n    mq.emit('consume', queue, ok.consumerTag);\n});\n\n// then use it\nmq.on('consume', function(queue, ctag) {\n});\n```\n. addCallback is documented here: https://github.com/postwait/node-amqp#queueunsubscribeconsumertag\n\nI am not sure I follow, how is this not what you want?  The code I have posted is working code.\n. Upon further inspection, I think I understand what you are saying in that there is not a perfect mapping between consume messages going out and consumeOk's coming in. \n\nI don't think that use case warrants so much added complexity, in that the simplest way to handle this is to call connection.queue then queue.subscribe, for every 'parallel' subscription you want to achieve, although I'm not sure why you would want to do this. \n\nWith that method every basicConsume message will be sent on it's own channel.  Every 'queue' object gets it's own channel, there is no 'control' channel.\n. ",
    "axelson": "I know this is an old issue but it's still open so I'm going to reply.\n\nI just dealt with this in my code. There are a couple options. If you're correctly unsubscribing from the queue you can set `closeChannelOnUnsubscribe` to true (defaults to false).\n\ncloseChannelOnUnsubscribe : a boolean when true the channel will close on unsubscribe, default false.\n\nOr you can call close on the channel instead of unsubscribe (but beware if you have multiple consumers for the queue). There's probably a way to close a channel that you unsubscribed to but I haven't spent the time to figure it out.\n. I'm no longer using this project so I won't be able to look into fixing it. But thanks for the workaround!\n. I know this is an old issue but it's still open so I'm going to reply.\n\nI just dealt with this in my code. There are a couple options. If you're correctly unsubscribing from the queue you can set `closeChannelOnUnsubscribe` to true (defaults to false).\n\ncloseChannelOnUnsubscribe : a boolean when true the channel will close on unsubscribe, default false.\n\nOr you can call close on the channel instead of unsubscribe (but beware if you have multiple consumers for the queue). There's probably a way to close a channel that you unsubscribed to but I haven't spent the time to figure it out.\n. I'm no longer using this project so I won't be able to look into fixing it. But thanks for the workaround!\n. ",
    "seanhess": "+1 this is happening to me too\n. +1 this is happening to me too\n. ",
    "cmoesel": "I'd like to connect over SSL as well.  Has any progress been made on merging this into the latest codebase?\n. Haven't seen this again for a long time.  Closing it.\n. @rschiavi: If you are writing your own re-connection logic anyway, you might want to have a look at the new [amqp.node](https://github.com/squaremo/amqp.node) library.  It seems to be getting a bit more TLC from its maintainers than this one has been getting lately.\n\nUpdate: Actually, I see now that amqp.node APIs are not yet considered stable, so you might not consider that library safe for production either...  Oh well.\n. Closing since #285 was merged a while ago.\n. I've encountered the same problem.  I recently upgraded from 0.1.6 to the HEAD from git, and now my services don't properly reconnect or failover anymore.  I'll see if 0.1.7 works and add another comment (so we know how recent the regression is).\n. I've tested with 0.1.7 and confirmed that reconnect still works there, so this is a regression since 0.1.7 was published.\n. I found the issue.  According to the AMQP spec, the client should send the [connection close](http://www.rabbitmq.com/amqp-0-9-1-reference.html#connection.close) method to the server whenever closing a connection.  The amqp-node library just closes the socket (without sending any notice to the server).\n\nI have a patch ready, but there is one thing I would like some feedback about.  According to AMQP spec, the server responds with a [close-ok](http://www.rabbitmq.com/amqp-0-9-1-reference.html#connection.close-ok).  This \"tells the recipient that it is safe to release resources for the connection and close the socket.\"  So... should I wait for the \"close-ok\" before closing the socket?  Should I put in a fallback in case we never receive the \"close-ok\" (maybe a timeout of some sort)?\n. @crzidea: My patch does not address the bug you just described.  In my case the connection did end-- it just didn't end cleanly.  I don't think my patch will fix the issue you describe-- that sounds like a different issue.\n. I just discovered that a few tests were failing with this fix applied.  This might be why it has not been merged yet.  I've just update the pull request with some minor fixes and now all tests pass.  Hopefully this improves the chances of being merged!\n. Closing since #248 was merged a while ago.\n. I just discovered an issue that caused some tests to fail and I fixed it.  All tests (including the new test for this feature) are now PASSING.  Please merge or provide feedback to me if you need something else.\n. This feature would be fulfilled by supporting consumer cancel notifications.  You can see my feature request for that here: https://github.com/postwait/node-amqp/issues/229\n\nI actually implemented a fix for this on an older version of node-amqp, but the codebase has changed so much since then that it wouldn't be an easy patch (which is why I did not submit one).  If I have a chance to port it to the new code, I'll create a pull request (but not sure if/when that will be).\n. @jgato: I've submitted a pull request for this functionality.  Please see #285.\n. My pull request #248 also addresses the clean disconnect problem, but I chose to integrate it into connection.end, rather than create a new function.  I do like that your pull request allows previous functionality to remain exactly the same though.\n\nIn my testing I discovered that it _is_ important to ignore any received messages (except connectionClose and connectionCloseOk) after you've sent the connection close message, otherwise some errors can occur.  So, it's not just a matter of following the spec, but does actually affect real behavior and stability.  You can see my pull request for an example of how I chose to do this.\n\nAlso-- a word of advice-- the maintainers of this library are unlikely to merge your request if it does not contain any unit tests, so you can improve your chances by adding tests as well.  That said, they haven't accepted my pull requests either, so who am I to be giving advice? ;-)\n. I'd like to connect over SSL as well.  Has any progress been made on merging this into the latest codebase?\n. Haven't seen this again for a long time.  Closing it.\n. @rschiavi: If you are writing your own re-connection logic anyway, you might want to have a look at the new [amqp.node](https://github.com/squaremo/amqp.node) library.  It seems to be getting a bit more TLC from its maintainers than this one has been getting lately.\n\nUpdate: Actually, I see now that amqp.node APIs are not yet considered stable, so you might not consider that library safe for production either...  Oh well.\n. Closing since #285 was merged a while ago.\n. I've encountered the same problem.  I recently upgraded from 0.1.6 to the HEAD from git, and now my services don't properly reconnect or failover anymore.  I'll see if 0.1.7 works and add another comment (so we know how recent the regression is).\n. I've tested with 0.1.7 and confirmed that reconnect still works there, so this is a regression since 0.1.7 was published.\n. I found the issue.  According to the AMQP spec, the client should send the [connection close](http://www.rabbitmq.com/amqp-0-9-1-reference.html#connection.close) method to the server whenever closing a connection.  The amqp-node library just closes the socket (without sending any notice to the server).\n\nI have a patch ready, but there is one thing I would like some feedback about.  According to AMQP spec, the server responds with a [close-ok](http://www.rabbitmq.com/amqp-0-9-1-reference.html#connection.close-ok).  This \"tells the recipient that it is safe to release resources for the connection and close the socket.\"  So... should I wait for the \"close-ok\" before closing the socket?  Should I put in a fallback in case we never receive the \"close-ok\" (maybe a timeout of some sort)?\n. @crzidea: My patch does not address the bug you just described.  In my case the connection did end-- it just didn't end cleanly.  I don't think my patch will fix the issue you describe-- that sounds like a different issue.\n. I just discovered that a few tests were failing with this fix applied.  This might be why it has not been merged yet.  I've just update the pull request with some minor fixes and now all tests pass.  Hopefully this improves the chances of being merged!\n. Closing since #248 was merged a while ago.\n. I just discovered an issue that caused some tests to fail and I fixed it.  All tests (including the new test for this feature) are now PASSING.  Please merge or provide feedback to me if you need something else.\n. This feature would be fulfilled by supporting consumer cancel notifications.  You can see my feature request for that here: https://github.com/postwait/node-amqp/issues/229\n\nI actually implemented a fix for this on an older version of node-amqp, but the codebase has changed so much since then that it wouldn't be an easy patch (which is why I did not submit one).  If I have a chance to port it to the new code, I'll create a pull request (but not sure if/when that will be).\n. @jgato: I've submitted a pull request for this functionality.  Please see #285.\n. My pull request #248 also addresses the clean disconnect problem, but I chose to integrate it into connection.end, rather than create a new function.  I do like that your pull request allows previous functionality to remain exactly the same though.\n\nIn my testing I discovered that it _is_ important to ignore any received messages (except connectionClose and connectionCloseOk) after you've sent the connection close message, otherwise some errors can occur.  So, it's not just a matter of following the spec, but does actually affect real behavior and stability.  You can see my pull request for an example of how I chose to do this.\n\nAlso-- a word of advice-- the maintainers of this library are unlikely to merge your request if it does not contain any unit tests, so you can improve your chances by adding tests as well.  That said, they haven't accepted my pull requests either, so who am I to be giving advice? ;-)\n. ",
    "namtzigla": "+1\n. +1\n. ",
    "fjakobs": "+1\n. +1\n. ",
    "unlucio": "+1\n. +1\n. ",
    "mcollina": ":+1: \n. You should not inherit from net.Stream, instead you should refactor to incapsulate the connection.\n. Unfortunately not. But I worked on similar issues in other protocols/libraries.\n. I do not know what the problem are, but I was able to make it going on [Ascoltatori](https://github.com/mcollina/ascoltatori), which is fully tested on node v0.10.\n. As I see, this library is in a kind of abandoned-unmaintained state.\nMoreover, AMQP 1.0.0 is also out.\n\nIt also need a clear rewrite of most of its parts to support TLS.\n. :+1: \n. You should not inherit from net.Stream, instead you should refactor to incapsulate the connection.\n. Unfortunately not. But I worked on similar issues in other protocols/libraries.\n. I do not know what the problem are, but I was able to make it going on [Ascoltatori](https://github.com/mcollina/ascoltatori), which is fully tested on node v0.10.\n. As I see, this library is in a kind of abandoned-unmaintained state.\nMoreover, AMQP 1.0.0 is also out.\n\nIt also need a clear rewrite of most of its parts to support TLS.\n. ",
    "vinnitu": "+1\n\nI try to modify code by replace net. to tls., but because used util.inherite(Connection, net.Stream) - we have error inside util if try inherite from tls.CryptoStream (or tls.CleartextStream)\n\nso... I need offical support ssl\\tls for node-amqp \n. maybe you have worked implementation?\n. +1\n. +1\n\nI try to modify code by replace net. to tls., but because used util.inherite(Connection, net.Stream) - we have error inside util if try inherite from tls.CryptoStream (or tls.CleartextStream)\n\nso... I need offical support ssl\\tls for node-amqp \n. maybe you have worked implementation?\n. +1\n. ",
    "israelshirk": "Maybe I'll be more descriptive; I'm using Hubot+AMQP to distribute server configurations in a very dynamic cloud configuration; SSL would make it possible for me to skip bringing up and shutting down cross-site VPNs.  \n\nI'd definitely love you more than I already do for making this in the first place.  If that were even possible.\n\n(or if you could point me in the right direction I'd be glad to take a stab at it)\n. @bakkerthehacker You are my hero.\n. @bakkerthehacker You are my hero.\n. Apologies - PICNIC.\n\n![](http://dailypicksandflicks.com/wp-content/uploads/2011/01/wtf-kitty.jpg)\n. Maybe I'll be more descriptive; I'm using Hubot+AMQP to distribute server configurations in a very dynamic cloud configuration; SSL would make it possible for me to skip bringing up and shutting down cross-site VPNs.  \n\nI'd definitely love you more than I already do for making this in the first place.  If that were even possible.\n\n(or if you could point me in the right direction I'd be glad to take a stab at it)\n. @bakkerthehacker You are my hero.\n. @bakkerthehacker You are my hero.\n. Apologies - PICNIC.\n\n![](http://dailypicksandflicks.com/wp-content/uploads/2011/01/wtf-kitty.jpg)\n. ",
    "bakkerthehacker": "+1\n\nIn addition to an ssl connection, it would be very nice to use the EXTERNAL auth mechanism used for the plugin here: https://github.com/rabbitmq/rabbitmq-auth-mechanism-ssl\n\nIf no one else wants to start on this, I may look into it, using what esk525 has started with.\n. The only thing I could suggest at this point is to try everything on this page: http://www.rabbitmq.com/troubleshooting-ssl.html\n\nI would suggest starting with the section \"Validate client connections with stunnel\"\n. :3\n. This has been implemented in pull #207 \n. This issue is fixed by #217 \n. This issue will be fixed by my pull #217, if it is merged\n. are absolutely sure you are running the git-hub version of the code, rather than the version from npm?\n\nthe current git-hub code has no .addListener or .on function on line 1083, nor does it have a .once function on line 1084.\n\nthe current npm code does have .on at line 1083 and .once at line 1084\n\nto install the git-hub version of amqp using npm, run the command:\n`npm install git+https://github.com/postwait/node-amqp.git`\n. this is an error in your certifiactes, specifically your certifiate authority.  \nensure that your server and client are both using the same certificate authority and that all the certificates are signed throught that authority. \n\nyou can temporarily get around the issue, and check that the rest of your system works by setting rejectUnauthorized to false.  \n. Allow me to quote from the SSL documentation I wrote:\n\n\"The key, certificate, and certificate authority files must be in pem format. \"\n\nEnsure your certs are in that format.  \n\nAlso, this thread isn't really meant to be a help thread.  I would suggest posting on the SSL issue thread here https://github.com/postwait/node-amqp/issues/89 or making a post on a help forum such as Stack Overflow.\n. Any update on this?\n. I'm assuming that postwait or someone else will decide that the code is stable enough and that enough new features have been merged in, rev the code, and push to npm.  \n. i could look into it\n. https://github.com/postwait/node-amqp#connection-options-and-url\n. the queue emits an event for any amqp message it receives.  you could listen for the destroy event with this code:\n\n```\nqueue.on('queueDeleteOk', function(){});\n```\n. any update on this?\n. the version of node-amqp on npm is older than the version on git.  SSL support was recently added and should show up in npm once the npm version is updated\n\nto install the git-hub version of amqp using npm, run the command:\n`npm install git+https://github.com/postwait/node-amqp.git`\n. The following issues with node-amqp can be resolved by using bramqp:\n\n#282 \n#292 \n#291 \n#278 \n#287 \n#273 \n#285 \n#246 \n#254 \n\nThere are probably other issues that are fixed as well. \n. I may also write a library that has the same api as node-amqp but calls bramqp.  This would allow clients to use existing node-amqp code with bramqp.  \n. Shameless plug for my own amqp library: https://github.com/bakkerthehacker/bramqp\n\nI have thought about writing a higher level wrapper around bramqp that implements a similar api to node-amqp.  However I don't think this would be possible without going through the library and depricating a handful of the functions.  \n\nIn the meantime, the only higher level solutions seem to be https://github.com/squaremo/amqp.node and https://github.com/dropbox/amqp-coffee\nUnfortunatley maintaining amqp-node seems to be a lost cause at this point.  :(\n. +1\n\nIn addition to an ssl connection, it would be very nice to use the EXTERNAL auth mechanism used for the plugin here: https://github.com/rabbitmq/rabbitmq-auth-mechanism-ssl\n\nIf no one else wants to start on this, I may look into it, using what esk525 has started with.\n. The only thing I could suggest at this point is to try everything on this page: http://www.rabbitmq.com/troubleshooting-ssl.html\n\nI would suggest starting with the section \"Validate client connections with stunnel\"\n. :3\n. This has been implemented in pull #207 \n. This issue is fixed by #217 \n. This issue will be fixed by my pull #217, if it is merged\n. are absolutely sure you are running the git-hub version of the code, rather than the version from npm?\n\nthe current git-hub code has no .addListener or .on function on line 1083, nor does it have a .once function on line 1084.\n\nthe current npm code does have .on at line 1083 and .once at line 1084\n\nto install the git-hub version of amqp using npm, run the command:\n`npm install git+https://github.com/postwait/node-amqp.git`\n. this is an error in your certifiactes, specifically your certifiate authority.  \nensure that your server and client are both using the same certificate authority and that all the certificates are signed throught that authority. \n\nyou can temporarily get around the issue, and check that the rest of your system works by setting rejectUnauthorized to false.  \n. Allow me to quote from the SSL documentation I wrote:\n\n\"The key, certificate, and certificate authority files must be in pem format. \"\n\nEnsure your certs are in that format.  \n\nAlso, this thread isn't really meant to be a help thread.  I would suggest posting on the SSL issue thread here https://github.com/postwait/node-amqp/issues/89 or making a post on a help forum such as Stack Overflow.\n. Any update on this?\n. I'm assuming that postwait or someone else will decide that the code is stable enough and that enough new features have been merged in, rev the code, and push to npm.  \n. i could look into it\n. https://github.com/postwait/node-amqp#connection-options-and-url\n. the queue emits an event for any amqp message it receives.  you could listen for the destroy event with this code:\n\n```\nqueue.on('queueDeleteOk', function(){});\n```\n. any update on this?\n. the version of node-amqp on npm is older than the version on git.  SSL support was recently added and should show up in npm once the npm version is updated\n\nto install the git-hub version of amqp using npm, run the command:\n`npm install git+https://github.com/postwait/node-amqp.git`\n. The following issues with node-amqp can be resolved by using bramqp:\n\n#282 \n#292 \n#291 \n#278 \n#287 \n#273 \n#285 \n#246 \n#254 \n\nThere are probably other issues that are fixed as well. \n. I may also write a library that has the same api as node-amqp but calls bramqp.  This would allow clients to use existing node-amqp code with bramqp.  \n. Shameless plug for my own amqp library: https://github.com/bakkerthehacker/bramqp\n\nI have thought about writing a higher level wrapper around bramqp that implements a similar api to node-amqp.  However I don't think this would be possible without going through the library and depricating a handful of the functions.  \n\nIn the meantime, the only higher level solutions seem to be https://github.com/squaremo/amqp.node and https://github.com/dropbox/amqp-coffee\nUnfortunatley maintaining amqp-node seems to be a lost cause at this point.  :(\n. ",
    "atdc98": "Hi all, I'm having some issues with connecting to a RabbitMQ server via SSL.  At first, since I don't control the rabbit server, I was attempting to not use any certs.  After not being able to connect, I contacted the admin and requested any log entries he might have.  I was returned the following:\n\n=INFO REPORT==== 1-Jul-2013::11:17:52 ===\naccepting AMQP connection <0.25461.2> (192.168.2.241:48428 -> 192.168.2.210:5671)\n\n=ERROR REPORT==== 1-Jul-2013::11:17:53 ===\nerror on AMQP connection <0.25445.2>: {ssl_upgrade_error,\"record overflow\"} (unknown POSIX error)\n\nTo help troubleshoot, the admin turned on the non-SSL port, and I was able to connect no problem.  I have wrote a python script to see if I could connect via SSL that way, and it worked as well.  So, I'm certain that the Rabbit server is configured correctly and prepared to accept an SSL connection.\n\nAt this point, I requested the SSL certs, and got a .crt file, which is in .pem format.  Below you can see the connection string I'm using.  All connection variables are passed into the method via an array.  \n\nconn =  AMQP.createConnection(\n                        {\n                            host:       conn_info['host'],\n                            port:       conn_info['host_port'],\n                            login:      conn_info['user'],\n                            password:   conn_info['pass'],\n                            vhost:      conn_info['virt_host'],\n                            ssl:        { \n                                          enabled: conn_info['ssl_opts']['enabled'],\n                                          caFile : '../../certs/ca.crt',\n                                          rejectUnauthorized: conn_info['ssl_opts']['rej_unauth']\n                                        }\n                        },\n                        {\n                            defaultExchangeName: conn_info['default_exch']\n                        }\n                    );\n\nSo, I'm positive at this point, the fault lies with me.  I'd really appreciate any help I can get!\n. bakker - thank you so much for this!  SSL support (or lack thereof) has stopped me in my tracks on my current project.  Rather than wait for this to get pulled into master, I replaced the amqp.js file in my own install.  However, when attempting to use it, I get the following error:\n\nevents.js:71\n        throw arguments[1]; // Unhandled 'error' event\n                       ^\nError: SELF_SIGNED_CERT_IN_CHAIN\n    at SecurePair.exports.connect.cleartext._controlReleased (tls.js:1286:32)\n    at SecurePair.EventEmitter.emit (events.js:93:17)\n    at SecurePair.maybeInitFinished (tls.js:930:10)\n    at CleartextStream.CryptoStream._push (tls.js:509:17)\n    at SecurePair.cycle (tls.js:898:20)\n    at EncryptedStream.CryptoStream.write (tls.js:285:13)\n    at Socket.ondata (stream.js:38:26)\n    at Socket.EventEmitter.emit (events.js:96:17)\n    at TCP.onread (net.js:397:14)\n=> Exited with code: 1\n\nI was hoping you could perhaps give me a hand?\n\nEDIT:  After looking more closely at the README, I may see the problem.  Is it necessary to provide the certs and keys?\n. Thank you so much!\n. Bakker - if you don't mind, I need a little more help.  I'm a little hand-tied here, as I am not in control of the RabbitMQ server to which I am connecting.  I've been told by the admin of the server in question that SSL certs are not being required on his end.  I'm using the rejectUnauthorized: false flag, but I still can't connect to the server and am still receiving the following:\n\n=ERROR REPORT==== 1-Jul-2013::11:17:51 ===\nerror on AMQP connection <0.25437.2>: {ssl_upgrade_error,\"record overflow\"} (unknown POSIX error)\n\nIs there anything you can think of that I can try?\n. Quick update:  I am able to connect via SSL to this RabbitMQ server using a Python script I wrote, from my local machine, and without supplying any certificate information.  Any ideas why I cannot connect using Meteor?  I'll supply any code snippets you'd like to see...\n. Another quick update:  I contacted the admin of the server, and explained my problem.  He supplied me with two .crt files and the following instructions when I requested a key file:\n\n\"So you should only need the ca.crt.  In our setup, we're not requiring client certificates so there's no need for a key file.\n\nThe server.crt I sent should be extra, it's only if the client is expecting a specific certificate.  The ca.crt should be enough.\"\n\nHowever, even when supplying these files in the certificate file and ca file arguments for amqp ssl, I still cannot connect to the server.  I tried each in the certFile and caFile argument, and each in only the caFile and only the certFile arguments.  I'm at a complete loss, would really appreciate any help I can get.\n. Hi all, I'm having some issues with connecting to a RabbitMQ server via SSL.  At first, since I don't control the rabbit server, I was attempting to not use any certs.  After not being able to connect, I contacted the admin and requested any log entries he might have.  I was returned the following:\n\n=INFO REPORT==== 1-Jul-2013::11:17:52 ===\naccepting AMQP connection <0.25461.2> (192.168.2.241:48428 -> 192.168.2.210:5671)\n\n=ERROR REPORT==== 1-Jul-2013::11:17:53 ===\nerror on AMQP connection <0.25445.2>: {ssl_upgrade_error,\"record overflow\"} (unknown POSIX error)\n\nTo help troubleshoot, the admin turned on the non-SSL port, and I was able to connect no problem.  I have wrote a python script to see if I could connect via SSL that way, and it worked as well.  So, I'm certain that the Rabbit server is configured correctly and prepared to accept an SSL connection.\n\nAt this point, I requested the SSL certs, and got a .crt file, which is in .pem format.  Below you can see the connection string I'm using.  All connection variables are passed into the method via an array.  \n\nconn =  AMQP.createConnection(\n                        {\n                            host:       conn_info['host'],\n                            port:       conn_info['host_port'],\n                            login:      conn_info['user'],\n                            password:   conn_info['pass'],\n                            vhost:      conn_info['virt_host'],\n                            ssl:        { \n                                          enabled: conn_info['ssl_opts']['enabled'],\n                                          caFile : '../../certs/ca.crt',\n                                          rejectUnauthorized: conn_info['ssl_opts']['rej_unauth']\n                                        }\n                        },\n                        {\n                            defaultExchangeName: conn_info['default_exch']\n                        }\n                    );\n\nSo, I'm positive at this point, the fault lies with me.  I'd really appreciate any help I can get!\n. bakker - thank you so much for this!  SSL support (or lack thereof) has stopped me in my tracks on my current project.  Rather than wait for this to get pulled into master, I replaced the amqp.js file in my own install.  However, when attempting to use it, I get the following error:\n\nevents.js:71\n        throw arguments[1]; // Unhandled 'error' event\n                       ^\nError: SELF_SIGNED_CERT_IN_CHAIN\n    at SecurePair.exports.connect.cleartext._controlReleased (tls.js:1286:32)\n    at SecurePair.EventEmitter.emit (events.js:93:17)\n    at SecurePair.maybeInitFinished (tls.js:930:10)\n    at CleartextStream.CryptoStream._push (tls.js:509:17)\n    at SecurePair.cycle (tls.js:898:20)\n    at EncryptedStream.CryptoStream.write (tls.js:285:13)\n    at Socket.ondata (stream.js:38:26)\n    at Socket.EventEmitter.emit (events.js:96:17)\n    at TCP.onread (net.js:397:14)\n=> Exited with code: 1\n\nI was hoping you could perhaps give me a hand?\n\nEDIT:  After looking more closely at the README, I may see the problem.  Is it necessary to provide the certs and keys?\n. Thank you so much!\n. Bakker - if you don't mind, I need a little more help.  I'm a little hand-tied here, as I am not in control of the RabbitMQ server to which I am connecting.  I've been told by the admin of the server in question that SSL certs are not being required on his end.  I'm using the rejectUnauthorized: false flag, but I still can't connect to the server and am still receiving the following:\n\n=ERROR REPORT==== 1-Jul-2013::11:17:51 ===\nerror on AMQP connection <0.25437.2>: {ssl_upgrade_error,\"record overflow\"} (unknown POSIX error)\n\nIs there anything you can think of that I can try?\n. Quick update:  I am able to connect via SSL to this RabbitMQ server using a Python script I wrote, from my local machine, and without supplying any certificate information.  Any ideas why I cannot connect using Meteor?  I'll supply any code snippets you'd like to see...\n. Another quick update:  I contacted the admin of the server, and explained my problem.  He supplied me with two .crt files and the following instructions when I requested a key file:\n\n\"So you should only need the ca.crt.  In our setup, we're not requiring client certificates so there's no need for a key file.\n\nThe server.crt I sent should be extra, it's only if the client is expecting a specific certificate.  The ca.crt should be enough.\"\n\nHowever, even when supplying these files in the certificate file and ca file arguments for amqp ssl, I still cannot connect to the server.  I tried each in the certFile and caFile argument, and each in only the caFile and only the certFile arguments.  I'm at a complete loss, would really appreciate any help I can get.\n. ",
    "mattbornski": "Bump.  This reconnection logic has been working nicely in production in our stack for several months now.  I'd like to have this merged in to the driver so others can use it, and also so that when the driver starts to diverge I don't need to maintain a separate version.\n. I haven't heard anything from the maintainers.\n. I made several attempts at some logic to try to filter out user-initiated \"end\" calls from internal \"end\" calls, and could not arrive at any piece of code that seemed useful and reliable.  I believe I just reconfigure the client with \"reconnect\" set false, then call end().\n. Sorry, I am away from a computer for a few weeks.\nOn Aug 15, 2012 5:35 AM, \"Theo Schlossnagle\" notifications@github.com\nwrote:\n\n> Can you rebase this off current master and give me a single commit with\n> the changeset?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/pull/90#issuecomment-7754678.\n. Hey guys, just a courtesy note: I'm pretty sure that this is never going to\nbe the top of my priority stack ever again.  If you'd like it merged I\nsuggest you adopt it and work with Theo to get it merged in.\n\nOn Thu, Sep 6, 2012 at 7:13 PM, Augusto Becciu notifications@github.comwrote:\n\n> I'd love to see this merged.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/pull/90#issuecomment-8353958.\n. bump.  I run into this issue fairly often.\n. Hey, after closer investigation, my issue was actually regarding targetStart, not sourceEnd.\n\nFurthermore, I've been able to identify the root cause:\n\n``` javascript\n...\nexchange.publish('foo.bar', JSON.stringify({'foo':'foo', 'bar': <some buffer>}));\n```\n\nI was able to publish buffers to the exchange; this is developer error, but when the consumer receives the buffer representation, all hell breaks loose in the parser.\n. Bump.  This reconnection logic has been working nicely in production in our stack for several months now.  I'd like to have this merged in to the driver so others can use it, and also so that when the driver starts to diverge I don't need to maintain a separate version.\n. I haven't heard anything from the maintainers.\n. I made several attempts at some logic to try to filter out user-initiated \"end\" calls from internal \"end\" calls, and could not arrive at any piece of code that seemed useful and reliable.  I believe I just reconfigure the client with \"reconnect\" set false, then call end().\n. Sorry, I am away from a computer for a few weeks.\nOn Aug 15, 2012 5:35 AM, \"Theo Schlossnagle\" notifications@github.com\nwrote:\n\n> Can you rebase this off current master and give me a single commit with\n> the changeset?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/pull/90#issuecomment-7754678.\n. Hey guys, just a courtesy note: I'm pretty sure that this is never going to\nbe the top of my priority stack ever again.  If you'd like it merged I\nsuggest you adopt it and work with Theo to get it merged in.\n\nOn Thu, Sep 6, 2012 at 7:13 PM, Augusto Becciu notifications@github.comwrote:\n\n> I'd love to see this merged.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/pull/90#issuecomment-8353958.\n. bump.  I run into this issue fairly often.\n. Hey, after closer investigation, my issue was actually regarding targetStart, not sourceEnd.\n\nFurthermore, I've been able to identify the root cause:\n\n``` javascript\n...\nexchange.publish('foo.bar', JSON.stringify({'foo':'foo', 'bar': <some buffer>}));\n```\n\nI was able to publish buffers to the exchange; this is developer error, but when the consumer receives the buffer representation, all hell breaks loose in the parser.\n. ",
    "rapimo": "I have this running in production, works well! Would be great to see this in the main branch.\n. assuming you have a local default installation of rabbitmq you should try:\n\n``` js\nvar conParam = { \n  host: 'localhost', \n  port: 5672,  \n  login: 'guest',   \n  password: 'guest',    \n  vhost: '/'  \n}\nvar connection = amqp.createConnection(conParam, { reconnect: true });\n```\n\nHowever the error message you posted sugests that the server closed the connection.\nDo you have any special setup? \n. so if you stop the server gracefully it perfectly makes sense to get a \n\"broker forced connection closure with reason 'shutdown'\" message\nThis is not a bug it's a feature \n. typically unacknowledged messages will be requeued on connection loss.\n. I have this running in production, works well! Would be great to see this in the main branch.\n. assuming you have a local default installation of rabbitmq you should try:\n\n``` js\nvar conParam = { \n  host: 'localhost', \n  port: 5672,  \n  login: 'guest',   \n  password: 'guest',    \n  vhost: '/'  \n}\nvar connection = amqp.createConnection(conParam, { reconnect: true });\n```\n\nHowever the error message you posted sugests that the server closed the connection.\nDo you have any special setup? \n. so if you stop the server gracefully it perfectly makes sense to get a \n\"broker forced connection closure with reason 'shutdown'\" message\nThis is not a bug it's a feature \n. typically unacknowledged messages will be requeued on connection loss.\n. ",
    "abecciu": "I'd love to see this merged.\n. I'd love to see this merged.\n. ",
    "skarsol": "I'm getting 0.0.2 from npm.\n. Okay, so the commit from a couple days ago that added 0.8 hasn't made it to npm yet? Will see about installing it manually then. Thanks.\n. I'm getting this exact same error as sk2 with nodev0.8.0\n. This is explained in Issue 91 (https://github.com/postwait/node-amqp/issues/91). The newest version on npm doesn't have 0.8 as a valid target so if you're running 0.8 it defaults to the catchall 0.2 version, which bombs out as above. I downloaded the tgz for 0.1.3, added 0.8 to the package.json, and did an npm install from that and it's working okay so far.\n. Download the tgz and use npm with the option to install from tgz to install it.\n. I'm getting 0.0.2 from npm.\n. Okay, so the commit from a couple days ago that added 0.8 hasn't made it to npm yet? Will see about installing it manually then. Thanks.\n. I'm getting this exact same error as sk2 with nodev0.8.0\n. This is explained in Issue 91 (https://github.com/postwait/node-amqp/issues/91). The newest version on npm doesn't have 0.8 as a valid target so if you're running 0.8 it defaults to the catchall 0.2 version, which bombs out as above. I downloaded the tgz for 0.1.3, added 0.8 to the package.json, and did an npm install from that and it's working okay so far.\n. Download the tgz and use npm with the option to install from tgz to install it.\n. ",
    "vvo": "I too had the problem and it can be easily reproduced : send big data buffers into amqp without stringifying them.\n\n``` javascript\nexchange.publish('foo.bar', new Buffer(0.5*1024*1024));\n```\n\nThis will cause a copy error meaning something is wrong with the `data` event on the `msg` object.\n\nDoes that means we should not send new Buffer('helllo');? The lib should be able to handle this right?\n. I guess this is related to : https://github.com/squaremo/rabbit.js/issues/24 so not just Buffers() but all messages > 100kb\n. I too had the problem and it can be easily reproduced : send big data buffers into amqp without stringifying them.\n\n``` javascript\nexchange.publish('foo.bar', new Buffer(0.5*1024*1024));\n```\n\nThis will cause a copy error meaning something is wrong with the `data` event on the `msg` object.\n\nDoes that means we should not send new Buffer('helllo');? The lib should be able to handle this right?\n. I guess this is related to : https://github.com/squaremo/rabbit.js/issues/24 so not just Buffers() but all messages > 100kb\n. ",
    "Aldaviva": "From the RabbitMQ web interface, you can add a Property with name = `content_type` and value = `application/json`.\n\nI found this in the [Queue.subscribe source](https://github.com/postwait/node-amqp/blob/33d53fa9476123ac3a71abf809ae14221cc709cb/amqp.js#L1681).\n. Where is the documentation for node-amqp's heartbeat option?\n. From the RabbitMQ web interface, you can add a Property with name = `content_type` and value = `application/json`.\n\nI found this in the [Queue.subscribe source](https://github.com/postwait/node-amqp/blob/33d53fa9476123ac3a71abf809ae14221cc709cb/amqp.js#L1681).\n. Where is the documentation for node-amqp's heartbeat option?\n. ",
    "davidfooks": "Ok I had a look in master and it looks like you have something along these lines (added an optional callback to bind). How long will it be until the next release (or how stable is master)?\n. Is this a restriction of AMQP or just this library implementation?\n. Ok I had a look in master and it looks like you have something along these lines (added an optional callback to bind). How long will it be until the next release (or how stable is master)?\n. Is this a restriction of AMQP or just this library implementation?\n. ",
    "SLaks": "It looks like the added code doesn't actually solve the problem.  \n\nThere is only a single `_bindCallback` variable, so the second `bind()` will overwrite the first `bind()`'s callback.\n. I'm not very familiar with the AMQP protocol, but it doesn't look like queue.bind-ok has any parameters.\n. It looks like the added code doesn't actually solve the problem.  \n\nThere is only a single `_bindCallback` variable, so the second `bind()` will overwrite the first `bind()`'s callback.\n. I'm not very familiar with the AMQP protocol, but it doesn't look like queue.bind-ok has any parameters.\n. ",
    "coreyjewett": "Looks like it would be possible to trap the \"close\" event firing when \"ready\" has never happened. This is working for me. Don't know where/how to push this concept up into the library:\n\n```\nvar is_ready = false;\nconn.on('ready', function() { is_ready = true; });\nconn.on('close', function () { \n  if (!is_ready) {\n    conn.emit('error', new Error(\"Connection closed prematurely; bad credentials?\"));\n  }\n});\n```\n. Same silent closure happens if vhost is not declared or is not valid. Code in my prior comment catches that also.\n. Looks like it would be possible to trap the \"close\" event firing when \"ready\" has never happened. This is working for me. Don't know where/how to push this concept up into the library:\n\n```\nvar is_ready = false;\nconn.on('ready', function() { is_ready = true; });\nconn.on('close', function () { \n  if (!is_ready) {\n    conn.emit('error', new Error(\"Connection closed prematurely; bad credentials?\"));\n  }\n});\n```\n. Same silent closure happens if vhost is not declared or is not valid. Code in my prior comment catches that also.\n. ",
    "yulrizka": "I belive so,\n\nthis is part of my code, just give an empty name, i saw a random name on the rabbitmq management tools\n\n``` javascript\nvar queueConf = {exclusive: true};            \nself.q = self.connection.queue('', queueConf);\n```\n. I belive so,\n\nthis is part of my code, just give an empty name, i saw a random name on the rabbitmq management tools\n\n``` javascript\nvar queueConf = {exclusive: true};            \nself.q = self.connection.queue('', queueConf);\n```\n. ",
    "agad": "IGNORE BELOW - this was caused by NPM pushing out an old version (mentioned in another issue).  Once I manually updated, problem went away.\n\nI have a slightly similar issue.  I can't bind to q because q returns 0.  Nothing else.  If I setup my code as:\n\n``` javascript\nself.queue = self.connection.queue(self.opts.queuename, { durable:true, autoDelete: false }, function(q)\n{\n      // q = 0 so can't bind to it.\n     self.queue.bind(\"*\");  // works fine without a problem...???  why is the value in the callback = to 0?\n}\n```\n. IGNORE BELOW - this was caused by NPM pushing out an old version (mentioned in another issue).  Once I manually updated, problem went away.\n\nI have a slightly similar issue.  I can't bind to q because q returns 0.  Nothing else.  If I setup my code as:\n\n``` javascript\nself.queue = self.connection.queue(self.opts.queuename, { durable:true, autoDelete: false }, function(q)\n{\n      // q = 0 so can't bind to it.\n     self.queue.bind(\"*\");  // works fine without a problem...???  why is the value in the callback = to 0?\n}\n```\n. ",
    "brendte": "+1 on this. Works like a charm for the \"Unknown field value type 65\" error I was getting when using a queue with a TTL in combination with a deadletter exchange to implement a delayed queue setup.\n. +1 on this. Works like a charm for the \"Unknown field value type 65\" error I was getting when using a queue with a TTL in combination with a deadletter exchange to implement a delayed queue setup.\n. ",
    "mjc-": "No, it does not work well. It does not work at all currently.\n\namqp.createConnection dies.with this error:\n\nbuffer.js:194\n      this.parent = new SlowBuffer(this.length);\n                    ^\nRangeError: length > kMaxLength\n    at new Buffer (buffer.js:194:21)\n    at AMQPParser.header [as parse](node_modules/amqp/amqp.js:161:21)\n    at AMQPParser.execute (node_modules/amqp/amqp.js:236:21)\n    at Connection.<anonymous> (node_modules/amqp/amqp.js:935:14)\n    at Connection.EventEmitter.emit (events.js:95:17)\n    at Connection.<anonymous> (_stream_readable.js:710:14)\n    at Connection.EventEmitter.emit (events.js:92:17)\n    at emitReadable_ (_stream_readable.js:382:10)\n    at emitReadable (_stream_readable.js:378:5)\n    at readableAddChunk (_stream_readable.js:143:7)\n. No, it does not work well. It does not work at all currently.\n\namqp.createConnection dies.with this error:\n\nbuffer.js:194\n      this.parent = new SlowBuffer(this.length);\n                    ^\nRangeError: length > kMaxLength\n    at new Buffer (buffer.js:194:21)\n    at AMQPParser.header [as parse](node_modules/amqp/amqp.js:161:21)\n    at AMQPParser.execute (node_modules/amqp/amqp.js:236:21)\n    at Connection.<anonymous> (node_modules/amqp/amqp.js:935:14)\n    at Connection.EventEmitter.emit (events.js:95:17)\n    at Connection.<anonymous> (_stream_readable.js:710:14)\n    at Connection.EventEmitter.emit (events.js:92:17)\n    at emitReadable_ (_stream_readable.js:382:10)\n    at emitReadable (_stream_readable.js:378:5)\n    at readableAddChunk (_stream_readable.js:143:7)\n. ",
    "anthonyu": "Multiple connections would be a nice feature.\n. Multiple connections would be a nice feature.\n. ",
    "chriswiggins": "This does work if you pass in an array of hostnames for the addresses. You can also use hostPreference inside your config as well to specify preference for a specific host\n. Unfortunately as far as I'm aware you can't. We'd all be grateful for a pull request though! :-)\n\nSent from my iPhone\n\nOn 11/07/2015, at 12:33 am, PreethiBabu87 <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nHi\n\nAm using amqplib/callback_api.\nhow can i list all the rabbit nodes in the connection url.\n\n## \n\nReply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/107#issuecomment-120399671.\n. @PreethiBabu87 its this package. Just don't use URLs to connect, do what is suggested at the top of the README:\n\n```\nvar connection = amqp.createConnection({ host: 'dev.rabbitmq.com' });\n\n```\n\nHowever for multiple hosts, do:\n\n```\nvar connection = amqp.createConnection({ hostArray:\n[ 'dev.rabbitmq.com', 'host2', 'host3'] });\n\n```\n. What happens if someone isn't passing in a URL but rather an options object? Your code will break existing functionality\n. Good point. I will close this as an issue. Thanks for your help!\n\nI didn't realise that heartbeat was not set by default. I can now see it working. Awesome :+1: \n. I'm in the same position. Unfortunately I don't think this library is being actively maintained so we might need to find a solution ourselves\n. Yeah sure sorry @postwait - we have a clustered RabbitMQ setup (3 hosts in HA) and HAProxy sitting in front of it. I've been testing by adding an iptables rule on the HAProxy server, dropping packets from HAProxy to a specific cluster member that the client is connected to. After 2 \\* heartbeat, the client would sometimes reconnect and sometimes not. By adding this option, (and setting it to true) the error is always thrown and the client reconnects to HAProxy, which in turn directs the TCP request at a host that it can reach.\n\nDoes that make sense? I wasn't sure how else to create a test scenario for it\n. This does work if you pass in an array of hostnames for the addresses. You can also use hostPreference inside your config as well to specify preference for a specific host\n. Unfortunately as far as I'm aware you can't. We'd all be grateful for a pull request though! :-)\n\nSent from my iPhone\n\nOn 11/07/2015, at 12:33 am, PreethiBabu87 <notifications@github.com<mailto:notifications@github.com>> wrote:\n\nHi\n\nAm using amqplib/callback_api.\nhow can i list all the rabbit nodes in the connection url.\n\n## \n\nReply to this email directly or view it on GitHubhttps://github.com/postwait/node-amqp/issues/107#issuecomment-120399671.\n. @PreethiBabu87 its this package. Just don't use URLs to connect, do what is suggested at the top of the README:\n\n```\nvar connection = amqp.createConnection({ host: 'dev.rabbitmq.com' });\n\n```\n\nHowever for multiple hosts, do:\n\n```\nvar connection = amqp.createConnection({ hostArray:\n[ 'dev.rabbitmq.com', 'host2', 'host3'] });\n\n```\n. What happens if someone isn't passing in a URL but rather an options object? Your code will break existing functionality\n. Good point. I will close this as an issue. Thanks for your help!\n\nI didn't realise that heartbeat was not set by default. I can now see it working. Awesome :+1: \n. I'm in the same position. Unfortunately I don't think this library is being actively maintained so we might need to find a solution ourselves\n. Yeah sure sorry @postwait - we have a clustered RabbitMQ setup (3 hosts in HA) and HAProxy sitting in front of it. I've been testing by adding an iptables rule on the HAProxy server, dropping packets from HAProxy to a specific cluster member that the client is connected to. After 2 \\* heartbeat, the client would sometimes reconnect and sometimes not. By adding this option, (and setting it to true) the error is always thrown and the client reconnects to HAProxy, which in turn directs the TCP request at a host that it can reach.\n\nDoes that make sense? I wasn't sure how else to create a test scenario for it\n. ",
    "momico": "It will be highly appreciated if an example of how to supply an array of hostnames, since I couldn't find an example or an explanation in the docs.\n. It will be highly appreciated if an example of how to supply an array of hostnames, since I couldn't find an example or an explanation in the docs.\n. ",
    "vertex": ":+1: \n. :thumbsup: any chance we can get this into the NPM module?\n. :+1: \n. :thumbsup: any chance we can get this into the NPM module?\n. ",
    "PreethiBabu87": "Hi \n\nAm using amqplib/callback_api.\nhow can i list all the rabbit nodes in the connection url.\n. So how will I be able to perform multiple connections using nodejs other than amqplib/callback_api?  Any other package can be used? \n. And I see your comment above stating that array of host names work.. What's the npm package that's required in order to get  it work\n. Hi \n\nAm using amqplib/callback_api.\nhow can i list all the rabbit nodes in the connection url.\n. So how will I be able to perform multiple connections using nodejs other than amqplib/callback_api?  Any other package can be used? \n. And I see your comment above stating that array of host names work.. What's the npm package that's required in order to get  it work\n. ",
    "xla": "Is it planned to merge this PR in the near future? What is missing to make the merge happen? Really looking forward to have heartbeat supported.\n. Is it planned to merge this PR in the near future? What is missing to make the merge happen? Really looking forward to have heartbeat supported.\n. ",
    "sk2": "Is this related to the following?\n\n```\nnode test.js \n\nsys.js:1\nthrow new Error(\n      ^\nError: The \"sys\" module is now called \"util\".\n    at sys.js:1:69\n    at NativeModule.compile (node.js:585:5)\n    at Function.require (node.js:553:18)\n    at Function._load (module.js:297:25)\n    at Module.require (module.js:362:17)\n    at require (module.js:378:17)\n    at Object.<anonymous> (/Users/sk2/node_modules/amqp/amqp.js:2:11)\n    at Module._compile (module.js:449:26)\n    at Object..js (module.js:467:10)\n    at Module.load (module.js:356:32)\n```\n. Is this related to the following?\n\n```\nnode test.js \n\nsys.js:1\nthrow new Error(\n      ^\nError: The \"sys\" module is now called \"util\".\n    at sys.js:1:69\n    at NativeModule.compile (node.js:585:5)\n    at Function.require (node.js:553:18)\n    at Function._load (module.js:297:25)\n    at Module.require (module.js:362:17)\n    at require (module.js:378:17)\n    at Object.<anonymous> (/Users/sk2/node_modules/amqp/amqp.js:2:11)\n    at Module._compile (module.js:449:26)\n    at Object..js (module.js:467:10)\n    at Module.load (module.js:356:32)\n```\n. ",
    "felipemachado-sambatech": "Actually, I just wanted to be able to do a \"npm install amqp\". I didn't verify if the master branch works with node 0.8.\n. New version has just been published on npm! 0.1.4! woo-hoo! :)\n. Actually, I just wanted to be able to do a \"npm install amqp\". I didn't verify if the master branch works with node 0.8.\n. New version has just been published on npm! 0.1.4! woo-hoo! :)\n. ",
    "ngoccuong291": "HI, I got the same error. @skarsol How exactly did you solve it? I \"git clone\" the node-amqp, get in the folder node-amqp, npm install but it didn't work\n. HI, I got the same error. @skarsol How exactly did you solve it? I \"git clone\" the node-amqp, get in the folder node-amqp, npm install but it didn't work\n. ",
    "adrianocola": "Please, update the npm registry to include support for node 0.8!\n. Please, update the npm registry to include support for node 0.8!\n. ",
    "adunkman": "I need to have publisher confirms to make this module useful for me. \n\nRelated issues: #116, #115, #114 and #41.\n\nI noticed that #41 contained code but that it was closed by the author without comment.\n\n@ahildoer is there a reason you closed your request? \n@postwait is there a reason that wasn't an acceptable pull request? \n\nI'm willing to write the code to implement publisher confirms, but I'd rather know all the information up front.\n. Looks like this functionality is implemented in #120 (specifically, 14e25019d55c1664dc95e3ceaf0e5a928ac67a8d).\n. Also related: #40, #42, #13, and #117. Lot of people involved in this.\n. Pull request #120 accepted, issues to be closed: #116, #117, and #118.\n. Hm, I don't see this code merged into master. It'd be awesome to get a new version published to NPM with these changes.\n. See #132.\n. I need to have publisher confirms to make this module useful for me. \n\nRelated issues: #116, #115, #114 and #41.\n\nI noticed that #41 contained code but that it was closed by the author without comment.\n\n@ahildoer is there a reason you closed your request? \n@postwait is there a reason that wasn't an acceptable pull request? \n\nI'm willing to write the code to implement publisher confirms, but I'd rather know all the information up front.\n. Looks like this functionality is implemented in #120 (specifically, 14e25019d55c1664dc95e3ceaf0e5a928ac67a8d).\n. Also related: #40, #42, #13, and #117. Lot of people involved in this.\n. Pull request #120 accepted, issues to be closed: #116, #117, and #118.\n. Hm, I don't see this code merged into master. It'd be awesome to get a new version published to NPM with these changes.\n. See #132.\n. ",
    "simpleseeker": "Is this working? In Exchange.prototype.publish, I confirmed that \"self.options.confirm\"  is true and I passed in a callback. But my callback never gets call.\n. Is this working? In Exchange.prototype.publish, I confirmed that \"self.options.confirm\"  is true and I passed in a callback. But my callback never gets call.\n. ",
    "ali-bugdayci": "Hi,\n\nThanks for the quick reply. First of all I dont buy why I cant use it. Doesn't rabbitmq reboot as if the queued messages are send before it crashed. If it doesn't then I believe this should be reported to rabbit to fix ack work on persisted messages too.\n\nI checked without ack:true. I am getting all the messages but afterward getting the following exception on node-amqp side:\n\nevents.js:66\n        throw arguments[1]; // Unhandled 'error' event\n                       ^\nError: PRECONDITION_FAILED - unknown delivery tag 4\n    at Queue._onMethod (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:1720:15)\n    at Queue.Channel._onChannelMethod (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:1365:14)\n    at Connection._onMethod (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:922:28)\n    at AMQPParser.self.addListener.parser.onMethod (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:797:12)\n    at AMQPParser._parseMethodFrame (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:442:10)\n    at frameEnd (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:187:16)\n    at frame (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:172:14)\n    at AMQPParser.header [as parse](/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:159:14)\n    at AMQPParser.execute (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:231:21)\n    at Connection.<anonymous> (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:837:12)\n. I find out that Persistent messages dont work well with the default {autoDelete: true } option. \n\nCorrect me if I am wrong but I believe they are two different things:\nautoDelete removes the queue if there are no messages in the queue\nwhere as if there is any persistent message then the queue will not be autoDeleted.\n\nFor the time being I am making the queue's autoDelete:false  but would this lead to too many resources being consumed ? \n\nThanks\n. Hi,\n\nThanks for the quick reply. First of all I dont buy why I cant use it. Doesn't rabbitmq reboot as if the queued messages are send before it crashed. If it doesn't then I believe this should be reported to rabbit to fix ack work on persisted messages too.\n\nI checked without ack:true. I am getting all the messages but afterward getting the following exception on node-amqp side:\n\nevents.js:66\n        throw arguments[1]; // Unhandled 'error' event\n                       ^\nError: PRECONDITION_FAILED - unknown delivery tag 4\n    at Queue._onMethod (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:1720:15)\n    at Queue.Channel._onChannelMethod (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:1365:14)\n    at Connection._onMethod (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:922:28)\n    at AMQPParser.self.addListener.parser.onMethod (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:797:12)\n    at AMQPParser._parseMethodFrame (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:442:10)\n    at frameEnd (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:187:16)\n    at frame (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:172:14)\n    at AMQPParser.header [as parse](/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:159:14)\n    at AMQPParser.execute (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:231:21)\n    at Connection.<anonymous> (/home/bor/sunucu/node_sunucu/node_modules/amqp/amqp.js:837:12)\n. I find out that Persistent messages dont work well with the default {autoDelete: true } option. \n\nCorrect me if I am wrong but I believe they are two different things:\nautoDelete removes the queue if there are no messages in the queue\nwhere as if there is any persistent message then the queue will not be autoDeleted.\n\nFor the time being I am making the queue's autoDelete:false  but would this lead to too many resources being consumed ? \n\nThanks\n. ",
    "barshow": "bump\n. ill work on that, and push up changes\n. all the tests are passing and I added new test for the publish acks\n. q.bind(exNot.name);   \n\nshould be   \n\nq.bind('134495441429916', 'beer');  \n. @humanchimp I think most people dont experience this which is why it hasn't been a high priority to fix.  You probably know this problem better than anyone and I have found @postwait to be really good at merging pull requests.\n. I am amazing the rabbit/amqp doesn't send anything back on auth failure!  \n\nThis solution scares me because of the potential false positives on a error.  However I have no better solution!  The error would have to occur before a ready is emitted for a false positive.   I am not sure how that could happen so maybe this is a safe solution.\n\nThanks for doing this!\n. you would subscribe each of them to the same queue you're pushing jobs to.  It will effectively round robin the jobs automatically\n\nhttp://www.rabbitmq.com/tutorials/tutorial-two-python.html \n\nThat will help get the idea.\n. the second way you specified is correct.  Below should work if you ae is actually called unknown\n\n```\namqp.exchange('transform', {\n      type:'topic',\n      durable:true,\n      arguments: {\n        'alternate-exchange': 'unknown'\n      }\n    }, function (exchange) {\n```\n. Im using it in production and its working, are you using the npm version pulling from master here on the github?  We're using master here.\n. Make sure you're using the correct version. There should  in /node_modules/amqp/test/test-publish-confirms-callback.js if you have the correct version of amqp.\n. I would pull from github and use master for now, the version isn't bumped yet, and the confirm stuff is new code\n. I think you can do npm update, but I've never used that.\n. if you're pulling this from master you can pass in an array of hosts to connect to it will round robin between and auto reconnect to a different one.\n. Just double checking but you are actually calling those functions?  Even in coffescript you need the () unless you're passing in arguments.\n\n``` coffeescript\n\n  connection.end()\n  connection.destroy()\n```\n. try this\n\n```\nself.queue = self.connection.queue(routingKey, {passive: false, durable: true, autoDelete: false}, function(queue){ \n  queue.bind(exchange, \"*\");\n});\n```\n. https://github.com/dropbox/amqp-coffee can do this\n\nqueue.messageCount(queueOptions, callback)\n\nrabbit gives this information back during queue declaration.\n. In the rabbit management interface client you can check the the channel you're publishing with is in confirm mode.  If its not thats You can also try https://github.com/dropbox/amqp-coffee if you're writing a new app it may be easier, if not the api changes may make it tough.\n. localhost:15672/#/channels  there should be a \"c\" int he Mode column.  That indicates that publish confirms are enabled on that channel.\n. You don't have to be using coffee script, to run amqp-coffee.  You can use multiple in parallel, for different publishes.  But that should also work for node-amqp.\n. https://github.com/postwait/node-amqp/blob/master/lib/exchange.js#L91 only happens after exchangeDeclareOk which doesn't happen with no-declare.   This is for sure a bug.  You can just not use no-declare.  You should be able to redeclare a exchange with no problem.  Ill plug https://github.com/dropbox/amqp-coffee again, with it you don't publish on a exchange.  You publish on the connection which solves the whole no-declare thing.\n. What would the point of supporting rpc and the amqp protocol. Are there rpc calls outside of the amqp spec?\n\n\u2014\nSent from Mailbox for iPhone\n\nOn Wed, Nov 6, 2013 at 8:54 PM, kuno notifications@github.com wrote:\n\n> ## Any progress here?\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/242#issuecomment-27937867\n. Should have read that closer I thought your were talking about the rpc rabbitmq plugin\u00a0\n\nrabbitmq_jsonrpc_channel\n\nThis driver doesn't do correlation I'd tracking but your app could\n\n\u2014\nSent from Mailbox for iPhone\n\nOn Wed, Nov 6, 2013 at 9:26 PM, Justin Morris notifications@github.com\nwrote:\n\n> ## http://www.rabbitmq.com/tutorials/tutorial-six-python.html\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/242#issuecomment-27938747\n. there is a pull request floating around that should fix this.  It is also fixed here https://github.com/dropbox/amqp-coffee\n. you can with https://github.com/dropbox/amqp-coffee\n. Isn't the default true? \n\nhttp://nodejs.org/api/net.html#net_socket_setnodelay_nodelay\n. Ill self promote a little bit and recommend https://github.com/dropbox/amqp-coffee we use it very heavily, like billions of messages a day.  Started with node-amqp, and improved reconnecting, and a lots of other things.\n. This is solved on https://github.com/dropbox/amqp-coffee which is based off node-amqp but has a slightly different api \n. bump\n. ill work on that, and push up changes\n. all the tests are passing and I added new test for the publish acks\n. q.bind(exNot.name);   \n\nshould be   \n\nq.bind('134495441429916', 'beer');  \n. @humanchimp I think most people dont experience this which is why it hasn't been a high priority to fix.  You probably know this problem better than anyone and I have found @postwait to be really good at merging pull requests.\n. I am amazing the rabbit/amqp doesn't send anything back on auth failure!  \n\nThis solution scares me because of the potential false positives on a error.  However I have no better solution!  The error would have to occur before a ready is emitted for a false positive.   I am not sure how that could happen so maybe this is a safe solution.\n\nThanks for doing this!\n. you would subscribe each of them to the same queue you're pushing jobs to.  It will effectively round robin the jobs automatically\n\nhttp://www.rabbitmq.com/tutorials/tutorial-two-python.html \n\nThat will help get the idea.\n. the second way you specified is correct.  Below should work if you ae is actually called unknown\n\n```\namqp.exchange('transform', {\n      type:'topic',\n      durable:true,\n      arguments: {\n        'alternate-exchange': 'unknown'\n      }\n    }, function (exchange) {\n```\n. Im using it in production and its working, are you using the npm version pulling from master here on the github?  We're using master here.\n. Make sure you're using the correct version. There should  in /node_modules/amqp/test/test-publish-confirms-callback.js if you have the correct version of amqp.\n. I would pull from github and use master for now, the version isn't bumped yet, and the confirm stuff is new code\n. I think you can do npm update, but I've never used that.\n. if you're pulling this from master you can pass in an array of hosts to connect to it will round robin between and auto reconnect to a different one.\n. Just double checking but you are actually calling those functions?  Even in coffescript you need the () unless you're passing in arguments.\n\n``` coffeescript\n\n  connection.end()\n  connection.destroy()\n```\n. try this\n\n```\nself.queue = self.connection.queue(routingKey, {passive: false, durable: true, autoDelete: false}, function(queue){ \n  queue.bind(exchange, \"*\");\n});\n```\n. https://github.com/dropbox/amqp-coffee can do this\n\nqueue.messageCount(queueOptions, callback)\n\nrabbit gives this information back during queue declaration.\n. In the rabbit management interface client you can check the the channel you're publishing with is in confirm mode.  If its not thats You can also try https://github.com/dropbox/amqp-coffee if you're writing a new app it may be easier, if not the api changes may make it tough.\n. localhost:15672/#/channels  there should be a \"c\" int he Mode column.  That indicates that publish confirms are enabled on that channel.\n. You don't have to be using coffee script, to run amqp-coffee.  You can use multiple in parallel, for different publishes.  But that should also work for node-amqp.\n. https://github.com/postwait/node-amqp/blob/master/lib/exchange.js#L91 only happens after exchangeDeclareOk which doesn't happen with no-declare.   This is for sure a bug.  You can just not use no-declare.  You should be able to redeclare a exchange with no problem.  Ill plug https://github.com/dropbox/amqp-coffee again, with it you don't publish on a exchange.  You publish on the connection which solves the whole no-declare thing.\n. What would the point of supporting rpc and the amqp protocol. Are there rpc calls outside of the amqp spec?\n\n\u2014\nSent from Mailbox for iPhone\n\nOn Wed, Nov 6, 2013 at 8:54 PM, kuno notifications@github.com wrote:\n\n> ## Any progress here?\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/242#issuecomment-27937867\n. Should have read that closer I thought your were talking about the rpc rabbitmq plugin\u00a0\n\nrabbitmq_jsonrpc_channel\n\nThis driver doesn't do correlation I'd tracking but your app could\n\n\u2014\nSent from Mailbox for iPhone\n\nOn Wed, Nov 6, 2013 at 9:26 PM, Justin Morris notifications@github.com\nwrote:\n\n> ## http://www.rabbitmq.com/tutorials/tutorial-six-python.html\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/issues/242#issuecomment-27938747\n. there is a pull request floating around that should fix this.  It is also fixed here https://github.com/dropbox/amqp-coffee\n. you can with https://github.com/dropbox/amqp-coffee\n. Isn't the default true? \n\nhttp://nodejs.org/api/net.html#net_socket_setnodelay_nodelay\n. Ill self promote a little bit and recommend https://github.com/dropbox/amqp-coffee we use it very heavily, like billions of messages a day.  Started with node-amqp, and improved reconnecting, and a lots of other things.\n. This is solved on https://github.com/dropbox/amqp-coffee which is based off node-amqp but has a slightly different api \n. ",
    "Raffiki": "thanks\n. thanks\n. ",
    "whizz": "Hi there. My guess is, in the second method, you send the message before the queue is bound to the exchange. Therefore, the difference is in the time it takes for the queue to bind and subscribe. Remeber, node is asynchronous most of the time, so the actual order of events (or could be):\n1. create queue\n2. start binding\n3. send test message\n4. binding is finished\n5. start subscribing\n6. subscribing is finished\n7. receive message\n8. print output\n. Hi there. My guess is, in the second method, you send the message before the queue is bound to the exchange. Therefore, the difference is in the time it takes for the queue to bind and subscribe. Remeber, node is asynchronous most of the time, so the actual order of events (or could be):\n1. create queue\n2. start binding\n3. send test message\n4. binding is finished\n5. start subscribing\n6. subscribing is finished\n7. receive message\n8. print output\n. ",
    "goloroden": "I solved it: It works if you do _NOT_ call `connect` (which, at least from my point of view, makes absolutely no sense).\n\nWhy is that?\n. Okay, I didn't know that.\nThx for clarification :-)!\n. Okay, checked it and this file is _NOT_ there.\n\nAlthough I used the latest version available through npm (which is 0.1.3).\nDoes that mean that this version is outdated, but a newer one is not yet available?\n. Okay ... just one last question: Can you already tell when a new version will be available via npm?\n. Okay, problem solved using `https://github.com/postwait/node-amqp/tarball/master` as version in `npm`.\n\nHowever, it would be nice if there was a new npm package with a new version number.\n. I solved it: It works if you do _NOT_ call `connect` (which, at least from my point of view, makes absolutely no sense).\n\nWhy is that?\n. Okay, I didn't know that.\nThx for clarification :-)!\n. Okay, checked it and this file is _NOT_ there.\n\nAlthough I used the latest version available through npm (which is 0.1.3).\nDoes that mean that this version is outdated, but a newer one is not yet available?\n. Okay ... just one last question: Can you already tell when a new version will be available via npm?\n. Okay, problem solved using `https://github.com/postwait/node-amqp/tarball/master` as version in `npm`.\n\nHowever, it would be nice if there was a new npm package with a new version number.\n. ",
    "jockster": "Thats amazing. I assumed that I had to learn about load balancing to do this. \n\nThank you very much.\n. Thats amazing. I assumed that I had to learn about load balancing to do this. \n\nThank you very much.\n. ",
    "pdelanauze": "I'll give it another shot but the second way did not work for me yesterday \n. +1\n`ERR { '0': { [Error: FRAME_ERROR - type 101, all octets = <<>>: {frame_too_large,1935894629,131064}] code: 501 } }`\n. I've tried getting the test suite to run many times to no avail, with instructions i'd gladly attempt writing a test case\n. From my experience it does some splitting to make sure to not go over the frame_max, but i have experienced very sporadic situations where it does not seem to do the splitting correctly, raising a FRAME_ERROR , frame_too_large, code 501. \n\nMaybe take a look at https://github.com/postwait/node-amqp/pull/164\n. I'll give it another shot but the second way did not work for me yesterday \n. +1\n`ERR { '0': { [Error: FRAME_ERROR - type 101, all octets = <<>>: {frame_too_large,1935894629,131064}] code: 501 } }`\n. I've tried getting the test suite to run many times to no avail, with instructions i'd gladly attempt writing a test case\n. From my experience it does some splitting to make sure to not go over the frame_max, but i have experienced very sporadic situations where it does not seem to do the splitting correctly, raising a FRAME_ERROR , frame_too_large, code 501. \n\nMaybe take a look at https://github.com/postwait/node-amqp/pull/164\n. ",
    "kevinohara80": "Is this still not in the latest published version? Confirm is not working for me. The callback never fires.\n\nI'm on `0.1.7`\n. I tried adding listeners to the publish object vs the callback. No dice.\n. Will this ever get released?\n. In looking at the test suite, it looks like it will pass no matter what happens. I can try to put together a PR today or tomorrow to update and verify the tests.\n\nI'll attach the PR to the issue I opened the other day that's still open.\n\nhttps://github.com/postwait/node-amqp/issues/225\n. Pretty please? :)\n\nOn Thu, Oct 3, 2013 at 8:13 PM, Matthew Ratzloff <notifications@github.com=\"mailto:notifications@github.com\">> wrote:\n\nCan we get an updated npm release?  This certainly warrants it.  Thanks!\n\n\u2014\nReply to this email directly or view it on GitHub.\n. I've seen no updates on this (or other issues). node-amqp feels all but dead at this point. \n. Is this still not in the latest published version? Confirm is not working for me. The callback never fires.\n\nI'm on `0.1.7`\n. I tried adding listeners to the publish object vs the callback. No dice.\n. Will this ever get released?\n. In looking at the test suite, it looks like it will pass no matter what happens. I can try to put together a PR today or tomorrow to update and verify the tests.\n\nI'll attach the PR to the issue I opened the other day that's still open.\n\nhttps://github.com/postwait/node-amqp/issues/225\n. Pretty please? :)\n\nOn Thu, Oct 3, 2013 at 8:13 PM, Matthew Ratzloff <notifications@github.com=\"mailto:notifications@github.com\">> wrote:\n\nCan we get an updated npm release?  This certainly warrants it.  Thanks!\n\n\u2014\nReply to this email directly or view it on GitHub.\n. I've seen no updates on this (or other issues). node-amqp feels all but dead at this point. \n. ",
    "shernshiou": "I met the same problem as @kevinohara80. (Both listener or callback)\nI'm on `0.1.7`\n. Get the latest from master instead from release. \n. +1\n. Tested using following code\n\n``` javascript\nconnection.on('ready', function () {\n    connection.exchange(exchange_name, { type: 'topic' }, function (exchange) {\n      //Not firing here\n    });\n  });\n```\n. I met the same problem as @kevinohara80. (Both listener or callback)\nI'm on `0.1.7`\n. Get the latest from master instead from release. \n. +1\n. Tested using following code\n\n``` javascript\nconnection.on('ready', function () {\n    connection.exchange(exchange_name, { type: 'topic' }, function (exchange) {\n      //Not firing here\n    });\n  });\n```\n. ",
    "krootee": "Same issue here - callback is not called.\nv 0.1.7\n. Thanks - version from master is working correctly in this case.\n. Per amqp there should be atleast 2 ways to do, but according to node-amqp documention none of them are supported :(\n+1 for this request.\n. Same issue here - callback is not called.\nv 0.1.7\n. Thanks - version from master is working correctly in this case.\n. Per amqp there should be atleast 2 ways to do, but according to node-amqp documention none of them are supported :(\n+1 for this request.\n. ",
    "vvilhonen": "Tried with the master with no luck..\n. @ssafejava Great work, thank you!\n. Tried with the master with no luck..\n. @ssafejava Great work, thank you!\n. ",
    "ssafejava": "Fixed this in ssafejava/node-amqp@8d3d579,\n\nA lot of tests are not passing in the official release and in the official HEAD. It's looking like interest in support the project has waned. Even the Travis CI config is not working, so a lot of recent PRs broke functionality without notice.\n\nIf you want a stable version of node-amqp try the fork linked above.\n. @yahuarkuntur This is working in the test cases, take a look at the commit above. Maybe you're missing a configuration option?\n. If you use the default exchange, there's no way to set {confirm: true}. I'm not sure how you would expect this to work.\n\nOn Sep 12, 2013, at 11:33 PM, Brian Debuire notifications@github.com wrote:\n\n> OK, I got it to work as shown above, but I can't use the default exchange for the same purpose...\n> \n> connection.on('ready', function () { \n>     console.log('connection ready');\n>     connection.exchange('node-exchange', {autoDelete: false, confirm: true, durable: true, type: 'direct'}, function(exchange) {\n>         console.log('exchange ready ' + exchange.name );\n>         connection.queue('node-queue', {autoDelete: false, durable: true}, function(queue){\n>             console.log('queue ready '  + queue.name);\n>             queue.bind(exchange, 'node-direct-key');\n>             exchange.publish('node-direct-key', message, {deliveryMode: 2}, function() {\n>                 console.log('message published');\n>             });\n>         });\n>     });\n> }); \n> Thank you!\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. In the meantime, use this repo's git URL & commit. The maintainer comes around here, but not often.\n\nOn Oct 5, 2013, at 10:46 PM, kevinohara80 notifications@github.com wrote:\n\n> Pretty please? :) \n> \n> On Thu, Oct 3, 2013 at 8:13 PM, Matthew Ratzloff <notifications@github.com=\"mailto:notifications@github.com\">> wrote: \n> \n> Can we get an updated npm release? This certainly warrants it. Thanks! \n> \n> \u2014 \n> Reply to this email directly or view it on GitHub.\n> \u2014\n> Reply to this email directly or view it on GitHub.\n. I'm getting this same issue with HEAD. I am not keen on using 0.1.7 as it has a big eventemitter leak that cripples the app after a small number of reconnects. Have you been able to narrow it down?\n. This was fixed by efc1682 as part of #236, which is now merged.\n. Something odd is going on with this configuration; 0.10 and 0.6 throw ECONNREFUSED on every test, and 0.8 passes all tests until it times out on test-reconnection.js. Locally, all of these tests pass. Does anybody have an idea of what might be going on with TravisCI's rabbitMQ?\n. Updated conflicts from upstream, this is ready to merge.\n. Looks like the version was incremented to 0.1.8 and [uploaded to npm](https://npmjs.org/package/amqp). Not sure why this PR wasn't merged instead.\n. The functionality hasn't changed, but the internal structure has, quite significantly from 0.1.7. But it doesn't matter, I'm glad the latest is out there.\n\nOn Nov 27, 2013, at 1:16 PM, crzidea notifications@github.com wrote:\n\n> The PR set the version to v0.2.0, which means a big change. But it isn't. I guess.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Yes exactly that - if the client dies, or the connection between the client & server is interrupted, the server will _not_ detect this the previous default of `heartbeat: 0` and unacked messages will stay unacked for eternity.\n\nWhen a heartbeat is set, the server will send messages to the client & expect a response every `heartbeat` seconds, the RabbitMQ default being 580 seconds. In that case, if the connection were interrupted, the old connection would be reaped at some time within the next ~10min and any unacked messages held by that connection will be released back into the ready queue.\n\nWhat really necessitates this patch is that even a small connection interruption can have disastrous results on the queue. Connected clients will reconnect (thus creating a new connection) but the old connections will live on indefinitely, holding their unacked messages in purgatory along with them.\n. FYI right now you can fix this behavior (without this patch) by simply adding `heartbeat: 580` (or whichever value you're comfortable with) to your connection options. This patch simply sets a non-zero default and documentation.\n. I strongly believe that the previous default was a bug; L452 of connection.js should have read `this.options.heartbeat || 580`, as the rabbitMQ default is `580` and it needs to be explicitly set to something else in order to disable it. I think this is very confusing to users that expect the defaults to be respected, especially since the example `option` hashes do not include a `heartbeat` attribute.\n\nPlease consider changing this in the next major release, and in the meantime documenting it as `heartbeat: 0 // by default, heartbeats are disabled, see below` in the example connection hashes to explain what is happening. Heartbeats are a fundamental feature of rabbitMQ and it is nonsensical to have them disabled by default - and we are going to leave it that way, it needs to be extremely explicit or we risk a great deal of hard-to-find bugs.\n. Fixed this in ssafejava/node-amqp@8d3d579,\n\nA lot of tests are not passing in the official release and in the official HEAD. It's looking like interest in support the project has waned. Even the Travis CI config is not working, so a lot of recent PRs broke functionality without notice.\n\nIf you want a stable version of node-amqp try the fork linked above.\n. @yahuarkuntur This is working in the test cases, take a look at the commit above. Maybe you're missing a configuration option?\n. If you use the default exchange, there's no way to set {confirm: true}. I'm not sure how you would expect this to work.\n\nOn Sep 12, 2013, at 11:33 PM, Brian Debuire notifications@github.com wrote:\n\n> OK, I got it to work as shown above, but I can't use the default exchange for the same purpose...\n> \n> connection.on('ready', function () { \n>     console.log('connection ready');\n>     connection.exchange('node-exchange', {autoDelete: false, confirm: true, durable: true, type: 'direct'}, function(exchange) {\n>         console.log('exchange ready ' + exchange.name );\n>         connection.queue('node-queue', {autoDelete: false, durable: true}, function(queue){\n>             console.log('queue ready '  + queue.name);\n>             queue.bind(exchange, 'node-direct-key');\n>             exchange.publish('node-direct-key', message, {deliveryMode: 2}, function() {\n>                 console.log('message published');\n>             });\n>         });\n>     });\n> }); \n> Thank you!\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. In the meantime, use this repo's git URL & commit. The maintainer comes around here, but not often.\n\nOn Oct 5, 2013, at 10:46 PM, kevinohara80 notifications@github.com wrote:\n\n> Pretty please? :) \n> \n> On Thu, Oct 3, 2013 at 8:13 PM, Matthew Ratzloff <notifications@github.com=\"mailto:notifications@github.com\">> wrote: \n> \n> Can we get an updated npm release? This certainly warrants it. Thanks! \n> \n> \u2014 \n> Reply to this email directly or view it on GitHub.\n> \u2014\n> Reply to this email directly or view it on GitHub.\n. I'm getting this same issue with HEAD. I am not keen on using 0.1.7 as it has a big eventemitter leak that cripples the app after a small number of reconnects. Have you been able to narrow it down?\n. This was fixed by efc1682 as part of #236, which is now merged.\n. Something odd is going on with this configuration; 0.10 and 0.6 throw ECONNREFUSED on every test, and 0.8 passes all tests until it times out on test-reconnection.js. Locally, all of these tests pass. Does anybody have an idea of what might be going on with TravisCI's rabbitMQ?\n. Updated conflicts from upstream, this is ready to merge.\n. Looks like the version was incremented to 0.1.8 and [uploaded to npm](https://npmjs.org/package/amqp). Not sure why this PR wasn't merged instead.\n. The functionality hasn't changed, but the internal structure has, quite significantly from 0.1.7. But it doesn't matter, I'm glad the latest is out there.\n\nOn Nov 27, 2013, at 1:16 PM, crzidea notifications@github.com wrote:\n\n> The PR set the version to v0.2.0, which means a big change. But it isn't. I guess.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Yes exactly that - if the client dies, or the connection between the client & server is interrupted, the server will _not_ detect this the previous default of `heartbeat: 0` and unacked messages will stay unacked for eternity.\n\nWhen a heartbeat is set, the server will send messages to the client & expect a response every `heartbeat` seconds, the RabbitMQ default being 580 seconds. In that case, if the connection were interrupted, the old connection would be reaped at some time within the next ~10min and any unacked messages held by that connection will be released back into the ready queue.\n\nWhat really necessitates this patch is that even a small connection interruption can have disastrous results on the queue. Connected clients will reconnect (thus creating a new connection) but the old connections will live on indefinitely, holding their unacked messages in purgatory along with them.\n. FYI right now you can fix this behavior (without this patch) by simply adding `heartbeat: 580` (or whichever value you're comfortable with) to your connection options. This patch simply sets a non-zero default and documentation.\n. I strongly believe that the previous default was a bug; L452 of connection.js should have read `this.options.heartbeat || 580`, as the rabbitMQ default is `580` and it needs to be explicitly set to something else in order to disable it. I think this is very confusing to users that expect the defaults to be respected, especially since the example `option` hashes do not include a `heartbeat` attribute.\n\nPlease consider changing this in the next major release, and in the meantime documenting it as `heartbeat: 0 // by default, heartbeats are disabled, see below` in the example connection hashes to explain what is happening. Heartbeats are a fundamental feature of rabbitMQ and it is nonsensical to have them disabled by default - and we are going to leave it that way, it needs to be extremely explicit or we risk a great deal of hard-to-find bugs.\n. ",
    "yahuarkuntur": "any updates on this? I still can't get it to work, not even with ssafejava's fork... \n\nThanks in advance!\n. OK, I got it to work as shown above, but I can't use the default exchange for the same purpose...\n\n``` javascript\nconnection.on('ready', function () { \n    console.log('connection ready');\n    connection.exchange('node-exchange', {autoDelete: false, confirm: true, durable: true, type: 'direct'}, function(exchange) {\n        console.log('exchange ready ' + exchange.name );\n        connection.queue('node-queue', {autoDelete: false, durable: true}, function(queue){\n            console.log('queue ready '  + queue.name);\n            queue.bind(exchange, 'node-direct-key');\n            exchange.publish('node-direct-key', message, {deliveryMode: 2}, function() {\n                console.log('message published');\n            });\n        });\n    });\n}); \n```\n\nThank you!\n. @ssafejava thanks for clearing me that out :smile: \n\nCheers!\n. any updates on this ??\n. :+1:\n. any updates on this? I still can't get it to work, not even with ssafejava's fork... \n\nThanks in advance!\n. OK, I got it to work as shown above, but I can't use the default exchange for the same purpose...\n\n``` javascript\nconnection.on('ready', function () { \n    console.log('connection ready');\n    connection.exchange('node-exchange', {autoDelete: false, confirm: true, durable: true, type: 'direct'}, function(exchange) {\n        console.log('exchange ready ' + exchange.name );\n        connection.queue('node-queue', {autoDelete: false, durable: true}, function(queue){\n            console.log('queue ready '  + queue.name);\n            queue.bind(exchange, 'node-direct-key');\n            exchange.publish('node-direct-key', message, {deliveryMode: 2}, function() {\n                console.log('message published');\n            });\n        });\n    });\n}); \n```\n\nThank you!\n. @ssafejava thanks for clearing me that out :smile: \n\nCheers!\n. any updates on this ??\n. :+1:\n. ",
    "athlan": "I confirm, works for me when i used https://github.com/postwait/node-amqp/tarball/master (`master`, not `release`)in `packages.json` instead of last version from `npm`.\n\nExample codes:\n\nworker/listener:\n\n```\nvar amqp = require('amqp');\nvar connection = amqp.createConnection();\n\n    connection.on('ready', function() {\n\n    connection.exchange(\"sub16\", {\n    autoDelete: false,\n    confirm: true,\n    durable: true,\n    type: 'direct'\n  }, function(exchange) {\n\n    connection.queue('sub1234', {\n    }, function(q) {\n      q.bind(exchange, 'r1');\n\n      q.subscribe({\n                ack: true\n            }, function(json, headers, deliveryInfo, m) {\n        console.log(\"msg: \" + JSON.stringify(json));\n\n        setTimeout(function() {\n                q.shift();\n        }, 500);\n      });\n    });\n    });\n});\n```\n\nmessage dispatcher/publisher:\n\n```\n\nvar amqp = require('amqp');\nvar connection = amqp.createConnection();\n\nconnection.on('ready', function() {\n    console.log('one');\n\n  connection.exchange('sub16', {\n    autoDelete: false,\n    confirm: true,\n    durable: true,\n    type: 'direct'\n    }, function(exchange) {\n    console.log('exchange ready ' + exchange.name );\n\n    var publish = exchange.publish('r1', { a: 'b' }, {deliveryMode: 2, immediate: true }, function() {\n      console.log('message published');\n    });\n\n      publish.addListener('ack', function() {\n      console.log('ack received');\n      });\n      console.log('message sent');\n  });\n});\n```\n. I confirm, works for me when i used https://github.com/postwait/node-amqp/tarball/master (`master`, not `release`)in `packages.json` instead of last version from `npm`.\n\nExample codes:\n\nworker/listener:\n\n```\nvar amqp = require('amqp');\nvar connection = amqp.createConnection();\n\n    connection.on('ready', function() {\n\n    connection.exchange(\"sub16\", {\n    autoDelete: false,\n    confirm: true,\n    durable: true,\n    type: 'direct'\n  }, function(exchange) {\n\n    connection.queue('sub1234', {\n    }, function(q) {\n      q.bind(exchange, 'r1');\n\n      q.subscribe({\n                ack: true\n            }, function(json, headers, deliveryInfo, m) {\n        console.log(\"msg: \" + JSON.stringify(json));\n\n        setTimeout(function() {\n                q.shift();\n        }, 500);\n      });\n    });\n    });\n});\n```\n\nmessage dispatcher/publisher:\n\n```\n\nvar amqp = require('amqp');\nvar connection = amqp.createConnection();\n\nconnection.on('ready', function() {\n    console.log('one');\n\n  connection.exchange('sub16', {\n    autoDelete: false,\n    confirm: true,\n    durable: true,\n    type: 'direct'\n    }, function(exchange) {\n    console.log('exchange ready ' + exchange.name );\n\n    var publish = exchange.publish('r1', { a: 'b' }, {deliveryMode: 2, immediate: true }, function() {\n      console.log('message published');\n    });\n\n      publish.addListener('ack', function() {\n      console.log('ack received');\n      });\n      console.log('message sent');\n  });\n});\n```\n. ",
    "mratzloff": "Can we get an updated npm release?  This certainly warrants it.  Thanks!\n. Can we get an updated npm release?  This certainly warrants it.  Thanks!\n. ",
    "jbyrneie": "All the above comments/code are creating the Exchange. I am using \"amqp 0.2.4\". My Exchange already exists. I do not get a callback when I publish a message to the Exchange. How can I determine that the message has been successful or failed when published\n. All the above comments/code are creating the Exchange. I am using \"amqp 0.2.4\". My Exchange already exists. I do not get a callback when I publish a message to the Exchange. How can I determine that the message has been successful or failed when published\n. ",
    "jacksonhull": "if you are struggling with this, try adding\n`persistent: false`\nto your publish command\n. if you are struggling with this, try adding\n`persistent: false`\nto your publish command\n. ",
    "shaharke": "This issue seems to be solved on the Master branch.\n. This issue seems to be solved on the Master branch.\n. ",
    "lookfirst": "I'm using master and it isn't resolved.\n\n```\n2013-02-10T21:33:02+00:00 app[web.1]: (node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\n2013-02-10T21:33:02+00:00 app[web.1]: Trace\n2013-02-10T21:33:02+00:00 app[web.1]:     at Exchange.EventEmitter.addListener (events.js:175:15)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Exchange.EventEmitter.once (events.js:196:8)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Exchange.publish (/app/node_modules/amqp/amqp.js:2243:12)\n2013-02-10T21:33:02+00:00 app[web.1]:     at exports.sendMessageDestination.exec (/app/lib/service/queue.coffee:101:29)\n2013-02-10T21:33:02+00:00 app[web.1]:     at async.some (/app/node_modules/async/lib/async.js:292:13)\n2013-02-10T21:33:02+00:00 app[web.1]:     at async.forEach (/app/node_modules/async/lib/async.js:86:13)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Array.forEach (native)\n2013-02-10T21:33:02+00:00 app[web.1]:     at _forEach (/app/node_modules/async/lib/async.js:26:24)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Object.async.forEach (/app/node_modules/async/lib/async.js:85:9)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Object.async.some (/app/node_modules/async/lib/async.js:291:15)\n```\n. Looking at this code further, I can see now why my code may be triggering this issue. I think there is a race condition where my code is executing .publish() is a very tight loop to publish a mad amount of messages and the task.once('ack') isn't able to fire and then remove the error listener fast enough to not print out the error above.\n. +1\n. In addition, I just ran into this:\n\n```\n2013-02-11T18:57:53+00:00 app[emailAlert.1]: Unhandled connection error: FRAME_ERROR - type 110, all octets = <<>>: {frame_too_large,291859809,131064}\n```\n\nWhich caused the heroku dyno to crash and start up again, but as it restarted...\n\n```\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: tasks\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: fixImages\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: emailAlert\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: emailNewsletter\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: chat\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: apns\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: rabbit server: letsdate:cloudamp\n2013-02-11T18:58:34+00:00 app[emailAlert.1]: (node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\n2013-02-11T18:58:34+00:00 app[emailAlert.1]: Trace\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Connection.EventEmitter.addListener (events.js:175:15)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Connection.EventEmitter.once (events.js:196:8)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Connection.connect (/app/node_modules/amqp/amqp.js:1068:8)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Connection.reconnect (/app/node_modules/amqp/amqp.js:1037:8)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Object.backoff (/app/node_modules/amqp/amqp.js:875:16)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Object.Proxy.callback.args.(anonymous function) [as _onTimeout] (/app/node_modules/nodetime/lib/core/proxy.js:131:20)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Timer.list.ontimeout (timers.js:101:19)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]: (node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\n2013-02-11T18:58:42+00:00 app[emailAlert.1]: Trace\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Connection.EventEmitter.addListener (events.js:175:15)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Connection.connect (/app/node_modules/amqp/amqp.js:1067:8)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Connection.reconnect (/app/node_modules/amqp/amqp.js:1037:8)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Object.backoff (/app/node_modules/amqp/amqp.js:875:16)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Object.Proxy.callback.args.(anonymous function) [as _onTimeout] (/app/node_modules/nodetime/lib/core/proxy.js:131:20)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Timer.list.ontimeout (timers.js:101:19)\n```\n\nLooks like the Connection code has a similar issue. Look for an update to this pull request. ;-)\n. There is zero documentation on how to even run your test suite, I'm not going to waste a day trying to figure it out. Sorry.\n\nI also have no idea how to write a test that tests a race condition in eventing code. I could understand wanting a functional test, but this is not something that is testable other than to show that your existing tests shouldn't be broken after applying this code.\n\nThis code is running in production and used across ~100 dynos on heroku and I no longer see the stack traces after deploying it. Apply it or not. I'd rather not maintain my own fork, but if I need to, I will.\n. wow\n. I'm using master and it isn't resolved.\n\n```\n2013-02-10T21:33:02+00:00 app[web.1]: (node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\n2013-02-10T21:33:02+00:00 app[web.1]: Trace\n2013-02-10T21:33:02+00:00 app[web.1]:     at Exchange.EventEmitter.addListener (events.js:175:15)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Exchange.EventEmitter.once (events.js:196:8)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Exchange.publish (/app/node_modules/amqp/amqp.js:2243:12)\n2013-02-10T21:33:02+00:00 app[web.1]:     at exports.sendMessageDestination.exec (/app/lib/service/queue.coffee:101:29)\n2013-02-10T21:33:02+00:00 app[web.1]:     at async.some (/app/node_modules/async/lib/async.js:292:13)\n2013-02-10T21:33:02+00:00 app[web.1]:     at async.forEach (/app/node_modules/async/lib/async.js:86:13)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Array.forEach (native)\n2013-02-10T21:33:02+00:00 app[web.1]:     at _forEach (/app/node_modules/async/lib/async.js:26:24)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Object.async.forEach (/app/node_modules/async/lib/async.js:85:9)\n2013-02-10T21:33:02+00:00 app[web.1]:     at Object.async.some (/app/node_modules/async/lib/async.js:291:15)\n```\n. Looking at this code further, I can see now why my code may be triggering this issue. I think there is a race condition where my code is executing .publish() is a very tight loop to publish a mad amount of messages and the task.once('ack') isn't able to fire and then remove the error listener fast enough to not print out the error above.\n. +1\n. In addition, I just ran into this:\n\n```\n2013-02-11T18:57:53+00:00 app[emailAlert.1]: Unhandled connection error: FRAME_ERROR - type 110, all octets = <<>>: {frame_too_large,291859809,131064}\n```\n\nWhich caused the heroku dyno to crash and start up again, but as it restarted...\n\n```\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: tasks\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: fixImages\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: emailAlert\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: emailNewsletter\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: chat\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: exchange: ldexchange, queue: apns\n2013-02-11T18:58:02+00:00 app[emailAlert.1]: rabbit server: letsdate:cloudamp\n2013-02-11T18:58:34+00:00 app[emailAlert.1]: (node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\n2013-02-11T18:58:34+00:00 app[emailAlert.1]: Trace\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Connection.EventEmitter.addListener (events.js:175:15)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Connection.EventEmitter.once (events.js:196:8)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Connection.connect (/app/node_modules/amqp/amqp.js:1068:8)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Connection.reconnect (/app/node_modules/amqp/amqp.js:1037:8)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Object.backoff (/app/node_modules/amqp/amqp.js:875:16)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Object.Proxy.callback.args.(anonymous function) [as _onTimeout] (/app/node_modules/nodetime/lib/core/proxy.js:131:20)\n2013-02-11T18:58:34+00:00 app[emailAlert.1]:     at Timer.list.ontimeout (timers.js:101:19)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]: (node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\n2013-02-11T18:58:42+00:00 app[emailAlert.1]: Trace\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Connection.EventEmitter.addListener (events.js:175:15)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Connection.connect (/app/node_modules/amqp/amqp.js:1067:8)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Connection.reconnect (/app/node_modules/amqp/amqp.js:1037:8)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Object.backoff (/app/node_modules/amqp/amqp.js:875:16)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Object.Proxy.callback.args.(anonymous function) [as _onTimeout] (/app/node_modules/nodetime/lib/core/proxy.js:131:20)\n2013-02-11T18:58:42+00:00 app[emailAlert.1]:     at Timer.list.ontimeout (timers.js:101:19)\n```\n\nLooks like the Connection code has a similar issue. Look for an update to this pull request. ;-)\n. There is zero documentation on how to even run your test suite, I'm not going to waste a day trying to figure it out. Sorry.\n\nI also have no idea how to write a test that tests a race condition in eventing code. I could understand wanting a functional test, but this is not something that is testable other than to show that your existing tests shouldn't be broken after applying this code.\n\nThis code is running in production and used across ~100 dynos on heroku and I no longer see the stack traces after deploying it. Apply it or not. I'd rather not maintain my own fork, but if I need to, I will.\n. wow\n. ",
    "jondot": "@jameskeane I think I'm hit by this. I'm running on your fork now, but looks like I keep having ghost channels open.\nperhaps I'm not creating a connection with the right options?\n\nA simple test is to forcefully close a connection at the RabbitMQ side, and watch how the client reconnects with one more channel than before.\n. @jameskeane I think I'm hit by this. I'm running on your fork now, but looks like I keep having ghost channels open.\nperhaps I'm not creating a connection with the right options?\n\nA simple test is to forcefully close a connection at the RabbitMQ side, and watch how the client reconnects with one more channel than before.\n. ",
    "nathanlundquist": "Be nice if they merged this change in. I ran into the same thing. Lots and lots of ghost channels left behind after channel errors occur.\n. Be nice if they merged this change in. I ran into the same thing. Lots and lots of ghost channels left behind after channel errors occur.\n. ",
    "amackera": "We have been running this in our production setting under pretty heavy load for a few weeks with no problems. Would really like to see it merged.\n. @rschiavi It would be really nice if you could provide some insight into how you've addressed these issues!\n. This branch seems quite a bit more readable than the current node-amqp library.\n. I was still able to reproduce this issue after applying this PR. It seems as though the channels themselves are never closed. I'll try to write a test case to reproduce what I'm talking about.\n. Roger that, good tip about .close().\n\nOn Tue, Sep 3, 2013 at 4:09 PM, unframework notifications@github.com\nwrote:\n\n> ## Yes, that's an unrelated issue we had to work around. Just do `.close()` after `.destroy()` on queues and exchanges - did not see it in the documentation, but queue and exchange objects are subclasses of channels. Maybe `.destroy()` is supposed to do it automatically but we didn't dig deeper. But again - that issue is unrelated.\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/pull/237#issuecomment-23742839\n. I'm not sure if this is the issue, but `.shift()` on a queue will `ack` the last received message. Maybe prefetch count is screwing that up and acknowledging the last received message 5 times? Unknown delivery tag tends to indicate you've acknowledged a message more than once.\n. We have been running this in our production setting under pretty heavy load for a few weeks with no problems. Would really like to see it merged.\n. @rschiavi It would be really nice if you could provide some insight into how you've addressed these issues!\n. This branch seems quite a bit more readable than the current node-amqp library.\n. I was still able to reproduce this issue after applying this PR. It seems as though the channels themselves are never closed. I'll try to write a test case to reproduce what I'm talking about.\n. Roger that, good tip about .close().\n\nOn Tue, Sep 3, 2013 at 4:09 PM, unframework notifications@github.com\nwrote:\n\n> ## Yes, that's an unrelated issue we had to work around. Just do `.close()` after `.destroy()` on queues and exchanges - did not see it in the documentation, but queue and exchange objects are subclasses of channels. Maybe `.destroy()` is supposed to do it automatically but we didn't dig deeper. But again - that issue is unrelated.\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/postwait/node-amqp/pull/237#issuecomment-23742839\n. I'm not sure if this is the issue, but `.shift()` on a queue will `ack` the last received message. Maybe prefetch count is screwing that up and acknowledging the last received message 5 times? Unknown delivery tag tends to indicate you've acknowledged a message more than once.\n. ",
    "DavidIAm": "Trying to figure out what on earth you're talking about since I never have seen 'addCallback' before, I looked into the history of node and found that between node 0.1.29 and 0.1.30 the explicit promise callback feature was removed, back in february of 2010.  Prior to that time there was an interface that looked like that, but I can find no documentation on anything that looks like that in the current api's.\n\nSo in a nutshell, YES, that's what I'm looking for but NO, I have no documentation that I can implement anything like that - nor given the code paths I understand out of the amqp module would anything like that work.  There would have to be an explicit listener to the basicConsumeOk that maps that particular acknowledgement back to the subscribe call that initiated it, and then activate the appropriate promise callback.  But there doesn't appear to be any information available to be used to map that information.  The amqp module does not have an obvious tight coupling between commands and their acknowledgement in general, though I may be missing something subtle in my reading of the code. \n\nI hypothesize by using alternative channels for the control of these operations, (issue one subscribe command on one channel and no more until a subscribe ack or nack has been received) tight coupling could be achieved.\n\nDue to the apparent loose coupling the fact that it works at all for the other three callbacks without confusion I chalk it up to an artifact of the patterns exhibited by the particular implementations of the protocol being utilized.\n\nThe fact is, I shouldn't have to assume as a library utilizer that the next event of a certain type is _MY_ consume acknowledgement - isn't it possible another execution context using this connection might have issued a subscribe on the control channel immediately after mine and before an acknowledgement for either is received?  Were that to happen with the current callback definitions for exchange declare and queue bind, I strongly suspect the callbacks would be triggered incorrectly.  (both might get called for both confirms, or one might get called and the other dropped, or both might get called for one confirm and the other confirm dropped)\n\nMaybe I'm wrong, and that's okay, I hope I am. But regardless of whether the module is working by design or accident, it currently works in my application setup.  \n\nThe subscribe signature should be consistent to the exchange declaration, connection ready, and queue binding and declaration interfaces, by providing a callback that ostensibly will be called when this particular command is acknowledged.\n. so I just spent about 15 minutes trying to figure out what this promise system even is.  Now, I think my original post probably seems rather confusing in the lack of my knowledge at the time that there exists a Promise module which was used in support of this module - but I used the term anyway.  Sorry about that.\n\nI like the promise module, it has interesting possibilities in code writing.\n\nSo we're facing two issues - one is, inconsistent API.  The other asynchronous calls for amqp commands have explicit callback parameters in their parameter lists.  Except for Subscribe which does not.  And the other calls, which per a light code study of at least the queue bind case, do not provide the promise api as an alternative.  Giving us a collection of things, one or more of which is not like the other.  Ick.\n\nThe other is that the subscribe call is not appropriately documented.  The entire explanation of subscribe, what it does and what it returns, doesn't discuss the promise interface or its availability at all.  The example doesn't use it, the text doesn't mention it.\n\nSurely you don't think the documentation of another api point (unsubscribe in this case) is appropriate documentation location for the subcribe api?  In this case, it was a page-or-so down the screen, but this is a long docs file.  I even reloaded the github page to see if you were pulling my chain and just changing the subscribe docs while I wasn't looking then pretending it was there all along.\n\nSo the easiest one is to repair the documentation so that the available api of subscribe is fully documented in its _own_ documentation block... which would have prevented the entire amount of exploration and troubleshooting I've done to figure out why that's not the case.  I can submit a pull request for that I suspect.\n\nIt would add internal consistency to the library to modify the subscribe implementation with an optional final callback parameter which is merely conditionally added as a promise callback when supplied. I could probably put that in a pull too, as its fairly simple.\n\nThe ultimate in consistency would be to do both the first and second, AND modify the other api's to use the promise API for their callbacks too, revising the documentation to reflect their availability, making it consistently flexible in all cases.  But that's a pretty deep refactoring of this code... \n. You said \"With that method every basicConsume message will be sent on it's own queue.\" - did you mean 'its own channel'?\n. I thought I'd comment that I actually managed to be bitten by this loose coupling - attempt to bind to a queue in multiple ways in parallel (use the async module for the parallel semantic) and the callback of one is overwritten by the other, making only one queue bind callback actually get activated.\n. Trying to figure out what on earth you're talking about since I never have seen 'addCallback' before, I looked into the history of node and found that between node 0.1.29 and 0.1.30 the explicit promise callback feature was removed, back in february of 2010.  Prior to that time there was an interface that looked like that, but I can find no documentation on anything that looks like that in the current api's.\n\nSo in a nutshell, YES, that's what I'm looking for but NO, I have no documentation that I can implement anything like that - nor given the code paths I understand out of the amqp module would anything like that work.  There would have to be an explicit listener to the basicConsumeOk that maps that particular acknowledgement back to the subscribe call that initiated it, and then activate the appropriate promise callback.  But there doesn't appear to be any information available to be used to map that information.  The amqp module does not have an obvious tight coupling between commands and their acknowledgement in general, though I may be missing something subtle in my reading of the code. \n\nI hypothesize by using alternative channels for the control of these operations, (issue one subscribe command on one channel and no more until a subscribe ack or nack has been received) tight coupling could be achieved.\n\nDue to the apparent loose coupling the fact that it works at all for the other three callbacks without confusion I chalk it up to an artifact of the patterns exhibited by the particular implementations of the protocol being utilized.\n\nThe fact is, I shouldn't have to assume as a library utilizer that the next event of a certain type is _MY_ consume acknowledgement - isn't it possible another execution context using this connection might have issued a subscribe on the control channel immediately after mine and before an acknowledgement for either is received?  Were that to happen with the current callback definitions for exchange declare and queue bind, I strongly suspect the callbacks would be triggered incorrectly.  (both might get called for both confirms, or one might get called and the other dropped, or both might get called for one confirm and the other confirm dropped)\n\nMaybe I'm wrong, and that's okay, I hope I am. But regardless of whether the module is working by design or accident, it currently works in my application setup.  \n\nThe subscribe signature should be consistent to the exchange declaration, connection ready, and queue binding and declaration interfaces, by providing a callback that ostensibly will be called when this particular command is acknowledged.\n. so I just spent about 15 minutes trying to figure out what this promise system even is.  Now, I think my original post probably seems rather confusing in the lack of my knowledge at the time that there exists a Promise module which was used in support of this module - but I used the term anyway.  Sorry about that.\n\nI like the promise module, it has interesting possibilities in code writing.\n\nSo we're facing two issues - one is, inconsistent API.  The other asynchronous calls for amqp commands have explicit callback parameters in their parameter lists.  Except for Subscribe which does not.  And the other calls, which per a light code study of at least the queue bind case, do not provide the promise api as an alternative.  Giving us a collection of things, one or more of which is not like the other.  Ick.\n\nThe other is that the subscribe call is not appropriately documented.  The entire explanation of subscribe, what it does and what it returns, doesn't discuss the promise interface or its availability at all.  The example doesn't use it, the text doesn't mention it.\n\nSurely you don't think the documentation of another api point (unsubscribe in this case) is appropriate documentation location for the subcribe api?  In this case, it was a page-or-so down the screen, but this is a long docs file.  I even reloaded the github page to see if you were pulling my chain and just changing the subscribe docs while I wasn't looking then pretending it was there all along.\n\nSo the easiest one is to repair the documentation so that the available api of subscribe is fully documented in its _own_ documentation block... which would have prevented the entire amount of exploration and troubleshooting I've done to figure out why that's not the case.  I can submit a pull request for that I suspect.\n\nIt would add internal consistency to the library to modify the subscribe implementation with an optional final callback parameter which is merely conditionally added as a promise callback when supplied. I could probably put that in a pull too, as its fairly simple.\n\nThe ultimate in consistency would be to do both the first and second, AND modify the other api's to use the promise API for their callbacks too, revising the documentation to reflect their availability, making it consistently flexible in all cases.  But that's a pretty deep refactoring of this code... \n. You said \"With that method every basicConsume message will be sent on it's own queue.\" - did you mean 'its own channel'?\n. I thought I'd comment that I actually managed to be bitten by this loose coupling - attempt to bind to a queue in multiple ways in parallel (use the async module for the parallel semantic) and the callback of one is overwritten by the other, making only one queue bind callback actually get activated.\n. ",
    "jasonpincin": "Closing this, submitting another with improved documentation. (Missed optional callback arguments and emitted events in this version.)\n. Closing this, submitting another with improved documentation. (Missed optional callback arguments and emitted events in this version.)\n. ",
    "zeisss": "@postwait: I added a test case, but I am not sure if this follows the correct style.\n. Hi panosru,\n\nI'm not postwait, but maybe I can help :)\n\n1) `connection.publish` publishes to the default exchange (normally the nameless one you see in the management plugin), but this can be configured. The first parameter you provide here is the routing key, which is equal the queue name when using the default exchange.\n\n`exchange.publish` is more explicit and makes it possible to provide a routing key on an explicit exchange.\n\n2) I don't exactly understand.  What do you mean by commit?\n\n3) I don't understand this neither. Afaik there is no concept of a rollback in AMQP. Consumers can request an acknowledgement mode when subscribing to a queue. This has the effect that on connection loss, any unacknowledged message gets requeued. Can you detail you question a bit more?\n\n4) Subscribe to a queue and provide a message handler. The message handler will be invoked for every message deliverey to the consumer. This propably differs from php-amqplib, since node.js is aync by design.\n\n5) You can't. You can only subscribe and republish the messages, but this destroys the order of messages in the queue. If you are only interested in the length of a queue, you have several options:\n- the management plugin provides a status api\n- call `connection.queue` with the `passive:true` option to read the state of the queue.\n. @panossru Regarding 4+5) Afaik (I may be wrong), AMQP does not allow arbitrary (by message-id/all) access to the messages nor deleting specific messages. I guess you could write a plugin to allow that, but I don't know much of the plugin world.\n. I had to change your code a bit, but this works for me:\n\n```\namqp = require('amqp')\namqp.createConnection {url: \"amqp://guest:guest@localhost:5672\"}, (connection) ->\n    connection.exchange 'ldexchange', {type: 'direct', confirm: true, durable: true}, (exchange) ->\n```\n\nI received an error with your parameters to `createConnection`, but I have no idea if this is the error you see:\n\n```\nTypeError: Object.getOwnPropertyNames called on non-object\n    at Function.getOwnPropertyNames (native)\n    at mixin (..../node-amqp/amqp.js:39:14)\n    at Connection.setOptions (..../node-amqp/amqp.js:1020:3)\n    at new Connection (..../node-amqp/amqp.js:798:8)\n    at Object.exports.createConnection (..../node-amqp/amqp.js:1010:11)\n    at Object.<anonymous> (..../node-amqp/foo.coffee:6:8)\n    at Object.<anonymous> (..../node-amqp/foo.coffee:14:4)\n    at Module._compile (module.js:449:26)\n    at Object.exports.run (..../node_modules/coffee-script/lib/coffee-script/coffee-script.js:83:25)\n    at compileScript (..../node_modules/coffee-script/lib/coffee-script/command.js:177:29)\n```\n\nDid this help?\n. @postwait: I added a test case, but I am not sure if this follows the correct style.\n. Hi panosru,\n\nI'm not postwait, but maybe I can help :)\n\n1) `connection.publish` publishes to the default exchange (normally the nameless one you see in the management plugin), but this can be configured. The first parameter you provide here is the routing key, which is equal the queue name when using the default exchange.\n\n`exchange.publish` is more explicit and makes it possible to provide a routing key on an explicit exchange.\n\n2) I don't exactly understand.  What do you mean by commit?\n\n3) I don't understand this neither. Afaik there is no concept of a rollback in AMQP. Consumers can request an acknowledgement mode when subscribing to a queue. This has the effect that on connection loss, any unacknowledged message gets requeued. Can you detail you question a bit more?\n\n4) Subscribe to a queue and provide a message handler. The message handler will be invoked for every message deliverey to the consumer. This propably differs from php-amqplib, since node.js is aync by design.\n\n5) You can't. You can only subscribe and republish the messages, but this destroys the order of messages in the queue. If you are only interested in the length of a queue, you have several options:\n- the management plugin provides a status api\n- call `connection.queue` with the `passive:true` option to read the state of the queue.\n. @panossru Regarding 4+5) Afaik (I may be wrong), AMQP does not allow arbitrary (by message-id/all) access to the messages nor deleting specific messages. I guess you could write a plugin to allow that, but I don't know much of the plugin world.\n. I had to change your code a bit, but this works for me:\n\n```\namqp = require('amqp')\namqp.createConnection {url: \"amqp://guest:guest@localhost:5672\"}, (connection) ->\n    connection.exchange 'ldexchange', {type: 'direct', confirm: true, durable: true}, (exchange) ->\n```\n\nI received an error with your parameters to `createConnection`, but I have no idea if this is the error you see:\n\n```\nTypeError: Object.getOwnPropertyNames called on non-object\n    at Function.getOwnPropertyNames (native)\n    at mixin (..../node-amqp/amqp.js:39:14)\n    at Connection.setOptions (..../node-amqp/amqp.js:1020:3)\n    at new Connection (..../node-amqp/amqp.js:798:8)\n    at Object.exports.createConnection (..../node-amqp/amqp.js:1010:11)\n    at Object.<anonymous> (..../node-amqp/foo.coffee:6:8)\n    at Object.<anonymous> (..../node-amqp/foo.coffee:14:4)\n    at Module._compile (module.js:449:26)\n    at Object.exports.run (..../node_modules/coffee-script/lib/coffee-script/coffee-script.js:83:25)\n    at compileScript (..../node_modules/coffee-script/lib/coffee-script/command.js:177:29)\n```\n\nDid this help?\n. ",
    "MarioVerbelen": "nice,\n\nit was not clear in the documentation\n. nice,\n\nit was not clear in the documentation\n. ",
    "ethanmick": "Could you give an example as to how this should work?\n\nI've created a cluster locally on my computer (http://www.rabbitmq.com/clustering.html), and use this code to try and connect:\n\n`connection = amqp.createConnection [  \n{url: 'amqp://localhost', port: 5672, login: config.mq.user, password: config.mq.pass },\n{ url: 'amqp://localhost', port: 5673, login: config.mq.user, password: config.mq.pass },\n{ url: 'amqp://localhost', port: 5674, login: config.mq.user, password: config.mq.pass }\n]`\n\nThe username and password are the same for all the different brokers in the cluster, with only the port being different. When I connect, it connects to the first one on port 5672. But if I shut that one down in the cluster, I get `Error: Error: connect ECONNREFUSED`.\n\nHow should this work? Thanks!\n\n**Edit**\n\nLooking at the code, it appears as though the only option that is expected to be an Array is the _host_ option. However, how does this work if the host is the same, but the port is different (running a cluster on your own computer)? What would be best is if the library took in the \"url\" option as an Array, so all the options can be specified unique to each computer.\n. Just verified that with a coworker. Even with the \"()\" the connection is not ending as it should (Also took out destroy(), as we probably don't want that either.)\n. Passing in { reconnect: false } stops it from reconnecting - if we call .end(), would it still reconnect?\n. Could you give an example as to how this should work?\n\nI've created a cluster locally on my computer (http://www.rabbitmq.com/clustering.html), and use this code to try and connect:\n\n`connection = amqp.createConnection [  \n{url: 'amqp://localhost', port: 5672, login: config.mq.user, password: config.mq.pass },\n{ url: 'amqp://localhost', port: 5673, login: config.mq.user, password: config.mq.pass },\n{ url: 'amqp://localhost', port: 5674, login: config.mq.user, password: config.mq.pass }\n]`\n\nThe username and password are the same for all the different brokers in the cluster, with only the port being different. When I connect, it connects to the first one on port 5672. But if I shut that one down in the cluster, I get `Error: Error: connect ECONNREFUSED`.\n\nHow should this work? Thanks!\n\n**Edit**\n\nLooking at the code, it appears as though the only option that is expected to be an Array is the _host_ option. However, how does this work if the host is the same, but the port is different (running a cluster on your own computer)? What would be best is if the library took in the \"url\" option as an Array, so all the options can be specified unique to each computer.\n. Just verified that with a coworker. Even with the \"()\" the connection is not ending as it should (Also took out destroy(), as we probably don't want that either.)\n. Passing in { reconnect: false } stops it from reconnecting - if we call .end(), would it still reconnect?\n. ",
    "palmerabollo": "Receive a notification when the message is delivered (at least when the exchange is in confirm mode), so you can avoid this kind of tricks to end a connection before sending a message:\n\n```\n  conn.publish('myqueue', { foo: \"bar\" });\n  setTimeout(function () { conn.end(); }, 5000); // enough timeout\n```\n\nMaybe I am missing a better alternative to close the connection once the message is delivered.\n. Receive a notification when the message is delivered (at least when the exchange is in confirm mode), so you can avoid this kind of tricks to end a connection before sending a message:\n\n```\n  conn.publish('myqueue', { foo: \"bar\" });\n  setTimeout(function () { conn.end(); }, 5000); // enough timeout\n```\n\nMaybe I am missing a better alternative to close the connection once the message is delivered.\n. ",
    "rimassa": "It should call my callback passing failed=true so I can be noticed about the failure, right?\nThanks\n. It should call my callback passing failed=true so I can be noticed about the failure, right?\nThanks\n. ",
    "nekinie": "Confirmed in version 1.7 on node v0.10.21\n. FYI, our solution was to use the packaged release from Github and not the one on NPM, hope it helps\n. Confirmed in version 1.7 on node v0.10.21\n. FYI, our solution was to use the packaged release from Github and not the one on NPM, hope it helps\n. ",
    "stowns": "My callback is not called regardless of success or failure which is troublesome because I need to close the connection\n\n```\nconnect = AQMP.createConnection({ host : @host });\n    connect.on 'ready', ->\n      console.log 'RabbitMQProducer: READY'\n\n      connect.exchange _this.exchange, {type: 'direct', confirm:true}, (ex) ->\n        console.log 'RabbitMQProducer Exchange Open!'\n        ex.publish _this.key, JSON.stringify(message), {deliveryMode: 2}, (err) -> \n          # never called\n          console.log 'Calling Connect END!'\n          connect.end()\n```\n\n\"version\": \"0.1.7\"\n. Pulling the latest release https://github.com/postwait/node-amqp/releases/tag/v0.1.7 has no impact on the code I posted above.  The cb is fired from connection.publish() but not exchange.publish().  My workaround is to call connect.end() just after ex.publish rather than with-in the callback.  My concern is that in some cases the connection will close before ack'ing by the consumer takes place.\n. same issue here on 10.10. connection 'ready' is called\n. My callback is not called regardless of success or failure which is troublesome because I need to close the connection\n\n```\nconnect = AQMP.createConnection({ host : @host });\n    connect.on 'ready', ->\n      console.log 'RabbitMQProducer: READY'\n\n      connect.exchange _this.exchange, {type: 'direct', confirm:true}, (ex) ->\n        console.log 'RabbitMQProducer Exchange Open!'\n        ex.publish _this.key, JSON.stringify(message), {deliveryMode: 2}, (err) -> \n          # never called\n          console.log 'Calling Connect END!'\n          connect.end()\n```\n\n\"version\": \"0.1.7\"\n. Pulling the latest release https://github.com/postwait/node-amqp/releases/tag/v0.1.7 has no impact on the code I posted above.  The cb is fired from connection.publish() but not exchange.publish().  My workaround is to call connect.end() just after ex.publish rather than with-in the callback.  My concern is that in some cases the connection will close before ack'ing by the consumer takes place.\n. same issue here on 10.10. connection 'ready' is called\n. ",
    "jensbjork": "I can confirm that the callback does not seem to fire in connection.publish(...) nor in connection.exchange.publish(...). Running version 0.2.0 through npm.\n. +1\n. I've specified the git repo through npm as well but the problem still remains. What was the conclusion around this issue if not only to update to the latest repo?\n\nAll I really want to do is to close the connection when publishing to a queue. Simply calling connection.disconnect() outside a callback does not seem to terminate the connection, it is still visible as a running connection in rabbitmq.\n\n```\n  var raw_text          = req.param('text');\n  var from_identifier   = req.param('msisdn');\n  var timestamp         = req.param('message-timestamp');\n\n  if (raw_text && from_identifier && timestamp) {\n\n    app.conn = amqp.createConnection({\n      host: 'localhost',\n      login: '{{ rabbitmq_username }}',\n      password: '{{ rabbitmq_password }}',\n      connectionTimeout: 30000\n    });\n\n    app.conn.on('ready', function() {\n      console.log(\"Connected to RabbitMQ\");\n\n      app.e = app.conn.exchange('amq.fanout', { confirm: true });\n      app.q = app.conn.queue('events');\n\n      app.e.publish('', { raw_text: raw_text, from_identifier: from_identifier, timestamp: timestamp }, {}, function(status) {\n        console.log(\"Sent message and disconnecting\");\n        app.conn.disconnect();\n      });\n\n    });\n  }\n```\n\nAre there any alternative methods that can be used in order to achieve this? All input is highly appriciated!\n. I can confirm that the callback does not seem to fire in connection.publish(...) nor in connection.exchange.publish(...). Running version 0.2.0 through npm.\n. +1\n. I've specified the git repo through npm as well but the problem still remains. What was the conclusion around this issue if not only to update to the latest repo?\n\nAll I really want to do is to close the connection when publishing to a queue. Simply calling connection.disconnect() outside a callback does not seem to terminate the connection, it is still visible as a running connection in rabbitmq.\n\n```\n  var raw_text          = req.param('text');\n  var from_identifier   = req.param('msisdn');\n  var timestamp         = req.param('message-timestamp');\n\n  if (raw_text && from_identifier && timestamp) {\n\n    app.conn = amqp.createConnection({\n      host: 'localhost',\n      login: '{{ rabbitmq_username }}',\n      password: '{{ rabbitmq_password }}',\n      connectionTimeout: 30000\n    });\n\n    app.conn.on('ready', function() {\n      console.log(\"Connected to RabbitMQ\");\n\n      app.e = app.conn.exchange('amq.fanout', { confirm: true });\n      app.q = app.conn.queue('events');\n\n      app.e.publish('', { raw_text: raw_text, from_identifier: from_identifier, timestamp: timestamp }, {}, function(status) {\n        console.log(\"Sent message and disconnecting\");\n        app.conn.disconnect();\n      });\n\n    });\n  }\n```\n\nAre there any alternative methods that can be used in order to achieve this? All input is highly appriciated!\n. ",
    "panosru": "@ZeissS\n\nThanks a lot for your reply!\n\n1) Ok I got that ;) I'll stick with `exchange.publish` :)\n\n2) 3) By commit I mean in case a transaction does not fail to perform a commit that would actually remove the messages from queue. By rollback I mean, in case of transaction failuter to \"rollback\" to previous state before the start of transaction but since @postwait confirmed that transaction support is not yet implemented so is not possible to rollback. [PHP AMQPChannel](http://php.net/manual/en/class.amqpchannel.php) [RabbitMQ Broker Semantics](http://www.rabbitmq.com/semantics.html) :) \n\n4) Would you mind to provide a simple example in order to get the point? Messages in PHP also work async, of course PHP itself is not async by design.\n\n5) If you don't set auto delete for messages and for any reason you need to know not only how many messages are in the queue but you need to iterate through them is not possible? Would be great if you could have an array of objects where each object would be a message object.\n\nOne more question I forgot to ask, is it possible to get a message from queue? For instance:\n\n``` js\nvar amqp = require('amqp');\n\nvar connection = amqp.createConnection({ host: 'dev.rabbitmq.com' });\n\n// Wait for connection to become established.\nconnection.on('ready', function () {\n  // Use the default 'amq.topic' exchange\n  connection.queue('my-queue', function(q){\n      // Get message by message id (Sync)\n      var message = q.get('message-id-here');\n\n      // Get message by message id (Async)\n      q.get('message-id-here', function (err, message) {\n           if (err) { \n               // Handle error in case message does not exist \n            } else {\n              // Do anything with message\n           }\n      });\n  });\n});\n```\n\n@postwait Thanks for clarifying that transactions are not yet supported, are there any plans to support them?\n\nThanks a lot to everyone :)\n. @ZeissS\n\nThanks a lot for your reply!\n\n1) Ok I got that ;) I'll stick with `exchange.publish` :)\n\n2) 3) By commit I mean in case a transaction does not fail to perform a commit that would actually remove the messages from queue. By rollback I mean, in case of transaction failuter to \"rollback\" to previous state before the start of transaction but since @postwait confirmed that transaction support is not yet implemented so is not possible to rollback. [PHP AMQPChannel](http://php.net/manual/en/class.amqpchannel.php) [RabbitMQ Broker Semantics](http://www.rabbitmq.com/semantics.html) :) \n\n4) Would you mind to provide a simple example in order to get the point? Messages in PHP also work async, of course PHP itself is not async by design.\n\n5) If you don't set auto delete for messages and for any reason you need to know not only how many messages are in the queue but you need to iterate through them is not possible? Would be great if you could have an array of objects where each object would be a message object.\n\nOne more question I forgot to ask, is it possible to get a message from queue? For instance:\n\n``` js\nvar amqp = require('amqp');\n\nvar connection = amqp.createConnection({ host: 'dev.rabbitmq.com' });\n\n// Wait for connection to become established.\nconnection.on('ready', function () {\n  // Use the default 'amq.topic' exchange\n  connection.queue('my-queue', function(q){\n      // Get message by message id (Sync)\n      var message = q.get('message-id-here');\n\n      // Get message by message id (Async)\n      q.get('message-id-here', function (err, message) {\n           if (err) { \n               // Handle error in case message does not exist \n            } else {\n              // Do anything with message\n           }\n      });\n  });\n});\n```\n\n@postwait Thanks for clarifying that transactions are not yet supported, are there any plans to support them?\n\nThanks a lot to everyone :)\n. ",
    "jus101": "Btw, my workaround for now:\n\n``` javascript\nthis.connection.options.heartbeat = 0;\nthis.connection._outboundHeartbeatTimerReset();\nthis.connection._inboundHeartbeatTimerReset();\nthis.connection.end();\n```\n. Btw, my workaround for now:\n\n``` javascript\nthis.connection.options.heartbeat = 0;\nthis.connection._outboundHeartbeatTimerReset();\nthis.connection._inboundHeartbeatTimerReset();\nthis.connection.end();\n```\n. ",
    "TheDeveloper": "I'm seeing this problem too.\n\nIt appears to happen when you try to declare an exchange in the same tick of the event loop as the readyCallback is called.\n\nThis is the debug output I get when running into this issue:\n\n```\nmaking non-ssl connection\nsetting connection timeout to 10000\nInitiating handshake...\nconnected so resetting connection timeout\nexecute: 0100000000014a000a000a0009000001250c6361706162696c69746965734600000058127075626c69736865725f636f6e6669726d7374011a65786368616e67655f65786368616e67655f62696e64696e677374010a62617369632e6e61636b740116636f6e73756d65725f63616e63656c5f6e6f74696679740109636f707972696768745300000027436f707972696768742028432920323030372d3230313320476f5069766f74616c2c20496e632e0b696e666f726d6174696f6e53000000354c6963656e73656420756e64657220746865204d504c2e202053656520687474703a2f2f7777772e7261626269746d712e636f6d2f08706c6174666f726d530000000a45726c616e672f4f54500770726f6475637453000000085261626269744d510776657273696f6e5300000005332e312e350000000e414d51504c41494e20504c41494e00000005656e5f5553ce\nExecuting method 0 { name: 'connectionStart',\n  fields:\n   [ { name: 'versionMajor', domain: 'octet' },\n     { name: 'versionMinor', domain: 'octet' },\n     { name: 'serverProperties', domain: 'table' },\n     { name: 'mechanisms', domain: 'longstr' },\n     { name: 'locales', domain: 'longstr' } ],\n  methodIndex: 10,\n  classIndex: 10 } { versionMajor: 0,\n  versionMinor: 9,\n  serverProperties:\n   { capabilities:\n      { publisher_confirms: true,\n        exchange_exchange_bindings: true,\n        'basic.nack': true,\n        consumer_cancel_notify: true },\n     copyright: 'Copyright (C) 2007-2013 GoPivotal, Inc.',\n     information: 'Licensed under the MPL.  See http://www.rabbitmq.com/',\n     platform: 'Erlang/OTP',\n     product: 'RabbitMQ',\n     version: '3.1.5' },\n  mechanisms: 'AMQPLAIN PLAIN',\n  locales: 'en_US' }\n0 > connectionStart {\"versionMajor\":0,\"versionMinor\":9,\"serverProperties\":{\"capabilities\":{\"publisher_confirms\":true,\"exchange_exchange_bindings\":true,\"basic.nack\":true,\"consumer_cancel_notify\":true},\"copyright\":\"Copyright (C) 2007-2013 GoPivotal, Inc.\",\"information\":\"Licensed under the MPL.  See http://www.rabbitmq.com/\",\"platform\":\"Erlang/OTP\",\"product\":\"RabbitMQ\",\"version\":\"3.1.5\"},\"mechanisms\":\"AMQPLAIN PLAIN\",\"locales\":\"en_US\"}\n0 < connectionStartOk {\"clientProperties\":{\"version\":\"0.2.0\",\"platform\":\"node-v0.10.26\",\"product\":\"node-amqp\"},\"mechanism\":\"AMQPLAIN\",\"response\":{\"LOGIN\":\"guest\",\"PASSWORD\":\"guest\"},\"locale\":\"en_US\"}\nsending frame: 1,0,0,0,0,0,129,0,10,0,11,0,0,0,67,7,118,101,114,115,105,111,110,83,0,0,0,5,48,46,50,46,48,8,112,108,97,116,102,111,114,109,83,0,0,0,13,110,111,100,101,45,118,48,46,49,48,46,50,54,7,112,114,111,100,117,99,116,83,0,0,0,9,110,111,100,101,45,97,109,113,112,8,65,77,81,80,76,65,73,78,0,0,0,35,5,76,79,71,73,78,83,0,0,0,5,103,117,101,115,116,8,80,65,83,83,87,79,82,68,83,0,0,0,5,103,117,101,115,116,5,101,110,95,85,83,206\nexecute: 0100000000000c000a001e0000000200000258ce\nExecuting method 0 { name: 'connectionTune',\n  fields:\n   [ { name: 'channelMax', domain: 'short' },\n     { name: 'frameMax', domain: 'long' },\n     { name: 'heartbeat', domain: 'short' } ],\n  methodIndex: 30,\n  classIndex: 10 } { channelMax: 0, frameMax: 131072, heartbeat: 600 }\n0 > connectionTune {\"channelMax\":0,\"frameMax\":131072,\"heartbeat\":600}\ntweaking maxFrameBuffer to 131072\n0 < connectionTuneOk {\"channelMax\":0,\"frameMax\":131072,\"heartbeat\":0}\nsending frame: 1,0,0,0,0,0,12,0,10,0,31,0,0,0,2,0,0,0,0,206\n0 < connectionOpen {\"virtualHost\":\"/\",\"reserved1\":\"\",\"reserved2\":true}\nsending frame: 1,0,0,0,0,0,8,0,10,0,40,1,47,0,1,206\nexecute: 01000000000005000a002900ce\nExecuting method 0 { name: 'connectionOpenOk',\n  fields: [ { name: 'reserved1', domain: 'shortstr' } ],\n  methodIndex: 41,\n  classIndex: 10 } { reserved1: '' }\n0 > connectionOpenOk {\"reserved1\":\"\"}\n1 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,1,0,0,0,5,0,20,0,10,0,206\n2 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,2,0,0,0,5,0,20,0,10,0,206\n1 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,1,0,0,0,5,0,20,0,10,0,206\n2 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,2,0,0,0,5,0,20,0,10,0,206\n3 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,3,0,0,0,5,0,20,0,10,0,206\n4 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,4,0,0,0,5,0,20,0,10,0,206\nexecute: 010001000000080014000b00000000ce010002000000080014000b00000000ce01000000000037000a003201f72c434f4d4d414e445f494e56414c4944202d207365636f6e6420276368616e6e656c2e6f70656e27207365656e0014000ace\nExecuting method 1 { name: 'channelOpenOk',\n  fields: [ { name: 'reserved1', domain: 'longstr' } ],\n  methodIndex: 11,\n  classIndex: 20 } { reserved1: '' }\n1 > channelOpenOk {\"reserved1\":\"\"}\n1 < exchangeDeclare {\"reserved1\":0,\"reserved2\":false,\"reserved3\":false,\"exchange\":\"counters\",\"type\":\"topic\",\"passive\":false,\"durable\":true,\"autoDelete\":false,\"internal\":false,\"noWait\":false,\"arguments\":{}}\nsending frame: 1,0,1,0,0,0,26,0,40,0,10,0,0,8,99,111,117,110,116,101,114,115,5,116,111,112,105,99,2,0,0,0,0,206\nExecuting method 2 { name: 'channelOpenOk',\n  fields: [ { name: 'reserved1', domain: 'longstr' } ],\n  methodIndex: 11,\n  classIndex: 20 } { reserved1: '' }\n2 > channelOpenOk {\"reserved1\":\"\"}\n2 < exchangeDeclare {\"reserved1\":0,\"reserved2\":false,\"reserved3\":false,\"exchange\":\"pageview\",\"type\":\"topic\",\"passive\":false,\"durable\":true,\"autoDelete\":false,\"internal\":false,\"noWait\":false,\"arguments\":{}}\nsending frame: 1,0,2,0,0,0,26,0,40,0,10,0,0,8,112,97,103,101,118,105,101,119,5,116,111,112,105,99,2,0,0,0,0,206\nExecuting method 0 { name: 'connectionClose',\n  fields:\n   [ { name: 'replyCode', domain: 'short' },\n     { name: 'replyText', domain: 'shortstr' },\n     { name: 'classId', domain: 'short' },\n     { name: 'methodId', domain: 'short' } ],\n  methodIndex: 50,\n  classIndex: 10 } { replyCode: 503,\n  replyText: 'COMMAND_INVALID - second \\'channel.open\\' seen',\n  classId: 20,\n  methodId: 10 }\n0 > connectionClose {\"replyCode\":503,\"replyText\":\"COMMAND_INVALID - second 'channel.open' seen\",\"classId\":20,\"methodId\":10}\nerror: amqp error code=503\n```\n\nFor the time being I've worked around this by wrapping code in the ready callback in a setImmediate(). It seems running on the next tick helps avoid the issue. Here's the debug output for that:\n\n```\nmaking non-ssl connection\nsetting connection timeout to 10000\nInitiating handshake...\nconnected so resetting connection timeout\nexecute: 0100000000014a000a000a0009000001250c6361706162696c69746965734600000058127075626c69736865725f636f6e6669726d7374011a65786368616e67655f65786368616e67655f62696e64696e677374010a62617369632e6e61636b740116636f6e73756d65725f63616e63656c5f6e6f74696679740109636f707972696768745300000027436f707972696768742028432920323030372d3230313320476f5069766f74616c2c20496e632e0b696e666f726d6174696f6e53000000354c6963656e73656420756e64657220746865204d504c2e202053656520687474703a2f2f7777772e7261626269746d712e636f6d2f08706c6174666f726d530000000a45726c616e672f4f54500770726f6475637453000000085261626269744d510776657273696f6e5300000005332e312e350000000e414d51504c41494e20504c41494e00000005656e5f5553ce\nExecuting method 0 { name: 'connectionStart',\n  fields:\n   [ { name: 'versionMajor', domain: 'octet' },\n     { name: 'versionMinor', domain: 'octet' },\n     { name: 'serverProperties', domain: 'table' },\n     { name: 'mechanisms', domain: 'longstr' },\n     { name: 'locales', domain: 'longstr' } ],\n  methodIndex: 10,\n  classIndex: 10 } { versionMajor: 0,\n  versionMinor: 9,\n  serverProperties:\n   { capabilities:\n      { publisher_confirms: true,\n        exchange_exchange_bindings: true,\n        'basic.nack': true,\n        consumer_cancel_notify: true },\n     copyright: 'Copyright (C) 2007-2013 GoPivotal, Inc.',\n     information: 'Licensed under the MPL.  See http://www.rabbitmq.com/',\n     platform: 'Erlang/OTP',\n     product: 'RabbitMQ',\n     version: '3.1.5' },\n  mechanisms: 'AMQPLAIN PLAIN',\n  locales: 'en_US' }\n0 > connectionStart {\"versionMajor\":0,\"versionMinor\":9,\"serverProperties\":{\"capabilities\":{\"publisher_confirms\":true,\"exchange_exchange_bindings\":true,\"basic.nack\":true,\"consumer_cancel_notify\":true},\"copyright\":\"Copyright (C) 2007-2013 GoPivotal, Inc.\",\"information\":\"Licensed under the MPL.  See http://www.rabbitmq.com/\",\"platform\":\"Erlang/OTP\",\"product\":\"RabbitMQ\",\"version\":\"3.1.5\"},\"mechanisms\":\"AMQPLAIN PLAIN\",\"locales\":\"en_US\"}\n0 < connectionStartOk {\"clientProperties\":{\"version\":\"0.2.0\",\"platform\":\"node-v0.10.26\",\"product\":\"node-amqp\"},\"mechanism\":\"AMQPLAIN\",\"response\":{\"LOGIN\":\"guest\",\"PASSWORD\":\"guest\"},\"locale\":\"en_US\"}\nsending frame: 1,0,0,0,0,0,129,0,10,0,11,0,0,0,67,7,118,101,114,115,105,111,110,83,0,0,0,5,48,46,50,46,48,8,112,108,97,116,102,111,114,109,83,0,0,0,13,110,111,100,101,45,118,48,46,49,48,46,50,54,7,112,114,111,100,117,99,116,83,0,0,0,9,110,111,100,101,45,97,109,113,112,8,65,77,81,80,76,65,73,78,0,0,0,35,5,76,79,71,73,78,83,0,0,0,5,103,117,101,115,116,8,80,65,83,83,87,79,82,68,83,0,0,0,5,103,117,101,115,116,5,101,110,95,85,83,206\nexecute: 0100000000000c000a001e0000000200000258ce\nExecuting method 0 { name: 'connectionTune',\n  fields:\n   [ { name: 'channelMax', domain: 'short' },\n     { name: 'frameMax', domain: 'long' },\n     { name: 'heartbeat', domain: 'short' } ],\n  methodIndex: 30,\n  classIndex: 10 } { channelMax: 0, frameMax: 131072, heartbeat: 600 }\n0 > connectionTune {\"channelMax\":0,\"frameMax\":131072,\"heartbeat\":600}\ntweaking maxFrameBuffer to 131072\n0 < connectionTuneOk {\"channelMax\":0,\"frameMax\":131072,\"heartbeat\":0}\nsending frame: 1,0,0,0,0,0,12,0,10,0,31,0,0,0,2,0,0,0,0,206\n0 < connectionOpen {\"virtualHost\":\"/\",\"reserved1\":\"\",\"reserved2\":true}\nsending frame: 1,0,0,0,0,0,8,0,10,0,40,1,47,0,1,206\nexecute: 01000000000005000a002900ce\nExecuting method 0 { name: 'connectionOpenOk',\n  fields: [ { name: 'reserved1', domain: 'shortstr' } ],\n  methodIndex: 41,\n  classIndex: 10 } { reserved1: '' }\n0 > connectionOpenOk {\"reserved1\":\"\"}\n1 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,1,0,0,0,5,0,20,0,10,0,206\n2 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,2,0,0,0,5,0,20,0,10,0,206\nexecute: 010001000000080014000b00000000ce\nExecuting method 1 { name: 'channelOpenOk',\n  fields: [ { name: 'reserved1', domain: 'longstr' } ],\n  methodIndex: 11,\n  classIndex: 20 } { reserved1: '' }\n1 > channelOpenOk {\"reserved1\":\"\"}\n1 < exchangeDeclare {\"reserved1\":0,\"reserved2\":false,\"reserved3\":false,\"exchange\":\"counters\",\"type\":\"topic\",\"passive\":false,\"durable\":true,\"autoDelete\":false,\"internal\":false,\"noWait\":false,\"arguments\":{}}\nsending frame: 1,0,1,0,0,0,26,0,40,0,10,0,0,8,99,111,117,110,116,101,114,115,5,116,111,112,105,99,2,0,0,0,0,206\nexecute: 010002000000080014000b00000000ce\nExecuting method 2 { name: 'channelOpenOk',\n  fields: [ { name: 'reserved1', domain: 'longstr' } ],\n  methodIndex: 11,\n  classIndex: 20 } { reserved1: '' }\n2 > channelOpenOk {\"reserved1\":\"\"}\n2 < exchangeDeclare {\"reserved1\":0,\"reserved2\":false,\"reserved3\":false,\"exchange\":\"pageview\",\"type\":\"topic\",\"passive\":false,\"durable\":true,\"autoDelete\":false,\"internal\":false,\"noWait\":false,\"arguments\":{}}\nsending frame: 1,0,2,0,0,0,26,0,40,0,10,0,0,8,112,97,103,101,118,105,101,119,5,116,111,112,105,99,2,0,0,0,0,206\nexecute: 010001000000040028000bce\nExecuting method 1 { name: 'exchangeDeclareOk',\n  fields: [],\n  methodIndex: 11,\n  classIndex: 40 } {}\n1 > exchangeDeclareOk {}\nexecute: 010002000000040028000bce\nExecuting method 2 { name: 'exchangeDeclareOk',\n  fields: [],\n  methodIndex: 11,\n  classIndex: 40 } {}\n2 > exchangeDeclareOk {}\n```\n. This happens because the ready events and optional ready callback are executed in the same stack as the parser's onMethod. The parser is wrapped by a try/catch block, catching any exceptions from this stack, including the user's event listeners and readyCallback.\n\nIf you want to let your program crash, a workaround for now would be to disable `reconnect` in the options, and avoid listening on any `'error'` events. Of course the downside is that since errors between module and user functions are not distinguished, you would lose all graceful error control.\n\nTo address the actual issue, we need to differentiate between an exception originating from a user function vs exceptions from the parser. We could invoke the user functions inside their own try/catch and ideally bind them to `process.domain` if existent. If not, we could re-throw the exception.\n. I'm seeing this problem too.\n\nIt appears to happen when you try to declare an exchange in the same tick of the event loop as the readyCallback is called.\n\nThis is the debug output I get when running into this issue:\n\n```\nmaking non-ssl connection\nsetting connection timeout to 10000\nInitiating handshake...\nconnected so resetting connection timeout\nexecute: 0100000000014a000a000a0009000001250c6361706162696c69746965734600000058127075626c69736865725f636f6e6669726d7374011a65786368616e67655f65786368616e67655f62696e64696e677374010a62617369632e6e61636b740116636f6e73756d65725f63616e63656c5f6e6f74696679740109636f707972696768745300000027436f707972696768742028432920323030372d3230313320476f5069766f74616c2c20496e632e0b696e666f726d6174696f6e53000000354c6963656e73656420756e64657220746865204d504c2e202053656520687474703a2f2f7777772e7261626269746d712e636f6d2f08706c6174666f726d530000000a45726c616e672f4f54500770726f6475637453000000085261626269744d510776657273696f6e5300000005332e312e350000000e414d51504c41494e20504c41494e00000005656e5f5553ce\nExecuting method 0 { name: 'connectionStart',\n  fields:\n   [ { name: 'versionMajor', domain: 'octet' },\n     { name: 'versionMinor', domain: 'octet' },\n     { name: 'serverProperties', domain: 'table' },\n     { name: 'mechanisms', domain: 'longstr' },\n     { name: 'locales', domain: 'longstr' } ],\n  methodIndex: 10,\n  classIndex: 10 } { versionMajor: 0,\n  versionMinor: 9,\n  serverProperties:\n   { capabilities:\n      { publisher_confirms: true,\n        exchange_exchange_bindings: true,\n        'basic.nack': true,\n        consumer_cancel_notify: true },\n     copyright: 'Copyright (C) 2007-2013 GoPivotal, Inc.',\n     information: 'Licensed under the MPL.  See http://www.rabbitmq.com/',\n     platform: 'Erlang/OTP',\n     product: 'RabbitMQ',\n     version: '3.1.5' },\n  mechanisms: 'AMQPLAIN PLAIN',\n  locales: 'en_US' }\n0 > connectionStart {\"versionMajor\":0,\"versionMinor\":9,\"serverProperties\":{\"capabilities\":{\"publisher_confirms\":true,\"exchange_exchange_bindings\":true,\"basic.nack\":true,\"consumer_cancel_notify\":true},\"copyright\":\"Copyright (C) 2007-2013 GoPivotal, Inc.\",\"information\":\"Licensed under the MPL.  See http://www.rabbitmq.com/\",\"platform\":\"Erlang/OTP\",\"product\":\"RabbitMQ\",\"version\":\"3.1.5\"},\"mechanisms\":\"AMQPLAIN PLAIN\",\"locales\":\"en_US\"}\n0 < connectionStartOk {\"clientProperties\":{\"version\":\"0.2.0\",\"platform\":\"node-v0.10.26\",\"product\":\"node-amqp\"},\"mechanism\":\"AMQPLAIN\",\"response\":{\"LOGIN\":\"guest\",\"PASSWORD\":\"guest\"},\"locale\":\"en_US\"}\nsending frame: 1,0,0,0,0,0,129,0,10,0,11,0,0,0,67,7,118,101,114,115,105,111,110,83,0,0,0,5,48,46,50,46,48,8,112,108,97,116,102,111,114,109,83,0,0,0,13,110,111,100,101,45,118,48,46,49,48,46,50,54,7,112,114,111,100,117,99,116,83,0,0,0,9,110,111,100,101,45,97,109,113,112,8,65,77,81,80,76,65,73,78,0,0,0,35,5,76,79,71,73,78,83,0,0,0,5,103,117,101,115,116,8,80,65,83,83,87,79,82,68,83,0,0,0,5,103,117,101,115,116,5,101,110,95,85,83,206\nexecute: 0100000000000c000a001e0000000200000258ce\nExecuting method 0 { name: 'connectionTune',\n  fields:\n   [ { name: 'channelMax', domain: 'short' },\n     { name: 'frameMax', domain: 'long' },\n     { name: 'heartbeat', domain: 'short' } ],\n  methodIndex: 30,\n  classIndex: 10 } { channelMax: 0, frameMax: 131072, heartbeat: 600 }\n0 > connectionTune {\"channelMax\":0,\"frameMax\":131072,\"heartbeat\":600}\ntweaking maxFrameBuffer to 131072\n0 < connectionTuneOk {\"channelMax\":0,\"frameMax\":131072,\"heartbeat\":0}\nsending frame: 1,0,0,0,0,0,12,0,10,0,31,0,0,0,2,0,0,0,0,206\n0 < connectionOpen {\"virtualHost\":\"/\",\"reserved1\":\"\",\"reserved2\":true}\nsending frame: 1,0,0,0,0,0,8,0,10,0,40,1,47,0,1,206\nexecute: 01000000000005000a002900ce\nExecuting method 0 { name: 'connectionOpenOk',\n  fields: [ { name: 'reserved1', domain: 'shortstr' } ],\n  methodIndex: 41,\n  classIndex: 10 } { reserved1: '' }\n0 > connectionOpenOk {\"reserved1\":\"\"}\n1 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,1,0,0,0,5,0,20,0,10,0,206\n2 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,2,0,0,0,5,0,20,0,10,0,206\n1 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,1,0,0,0,5,0,20,0,10,0,206\n2 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,2,0,0,0,5,0,20,0,10,0,206\n3 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,3,0,0,0,5,0,20,0,10,0,206\n4 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,4,0,0,0,5,0,20,0,10,0,206\nexecute: 010001000000080014000b00000000ce010002000000080014000b00000000ce01000000000037000a003201f72c434f4d4d414e445f494e56414c4944202d207365636f6e6420276368616e6e656c2e6f70656e27207365656e0014000ace\nExecuting method 1 { name: 'channelOpenOk',\n  fields: [ { name: 'reserved1', domain: 'longstr' } ],\n  methodIndex: 11,\n  classIndex: 20 } { reserved1: '' }\n1 > channelOpenOk {\"reserved1\":\"\"}\n1 < exchangeDeclare {\"reserved1\":0,\"reserved2\":false,\"reserved3\":false,\"exchange\":\"counters\",\"type\":\"topic\",\"passive\":false,\"durable\":true,\"autoDelete\":false,\"internal\":false,\"noWait\":false,\"arguments\":{}}\nsending frame: 1,0,1,0,0,0,26,0,40,0,10,0,0,8,99,111,117,110,116,101,114,115,5,116,111,112,105,99,2,0,0,0,0,206\nExecuting method 2 { name: 'channelOpenOk',\n  fields: [ { name: 'reserved1', domain: 'longstr' } ],\n  methodIndex: 11,\n  classIndex: 20 } { reserved1: '' }\n2 > channelOpenOk {\"reserved1\":\"\"}\n2 < exchangeDeclare {\"reserved1\":0,\"reserved2\":false,\"reserved3\":false,\"exchange\":\"pageview\",\"type\":\"topic\",\"passive\":false,\"durable\":true,\"autoDelete\":false,\"internal\":false,\"noWait\":false,\"arguments\":{}}\nsending frame: 1,0,2,0,0,0,26,0,40,0,10,0,0,8,112,97,103,101,118,105,101,119,5,116,111,112,105,99,2,0,0,0,0,206\nExecuting method 0 { name: 'connectionClose',\n  fields:\n   [ { name: 'replyCode', domain: 'short' },\n     { name: 'replyText', domain: 'shortstr' },\n     { name: 'classId', domain: 'short' },\n     { name: 'methodId', domain: 'short' } ],\n  methodIndex: 50,\n  classIndex: 10 } { replyCode: 503,\n  replyText: 'COMMAND_INVALID - second \\'channel.open\\' seen',\n  classId: 20,\n  methodId: 10 }\n0 > connectionClose {\"replyCode\":503,\"replyText\":\"COMMAND_INVALID - second 'channel.open' seen\",\"classId\":20,\"methodId\":10}\nerror: amqp error code=503\n```\n\nFor the time being I've worked around this by wrapping code in the ready callback in a setImmediate(). It seems running on the next tick helps avoid the issue. Here's the debug output for that:\n\n```\nmaking non-ssl connection\nsetting connection timeout to 10000\nInitiating handshake...\nconnected so resetting connection timeout\nexecute: 0100000000014a000a000a0009000001250c6361706162696c69746965734600000058127075626c69736865725f636f6e6669726d7374011a65786368616e67655f65786368616e67655f62696e64696e677374010a62617369632e6e61636b740116636f6e73756d65725f63616e63656c5f6e6f74696679740109636f707972696768745300000027436f707972696768742028432920323030372d3230313320476f5069766f74616c2c20496e632e0b696e666f726d6174696f6e53000000354c6963656e73656420756e64657220746865204d504c2e202053656520687474703a2f2f7777772e7261626269746d712e636f6d2f08706c6174666f726d530000000a45726c616e672f4f54500770726f6475637453000000085261626269744d510776657273696f6e5300000005332e312e350000000e414d51504c41494e20504c41494e00000005656e5f5553ce\nExecuting method 0 { name: 'connectionStart',\n  fields:\n   [ { name: 'versionMajor', domain: 'octet' },\n     { name: 'versionMinor', domain: 'octet' },\n     { name: 'serverProperties', domain: 'table' },\n     { name: 'mechanisms', domain: 'longstr' },\n     { name: 'locales', domain: 'longstr' } ],\n  methodIndex: 10,\n  classIndex: 10 } { versionMajor: 0,\n  versionMinor: 9,\n  serverProperties:\n   { capabilities:\n      { publisher_confirms: true,\n        exchange_exchange_bindings: true,\n        'basic.nack': true,\n        consumer_cancel_notify: true },\n     copyright: 'Copyright (C) 2007-2013 GoPivotal, Inc.',\n     information: 'Licensed under the MPL.  See http://www.rabbitmq.com/',\n     platform: 'Erlang/OTP',\n     product: 'RabbitMQ',\n     version: '3.1.5' },\n  mechanisms: 'AMQPLAIN PLAIN',\n  locales: 'en_US' }\n0 > connectionStart {\"versionMajor\":0,\"versionMinor\":9,\"serverProperties\":{\"capabilities\":{\"publisher_confirms\":true,\"exchange_exchange_bindings\":true,\"basic.nack\":true,\"consumer_cancel_notify\":true},\"copyright\":\"Copyright (C) 2007-2013 GoPivotal, Inc.\",\"information\":\"Licensed under the MPL.  See http://www.rabbitmq.com/\",\"platform\":\"Erlang/OTP\",\"product\":\"RabbitMQ\",\"version\":\"3.1.5\"},\"mechanisms\":\"AMQPLAIN PLAIN\",\"locales\":\"en_US\"}\n0 < connectionStartOk {\"clientProperties\":{\"version\":\"0.2.0\",\"platform\":\"node-v0.10.26\",\"product\":\"node-amqp\"},\"mechanism\":\"AMQPLAIN\",\"response\":{\"LOGIN\":\"guest\",\"PASSWORD\":\"guest\"},\"locale\":\"en_US\"}\nsending frame: 1,0,0,0,0,0,129,0,10,0,11,0,0,0,67,7,118,101,114,115,105,111,110,83,0,0,0,5,48,46,50,46,48,8,112,108,97,116,102,111,114,109,83,0,0,0,13,110,111,100,101,45,118,48,46,49,48,46,50,54,7,112,114,111,100,117,99,116,83,0,0,0,9,110,111,100,101,45,97,109,113,112,8,65,77,81,80,76,65,73,78,0,0,0,35,5,76,79,71,73,78,83,0,0,0,5,103,117,101,115,116,8,80,65,83,83,87,79,82,68,83,0,0,0,5,103,117,101,115,116,5,101,110,95,85,83,206\nexecute: 0100000000000c000a001e0000000200000258ce\nExecuting method 0 { name: 'connectionTune',\n  fields:\n   [ { name: 'channelMax', domain: 'short' },\n     { name: 'frameMax', domain: 'long' },\n     { name: 'heartbeat', domain: 'short' } ],\n  methodIndex: 30,\n  classIndex: 10 } { channelMax: 0, frameMax: 131072, heartbeat: 600 }\n0 > connectionTune {\"channelMax\":0,\"frameMax\":131072,\"heartbeat\":600}\ntweaking maxFrameBuffer to 131072\n0 < connectionTuneOk {\"channelMax\":0,\"frameMax\":131072,\"heartbeat\":0}\nsending frame: 1,0,0,0,0,0,12,0,10,0,31,0,0,0,2,0,0,0,0,206\n0 < connectionOpen {\"virtualHost\":\"/\",\"reserved1\":\"\",\"reserved2\":true}\nsending frame: 1,0,0,0,0,0,8,0,10,0,40,1,47,0,1,206\nexecute: 01000000000005000a002900ce\nExecuting method 0 { name: 'connectionOpenOk',\n  fields: [ { name: 'reserved1', domain: 'shortstr' } ],\n  methodIndex: 41,\n  classIndex: 10 } { reserved1: '' }\n0 > connectionOpenOk {\"reserved1\":\"\"}\n1 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,1,0,0,0,5,0,20,0,10,0,206\n2 < channelOpen {\"reserved1\":\"\"}\nsending frame: 1,0,2,0,0,0,5,0,20,0,10,0,206\nexecute: 010001000000080014000b00000000ce\nExecuting method 1 { name: 'channelOpenOk',\n  fields: [ { name: 'reserved1', domain: 'longstr' } ],\n  methodIndex: 11,\n  classIndex: 20 } { reserved1: '' }\n1 > channelOpenOk {\"reserved1\":\"\"}\n1 < exchangeDeclare {\"reserved1\":0,\"reserved2\":false,\"reserved3\":false,\"exchange\":\"counters\",\"type\":\"topic\",\"passive\":false,\"durable\":true,\"autoDelete\":false,\"internal\":false,\"noWait\":false,\"arguments\":{}}\nsending frame: 1,0,1,0,0,0,26,0,40,0,10,0,0,8,99,111,117,110,116,101,114,115,5,116,111,112,105,99,2,0,0,0,0,206\nexecute: 010002000000080014000b00000000ce\nExecuting method 2 { name: 'channelOpenOk',\n  fields: [ { name: 'reserved1', domain: 'longstr' } ],\n  methodIndex: 11,\n  classIndex: 20 } { reserved1: '' }\n2 > channelOpenOk {\"reserved1\":\"\"}\n2 < exchangeDeclare {\"reserved1\":0,\"reserved2\":false,\"reserved3\":false,\"exchange\":\"pageview\",\"type\":\"topic\",\"passive\":false,\"durable\":true,\"autoDelete\":false,\"internal\":false,\"noWait\":false,\"arguments\":{}}\nsending frame: 1,0,2,0,0,0,26,0,40,0,10,0,0,8,112,97,103,101,118,105,101,119,5,116,111,112,105,99,2,0,0,0,0,206\nexecute: 010001000000040028000bce\nExecuting method 1 { name: 'exchangeDeclareOk',\n  fields: [],\n  methodIndex: 11,\n  classIndex: 40 } {}\n1 > exchangeDeclareOk {}\nexecute: 010002000000040028000bce\nExecuting method 2 { name: 'exchangeDeclareOk',\n  fields: [],\n  methodIndex: 11,\n  classIndex: 40 } {}\n2 > exchangeDeclareOk {}\n```\n. This happens because the ready events and optional ready callback are executed in the same stack as the parser's onMethod. The parser is wrapped by a try/catch block, catching any exceptions from this stack, including the user's event listeners and readyCallback.\n\nIf you want to let your program crash, a workaround for now would be to disable `reconnect` in the options, and avoid listening on any `'error'` events. Of course the downside is that since errors between module and user functions are not distinguished, you would lose all graceful error control.\n\nTo address the actual issue, we need to differentiate between an exception originating from a user function vs exceptions from the parser. We could invoke the user functions inside their own try/catch and ideally bind them to `process.domain` if existent. If not, we could re-throw the exception.\n. ",
    "matomesc": "I ran into this issue when calling `connection.publish` several times in the same tick of the event loop. Solved it by using `process.setImmediate`.\n. Instead of `q.shift()`, i just did `ack.acknowledge()` which solved the problem. What exactly is the point of `.shift()`?\n. I ran into this issue when calling `connection.publish` several times in the same tick of the event loop. Solved it by using `process.setImmediate`.\n. Instead of `q.shift()`, i just did `ack.acknowledge()` which solved the problem. What exactly is the point of `.shift()`?\n. ",
    "aheckmann": "this can be closed now.\n. Please add a test to this PR. The odds of any code being accepted without tests are slim-to-none.\n. please add the test to this PR.\n. we just ran into this issue as well. the docs need to be updated as described.\n. thanks!\n. +1\n. there is definitely a bug in here waiting to bite at some point without this fix.\n. Please add a test.\n\nPlease do not bump the version in a pull request. The version will be determined after examining the state of the master branch at time of release.\n. Yeah I'd love to see a test included so we can see if this fix works.\n. this can be closed now.\n. Please add a test to this PR. The odds of any code being accepted without tests are slim-to-none.\n. please add the test to this PR.\n. we just ran into this issue as well. the docs need to be updated as described.\n. thanks!\n. +1\n. there is definitely a bug in here waiting to bite at some point without this fix.\n. Please add a test.\n\nPlease do not bump the version in a pull request. The version will be determined after examining the state of the master branch at time of release.\n. Yeah I'd love to see a test included so we can see if this fix works.\n. ",
    "esidorov": "Thanks, but, nope, \n\n```\nself.queue = self.connection.queue(\"Test\", null, function(q){\nconsole.log(q.name)\n});\n```\n\nCode above crates a gueue 'Test', prints it's name, but throws an error mentioned in my original post.\n. Thanks, but, nope, \n\n```\nself.queue = self.connection.queue(\"Test\", null, function(q){\nconsole.log(q.name)\n});\n```\n\nCode above crates a gueue 'Test', prints it's name, but throws an error mentioned in my original post.\n. ",
    "agubler": "Opened Pull Request addressing the missing functionality - https://github.com/postwait/node-amqp/pull/231\n. Opened Pull Request addressing the missing functionality - https://github.com/postwait/node-amqp/pull/231\n. ",
    "compressed": "Agree. I'm running into this as well.\n. Agree. I'm running into this as well.\n. ",
    "vihang": "+1 Same Issue\n. +1 Same Issue\n. ",
    "mohannad-b": "+1\n. +1\n. ",
    "zerodivisi0n": "I encountered the same error and it seems that it is because application opens queues, exchanges or other activity before server connection established. The simplest solution of this is start amqp activity after connection established, e.g. after connection `ready` event. The right solution is to enqueue all operations and execute it after connection established.\n. I encountered the same error and it seems that it is because application opens queues, exchanges or other activity before server connection established. The simplest solution of this is start amqp activity after connection established, e.g. after connection `ready` event. The right solution is to enqueue all operations and execute it after connection established.\n. ",
    "dkekish": "I have the same issue,   wondering if its tied to the new version of node?    \n. I have the same issue,   wondering if its tied to the new version of node?    \n. ",
    "jdavisclark": "I have not seen this error message, but my worker processes are hemorrhaging memory.\n**Edit**: amqp wasnt my issue (it was jsdom). No amqp logic was changed and all my memory issues are resolved.\n. I have not seen this error message, but my worker processes are hemorrhaging memory.\n**Edit**: amqp wasnt my issue (it was jsdom). No amqp logic was changed and all my memory issues are resolved.\n. ",
    "Enjeru": "But I have this error on my broker side. Where I do only publish. I think it's tied with reconnect method.\n. But I have this error on my broker side. Where I do only publish. I think it's tied with reconnect method.\n. ",
    "ijohn": "I can always reproduce this using node 0.10.2. Please refer to this issue:\nhttps://github.com/joyent/node/issues/5179#issuecomment-15714901\n. I can always reproduce this using node 0.10.2. Please refer to this issue:\nhttps://github.com/joyent/node/issues/5179#issuecomment-15714901\n. ",
    "martyhu": "I can reproduce this as well in a VM running node 0.10.4. I run the same VM with 0.8.22 and have no errors.\n\n``` coffeescript\nrabbitMQ = amqp.createConnection({ host: app.rabbitmq })\n  rabbitMQ.on 'ready', ->\n    console.log \"this never fires\"\n```\n\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace:\n  at Connection.EventEmitter.addListener (events.js:160:15)\n  at Connection.connect (/home/node/analytics-backend/releases/20130422021733/node_modules/amqp/amqp.js:1068:8)\n  at Connection.reconnect (/home/node/analytics-backend/releases/20130422021733/node_modules/amqp/amqp.js:1038:8)\n  at [object Object]._onTimeout (/home/node/analytics-backend/releases/20130422021733/node_modules/amqp/amqp.js:876:16)\n  at Timer.listOnTimeout [as ontimeout](timers.js:110:15)\n. I can reproduce this as well in a VM running node 0.10.4. I run the same VM with 0.8.22 and have no errors.\n\n``` coffeescript\nrabbitMQ = amqp.createConnection({ host: app.rabbitmq })\n  rabbitMQ.on 'ready', ->\n    console.log \"this never fires\"\n```\n\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace:\n  at Connection.EventEmitter.addListener (events.js:160:15)\n  at Connection.connect (/home/node/analytics-backend/releases/20130422021733/node_modules/amqp/amqp.js:1068:8)\n  at Connection.reconnect (/home/node/analytics-backend/releases/20130422021733/node_modules/amqp/amqp.js:1038:8)\n  at [object Object]._onTimeout (/home/node/analytics-backend/releases/20130422021733/node_modules/amqp/amqp.js:876:16)\n  at Timer.listOnTimeout [as ontimeout](timers.js:110:15)\n. ",
    "ryanrhee": "Here's the error message I'm getting:\n\n```\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\n```\n\nThe `console.log` line below never fires.\n\n```\n        connection.on('ready', function() {\n            console.log('connected to rabbitMQ.');\n        });\n```\n\nThis happens for both 0.10.4 as well as 0.8.22\n. Here's the error message I'm getting:\n\n```\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\n```\n\nThe `console.log` line below never fires.\n\n```\n        connection.on('ready', function() {\n            console.log('connected to rabbitMQ.');\n        });\n```\n\nThis happens for both 0.10.4 as well as 0.8.22\n. ",
    "mlchai": "I am also getting this exact error whenever my rabbitmq server is down or I have provided incorrect connection information. This is using node 0.10.x as well.\n. I am also getting this exact error whenever my rabbitmq server is down or I have provided incorrect connection information. This is using node 0.10.x as well.\n. ",
    "hmeerlo": "'Just mute the warning' doesn't do the trick. I have set the maxListeners to 100 and it still occurs. It very obviously is a bug in the reconnect code somewhere (hint: don't test it with exponential backoff or you will fall asleep during the test). I will try to hunt it down.\n. Ok the problem is the connect() function. It adds 2 listeners to the Connection object for an 'end' and 'ready' event but these are never removed in case no connection can be established. But instead they are added again upon retry. I commented that part out (it seemed not critical to the functioning) and it worked fine after that.\n. Well one step further, but now the reconnect code fails on me because I use temporary queues (name generated by the broker) and the reconnect code tries to re-declare them with the broker using the assigned names. This is not allowed by the broker (the prefix is not allowed). So as an alternative I tried to disable the reconnect (using {reconnect: false} in the createConnection call) but that gives me a whole new problem because I now get 2 'error' events with this message: {\"code\":\"Unknown system errno 37\",\"errno\":\"Unknown system errno 37\",\"syscall\":\"connect\"}. Then I reenabled the reconnect and saw that when reconnect is set to true I also get this error but only once, after that I get the 'ready' event. Does anyone have any suggestion how to properly handle the broker disconnects?\n. 'Just mute the warning' doesn't do the trick. I have set the maxListeners to 100 and it still occurs. It very obviously is a bug in the reconnect code somewhere (hint: don't test it with exponential backoff or you will fall asleep during the test). I will try to hunt it down.\n. Ok the problem is the connect() function. It adds 2 listeners to the Connection object for an 'end' and 'ready' event but these are never removed in case no connection can be established. But instead they are added again upon retry. I commented that part out (it seemed not critical to the functioning) and it worked fine after that.\n. Well one step further, but now the reconnect code fails on me because I use temporary queues (name generated by the broker) and the reconnect code tries to re-declare them with the broker using the assigned names. This is not allowed by the broker (the prefix is not allowed). So as an alternative I tried to disable the reconnect (using {reconnect: false} in the createConnection call) but that gives me a whole new problem because I now get 2 'error' events with this message: {\"code\":\"Unknown system errno 37\",\"errno\":\"Unknown system errno 37\",\"syscall\":\"connect\"}. Then I reenabled the reconnect and saw that when reconnect is set to true I also get this error but only once, after that I get the 'ready' event. Does anyone have any suggestion how to properly handle the broker disconnects?\n. ",
    "bcjwilson": "Is anyone working on this? I'm trying to make a robust client that will patiently wait for Rabbit to come online if it's initially down.\n. Still broken for me, post 217 merge.\n\n```\n// not running RabbitMQ locally ...\nvar connection = amqp.createConnection();\n```\n\nThen ten seconds later:\n\n```\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.connect (/my/project/node_modules/amqp/amqp.js:1083:8)\n    at Connection.reconnect /my/project/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/my/project/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:179:8)\n    at Connection.connect (/my/project/node_modules/amqp/amqp.js:1084:8)\n    at Connection.reconnect (/my/project/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/my/project/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n```\n. I thought I had, but apparently not. Updating my package.json to point to that url, I'm not currently seeing the memory leak warning any more. Thanks!\n. Post merge, still seeing memory leak problem due to reconnect event handlers.\n. Belay that, working locally. How do we get this out to npm?\n. Thanks for fixing that. I'm now seeing a new problem, not sure whether this is expected behavior.\n\nExample code:\n\n```\n  // not running RabbitMQ locally\n  var connection = amqp.createConnection();\n\n  connection.on('error', function(err){\n    console.log(\"ERROR: \" + err.message);\n  });\n```\n\nOutput (one second between each line):\n\n```\nERROR: connect ECONNREFUSED\nERROR: connect EADDRNOTAVAIL\nERROR: connect EADDRNOTAVAIL\n...\nERROR: connect EADDRNOTAVAIL\n```\n\nThe first connection attempt is refused, after that it's address not available. Shouldn't they all be connection refused?\n. Thanks, I'm not yet familiar enough with the amqp source to make a suggestion. The little research I've done suggests that EADDRNOTAVAIL means you're trying to bind a socket that's already bound. But connecting from a client-side app shouldn't have to do that, right?\n\nMaybe it has to do with keeping the old connection around?\n\nSide question: Is there a way to turn off the reconnect logic from client code? When RabbitMQ dies, I have to rebuild the world on the client side anyway (reestablish transient exchanges, make a new queue etc.) So I'd kinda like to just do the reconnecting myself.\n. Thanks, that's just what I needed - also, looks like the patch made it to npm :)\n. Is anyone working on this? I'm trying to make a robust client that will patiently wait for Rabbit to come online if it's initially down.\n. Still broken for me, post 217 merge.\n\n```\n// not running RabbitMQ locally ...\nvar connection = amqp.createConnection();\n```\n\nThen ten seconds later:\n\n```\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.connect (/my/project/node_modules/amqp/amqp.js:1083:8)\n    at Connection.reconnect /my/project/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/my/project/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:179:8)\n    at Connection.connect (/my/project/node_modules/amqp/amqp.js:1084:8)\n    at Connection.reconnect (/my/project/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/my/project/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n```\n. I thought I had, but apparently not. Updating my package.json to point to that url, I'm not currently seeing the memory leak warning any more. Thanks!\n. Post merge, still seeing memory leak problem due to reconnect event handlers.\n. Belay that, working locally. How do we get this out to npm?\n. Thanks for fixing that. I'm now seeing a new problem, not sure whether this is expected behavior.\n\nExample code:\n\n```\n  // not running RabbitMQ locally\n  var connection = amqp.createConnection();\n\n  connection.on('error', function(err){\n    console.log(\"ERROR: \" + err.message);\n  });\n```\n\nOutput (one second between each line):\n\n```\nERROR: connect ECONNREFUSED\nERROR: connect EADDRNOTAVAIL\nERROR: connect EADDRNOTAVAIL\n...\nERROR: connect EADDRNOTAVAIL\n```\n\nThe first connection attempt is refused, after that it's address not available. Shouldn't they all be connection refused?\n. Thanks, I'm not yet familiar enough with the amqp source to make a suggestion. The little research I've done suggests that EADDRNOTAVAIL means you're trying to bind a socket that's already bound. But connecting from a client-side app shouldn't have to do that, right?\n\nMaybe it has to do with keeping the old connection around?\n\nSide question: Is there a way to turn off the reconnect logic from client code? When RabbitMQ dies, I have to rebuild the world on the client side anyway (reestablish transient exchanges, make a new queue etc.) So I'd kinda like to just do the reconnecting myself.\n. Thanks, that's just what I needed - also, looks like the patch made it to npm :)\n. ",
    "ilyabo": "Still reproducible with 0.1.7. The connection \"ready\" event is triggered once about every second.\n. Still reproducible with 0.1.7. The connection \"ready\" event is triggered once about every second.\n. ",
    "soimafreak": "+1\n. +1\n. ",
    "shandyDev": "+1 \nIf I make manual install (current master), this will works correct?\n. +1 \nIf I make manual install (current master), this will works correct?\n. ",
    "TomDunn": "From my personal experience, all the tests fail with node 0.10.3.\n\nI installed 0.10.3 on Ubuntu from a ppa, after switching back to the default 0.6.19 version, all the tests pass.\n\nMore work will need to be made in order to make this compatible with 0.10.3\n. From my personal experience, all the tests fail with node 0.10.3.\n\nI installed 0.10.3 on Ubuntu from a ppa, after switching back to the default 0.6.19 version, all the tests pass.\n\nMore work will need to be made in order to make this compatible with 0.10.3\n. ",
    "joaoneto": "First of all, thank you @postwait for creating this great important lib!\nIt's time to make it compatible with **v0.10** Node.js, no one has a `pull request` to make this lib compatible?\n\n_While this, we look forward for updates_\n. First of all, thank you @postwait for creating this great important lib!\nIt's time to make it compatible with **v0.10** Node.js, no one has a `pull request` to make this lib compatible?\n\n_While this, we look forward for updates_\n. ",
    "kuebk": "The NPM version is outdated could you please publish new version?\n. The NPM version is outdated could you please publish new version?\n. ",
    "markdaws": "Hi any feedback on this, pretty simple change.\n\nThanks\n. Hi any feedback on this, pretty simple change.\n\nThanks\n. ",
    "sam-github": "IMO, the open callback should be like the net.Socket.connect/'connect' callback. Instead of being stored in _openCallback, providing an openCallback should be synonymous with adding it as a listener on the 'open' event. This would make this pull request unnecessary, the two methods of getting callbacks would be unified.\n. bump. I see these warnings, too. amqp should be installed as a local dep, not global, as OP says.\n. Thank you. Also, with node .10, it might be a helpful time to push a new npm, other people are probably getting the npm install warnings.\n. IMO, the open callback should be like the net.Socket.connect/'connect' callback. Instead of being stored in _openCallback, providing an openCallback should be synonymous with adding it as a listener on the 'open' event. This would make this pull request unnecessary, the two methods of getting callbacks would be unified.\n. bump. I see these warnings, too. amqp should be installed as a local dep, not global, as OP says.\n. Thank you. Also, with node .10, it might be a helpful time to push a new npm, other people are probably getting the npm install warnings.\n. ",
    "shiroyuki": "IMO, I agreed with @sam-github about being synonymous but internally the method is used when the code declares a queue. Hence, `_openCallback` should have been something like `_onSuccessfulDeclarationCallback` and this callback is not the same as `openCallback` used by `net.Socket.connect`. Nevertheless, I agreed with @markdaws enabling the way to get `messageCount` and `consumerCount` from `args`.\n. Will try.\n. Just wonder how you run the tests?\n. The test is added.\n. IMO, I agreed with @sam-github about being synonymous but internally the method is used when the code declares a queue. Hence, `_openCallback` should have been something like `_onSuccessfulDeclarationCallback` and this callback is not the same as `openCallback` used by `net.Socket.connect`. Nevertheless, I agreed with @markdaws enabling the way to get `messageCount` and `consumerCount` from `args`.\n. Will try.\n. Just wonder how you run the tests?\n. The test is added.\n. ",
    "ekryski": "I stumbled across this guy's [hack](https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/javascript-nodejs/amqp-hacks.js) and it fixes my problem. I'll look into the code and issue a patch but I wouldn't mind some feedback from one of the core maintainers.\n. I didn't but I had other issues with this library so I now use http://www.squaremobius.net/amqp.node/\n. I stumbled across this guy's [hack](https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/javascript-nodejs/amqp-hacks.js) and it fixes my problem. I'll look into the code and issue a patch but I wouldn't mind some feedback from one of the core maintainers.\n. I didn't but I had other issues with this library so I now use http://www.squaremobius.net/amqp.node/\n. ",
    "paulbjensen": "Hi,\n\nWas a PR submitted for this? I believe that we are currently encountering this issue as well\n. Thanks for the tip, I'll take a look into that.\n. Hi,\n\nWas a PR submitted for this? I believe that we are currently encountering this issue as well\n. Thanks for the tip, I'll take a look into that.\n. ",
    "WoZ": "Docs say that queue.destroy deletes queue on a server, but what to do with passive queues? I try to check presence of a queue and I don't want to delete queue. Looks like queue.destroy is not my case.\n. I checked `exchange.close()` and found another problem... When there is no exchange and I call `connection.exchange()` with `passive: true`, channel will be created, node-amqp emits `error` event\n\n`[Error: NOT_FOUND - no exchange 'nonpresent.exchange' in vhost '/'] code: 404`.\n\nI tried to close this nonexistent exchange with `exchange.close()` and this method fails. My attempts led to recursive reconnection. That's because `Connection.prototype._onMethod` receives `methods.connectionClose` with error\n\n`[Error: CHANNEL_ERROR - expected 'channel.open'] code: 504`\n\nand tries to recconect and create new exchange. After each reconnect I have +1 channel in `Connection`.\n\nDemo code:\n\n``` javascript\nvar amqp = require('amqp');\nvar exchangeName = 'nonpresent.exchange';\n\nvar connection = amqp.createConnection({host: 'localhost'});\nconnection.on('ready', function() {\n\n    connection.on('error', function(err) {\n        console.log('connection error:', err);\n    });\n    var exch = connection.exchange(exchangeName, {passive: true});\n    exch.on('error', function(err) {\n        console.log('exchange error:', err);\n    });\n    setTimeout(function() {\n        exch.on('close', function() {\n            console.log('closed');\n        });\n\n        exch.close();\n    }, 1000);\n});\n\n```\n. Docs say that queue.destroy deletes queue on a server, but what to do with passive queues? I try to check presence of a queue and I don't want to delete queue. Looks like queue.destroy is not my case.\n. I checked `exchange.close()` and found another problem... When there is no exchange and I call `connection.exchange()` with `passive: true`, channel will be created, node-amqp emits `error` event\n\n`[Error: NOT_FOUND - no exchange 'nonpresent.exchange' in vhost '/'] code: 404`.\n\nI tried to close this nonexistent exchange with `exchange.close()` and this method fails. My attempts led to recursive reconnection. That's because `Connection.prototype._onMethod` receives `methods.connectionClose` with error\n\n`[Error: CHANNEL_ERROR - expected 'channel.open'] code: 504`\n\nand tries to recconect and create new exchange. After each reconnect I have +1 channel in `Connection`.\n\nDemo code:\n\n``` javascript\nvar amqp = require('amqp');\nvar exchangeName = 'nonpresent.exchange';\n\nvar connection = amqp.createConnection({host: 'localhost'});\nconnection.on('ready', function() {\n\n    connection.on('error', function(err) {\n        console.log('connection error:', err);\n    });\n    var exch = connection.exchange(exchangeName, {passive: true});\n    exch.on('error', function(err) {\n        console.log('exchange error:', err);\n    });\n    setTimeout(function() {\n        exch.on('close', function() {\n            console.log('closed');\n        });\n\n        exch.close();\n    }, 1000);\n});\n\n```\n. ",
    "ric03uec": "@helxsz @postwait any clues about this. I'm able to run a similar setup successfully on the dev machine but getting this error on production where the mq and app are running on different machines. rabbitmq is default install with no custom config.\n. never mind. figured it out. Had to modify the `ufw` rules to not drop the forward requests.\nThanks  :)\n. @helxsz @postwait any clues about this. I'm able to run a similar setup successfully on the dev machine but getting this error on production where the mq and app are running on different machines. rabbitmq is default install with no custom config.\n. never mind. figured it out. Had to modify the `ufw` rules to not drop the forward requests.\nThanks  :)\n. ",
    "makebbekus": "@ric03uec I'm running into the same issue. Could you elaborate on the config changes you made? Thanks!\n. @ric03uec I'm running into the same issue. Could you elaborate on the config changes you made? Thanks!\n. ",
    "vishr": "+1\n. +1\n. ",
    "danielsantiago": "+1 this is a must to add more workers if needed.\n. See https://github.com/postwait/node-amqp/pull/258\n. +1. I was looking for this thanks.\n. +1 this is a must to add more workers if needed.\n. See https://github.com/postwait/node-amqp/pull/258\n. +1. I was looking for this thanks.\n. ",
    "ikr": "Need the queue size too -- for monitoring: check if the queue grew too much.\n+1\n. Need the queue size too -- for monitoring: check if the queue grew too much.\n+1\n. ",
    "beppu": "If you're using RabbitMQ, I recommend getting info about the queue via their HTTP API.\n\nhttps://github.com/timisbusy/node-amqp-stats\n. If you're using RabbitMQ, I recommend getting info about the queue via their HTTP API.\n\nhttps://github.com/timisbusy/node-amqp-stats\n. ",
    "willdurand": ":+1: \n. :+1: \n. ",
    "keyurrp": "Looks like a duplicate, please close this.\n. Looks like a duplicate, please close this.\n. ",
    "dlindahl": "Just for further reference, you can also get this error if you try to perform some sort of action on the connection before it has been fully established.\n\nSo make sure that you don't attempt an action before your connection handler has been fired.\n. Just for further reference, you can also get this error if you try to perform some sort of action on the connection before it has been fully established.\n\nSo make sure that you don't attempt an action before your connection handler has been fired.\n. ",
    "cmaggard": "@rschiavi Was the issue something in your codebase? We're experiencing similar issues with a project and are looking for insight.\n. @rschiavi Was the issue something in your codebase? We're experiencing similar issues with a project and are looking for insight.\n. ",
    "andrewseddon": "We get the exact same issue under high cpu.\n. any chance you could share your code?\n. We get the exact same issue under high cpu.\n. any chance you could share your code?\n. ",
    "geek": "@rschiavi please do share your code :)\n. My hunch is that this is the culprit: https://github.com/postwait/node-amqp/blob/master/lib/connection.js#L102  \n\nshould it be `socket.destroy()` ?\n. @rschiavi please do share your code :)\n. My hunch is that this is the culprit: https://github.com/postwait/node-amqp/blob/master/lib/connection.js#L102  \n\nshould it be `socket.destroy()` ?\n. ",
    "borrey": "I am also getting this behaviour on node 0.10.12 and 0.10.9... \nI remember seeing this issue on here before with ECONNRESET e.syscall==read with a pull request attached to it...\nIt seems to call connection.on( 'ready', function(){ ... });\n. I am also getting this behaviour on node 0.10.12 and 0.10.9... \nI remember seeing this issue on here before with ECONNRESET e.syscall==read with a pull request attached to it...\nIt seems to call connection.on( 'ready', function(){ ... });\n. ",
    "jonsharratt": "Hope this gets fixed / merged soon :+1: \n. Hope this gets fixed / merged soon :+1: \n. ",
    "saalaa": "I looked at the tests and this one caught my attention:\n\nhttps://github.com/postwait/node-amqp/blob/master/test/test-reject.js\n\nI adjusted my code according to it and it's working. This bug is still valid since `queue.shift()` is not working as advertised as far as `requeue` is concerned.\n\nFor the record, here's the adjusted subscriber code:\n\n``` javascript\nvar amqp = require('amqp');\n\nvar mq = amqp.createConnection({host: 'localhost'});\n\nvar options = {\n  autoDelete: false,\n  durable: true\n};\n\nmq.on('ready', function () {\n  mq.queue('my-queue', options, function (q) {\n    q.bind('#');\n\n    q.subscribe({ack: true}, function (json, headers, info, message) {\n      console.log(json);\n      message.reject(true);\n    });\n  });\n});\n```\n. I looked at the tests and this one caught my attention:\n\nhttps://github.com/postwait/node-amqp/blob/master/test/test-reject.js\n\nI adjusted my code according to it and it's working. This bug is still valid since `queue.shift()` is not working as advertised as far as `requeue` is concerned.\n\nFor the record, here's the adjusted subscriber code:\n\n``` javascript\nvar amqp = require('amqp');\n\nvar mq = amqp.createConnection({host: 'localhost'});\n\nvar options = {\n  autoDelete: false,\n  durable: true\n};\n\nmq.on('ready', function () {\n  mq.queue('my-queue', options, function (q) {\n    q.bind('#');\n\n    q.subscribe({ack: true}, function (json, headers, info, message) {\n      console.log(json);\n      message.reject(true);\n    });\n  });\n});\n```\n. ",
    "bausmeier": "Your code in the original issue works perfectly for me. What version of node-amqp are you using? The options to reject and requeue a message using `queue.shift` have not been included in the version which has been published to npm yet. I expect that they will be included in 0.1.8.\n. The `queue.shift` code was removed when another pull request was merged in. See [this comment](https://github.com/postwait/node-amqp/commit/32321964b47df9f82b1a13fe24e7c01039b100c2#commitcomment-3566648).\n. Your code in the original issue works perfectly for me. What version of node-amqp are you using? The options to reject and requeue a message using `queue.shift` have not been included in the version which has been published to npm yet. I expect that they will be included in 0.1.8.\n. The `queue.shift` code was removed when another pull request was merged in. See [this comment](https://github.com/postwait/node-amqp/commit/32321964b47df9f82b1a13fe24e7c01039b100c2#commitcomment-3566648).\n. ",
    "CodeShark": "I think I figured it out. { durable: true, autoDelete: false } for the queue on both the sender and receiver.\n. I think I figured it out. { durable: true, autoDelete: false } for the queue on both the sender and receiver.\n. ",
    "skeggse": "On a related note, it would be nice if node-amqp had better typechecking for parameters--the error thrown if you omit `name` is highly misleading.\n. This is a leak of the `_socketEnd` event, likely caused by the reconnect mechanism.\n. On a related note, it would be nice if node-amqp had better typechecking for parameters--the error thrown if you omit `name` is highly misleading.\n. This is a leak of the `_socketEnd` event, likely caused by the reconnect mechanism.\n. ",
    "fjohnson": "I am also encountering this issue under a very similar set of circumstances. Only in my case I do not see the PRECONDITION_FAILED error, but instead only get a \"socket is closed\" exception.\n. I discovered the proper way of acknowledging messages received from a prefetchCount window. I have submitted a pull request for updates to the documentation. See the solution to this problem here: https://github.com/postwait/node-amqp/pull/263\n. I am also encountering this issue under a very similar set of circumstances. Only in my case I do not see the PRECONDITION_FAILED error, but instead only get a \"socket is closed\" exception.\n. I discovered the proper way of acknowledging messages received from a prefetchCount window. I have submitted a pull request for updates to the documentation. See the solution to this problem here: https://github.com/postwait/node-amqp/pull/263\n. ",
    "jacobstr": ":+1: Experienced this as well.\n. :+1: Experienced this as well.\n. ",
    "logicware": "Thanks. It is comforting to know other people have run into the same problem ;) I read somewhere that there is a frame_max setting in config file that can be set to 0 for unlimited size. I don't know that would solve the issue or not. Currently I am using cloudAMQP on Heroku with my node.js server. I contacted support and they told me that only if I had the $499/mo. package they would change the config file for me. Makes sense, with packages with different limitations they cannot allow the user to change any configuration.\n\u00a0\u00a0\nRegards\nMatloob ul Hasan\n\n> ---\n> \n> From: Patrick de Lanauze notifications@github.com\n> To: postwait/node-amqp node-amqp@noreply.github.com \n> Cc: Matloob ul Hasan matloobh@yahoo.com \n> Sent: Friday, July 19, 2013 1:25 AM\n> Subject: Re: [node-amqp] How to send data larger than frame size? (#224)\n> \n> From my experience it does some splitting to make sure to not go over the frame_max, but i have experienced very sporadic situations where it does not seem to do the splitting correctly, raising a FRAME_ERROR , frame_too_large, code 501. \n> Maybe take a look at #164\n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Thanks. It is comforting to know other people have run into the same problem ;) I read somewhere that there is a frame_max setting in config file that can be set to 0 for unlimited size. I don't know that would solve the issue or not. Currently I am using cloudAMQP on Heroku with my node.js server. I contacted support and they told me that only if I had the $499/mo. package they would change the config file for me. Makes sense, with packages with different limitations they cannot allow the user to change any configuration.\n\u00a0\u00a0\nRegards\nMatloob ul Hasan\n\n> ---\n> \n> From: Patrick de Lanauze notifications@github.com\n> To: postwait/node-amqp node-amqp@noreply.github.com \n> Cc: Matloob ul Hasan matloobh@yahoo.com \n> Sent: Friday, July 19, 2013 1:25 AM\n> Subject: Re: [node-amqp] How to send data larger than frame size? (#224)\n> \n> From my experience it does some splitting to make sure to not go over the frame_max, but i have experienced very sporadic situations where it does not seem to do the splitting correctly, raising a FRAME_ERROR , frame_too_large, code 501. \n> Maybe take a look at #164\n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "cngan": "Try to amend the 'amqp' dependency in package.json with \"https://codeload.github.com/postwait/node-amqp/tar.gz/master\".\n. Try to amend the 'amqp' dependency in package.json with \"https://codeload.github.com/postwait/node-amqp/tar.gz/master\".\n. ",
    "looksgood": "+1\n. +1\n. ",
    "lky1001": "can you add confirm : true option?\nvar opts = { mandatory: true, confirm : ture };\n. can you add confirm : true option?\nvar opts = { mandatory: true, confirm : ture };\n. ",
    "bernardmo": "Hi, any help with this? I'm using already declared exchange - CB function is never called but data is received in exchange.\n\n```\nvar exchangeConn = amqp.createConnection( { url: connString } );\nexchangeConn.on( 'ready', function() {\n\n    exchangeConn.exchange( 'MyExchange', { noDeclare: true, confirm: true }, function( exchange ) {\n\n        exchange.publish( '', 'Some data', { mandatory: true }, function( error ) {\n\n            // never in, but data got in exchange\n        });\n    });\n});\n```\n. @glenjamin - Versions:\nnode-amqp 0.2.1 (also tried pulling master from git - doesn't work)\nRabbitMQ 3.2.4\n\n@davidmba - channel doesn't show \"c\" option in mode column like @testower  says\n. So an \"ugly\" fix like https://github.com/postwait/node-amqp/pull/328 works for me\n. @jensbjork pull the latest version from github, npm installation doesn't shift changes from #328 \n. Hi, any help with this? I'm using already declared exchange - CB function is never called but data is received in exchange.\n\n```\nvar exchangeConn = amqp.createConnection( { url: connString } );\nexchangeConn.on( 'ready', function() {\n\n    exchangeConn.exchange( 'MyExchange', { noDeclare: true, confirm: true }, function( exchange ) {\n\n        exchange.publish( '', 'Some data', { mandatory: true }, function( error ) {\n\n            // never in, but data got in exchange\n        });\n    });\n});\n```\n. @glenjamin - Versions:\nnode-amqp 0.2.1 (also tried pulling master from git - doesn't work)\nRabbitMQ 3.2.4\n\n@davidmba - channel doesn't show \"c\" option in mode column like @testower  says\n. So an \"ugly\" fix like https://github.com/postwait/node-amqp/pull/328 works for me\n. @jensbjork pull the latest version from github, npm installation doesn't shift changes from #328 \n. ",
    "testower": "I can confirm that the confirm: true option does not help. The confirm callback on exchange.publish is never called.\n. In my case\n\namqp 0.9.1\nRabbitMQ 3.0.4\nnode-amqp 0.2.0\n. Where would that be indicated in the interface exactly?\n. Thanks for that tip. As for amqp-coffee, that looks interesting. I don't know much coffee, does it require me to be using coffee? And can I use multiple callbacks for parallelll queue bindings? If so, I might just switch :-)\n. As per #298, queue.bind will overwrite the callback for each call. So any bind operations going on at the same time, only the last callback passed in will be called, rather than each individual callback being called its bind completes.\n. Back on-topic. Using:\n\n```\n            {\n                noDeclare: true,\n                confirm: true\n            },\n```\n\nDoes not seem to put channel in confirm mode:\n\n![screenshot 2014-04-14 21 57 19](https://cloud.githubusercontent.com/assets/231492/2700086/2073b88c-c40f-11e3-8f11-c8ab241eaf6e.png)\n\nThe mode column is the third column\n. The problem of running multiple bind operations in parallell with their own callbacks was not be fixed by this, am I right?\n\nI would like some pointers of best practice. I need to wait for a binding to complete before polling for data through it, and much of this happens in parallell all the way back to the client. But if there is already a binding operation in progress, issuing another one will replace the callback.\n\nIf I would like to patch node-amqp to support a separate callback for each binding operation, how would I proceed?\n\nI posted this question to stackoverflow: http://stackoverflow.com/questions/22931748/node-amqp-multiple-bind-callbacks\n. The problem is that I need to know _which particular binding_ completed. Do you have any suggestions for how to achieve that? I can't find any documentation on the bindOk event though.\n. Nothing comes out of the event, just an empty object  {}. The async-option was the workaround I already had in place, but it's too slow. As for multiple channels, how would that work? Declare a new queue for each binding?\n. I'm sorry. I realize this question is probably better suited for stackoverflow. So reposted the question there:\n\nhttp://stackoverflow.com/questions/22177459/persist-queue-serialize-deserialize-queue-object-in-node-amqp\n. I think you should add closeChannelOnUnsubscribe: true, to the queue options.\n\n```\nthis.connection.queue(queueName, { durable: true, autoDelete: false, closeChannelOnUnsubscribe: true  }, function(queue) {\n```\n. I can confirm that the confirm: true option does not help. The confirm callback on exchange.publish is never called.\n. In my case\n\namqp 0.9.1\nRabbitMQ 3.0.4\nnode-amqp 0.2.0\n. Where would that be indicated in the interface exactly?\n. Thanks for that tip. As for amqp-coffee, that looks interesting. I don't know much coffee, does it require me to be using coffee? And can I use multiple callbacks for parallelll queue bindings? If so, I might just switch :-)\n. As per #298, queue.bind will overwrite the callback for each call. So any bind operations going on at the same time, only the last callback passed in will be called, rather than each individual callback being called its bind completes.\n. Back on-topic. Using:\n\n```\n            {\n                noDeclare: true,\n                confirm: true\n            },\n```\n\nDoes not seem to put channel in confirm mode:\n\n![screenshot 2014-04-14 21 57 19](https://cloud.githubusercontent.com/assets/231492/2700086/2073b88c-c40f-11e3-8f11-c8ab241eaf6e.png)\n\nThe mode column is the third column\n. The problem of running multiple bind operations in parallell with their own callbacks was not be fixed by this, am I right?\n\nI would like some pointers of best practice. I need to wait for a binding to complete before polling for data through it, and much of this happens in parallell all the way back to the client. But if there is already a binding operation in progress, issuing another one will replace the callback.\n\nIf I would like to patch node-amqp to support a separate callback for each binding operation, how would I proceed?\n\nI posted this question to stackoverflow: http://stackoverflow.com/questions/22931748/node-amqp-multiple-bind-callbacks\n. The problem is that I need to know _which particular binding_ completed. Do you have any suggestions for how to achieve that? I can't find any documentation on the bindOk event though.\n. Nothing comes out of the event, just an empty object  {}. The async-option was the workaround I already had in place, but it's too slow. As for multiple channels, how would that work? Declare a new queue for each binding?\n. I'm sorry. I realize this question is probably better suited for stackoverflow. So reposted the question there:\n\nhttp://stackoverflow.com/questions/22177459/persist-queue-serialize-deserialize-queue-object-in-node-amqp\n. I think you should add closeChannelOnUnsubscribe: true, to the queue options.\n\n```\nthis.connection.queue(queueName, { durable: true, autoDelete: false, closeChannelOnUnsubscribe: true  }, function(queue) {\n```\n. ",
    "chevett": "This appears to work for me.\n\nrabbit: `3.2.4`\nnode-amqp: both `2.0` and `master`\nnode: `v0.10.31`\n\nI can run `sudo rabbitmqctl list_channels name confirm` and I see that my channels are in confirm mode.\n. This appears to work for me.\n\nrabbit: `3.2.4`\nnode-amqp: both `2.0` and `master`\nnode: `v0.10.31`\n\nI can run `sudo rabbitmqctl list_channels name confirm` and I see that my channels are in confirm mode.\n. ",
    "soichih": "+1\n\nHaving the same problem on.\n\nRabbitMQ: 3.5.1\nnode-amqp: 0.2.4\nnodejs: v0.10.36\n\nI am not using noDeclare option, so I am not sure how to go around this problem..\n\n> conn.exchange('topic-test', {type: 'topic', confirm: true}, function(ex) {...}\n. Same issue. When I call `connection.disconnect()` I receive an error event.\r\n\r\n```\r\n Error: read ECONNRESET\r\n    at exports._errnoException (util.js:1020:11)\r\n    at TCP.onread (net.js:568:26)\r\n\r\n```\r\n\r\nI have a script that uses amqp and I need to terminate it after all processing is done. However, calling disconnect won't kill the amqp's  even loop(?) so my script keeps running. Calling disconnect() doesn't seem to end the event loop in this case.. +1\n\nHaving the same problem on.\n\nRabbitMQ: 3.5.1\nnode-amqp: 0.2.4\nnodejs: v0.10.36\n\nI am not using noDeclare option, so I am not sure how to go around this problem..\n\n> conn.exchange('topic-test', {type: 'topic', confirm: true}, function(ex) {...}\n. Same issue. When I call `connection.disconnect()` I receive an error event.\r\n\r\n```\r\n Error: read ECONNRESET\r\n    at exports._errnoException (util.js:1020:11)\r\n    at TCP.onread (net.js:568:26)\r\n\r\n```\r\n\r\nI have a script that uses amqp and I need to terminate it after all processing is done. However, calling disconnect won't kill the amqp's  even loop(?) so my script keeps running. Calling disconnect() doesn't seem to end the event loop in this case.. ",
    "defra91": "+1 I was looking for this and it was really useful\n. +1 I was looking for this and it was really useful\n. ",
    "andriijas": "@postwait can we get this merged?\n. Got the same problem. The built in reconnection mechanism doesnt kick in, neither is any error event triggered.\n. might explain why the reconnect mechanism doesnt work, at all.\n. @postwait can we get this merged?\n. Got the same problem. The built in reconnection mechanism doesnt kick in, neither is any error event triggered.\n. might explain why the reconnect mechanism doesnt work, at all.\n. ",
    "unframework": "Yes, that's an unrelated issue we had to work around. Just do `.close()` after `.destroy()` on queues and exchanges - did not see it in the documentation, but queue and exchange objects are subclasses of channels. Maybe `.destroy()` is supposed to do it automatically but we didn't dig deeper. But again - that issue is unrelated.\n. @andris9 - just want to point out that beside spacing/comment/JSLint differences, my commit also adds a check in the handshake to fail-fast if the server does try to specify alternate channelMax. Also, the code throws an exception instead of reporting an error event when channels are depleted, specifically to signify that it is a serious developer error (not the same as e.g. simple network disconnects/etc). The latter can be debated, though, heh.\n. Yes, that's an unrelated issue we had to work around. Just do `.close()` after `.destroy()` on queues and exchanges - did not see it in the documentation, but queue and exchange objects are subclasses of channels. Maybe `.destroy()` is supposed to do it automatically but we didn't dig deeper. But again - that issue is unrelated.\n. @andris9 - just want to point out that beside spacing/comment/JSLint differences, my commit also adds a check in the handshake to fail-fast if the server does try to specify alternate channelMax. Also, the code throws an exception instead of reporting an error event when channels are depleted, specifically to signify that it is a serious developer error (not the same as e.g. simple network disconnects/etc). The latter can be debated, though, heh.\n. ",
    "aahoughton": "Ha, I was about to submit a pull request for the same issue.  This implementation is prettier. :)\n. Ha, I was about to submit a pull request for the same issue.  This implementation is prettier. :)\n. ",
    "andris9": "Any progress on this issue? I can confirm (using node-amqp v0.1.8) that once `connection.channelCounter` reaches over 2^16 `CHANNEL_ERROR` is thrown.\n\nTo test this, I set the `channelCounter` value to 65536 - 3 and opened some exchanges and queues.\n\n```\nError: CHANNEL_ERROR - unexpected method in connection state running\n    at Connection._onMethod (/var/app/node_modules/amqp/lib/connection.js:468:15)\n    at AMQPParser.self.parser.onMethod (/var/app/node_modules/amqp/lib/connection.js:122:12)\n    at AMQPParser._parseMethodFrame (/var/app/node_modules/amqp/lib/parser.js:361:10)\n    at frameEnd (/var/app/node_modules/amqp/lib/parser.js:92:16)\n    at frame (/var/app/node_modules/amqp/lib/parser.js:77:14)\n    at AMQPParser.header [as parse] (/var/app/node_modules/amqp/lib/parser.js:63:14)\n    at AMQPParser.execute (/var/app/node_modules/amqp/lib/parser.js:136:21)\n    at Connection.<anonymous> (/var/app/node_modules/amqp/lib/connection.js:160:21)\n    at Connection.EventEmitter.emit (events.js:95:17)\n    at Socket.EventEmitter.emit (events.js:95:17))\n```\n. My take on fixing this: https://github.com/andris9/node-amqp/commit/84435b7a50632a07cac3471466ccf22ea82e9e97\n. I agree and this is why I didn't submit a separate pull request. I couldn't use your patch directly as it is somewhat outdated, the code is moved from amqp.js to connection.js. Adding just a small function to reuse channel id values seemed simpler than fixing the patch conflicts.\n. Automatic reconnection is triggered by the 'error' event so if there were no errors catched, 'close' is emitted instead and reconneciton never happens. What you could do, is to emit an error by yourself when a 'close' happens.\n\n```\nconnection.on(\"close\", function(){\n    var trigger = new Error(\"Trigger reconnect\");\n    trigger.code = \"RECONNECT\";\n    connection.emit(\"error\", trigger);\n});\n\nconnection.on(\"error\", function(err){\n    if(err.code == \"RECONNECT\"){\n        return; // ignore this\n    }\n});\n```\n. Any progress on this issue? I can confirm (using node-amqp v0.1.8) that once `connection.channelCounter` reaches over 2^16 `CHANNEL_ERROR` is thrown.\n\nTo test this, I set the `channelCounter` value to 65536 - 3 and opened some exchanges and queues.\n\n```\nError: CHANNEL_ERROR - unexpected method in connection state running\n    at Connection._onMethod (/var/app/node_modules/amqp/lib/connection.js:468:15)\n    at AMQPParser.self.parser.onMethod (/var/app/node_modules/amqp/lib/connection.js:122:12)\n    at AMQPParser._parseMethodFrame (/var/app/node_modules/amqp/lib/parser.js:361:10)\n    at frameEnd (/var/app/node_modules/amqp/lib/parser.js:92:16)\n    at frame (/var/app/node_modules/amqp/lib/parser.js:77:14)\n    at AMQPParser.header [as parse] (/var/app/node_modules/amqp/lib/parser.js:63:14)\n    at AMQPParser.execute (/var/app/node_modules/amqp/lib/parser.js:136:21)\n    at Connection.<anonymous> (/var/app/node_modules/amqp/lib/connection.js:160:21)\n    at Connection.EventEmitter.emit (events.js:95:17)\n    at Socket.EventEmitter.emit (events.js:95:17))\n```\n. My take on fixing this: https://github.com/andris9/node-amqp/commit/84435b7a50632a07cac3471466ccf22ea82e9e97\n. I agree and this is why I didn't submit a separate pull request. I couldn't use your patch directly as it is somewhat outdated, the code is moved from amqp.js to connection.js. Adding just a small function to reuse channel id values seemed simpler than fixing the patch conflicts.\n. Automatic reconnection is triggered by the 'error' event so if there were no errors catched, 'close' is emitted instead and reconneciton never happens. What you could do, is to emit an error by yourself when a 'close' happens.\n\n```\nconnection.on(\"close\", function(){\n    var trigger = new Error(\"Trigger reconnect\");\n    trigger.code = \"RECONNECT\";\n    connection.emit(\"error\", trigger);\n});\n\nconnection.on(\"error\", function(err){\n    if(err.code == \"RECONNECT\"){\n        return; // ignore this\n    }\n});\n```\n. ",
    "reu": "Yeah, sure, just a sec.\n. Done =]\n. Yeah, sure, just a sec.\n. Done =]\n. ",
    "tolgaek": "The commit fixes this issue\n. The commit fixes this issue\n. ",
    "CaitieM20": "+1 getting this merged in would be awesome!\n. +1 getting this merged in would be awesome!\n. ",
    "kuno": "Any progress here?\n. Sorry, you means, the `exchange` object also has a `ready` event, and it's much more reliable?\n. @vrvolle \n\nYes, in the end it cause memory leak.\n\nAs a workaround, you can either set the upper limit of listners of `ready' event, or simply using`once`instead`on`\n. Any progress here?\n. Sorry, you means, the `exchange` object also has a `ready` event, and it's much more reliable?\n. @vrvolle \n\nYes, in the end it cause memory leak.\n\nAs a workaround, you can either set the upper limit of listners of `ready' event, or simply using`once`instead`on`\n. ",
    "fakewaffle": "http://www.rabbitmq.com/tutorials/tutorial-six-python.html\n. http://www.rabbitmq.com/tutorials/tutorial-six-python.html\n. ",
    "crzidea": "Does this issue fixed? I tried the following code:\n\n``` js\nconnection.end();\n```\n\nBut the connection reconnected automatically. Then I tried this:\n\n``` js\nconnection.implOptions.reconnect = false;\nconnection.end();\n```\n\nBut I got an error:\n\n```\nError: read ECONNRESET\n    at errnoException (net.js:901:11)\n    at TCP.onread (net.js:556:19)\n```\n\n@postwait Would you handle this PR?\n. @cmoesel Thank you for your reminding. I will check it..\n. The PR set the version to v0.2.0, which means a big change. But it isn't. I guess.\n. I'm sorry for using v0.1.7. Nothing goes wrong with v0.1.8 now.\n. Got it! closed.\n. Modify this [line](https://github.com/postwait/node-amqp/blob/master/lib/connection.js#L20) to meet your need.**OR** hope @postwait exposing this number.\n. This [line](https://github.com/postwait/node-amqp/blob/master/lib/connection.js#L454) may also help but I haven't a try. If you tweaked `maxFrameBuffer` successfully, would you share your code here please? Whatever, that was not well documented.\n\nAnd remember to set  `frame_max` on RabbitMQ before tweaking.\n. Does this issue fixed? I tried the following code:\n\n``` js\nconnection.end();\n```\n\nBut the connection reconnected automatically. Then I tried this:\n\n``` js\nconnection.implOptions.reconnect = false;\nconnection.end();\n```\n\nBut I got an error:\n\n```\nError: read ECONNRESET\n    at errnoException (net.js:901:11)\n    at TCP.onread (net.js:556:19)\n```\n\n@postwait Would you handle this PR?\n. @cmoesel Thank you for your reminding. I will check it..\n. The PR set the version to v0.2.0, which means a big change. But it isn't. I guess.\n. I'm sorry for using v0.1.7. Nothing goes wrong with v0.1.8 now.\n. Got it! closed.\n. Modify this [line](https://github.com/postwait/node-amqp/blob/master/lib/connection.js#L20) to meet your need.**OR** hope @postwait exposing this number.\n. This [line](https://github.com/postwait/node-amqp/blob/master/lib/connection.js#L454) may also help but I haven't a try. If you tweaked `maxFrameBuffer` successfully, would you share your code here please? Whatever, that was not well documented.\n\nAnd remember to set  `frame_max` on RabbitMQ before tweaking.\n. ",
    "theartoflogic": "Is this fix going to be merged any time soon? I don't see it in master or the latest release (0.1.8).\n. I am getting the same error, however, it's limited to only the servers in my prod environment. My local environment, dev, and stage all work fine. However, it's 100% reproducible on the prod servers. The interesting thing is that they all have the same server setup (except my local env).\n\nI have tried using the latest stable version of the node-amqp library (that does not include the explicit `connectionCloseOk` handler), as well as with the `connectionCloseOk` handler and both have the same issue.\n\nAfter using node-inspector to step through the entire execution flow (very, very tediously) I still could not figure out exactly why it was throwing the ECONNRESET error. The `connectionClose` event to the rabbit server gets sent fine, and I get the `connectionCloseOk` response from the server. However, once it calls `socket.end()` after that it always throw this exception.\n\nIf I use netstat to see how many sockets are open to the rabbit server I can see that the socket has not been closed, so eventually rabbit starts blocking the connections as my node-pool continues to create new connections (thinking the old ones were closed properly).\n\nI've been able to fix the ECONNRESET error by modifying the call to `socket.end()` to be `socket.destroy()` instead after it receives the `connectionCloseOk` response. With that change I no longer get the ECONNRESET error, and the socket is properly closed. However, I'm not sure if that's the proper way to close the socket, or if there may be other unintended consequences that arise from that change, but so far I haven't noticed any ill effects and it's been running in my prod environment for the past few weeks.\n\nHere is some information on the environment where this issue happens:\n\n**OS:** Debian Squeeze (v6.0.8)\n**Node:** v0.10.5\n**RabbitMQ:** v3.1.5\n**node-amqp:** v0.1.8\n. @rafaelkaufmann the `socket.destroy()` call, for me at least, does seem to close the socket. I did the same thing...I used a branch with the `connectionCloseOk` handler, changed `socket.end()` to `socket.destroy()` and everything started working properly: there was no longer an exception, the socket did not show up when using `netstat -an | grep 5672`, and the RabbitMQ admin console showed that the connection was no longer open.\n\nI'm not sure why it wouldn't work for you, but I'd chalk it up to the weirdness of this bug in general. It seems to vary under what circumstances it happens, and it seems that it varies under which conditions it's \"fixed\" as well. For now, it's working for me and that's the most important thing. I'm still hoping for an actual fix for it though. I just wanted to present my findings as far as what worked for me in case it can help anyone else in the short term.\n. Is this fix going to be merged any time soon? I don't see it in master or the latest release (0.1.8).\n. I am getting the same error, however, it's limited to only the servers in my prod environment. My local environment, dev, and stage all work fine. However, it's 100% reproducible on the prod servers. The interesting thing is that they all have the same server setup (except my local env).\n\nI have tried using the latest stable version of the node-amqp library (that does not include the explicit `connectionCloseOk` handler), as well as with the `connectionCloseOk` handler and both have the same issue.\n\nAfter using node-inspector to step through the entire execution flow (very, very tediously) I still could not figure out exactly why it was throwing the ECONNRESET error. The `connectionClose` event to the rabbit server gets sent fine, and I get the `connectionCloseOk` response from the server. However, once it calls `socket.end()` after that it always throw this exception.\n\nIf I use netstat to see how many sockets are open to the rabbit server I can see that the socket has not been closed, so eventually rabbit starts blocking the connections as my node-pool continues to create new connections (thinking the old ones were closed properly).\n\nI've been able to fix the ECONNRESET error by modifying the call to `socket.end()` to be `socket.destroy()` instead after it receives the `connectionCloseOk` response. With that change I no longer get the ECONNRESET error, and the socket is properly closed. However, I'm not sure if that's the proper way to close the socket, or if there may be other unintended consequences that arise from that change, but so far I haven't noticed any ill effects and it's been running in my prod environment for the past few weeks.\n\nHere is some information on the environment where this issue happens:\n\n**OS:** Debian Squeeze (v6.0.8)\n**Node:** v0.10.5\n**RabbitMQ:** v3.1.5\n**node-amqp:** v0.1.8\n. @rafaelkaufmann the `socket.destroy()` call, for me at least, does seem to close the socket. I did the same thing...I used a branch with the `connectionCloseOk` handler, changed `socket.end()` to `socket.destroy()` and everything started working properly: there was no longer an exception, the socket did not show up when using `netstat -an | grep 5672`, and the RabbitMQ admin console showed that the connection was no longer open.\n\nI'm not sure why it wouldn't work for you, but I'd chalk it up to the weirdness of this bug in general. It seems to vary under what circumstances it happens, and it seems that it varies under which conditions it's \"fixed\" as well. For now, it's working for me and that's the most important thing. I'm still hoping for an actual fix for it though. I just wanted to present my findings as far as what worked for me in case it can help anyone else in the short term.\n. ",
    "carlhoerberg": "the key is to only declare the exchange once, and then reuse it, this is because node-amqp implicitly opens a \"channel\" each time you call `connection.exchange`. Channels should be semi-long-lived, not opened and closed over and over again, if you want any kind of performance..\n. Ok, np, shame though that the commit history wasn't preserved.. \n. We at @CloudAMQP have offered to take over the maintenance of the repo, but @postwait was not at the time interested to pass it on. \n. 3.3.5 is out and without this patch node-amqp cannot connect to rabbitmq server who has set the channel_max property. \n. Will a new version be released too soon? \n. Ok, thanks!\n. the key is to only declare the exchange once, and then reuse it, this is because node-amqp implicitly opens a \"channel\" each time you call `connection.exchange`. Channels should be semi-long-lived, not opened and closed over and over again, if you want any kind of performance..\n. Ok, np, shame though that the commit history wasn't preserved.. \n. We at @CloudAMQP have offered to take over the maintenance of the repo, but @postwait was not at the time interested to pass it on. \n. 3.3.5 is out and without this patch node-amqp cannot connect to rabbitmq server who has set the channel_max property. \n. Will a new version be released too soon? \n. Ok, thanks!\n. ",
    "AliUz": "Any update on this? I am experiencing the same issue, is there a code sample on how to use the exchange connection as a singleton? \n. you should create the channel connection once and reuse it for each subsequent request. reference: #247\n. @hayzem, @dabates, the same issue is already open here: #247. It seems you have to open the exchange connection once, and reuse it for any subsequent connection, otherwise you are opening a new channel for each request. \n. Any update on this? I am experiencing the same issue, is there a code sample on how to use the exchange connection as a singleton? \n. you should create the channel connection once and reuse it for each subsequent request. reference: #247\n. @hayzem, @dabates, the same issue is already open here: #247. It seems you have to open the exchange connection once, and reuse it for any subsequent connection, otherwise you are opening a new channel for each request. \n. ",
    "serhatates": "+1. +1. +1. +1. ",
    "aw": ":+1: :sparkles: \n. :+1: :sparkles: \n. ",
    "gjohnson": ":+1:\n. +1\n. this can be closed now.\n. It should be: \"Instead the listener function should take four parameters `(data, headers, deliveryInfo, msg)` and `msg.acknowledge()` should be called to ack a single message.\"\n\nThe `data` is the first argument and `msg` is the fourth argument.\n\nhttps://github.com/postwait/node-amqp/blob/master/lib/queue.js#L190\n. Once I run into whatever this might effect, I'll post a test case that reproduces it.\n. This really just an issue with the message you are sending, you should clean it up prior to publishing it. If you post an example of the message, someone can probably help you if needed.\n. This can be closed.\n. Should add a test to make sure it buffers as are you are expecting. Also, looks like you accidentally committed your package.json\n. I would just log the error and exit.\n\n``` js\nconnection.on('error', function (err) {\n  connection.close();\n  console.error(err.stack)\n  process.exit(1);\n});\n```\n. +1\n. @mrvisser @TheDeveloper can you guys post a gist/example that actually uses the driver instead of just `net` to reproduce the example?\n. :+1:\n. +1\n. this can be closed now.\n. It should be: \"Instead the listener function should take four parameters `(data, headers, deliveryInfo, msg)` and `msg.acknowledge()` should be called to ack a single message.\"\n\nThe `data` is the first argument and `msg` is the fourth argument.\n\nhttps://github.com/postwait/node-amqp/blob/master/lib/queue.js#L190\n. Once I run into whatever this might effect, I'll post a test case that reproduces it.\n. This really just an issue with the message you are sending, you should clean it up prior to publishing it. If you post an example of the message, someone can probably help you if needed.\n. This can be closed.\n. Should add a test to make sure it buffers as are you are expecting. Also, looks like you accidentally committed your package.json\n. I would just log the error and exit.\n\n``` js\nconnection.on('error', function (err) {\n  connection.close();\n  console.error(err.stack)\n  process.exit(1);\n});\n```\n. +1\n. @mrvisser @TheDeveloper can you guys post a gist/example that actually uses the driver instead of just `net` to reproduce the example?\n. ",
    "alexgorbatchev": ":+1: \n. \ud83d\udc4d \n. :+1: \n. \ud83d\udc4d \n. ",
    "adione": "Default connection options are set to auto-reconnect so to really close it you should set the options to false first and then invoke the close, e.g.:\n\n``` js\nconnection.implOptions.reconnect = false;\nconnection.end();\n```\n. Default connection options are set to auto-reconnect so to really close it you should set the options to false first and then invoke the close, e.g.:\n\n``` js\nconnection.implOptions.reconnect = false;\nconnection.end();\n```\n. ",
    "sachinkale": "Thank you that solved the issue.\n. Thank you that solved the issue.\n. ",
    "wentianle": "var amqp = require('amqp');\nvar connection = amqp.createConnection({ host: '192.168.8.160' });\n\n// Wait for connection to become established.\nconnection.on('ready', function () {\n    // Use the default 'amq.topic' exchange\n    connection.queue('hello', function(q){\n\n```\nconsole.info(\"aaa\");\n    // Catch all messages\n    // Receive messages\n    q.subscribe(function (message) {\n        // Print messages to stdout\n        console.log(message);\n    });\n});\n```\n\n});\n. var amqp = require('amqp');\nvar connection = amqp.createConnection({ host: '192.168.8.160' });\n\n// Wait for connection to become established.\nconnection.on('ready', function () {\n    // Use the default 'amq.topic' exchange\n    connection.queue('hello', function(q){\n\n```\nconsole.info(\"aaa\");\n    // Catch all messages\n    // Receive messages\n    q.subscribe(function (message) {\n        // Print messages to stdout\n        console.log(message);\n    });\n});\n```\n\n});\n. ",
    "zcaudate": "what is the status of this issue.\n\nI'm getting it too but in jasmine tests on node.  I get this when I create a Connection. Even when I call conn.end(), there is still a warning.\n\n```\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.connect (/Users/Chris/dev/play/node-webkit-amqp-cljs/app/node_modules/amqp/amqp.js:1083:8)\n    at Connection.reconnect (/Users/Chris/dev/play/node-webkit-amqp-cljs/app/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/Users/Chris/dev/play/node-webkit-amqp-cljs/app/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:179:8)\n    at Connection.connect (/Users/Chris/dev/play/node-webkit-amqp-cljs/app/node_modules/amqp/amqp.js:1084:8)\n```\n. what is the status of this issue.\n\nI'm getting it too but in jasmine tests on node.  I get this when I create a Connection. Even when I call conn.end(), there is still a warning.\n\n```\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.connect (/Users/Chris/dev/play/node-webkit-amqp-cljs/app/node_modules/amqp/amqp.js:1083:8)\n    at Connection.reconnect (/Users/Chris/dev/play/node-webkit-amqp-cljs/app/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/Users/Chris/dev/play/node-webkit-amqp-cljs/app/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:179:8)\n    at Connection.connect (/Users/Chris/dev/play/node-webkit-amqp-cljs/app/node_modules/amqp/amqp.js:1084:8)\n```\n. ",
    "badaozhai": "(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Request.EventEmitter.addListener (events.js:160:15)  \n    at ClientRequest.g (events.js:175:14)\n    at ClientRequest.EventEmitter.emit (events.js:95:17)\n    at HTTPParser.parserOnIncomingClient [as onIncoming](http.js:1688:21)\n    at HTTPParser.parserOnHeadersComplete [as onHeadersComplete](http.js:121:23)\n    at Socket.socketOnData [as ondata](http.js:1583:20)\n    at TCP.onread (net.js:525:27)\n\ni had try some methods to debug my code,but failed. could somebody help me,thank you very much.\n. (node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Request.EventEmitter.addListener (events.js:160:15)  \n    at ClientRequest.g (events.js:175:14)\n    at ClientRequest.EventEmitter.emit (events.js:95:17)\n    at HTTPParser.parserOnIncomingClient [as onIncoming](http.js:1688:21)\n    at HTTPParser.parserOnHeadersComplete [as onHeadersComplete](http.js:121:23)\n    at Socket.socketOnData [as ondata](http.js:1583:20)\n    at TCP.onread (net.js:525:27)\n\ni had try some methods to debug my code,but failed. could somebody help me,thank you very much.\n. ",
    "dandv": "Maybe a Mikeal's [`request` issue](https://github.com/mikeal/request/issues/673) ?\n. Maybe a Mikeal's [`request` issue](https://github.com/mikeal/request/issues/673) ?\n. ",
    "demchenkoe": "Bug is actual also for last version v0.2.0\n\n```\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:185:8)\n    at Connection.connect (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:1084:8)\n    at Connection.reconnect (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.connect (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:1083:8)\n    at Connection.reconnect (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n```\n. Bug is actual also for last version v0.2.0\n\n```\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.EventEmitter.once (events.js:185:8)\n    at Connection.connect (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:1084:8)\n    at Connection.reconnect (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.\nTrace\n    at Connection.EventEmitter.addListener (events.js:160:15)\n    at Connection.connect (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:1083:8)\n    at Connection.reconnect (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:1049:8)\n    at null._onTimeout (/home/goldy/projects/mcs/node_modules/amqp-rpc/node_modules/amqp/amqp.js:886:16)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n```\n. ",
    "mko": "I noticed the same behavior, and as I was debugging the issue, I discovered that I was actually opening the connection three times because it would error twice and then work the third time.\n\nThis is related to the timing of interacting with exchanges and queues. You've probably attempted to bind a queue to an exchange before the queue creation has resolved (this was my problem).\n\nTry moving any queue binding into the exchange `ready` callback.\n. I noticed the same behavior, and as I was debugging the issue, I discovered that I was actually opening the connection three times because it would error twice and then work the third time.\n\nThis is related to the timing of interacting with exchanges and queues. You've probably attempted to bind a queue to an exchange before the queue creation has resolved (this was my problem).\n\nTry moving any queue binding into the exchange `ready` callback.\n. ",
    "kontrafiktion": "In OSX 10.9 with RabbitMQ 3.2.1, amqp 0.1.7 and the following code:\n\n``` JavaScript\nvar amqpConnectionOptions = { \n  host: 'localhost'\n  , login: 'guest'\n  , password: '***'\n  , authMechanism: 'AMQPLAIN'\n  , vhost: '/'\n  , ssl: { enabled : false }\n}\n\nvar connection = amqp.createConnection(amqpConnectionOptions);\n\n// Wait for connection to become established.\nconnection.addListener('ready', function () {\n\n  console.log(\"ready\");\n\n  // Use the default 'amq.topic' exchange\n  connection.queue('web-train-pos', function(q){\n      // Catch all messages\n      q.bind('#');\n\n      // // Receive messages\n      // q.subscribe(function (message) {\n      //   // Print messages to stdout\n      //   console.log(\"msg: \" + message);\n      // });\n  });\n});\n```\n\nI get an endless number of 'ready' messages\n. In OSX 10.9 with RabbitMQ 3.2.1, amqp 0.1.7 and the following code:\n\n``` JavaScript\nvar amqpConnectionOptions = { \n  host: 'localhost'\n  , login: 'guest'\n  , password: '***'\n  , authMechanism: 'AMQPLAIN'\n  , vhost: '/'\n  , ssl: { enabled : false }\n}\n\nvar connection = amqp.createConnection(amqpConnectionOptions);\n\n// Wait for connection to become established.\nconnection.addListener('ready', function () {\n\n  console.log(\"ready\");\n\n  // Use the default 'amq.topic' exchange\n  connection.queue('web-train-pos', function(q){\n      // Catch all messages\n      q.bind('#');\n\n      // // Receive messages\n      // q.subscribe(function (message) {\n      //   // Print messages to stdout\n      //   console.log(\"msg: \" + message);\n      // });\n  });\n});\n```\n\nI get an endless number of 'ready' messages\n. ",
    "joshribakoff": "Binding once is not an acceptable workaround, that will run the callback upon the first failure, before the connection is established. \n\nHow are you guys delineating between a 'success' ready and a 'failure' ready event??\n. Binding once is not an acceptable workaround, that will run the callback upon the first failure, before the connection is established. \n\nHow are you guys delineating between a 'success' ready and a 'failure' ready event??\n. ",
    "Amberlamps": "mko already described what is happening and how to solve the issue. It might occur when you try to bind a queue to an exchange, that is not ready yet. Connect to the exchange before binding a queue to it.\n. It might occur when you try to bind a queue to an exchange, that is not ready yet. Connect to the exchange before binding a queue to it.\n. `connection.disconnect()` triggers a `ECONNRESET` error and immediately tries to reconnect. Therefore the `ready` event is emitted. In order to disconnect from amqp, I needed to call `connection.destroy()` as well.\n\nWhy is this not in the documentation and why is `connection.disconnect()` not working?\n. mko already described what is happening and how to solve the issue. It might occur when you try to bind a queue to an exchange, that is not ready yet. Connect to the exchange before binding a queue to it.\n. It might occur when you try to bind a queue to an exchange, that is not ready yet. Connect to the exchange before binding a queue to it.\n. `connection.disconnect()` triggers a `ECONNRESET` error and immediately tries to reconnect. Therefore the `ready` event is emitted. In order to disconnect from amqp, I needed to call `connection.destroy()` as well.\n\nWhy is this not in the documentation and why is `connection.disconnect()` not working?\n. ",
    "tungv": "almost a year and no solution?\n. One possible cause is that you got some error in you `ready` listener, which will throw an uncaught exception. The solution for that should be a `try catch` or `process.nextTick` to make sure handlers won't throw.\n. almost a year and no solution?\n. One possible cause is that you got some error in you `ready` listener, which will throw an uncaught exception. The solution for that should be a `try catch` or `process.nextTick` to make sure handlers won't throw.\n. ",
    "piot": "I have the same problem. Multiple 'ready'  (once every second or so) from the createConnection().\n. I have the same problem. Multiple 'ready'  (once every second or so) from the createConnection().\n. ",
    "footloosemoose": "I had the same issue but, as @mko suggested, there was a connection error.\n\nFor those who stumble across this, diagnose the issue by adding an error listener:\n\n```\nconnection.on('error', function(e) {\n  console.log(\"connection error...\", e);\n})\n```\n\nMy issue was that I was trying to change the signature of an exchange (which apparently you can't do?).  I ended up going into the web admin to fix.  All good now.\n. I had the same issue but, as @mko suggested, there was a connection error.\n\nFor those who stumble across this, diagnose the issue by adding an error listener:\n\n```\nconnection.on('error', function(e) {\n  console.log(\"connection error...\", e);\n})\n```\n\nMy issue was that I was trying to change the signature of an exchange (which apparently you can't do?).  I ended up going into the web admin to fix.  All good now.\n. ",
    "jdkanani": "If your `ready` callback throws an error, it will be called again and again.\n\nSolution is to add try/catch block to this code snippet:\nhttps://github.com/postwait/node-amqp/blob/master/lib/connection.js#L507-L515\n\n``` js\ncase methods.connectionOpenOk:\n      // 7. Finally they respond with connectionOpenOk\n      // Whew! That's why they call it the Advanced MQP.\n      if (this._readyCallback) {\n       try{ // <--------------------------------------- Solution\n            this._readyCallback(this);\n        }catch(){}\n        this._readyCallback = null;\n      }\n      this.emit('ready');\n      break;\n```\n\nor make sure your `ready` callback does not throw any error.\n. If your `ready` callback throws an error, it will be called again and again.\n\nSolution is to add try/catch block to this code snippet:\nhttps://github.com/postwait/node-amqp/blob/master/lib/connection.js#L507-L515\n\n``` js\ncase methods.connectionOpenOk:\n      // 7. Finally they respond with connectionOpenOk\n      // Whew! That's why they call it the Advanced MQP.\n      if (this._readyCallback) {\n       try{ // <--------------------------------------- Solution\n            this._readyCallback(this);\n        }catch(){}\n        this._readyCallback = null;\n      }\n      this.emit('ready');\n      break;\n```\n\nor make sure your `ready` callback does not throw any error.\n. ",
    "mmick66": "@footloosemoose Thank you for the suggestion. My problem was indeed that. I was getting an error which I was not tracing. Strange because what I is happening with me is that as soon as I pass a confirm property to the options object I get the error 'TypeError: undefined is not a function'\n\n``` javascript\nconnection.exchange('my.exchange', { \n                                 type: 'direct', \n                                 autoDelete: false, \n                                 durable: true, \n                                 confirm: true \n                           }, function(ex) { });\n```\n\nAny ideas as to why this might be?\n. @footloosemoose Thank you for the suggestion. My problem was indeed that. I was getting an error which I was not tracing. Strange because what I is happening with me is that as soon as I pass a confirm property to the options object I get the error 'TypeError: undefined is not a function'\n\n``` javascript\nconnection.exchange('my.exchange', { \n                                 type: 'direct', \n                                 autoDelete: false, \n                                 durable: true, \n                                 confirm: true \n                           }, function(ex) { });\n```\n\nAny ideas as to why this might be?\n. ",
    "joekarl": "I second this commit. 0.1.7 is too buggy to have it as the latest version on npm.\n. I second this commit. 0.1.7 is too buggy to have it as the latest version on npm.\n. ",
    "maneti": "Agreed, the current npm version is unusable in the latest version of node.\n. Agreed, the current npm version is unusable in the latest version of node.\n. ",
    "sheershoff": "Agreed\n. Agreed\n. ",
    "jergason": "This would help me. What can we do to get it out there?\n. This would help me. What can we do to get it out there?\n. ",
    "ayoung": "@jgato I believe what we're looking for is the `basicConsumeOk` event. `.subscribe()` ultimately calls `.subscribeRaw()` which emits that event.\n\nYou'll see that in [queue.js](https://github.com/postwait/node-amqp/blob/master/lib/queue.js#L51-L72) `basicQos` is only sent when `options.prefetchCount !== undefined` which in my case, and I'm assuming in yours as well, is not true.\n\nThe documentation is a bit misleading in this.\n. Does my closed pull request fix that for you?\n. I just realized this fix won't work.\n. @jgato I believe what we're looking for is the `basicConsumeOk` event. `.subscribe()` ultimately calls `.subscribeRaw()` which emits that event.\n\nYou'll see that in [queue.js](https://github.com/postwait/node-amqp/blob/master/lib/queue.js#L51-L72) `basicQos` is only sent when `options.prefetchCount !== undefined` which in my case, and I'm assuming in yours as well, is not true.\n\nThe documentation is a bit misleading in this.\n. Does my closed pull request fix that for you?\n. I just realized this fix won't work.\n. ",
    "thanigaiv": "I'm seeing the same error. Any workaround for this?\n. I'm seeing the same error. Any workaround for this?\n. ",
    "chanakyap": "i have updated my node-celery to https://github.com/nathan-muir/node-celery , and no error after this . Hope that helps .\n. i have updated my node-celery to https://github.com/nathan-muir/node-celery , and no error after this . Hope that helps .\n. ",
    "davedoesdev": "The second call is a result of this in `Queue.prototype._onMethod`:\n\n``` js\n    case methods.queueDeclareOk:\n      this.state = 'open';\n      this.name = args.queue;\n      this.connection.queues[this.name] = this;\n\n      // Rebind to previously bound exchanges, if present.\n      // Important this is called *before* openCallback, otherwise bindings will happen twice.\n      // Run test-purge to make sure you got this right\n      _.each(this._bindings, function(exchange, exchangeName){\n        _.each(exchange, function(count, routingKey){\n          self.bind(exchangeName, routingKey);\n        });\n      });\n```\n\nI'm guessing your bind gets in first.\n. This only displays `bind` once:\n\n``` js\nvar connect = require('amqp').createConnection();\nvar messages = [];\nmessages.push(' (\\\\-/)');\nmessages.push(\" ('.')  -> hello world\");\nmessages.push('(\") (\")');\n\nconnect.on('ready', function() {\n    var ex = connect.exchange();\n    var q = connect.queue('hello', function () {\n        console.log('declare');\n        q.bind('#');\n        q.on('queueBindOk', function() {\n            console.log('bind');\n            messages.forEach(function(message) {\n                ex.publish('hello', message, {});\n            });\n        });\n    });\n});\n```\n. Yes, it doesn't seem right to display twice. However, this module is quite a high-level wrapper over amqp so it may be that `queueBindOk` is caught in order to rebind the queue when reconnecting (or something like that).\nIt seems each queue uses a separate channel so waiting until the channel is open (which is what the callback to `queue` does) looks like the 'approved' way of doing it.\n. The second call is a result of this in `Queue.prototype._onMethod`:\n\n``` js\n    case methods.queueDeclareOk:\n      this.state = 'open';\n      this.name = args.queue;\n      this.connection.queues[this.name] = this;\n\n      // Rebind to previously bound exchanges, if present.\n      // Important this is called *before* openCallback, otherwise bindings will happen twice.\n      // Run test-purge to make sure you got this right\n      _.each(this._bindings, function(exchange, exchangeName){\n        _.each(exchange, function(count, routingKey){\n          self.bind(exchangeName, routingKey);\n        });\n      });\n```\n\nI'm guessing your bind gets in first.\n. This only displays `bind` once:\n\n``` js\nvar connect = require('amqp').createConnection();\nvar messages = [];\nmessages.push(' (\\\\-/)');\nmessages.push(\" ('.')  -> hello world\");\nmessages.push('(\") (\")');\n\nconnect.on('ready', function() {\n    var ex = connect.exchange();\n    var q = connect.queue('hello', function () {\n        console.log('declare');\n        q.bind('#');\n        q.on('queueBindOk', function() {\n            console.log('bind');\n            messages.forEach(function(message) {\n                ex.publish('hello', message, {});\n            });\n        });\n    });\n});\n```\n. Yes, it doesn't seem right to display twice. However, this module is quite a high-level wrapper over amqp so it may be that `queueBindOk` is caught in order to rebind the queue when reconnecting (or something like that).\nIt seems each queue uses a separate channel so waiting until the channel is open (which is what the callback to `queue` does) looks like the 'approved' way of doing it.\n. ",
    "waynebrantley": "Seems like original should not display twice though, huh?\n. Seems like original should not display twice though, huh?\n. ",
    "jbowes": "oops, might be something wrong with this. closing while i investigate.\n. oops, might be something wrong with this. closing while i investigate.\n. ",
    "jmontrose": "I'll reopen this (without the version bump) when I have a test written.\n. I'll reopen this (without the version bump) when I have a test written.\n. ",
    "zygis": "added to node_modules/amqp/lib/connection.js:698\nconsole.log(args.routingKey.connection._defaultExchange)\n\n```\n{ domain: null,\n  _events: {},\n  _maxListeners: 0,\n  channel: 4,\n  connection: \n   { domain: null,\n     _events: \n      { connect: [Function],\n        data: [Function],\n        error: [Object],\n        ready: [Object],\n        end: [Function] },\n     _maxListeners: 10,\n     options: \n      { host: 'somehost',\n        port: '5672',\n        login: 'guest',\n        password: 'guest',\n        authMechanism: 'AMQPLAIN',\n        vhost: '/',\n        ssl: [Object],\n        clientProperties: [Object] },\n     implOptions: \n      { defaultExchangeName: '',\n        reconnect: true,\n        reconnectBackoffStrategy: 'linear',\n        reconnectExponentialLimit: 120000,\n        reconnectBackoffTime: 1000 },\n     connectionAttemptScheduled: false,\n     _defaultExchange: [Circular],\n     channelCounter: 4,\n     _sendBuffer: <Buffer 01 00 04 00 00 00 0e 00 3c 00 28 00 00 00 05 74 61 73 6b 73 00 ce 00 00 ce 00 ce 00 00 00 00 ce 38 08 70 6c 61 74 66 6f 72 6d 53 00 00 00 0d 6e 6f 64 65 ...>,\n     socket: \n      { _connecting: false,\n        _handle: [Object],\n        _readableState: [Object],\n        readable: true,\n        domain: null,\n        _events: [Object],\n        _maxListeners: 10,\n        _writableState: [Object],\n        writable: true,\n        allowHalfOpen: false,\n        onend: null,\n        destroyed: false,\n        errorEmitted: false,\n        bytesRead: 575,\n        _bytesDispatched: 406,\n        _pendingData: null,\n        _pendingEncoding: '',\n        pipe: [Function],\n        addListener: [Function],\n        on: [Function],\n        pause: [Function],\n        resume: [Function],\n        read: [Function],\n        _consuming: true },\n     end: [Function],\n     destroy: [Function],\n     write: [Function],\n     pause: [Function],\n     resume: [Function],\n     setEncoding: [Function],\n     ref: [Function],\n     unref: [Function],\n     address: [Function],\n     channels: \n      { '0': [Circular],\n        '1': [Object],\n        '2': [Object],\n        '3': [Object],\n        '4': [Circular] },\n     queues: { compute: [Object], tasks: [Object] },\n     exchanges: { cache: [Object], '': [Circular] },\n     parser: \n      { isClient: true,\n        state: 'frameHeader',\n        parse: [Function: header],\n        onMethod: [Function],\n        onContent: [Function],\n        onContentHeader: [Function],\n        onHeartBeat: [Function],\n        onError: [Function] },\n     readyEmitted: true,\n     serverProperties: \n      { capabilities: [Object],\n        copyright: 'Copyright (C) 2007-2013 GoPivotal, Inc.',\n        information: 'Licensed under the MPL.  See http://www.rabbitmq.com/',\n        platform: 'Erlang/OTP',\n        product: 'RabbitMQ',\n        version: '3.2.2' },\n     _outboundHeartbeatTimer: null,\n     _inboundHeartbeatTimer: null },\n  _tasks: [ { promise: [Object], reply: null, sent: false, cb: [Function] } ],\n  name: '',\n  binds: 0,\n  exchangeBinds: 0,\n  sourceExchanges: {},\n  options: { autoDelete: true },\n  _openCallback: undefined,\n  _sequence: null,\n  _unAcked: {},\n  state: 'open' }\n```\n\nargs.routingKey.connection._defaultExchange.connection.defaultExchange  [Circular]\n. Message was a simple string. However I solved problem. I noticed that after the first error (even if the error is caught) - begins practically unpredictable things. Already mentioned error, prefetchCount breaks, and so on...\n. added to node_modules/amqp/lib/connection.js:698\nconsole.log(args.routingKey.connection._defaultExchange)\n\n```\n{ domain: null,\n  _events: {},\n  _maxListeners: 0,\n  channel: 4,\n  connection: \n   { domain: null,\n     _events: \n      { connect: [Function],\n        data: [Function],\n        error: [Object],\n        ready: [Object],\n        end: [Function] },\n     _maxListeners: 10,\n     options: \n      { host: 'somehost',\n        port: '5672',\n        login: 'guest',\n        password: 'guest',\n        authMechanism: 'AMQPLAIN',\n        vhost: '/',\n        ssl: [Object],\n        clientProperties: [Object] },\n     implOptions: \n      { defaultExchangeName: '',\n        reconnect: true,\n        reconnectBackoffStrategy: 'linear',\n        reconnectExponentialLimit: 120000,\n        reconnectBackoffTime: 1000 },\n     connectionAttemptScheduled: false,\n     _defaultExchange: [Circular],\n     channelCounter: 4,\n     _sendBuffer: <Buffer 01 00 04 00 00 00 0e 00 3c 00 28 00 00 00 05 74 61 73 6b 73 00 ce 00 00 ce 00 ce 00 00 00 00 ce 38 08 70 6c 61 74 66 6f 72 6d 53 00 00 00 0d 6e 6f 64 65 ...>,\n     socket: \n      { _connecting: false,\n        _handle: [Object],\n        _readableState: [Object],\n        readable: true,\n        domain: null,\n        _events: [Object],\n        _maxListeners: 10,\n        _writableState: [Object],\n        writable: true,\n        allowHalfOpen: false,\n        onend: null,\n        destroyed: false,\n        errorEmitted: false,\n        bytesRead: 575,\n        _bytesDispatched: 406,\n        _pendingData: null,\n        _pendingEncoding: '',\n        pipe: [Function],\n        addListener: [Function],\n        on: [Function],\n        pause: [Function],\n        resume: [Function],\n        read: [Function],\n        _consuming: true },\n     end: [Function],\n     destroy: [Function],\n     write: [Function],\n     pause: [Function],\n     resume: [Function],\n     setEncoding: [Function],\n     ref: [Function],\n     unref: [Function],\n     address: [Function],\n     channels: \n      { '0': [Circular],\n        '1': [Object],\n        '2': [Object],\n        '3': [Object],\n        '4': [Circular] },\n     queues: { compute: [Object], tasks: [Object] },\n     exchanges: { cache: [Object], '': [Circular] },\n     parser: \n      { isClient: true,\n        state: 'frameHeader',\n        parse: [Function: header],\n        onMethod: [Function],\n        onContent: [Function],\n        onContentHeader: [Function],\n        onHeartBeat: [Function],\n        onError: [Function] },\n     readyEmitted: true,\n     serverProperties: \n      { capabilities: [Object],\n        copyright: 'Copyright (C) 2007-2013 GoPivotal, Inc.',\n        information: 'Licensed under the MPL.  See http://www.rabbitmq.com/',\n        platform: 'Erlang/OTP',\n        product: 'RabbitMQ',\n        version: '3.2.2' },\n     _outboundHeartbeatTimer: null,\n     _inboundHeartbeatTimer: null },\n  _tasks: [ { promise: [Object], reply: null, sent: false, cb: [Function] } ],\n  name: '',\n  binds: 0,\n  exchangeBinds: 0,\n  sourceExchanges: {},\n  options: { autoDelete: true },\n  _openCallback: undefined,\n  _sequence: null,\n  _unAcked: {},\n  state: 'open' }\n```\n\nargs.routingKey.connection._defaultExchange.connection.defaultExchange  [Circular]\n. Message was a simple string. However I solved problem. I noticed that after the first error (even if the error is caught) - begins practically unpredictable things. Already mentioned error, prefetchCount breaks, and so on...\n. ",
    "dr-fozzy": "Hi. I faced the same problem. \nThe solution is to use connection.once('ready'... instead connection.on('ready'...\n. Hi. I faced the same problem. \nThe solution is to use connection.once('ready'... instead connection.on('ready'...\n. ",
    "tj": "it also uses a lot of CPU, absolutely should not be in production (at least when we were using it at cloudup, unless that has been resolved), but either way it shouldn't be in this module\n. it also uses a lot of CPU, absolutely should not be in production (at least when we were using it at cloudup, unless that has been resolved), but either way it shouldn't be in this module\n. ",
    "thanodnl": "I have this script in our app repo which takes messages from queue A and publishes them to queue B before the change the output was:\n\nnode test/performance/rbmq.js worker a b\nBound queue 'rbmqtest-a' to '#'\nRunning in development mode\nProcessing...\nProcessed 1000 objects in 32873ms (30 per second)\nProcessed 1000 objects in 23739ms (42 per second)\nProcessed 1000 objects in 31317ms (32 per second)\nProcessed 1000 objects in 23106ms (43 per second)\nProcessed 1000 objects in 26902ms (37 per second)\nProcessed 1000 objects in 28750ms (35 per second)\nProcessed 1000 objects in 30068ms (33 per second)\nProcessed 1000 objects in 31784ms (31 per second)\nProcessed 1000 objects in 30519ms (33 per second)\nProcessed 1000 objects in 27663ms (36 per second)\n\nafter the change the output was:\nnode test/performance/rbmq.js worker c d\nBound queue 'rbmqtest-c' to '#'\nRunning in development mode\nProcessing...\nProcessed 1000 objects in 1314ms (761 per second)\nProcessed 1000 objects in 1220ms (820 per second)\nProcessed 1000 objects in 1155ms (866 per second)\nProcessed 1000 objects in 1589ms (629 per second)\nProcessed 1000 objects in 1172ms (853 per second)\nProcessed 1000 objects in 1382ms (724 per second)\nProcessed 1000 objects in 1053ms (950 per second)\nProcessed 1000 objects in 1320ms (758 per second)\nProcessed 1000 objects in 1102ms (907 per second)\nProcessed 1000 objects in 1231ms (812 per second)\n\nas you see it is almost a 20 fold faster, if you need such a script in your repo to be confident I am willing to make one based on this script.\n. I have this script in our app repo which takes messages from queue A and publishes them to queue B before the change the output was:\n\nnode test/performance/rbmq.js worker a b\nBound queue 'rbmqtest-a' to '#'\nRunning in development mode\nProcessing...\nProcessed 1000 objects in 32873ms (30 per second)\nProcessed 1000 objects in 23739ms (42 per second)\nProcessed 1000 objects in 31317ms (32 per second)\nProcessed 1000 objects in 23106ms (43 per second)\nProcessed 1000 objects in 26902ms (37 per second)\nProcessed 1000 objects in 28750ms (35 per second)\nProcessed 1000 objects in 30068ms (33 per second)\nProcessed 1000 objects in 31784ms (31 per second)\nProcessed 1000 objects in 30519ms (33 per second)\nProcessed 1000 objects in 27663ms (36 per second)\n\nafter the change the output was:\nnode test/performance/rbmq.js worker c d\nBound queue 'rbmqtest-c' to '#'\nRunning in development mode\nProcessing...\nProcessed 1000 objects in 1314ms (761 per second)\nProcessed 1000 objects in 1220ms (820 per second)\nProcessed 1000 objects in 1155ms (866 per second)\nProcessed 1000 objects in 1589ms (629 per second)\nProcessed 1000 objects in 1172ms (853 per second)\nProcessed 1000 objects in 1382ms (724 per second)\nProcessed 1000 objects in 1053ms (950 per second)\nProcessed 1000 objects in 1320ms (758 per second)\nProcessed 1000 objects in 1102ms (907 per second)\nProcessed 1000 objects in 1231ms (812 per second)\n\nas you see it is almost a 20 fold faster, if you need such a script in your repo to be confident I am willing to make one based on this script.\n. ",
    "mrvisser": "+1 Here's how you can reproduce the networking phenomenon:\n\n``` javascript\nvar net = require('net');\nvar util = require('util');\n\nvar server = net.createServer(function(c) {\n    c.on('data', function(data) {\n        console.log('received data: %s', data.toString());\n    });\n});\n\nserver.listen(8124, function() {\n    var client = net.connect({'port': 8124}, function() {\n        var b = new Buffer('hello ');\n        for (var i = 0; i < 121000; i ++) {\n            client.write(b);\n            if (i % 10000 === 0) {\n                console.log(client.bufferSize);\n            }\n        }\n\n        // Modify the buffer in place. Anything that gets held onto by _stream_writeable.js due to\n        // back-pressure will be handed to tcp_wrap (net.js) in a new tick and therefore this corruption\n        // will take effect\n        b[1] = 255;\n\n        client.end();\n        server.close();\n    });\n});\n```\n\nThis reproduces it with less than 1Mb of data going out a socket on my Macbook. In low-I/O situations, the buffer gets sent to tcp_wrap and the buffer gets copied. But when the OS buffer is full, `_stream_writable.js` starts [holding onto the buffers by reference](https://github.com/joyent/node/blob/v0.10.17/lib/_stream_writable.js#L207) which makes them susceptible to overwrites in the shared buffer.\n. I've posted a test that reproduces this on node-amqp master, and verified it's fixed by this PR: https://gist.github.com/mrvisser/8915100\n\nThis test fails when:\n\na) Not enough I/O was generated for it to cause the error conditions\nb) The bug is triggered, resulting in an exception and the RabbitMQ connection being dropped\n\nIt succeeds when it receives all expected messages and has eaten up quite a bit of your RAM :(\n. @aheckmann @gjohnson were either of you able to get around to reproducing with my test case?\n. +1 Here's how you can reproduce the networking phenomenon:\n\n``` javascript\nvar net = require('net');\nvar util = require('util');\n\nvar server = net.createServer(function(c) {\n    c.on('data', function(data) {\n        console.log('received data: %s', data.toString());\n    });\n});\n\nserver.listen(8124, function() {\n    var client = net.connect({'port': 8124}, function() {\n        var b = new Buffer('hello ');\n        for (var i = 0; i < 121000; i ++) {\n            client.write(b);\n            if (i % 10000 === 0) {\n                console.log(client.bufferSize);\n            }\n        }\n\n        // Modify the buffer in place. Anything that gets held onto by _stream_writeable.js due to\n        // back-pressure will be handed to tcp_wrap (net.js) in a new tick and therefore this corruption\n        // will take effect\n        b[1] = 255;\n\n        client.end();\n        server.close();\n    });\n});\n```\n\nThis reproduces it with less than 1Mb of data going out a socket on my Macbook. In low-I/O situations, the buffer gets sent to tcp_wrap and the buffer gets copied. But when the OS buffer is full, `_stream_writable.js` starts [holding onto the buffers by reference](https://github.com/joyent/node/blob/v0.10.17/lib/_stream_writable.js#L207) which makes them susceptible to overwrites in the shared buffer.\n. I've posted a test that reproduces this on node-amqp master, and verified it's fixed by this PR: https://gist.github.com/mrvisser/8915100\n\nThis test fails when:\n\na) Not enough I/O was generated for it to cause the error conditions\nb) The bug is triggered, resulting in an exception and the RabbitMQ connection being dropped\n\nIt succeeds when it receives all expected messages and has eaten up quite a bit of your RAM :(\n. @aheckmann @gjohnson were either of you able to get around to reproducing with my test case?\n. ",
    "rehno-lindeque": "+1 Appears to have fixed the problem for me\n. +1 Appears to have fixed the problem for me\n. ",
    "podviaznikov": "I have the same question.\n\nIs it possible to update message headers? I want to update them in case of failure (before `messageObject.reject(true);`).\n. I have the same question.\n\nIs it possible to update message headers? I want to update them in case of failure (before `messageObject.reject(true);`).\n. ",
    "mcasimir": "big +1\n. Same issue, can u reopen/explain what is the right way to completely close a connection?\n. big +1\n. Same issue, can u reopen/explain what is the right way to completely close a connection?\n. ",
    "djhojd": "+1, same here\n. +1, same here\n. ",
    "rafaelkaufmann": "+1 for this issue on CentOS 6.3, Node 0.10.22, RabbitMQ 3.2.3, node-amqp v0.1.8. Also, I did not get the error on my development machine, which is a Mac OS Mavericks installation with same configurations otherwise.\n. @theartoflogic: you should be aware that socket.destroy() does not actually end the connection. I tried to use @glenjamin 's `disconnect` branch, which features a `connectionCloseOk` handler, and replaced `socket.end()` with `socket.destroy()` there. This did shut up the exception, but a look at `rabbitmqadmin list connections` afterwards will show you that the connection still exists as far as the Rabbit server is concerned. These dangling connections can very well build up...\n. That's truly bizarre @theartoflogic. Thanks for sharing. :+1: \n. @glenjamin, I wound up fleeing from the problem :) Meaning I refactored my app to be less dependent on the details of connection management...\n. +1 for this issue on CentOS 6.3, Node 0.10.22, RabbitMQ 3.2.3, node-amqp v0.1.8. Also, I did not get the error on my development machine, which is a Mac OS Mavericks installation with same configurations otherwise.\n. @theartoflogic: you should be aware that socket.destroy() does not actually end the connection. I tried to use @glenjamin 's `disconnect` branch, which features a `connectionCloseOk` handler, and replaced `socket.end()` with `socket.destroy()` there. This did shut up the exception, but a look at `rabbitmqadmin list connections` afterwards will show you that the connection still exists as far as the Rabbit server is concerned. These dangling connections can very well build up...\n. That's truly bizarre @theartoflogic. Thanks for sharing. :+1: \n. @glenjamin, I wound up fleeing from the problem :) Meaning I refactored my app to be less dependent on the details of connection management...\n. ",
    "OJezu": "It seems that RabbitMQ responds to TCP FIN packet with RST packet:\n\n```\n 35 1.061573000    127.0.0.1 -> 127.0.0.1    TCP 66 47322 > amqp [FIN, ACK] Seq=356 Ack=512 Win=32768 Len=0 TSval=123271910 TSecr=123271909\n 36 1.061735000    127.0.0.1 -> 127.0.0.1    TCP 66 amqp > 47322 [RST, ACK] Seq=512 Ack=357 Win=32768 Len=0 TSval=123271910 TSecr=123271910\n```\n\nIt happens no matter if the node-amqp is from master, or from #248. It can either be a bug or working-as-intented on RabbitMQ side. I would file a bug upstream, but no idea where their bug tracker is (mailing list?)\n. @glenjamin it is not problem of app sending data after close. It seems that RabbitMQ responds (on TCP level) with RST to client's FIN. I did some tracing, and there is no packet sent to RabbitMQ after amqp's Close. RST may be intentional, i.e. RabbitMQ does not wish to do full for way close, but cuts the connection short with RST. If that is the case, then probably something should handle and quiet ECONNRESET after closeOk is received.\n. Potential fix in OhJeez/node-amqp@7b8572eb . I will create PR as soon as I test it.\n. It seems that RabbitMQ responds to TCP FIN packet with RST packet:\n\n```\n 35 1.061573000    127.0.0.1 -> 127.0.0.1    TCP 66 47322 > amqp [FIN, ACK] Seq=356 Ack=512 Win=32768 Len=0 TSval=123271910 TSecr=123271909\n 36 1.061735000    127.0.0.1 -> 127.0.0.1    TCP 66 amqp > 47322 [RST, ACK] Seq=512 Ack=357 Win=32768 Len=0 TSval=123271910 TSecr=123271910\n```\n\nIt happens no matter if the node-amqp is from master, or from #248. It can either be a bug or working-as-intented on RabbitMQ side. I would file a bug upstream, but no idea where their bug tracker is (mailing list?)\n. @glenjamin it is not problem of app sending data after close. It seems that RabbitMQ responds (on TCP level) with RST to client's FIN. I did some tracing, and there is no packet sent to RabbitMQ after amqp's Close. RST may be intentional, i.e. RabbitMQ does not wish to do full for way close, but cuts the connection short with RST. If that is the case, then probably something should handle and quiet ECONNRESET after closeOk is received.\n. Potential fix in OhJeez/node-amqp@7b8572eb . I will create PR as soon as I test it.\n. ",
    "bicubic": "I've been stuck on this issue for a while, can definitely confirm. This makes it impossible to maintain a persistent connection for long periods of time, and in turn makes this library unsuitable for real world applications. I hope this gets priority. \n. I've been stuck on this issue for a while, can definitely confirm. This makes it impossible to maintain a persistent connection for long periods of time, and in turn makes this library unsuitable for real world applications. I hope this gets priority. \n. ",
    "zeusdeux": "@mrjoes I am using the same workaround. But in my case it's leaking channels. Is it doing the same for you?\n. We are using this in production as well. But if this sees no activity we are going to be shifting to solutions provided by @squaremo \n. @squaremo what's your reasoning behind thinking of reconnection as a misfeature, if I may ask?\n. I have personally shifted our whole codebase from here to @squaremo's amqp.node and the only thing I miss is auto reconnect. This does seem dead, yes.\n. @mrjoes I am using the same workaround. But in my case it's leaking channels. Is it doing the same for you?\n. We are using this in production as well. But if this sees no activity we are going to be shifting to solutions provided by @squaremo \n. @squaremo what's your reasoning behind thinking of reconnection as a misfeature, if I may ask?\n. I have personally shifted our whole codebase from here to @squaremo's amqp.node and the only thing I miss is auto reconnect. This does seem dead, yes.\n. ",
    "dankle": "I'm having the same problem, any updates on this issue?\n. I'm having the same problem, any updates on this issue?\n. ",
    "dchankhour": "That might be an issue since the default is set to true, but i wanted to have the ability to set the autoDelete option for the default exchange.  Basically allow the default exchange to have the same options giving for creating a new exchange:\n\nif (!this._defaultExchange) this._defaultExchange = this.exchange();\n. The issue i was trying to resolve is that i wanted the Default Exchanged to have the autoDelete option set to false which is necessary to make my App behave correctly.   But i noticed that the default exchange is always created with autoDelete set to true.  \n\nMy change does not change the default value, but instead it gives a way of changing the default value if need.\n. I currently have my global RabbitMQ connection:\n\n```\n                var conn = amqp.createConnection({\n                    url: config.rabbit.url[app.get('env')]\n                }, \n                {\n                    defaultExchangeName: 'AppServerWorkExchange',\n                    defaultExchangeAutoDelete: false,\n                    reconnect: false\n                });\n```\n\nOnce the user logs in, i need to create a new queue from a new connection:\n\n```\n                var tempConn = amqp.createConnection({\n                    url: brokers[x].Uri\n                });\n\n                tempConn.on('ready', function() {\n\n                    tempConn.exchange(brokers[x].ExchangeName, {\n                        type: 'topic',\n                        autoDelete: false\n                    }, function(exch) {\n\n                        //Create Private Queue\n                        var eventQueue = tempConn.queue('', {\n                            exclusive: true\n                        }, function(q2) {\n```\n\nOnce the user logs out, i want to clear the connection and the queue.\n. I'm currently not receiving any errors, but the issue is that after i do:\nqueue.unbind\nqueue.destory\nqueue.unsubscribe\n\nI do see that the queue is cleared up , but the number of channels does not go down.\n. I was able to solve the issue by using conn.destroy() but i had to revert to an older version.  it seems that the new version has an issue with disconnect().\n. I was able to fix the issue by actually providing a queue name.  However, i'm still running into an issue where the basicQosOk is getting called back on reconnect.\n. Was able to fix the issue by not allowing the ready call back to fire again on reconnect.\n. After some research, i have gotten the error after the following error has occurred:\n\nUnmatched field {\\\"name\\\":\\\"replyTo\\\",\\\"domain\\\":\\\"shortstr\\\"}\n. That might be an issue since the default is set to true, but i wanted to have the ability to set the autoDelete option for the default exchange.  Basically allow the default exchange to have the same options giving for creating a new exchange:\n\nif (!this._defaultExchange) this._defaultExchange = this.exchange();\n. The issue i was trying to resolve is that i wanted the Default Exchanged to have the autoDelete option set to false which is necessary to make my App behave correctly.   But i noticed that the default exchange is always created with autoDelete set to true.  \n\nMy change does not change the default value, but instead it gives a way of changing the default value if need.\n. I currently have my global RabbitMQ connection:\n\n```\n                var conn = amqp.createConnection({\n                    url: config.rabbit.url[app.get('env')]\n                }, \n                {\n                    defaultExchangeName: 'AppServerWorkExchange',\n                    defaultExchangeAutoDelete: false,\n                    reconnect: false\n                });\n```\n\nOnce the user logs in, i need to create a new queue from a new connection:\n\n```\n                var tempConn = amqp.createConnection({\n                    url: brokers[x].Uri\n                });\n\n                tempConn.on('ready', function() {\n\n                    tempConn.exchange(brokers[x].ExchangeName, {\n                        type: 'topic',\n                        autoDelete: false\n                    }, function(exch) {\n\n                        //Create Private Queue\n                        var eventQueue = tempConn.queue('', {\n                            exclusive: true\n                        }, function(q2) {\n```\n\nOnce the user logs out, i want to clear the connection and the queue.\n. I'm currently not receiving any errors, but the issue is that after i do:\nqueue.unbind\nqueue.destory\nqueue.unsubscribe\n\nI do see that the queue is cleared up , but the number of channels does not go down.\n. I was able to solve the issue by using conn.destroy() but i had to revert to an older version.  it seems that the new version has an issue with disconnect().\n. I was able to fix the issue by actually providing a queue name.  However, i'm still running into an issue where the basicQosOk is getting called back on reconnect.\n. Was able to fix the issue by not allowing the ready call back to fire again on reconnect.\n. After some research, i have gotten the error after the following error has occurred:\n\nUnmatched field {\\\"name\\\":\\\"replyTo\\\",\\\"domain\\\":\\\"shortstr\\\"}\n. ",
    "simonmorley": "I have the same problem here and the connection is not recovering. \n. We've already ported most applications to amqplib and are having a much better time. Sorry to say so.\n\nLet random failures and connection loses. Have processed about 20 million records already.\n\nOnly issue is getting head around the promise based setup. Although there's a callback API available. This of course has nothing to do with squaremo :)\n. @squaremo I agree with your point about auto-recovery. Our Rabbit cluster doesn't sit within our core network and hides behind haproxy. The failures we see are numerous (network fails) and no library we've used handles them all.\n\nInitially I thought this was the responsibility of the library but in hindsight realise the developer needs to be fully aware of why a failure might occur.\n\nWe use your library and don't bother with failures, just let the process die and restart with forever. The microseconds of downtime don't have any affect on us.\n\nHowever, within the ruby-amqp library we also use, we do use the built-in recovery feature but have had to wrap some extra error handling to make it work (primarily in the event RabbitMQ is down when it restarts).\n\nWith node-amqp, even though there was auto-recovery, it didn't work for us. We ended up altering things slightly as per #345 \n\nWith your library, the promise based architecture was a challenge for us but overall, we've had far more success and our random connection drops (and therefore missing data) have vanished completely. The port was worth it :)\n. I have the same problem here and the connection is not recovering. \n. We've already ported most applications to amqplib and are having a much better time. Sorry to say so.\n\nLet random failures and connection loses. Have processed about 20 million records already.\n\nOnly issue is getting head around the promise based setup. Although there's a callback API available. This of course has nothing to do with squaremo :)\n. @squaremo I agree with your point about auto-recovery. Our Rabbit cluster doesn't sit within our core network and hides behind haproxy. The failures we see are numerous (network fails) and no library we've used handles them all.\n\nInitially I thought this was the responsibility of the library but in hindsight realise the developer needs to be fully aware of why a failure might occur.\n\nWe use your library and don't bother with failures, just let the process die and restart with forever. The microseconds of downtime don't have any affect on us.\n\nHowever, within the ruby-amqp library we also use, we do use the built-in recovery feature but have had to wrap some extra error handling to make it work (primarily in the event RabbitMQ is down when it restarts).\n\nWith node-amqp, even though there was auto-recovery, it didn't work for us. We ended up altering things slightly as per #345 \n\nWith your library, the promise based architecture was a challenge for us but overall, we've had far more success and our random connection drops (and therefore missing data) have vanished completely. The port was worth it :)\n. ",
    "lgtml": "The default on the OS is to set Nagle to true on every new socket, meaning noDelay should be false by default. I will find a way to confirm that doc is wrong or not.\n. My co-worker pointed out that the default value for setNoDelay is likely true. I checked the node source and he was right, they allow you to omit the true for backwards compatibility.\n\n```\nSocket.prototype.setNoDelay = function(enable) {\n  // backwards compatibility: assume true when `enable` is omitted\n  if (this._handle && this._handle.setNoDelay)\n    this._handle.setNoDelay(util.isUndefined(enable) ? true : !!enable);\n};\n```\n\nLink: https://github.com/joyent/node/blob/master/lib/net.js#L329\n\nAlso note, when I was load testing through rabbit I saw a huge performance increase once I set this to true on small messages. Dropped from 45ms to 8ms.\n. @davidmba we deployed out fork and here is the performance R/T increase we saw within our system.\n\n![screenshot 2014-03-28 08 40 31](https://cloud.githubusercontent.com/assets/823822/2549063/2ab2f758-b66e-11e3-8a66-3fc95685ea93.png)\n. The default on the OS is to set Nagle to true on every new socket, meaning noDelay should be false by default. I will find a way to confirm that doc is wrong or not.\n. My co-worker pointed out that the default value for setNoDelay is likely true. I checked the node source and he was right, they allow you to omit the true for backwards compatibility.\n\n```\nSocket.prototype.setNoDelay = function(enable) {\n  // backwards compatibility: assume true when `enable` is omitted\n  if (this._handle && this._handle.setNoDelay)\n    this._handle.setNoDelay(util.isUndefined(enable) ? true : !!enable);\n};\n```\n\nLink: https://github.com/joyent/node/blob/master/lib/net.js#L329\n\nAlso note, when I was load testing through rabbit I saw a huge performance increase once I set this to true on small messages. Dropped from 45ms to 8ms.\n. @davidmba we deployed out fork and here is the performance R/T increase we saw within our system.\n\n![screenshot 2014-03-28 08 40 31](https://cloud.githubusercontent.com/assets/823822/2549063/2ab2f758-b66e-11e3-8a66-3fc95685ea93.png)\n. ",
    "gabrielf": "It would be nice if the README mentioned how one is supposed to do error handling. I also discovered the error event by reading the module's source code for someone used to callbacks that get an error as their first parameter it is not immediately obvious how I should detect if a certain rabbit call fails.\n. It would be nice if the README mentioned how one is supposed to do error handling. I also discovered the error event by reading the module's source code for someone used to callbacks that get an error as their first parameter it is not immediately obvious how I should detect if a certain rabbit call fails.\n. ",
    "dattran92": "I have the same problem.\nMy solution is to create connection and channel once when initialising the app. Then use it later. \nLooking forward for better solution.\n. Do you have anywhere in your code beside above to create connection? (for example, create a new connection anytime you publish a message to queue)\n. I have the same problem.\nMy solution is to create connection and channel once when initialising the app. Then use it later. \nLooking forward for better solution.\n. Do you have anywhere in your code beside above to create connection? (for example, create a new connection anytime you publish a message to queue)\n. ",
    "timfpark": "Darn it, missed that option.  Setting this closes the channels automatically.\n. Darn it, missed that option.  Setting this closes the channels automatically.\n. ",
    "mike-lang": "disregard - mistaken PR target\n. disregard - mistaken PR target\n. ",
    "dglozic": "+1 \nIt does not seem to matter which client you use to publish - I got the same result using Eclipse PAHO Java client to publish an MQTT message, and using RabbitMQ for the broker.\n\nWhen using AMQP client to publish to \"amq.topic\" exchange, the error is absent - I get message print to the console as expected.\n. +1 \nIt does not seem to matter which client you use to publish - I got the same result using Eclipse PAHO Java client to publish an MQTT message, and using RabbitMQ for the broker.\n\nWhen using AMQP client to publish to \"amq.topic\" exchange, the error is absent - I get message print to the console as expected.\n. ",
    "evertharmeling": "Seems like I have the same problem, I'm using the `PubSubClient` on my `Arduino` and receiving this error. When publishing with PHP with the `videlalvaro/php-amqplib` it works as expecting (receiving the messages).\n\nBut I can receive the Arduino message with my PHP library.\n\nIn my case the `parseValue` function (in `/amqp/lib/parser.js`), `switch(buffer[buffer.read++])` returns `70`...\n. Seems like I have the same problem, I'm using the `PubSubClient` on my `Arduino` and receiving this error. When publishing with PHP with the `videlalvaro/php-amqplib` it works as expecting (receiving the messages).\n\nBut I can receive the Arduino message with my PHP library.\n\nIn my case the `parseValue` function (in `/amqp/lib/parser.js`), `switch(buffer[buffer.read++])` returns `70`...\n. ",
    "a-c-m": "incomplete issue. please close.\n. incomplete issue. please close.\n. ",
    "jfromaniello": "woops, sorry #333 \n. woops, sorry #333 \n. ",
    "s-ol": "this is an oversight in `node-amqp` I think, [in this ruby lib](http://rubybunny.info/articles/exchanges.html#returned_messages) the payload is available for example:\r\n\r\n>A returned message handler has access to AMQP method (basic.return) information, message metadata and payload (as a byte array). The metadata and message body are returned without modifications so that the application can store the message for later redelivery.\r\n\r\nin [`exchange.js:179`](https://github.com/postwait/node-amqp/blob/1d30ce178d4a1781f2199f136e4e942e725cfa4c/lib/exchange.js#L179) the message should be retrieved just like in the `basicAck` branch above and passed on to the callback IMO.\r\n~~I'm probably going to write a PR for this now.~~\r\n**EDIT:** dropped the meteor package wrapping this lib and switched over to [amqp.node](https://github.com/squaremo/amqp.node) which we are using in another codebase already.. this is an oversight in `node-amqp` I think, [in this ruby lib](http://rubybunny.info/articles/exchanges.html#returned_messages) the payload is available for example:\r\n\r\n>A returned message handler has access to AMQP method (basic.return) information, message metadata and payload (as a byte array). The metadata and message body are returned without modifications so that the application can store the message for later redelivery.\r\n\r\nin [`exchange.js:179`](https://github.com/postwait/node-amqp/blob/1d30ce178d4a1781f2199f136e4e942e725cfa4c/lib/exchange.js#L179) the message should be retrieved just like in the `basicAck` branch above and passed on to the callback IMO.\r\n~~I'm probably going to write a PR for this now.~~\r\n**EDIT:** dropped the meteor package wrapping this lib and switched over to [amqp.node](https://github.com/squaremo/amqp.node) which we are using in another codebase already.. ",
    "ne0c0de": "any news about this issue or could you do it @axelson ?\n. i make a quick workaround which may be suitable for you.\n\nOn https://github.com/postwait/node-amqp/blob/master/lib/queue.js add this line after line#45:\n\n`if (process.env.SUPERVISOR_PROCESS_NAME) consumerTag = process.env.SUPERVISOR_PROCESS_NAME;\n`\n\nThis will set consuemr tag as supervisor process name (which is applicable when you running nodejs consumer with supervisord)\n. any news about this issue or could you do it @axelson ?\n. i make a quick workaround which may be suitable for you.\n\nOn https://github.com/postwait/node-amqp/blob/master/lib/queue.js add this line after line#45:\n\n`if (process.env.SUPERVISOR_PROCESS_NAME) consumerTag = process.env.SUPERVISOR_PROCESS_NAME;\n`\n\nThis will set consuemr tag as supervisor process name (which is applicable when you running nodejs consumer with supervisord)\n. ",
    "albert-lacki": "Two more things to be considered to work with node 0.4\nhttps://github.com/albert-lacki/node-amqp/commit/6aa85dd86f6b827939ad4867af1f7383839baf85\nhttps://github.com/albert-lacki/node-amqp/commit/1bfb9eb31845e0bae20deefb3cca942c9c3e96fe\n\nI don't think it's going to be merged ;-)\n. Two more things to be considered to work with node 0.4\nhttps://github.com/albert-lacki/node-amqp/commit/6aa85dd86f6b827939ad4867af1f7383839baf85\nhttps://github.com/albert-lacki/node-amqp/commit/1bfb9eb31845e0bae20deefb3cca942c9c3e96fe\n\nI don't think it's going to be merged ;-)\n. ",
    "rpadovani": "Confirmed, it's a typo in the code, this patch fixes it (I just started to use the library, I'll try to submit a pacht in next days):\n\n```\n--- a/lib/exchange.js\n+++ b/lib/exchange.js\n@@ -99,7 +99,7 @@ Exchange.prototype._onMethod = function (channel, method, args) {\n             , type:       this.options.type || 'topic'\n             , passive:    !!this.options.passive\n             , durable:    !!this.options.durable\n-            , autoDelete: !!this.options.autoDelete\n+            , auto_delete: !!this.options.autoDelete\n             , internal:   !!this.options.internal\n             , noWait:     false\n             , \"arguments\":this.options.arguments || {}\n```\n. Same problem here, but dropping arguments doesn't solve the issue.\n. Confirmed, it's a typo in the code, this patch fixes it (I just started to use the library, I'll try to submit a pacht in next days):\n\n```\n--- a/lib/exchange.js\n+++ b/lib/exchange.js\n@@ -99,7 +99,7 @@ Exchange.prototype._onMethod = function (channel, method, args) {\n             , type:       this.options.type || 'topic'\n             , passive:    !!this.options.passive\n             , durable:    !!this.options.durable\n-            , autoDelete: !!this.options.autoDelete\n+            , auto_delete: !!this.options.autoDelete\n             , internal:   !!this.options.internal\n             , noWait:     false\n             , \"arguments\":this.options.arguments || {}\n```\n. Same problem here, but dropping arguments doesn't solve the issue.\n. ",
    "jaipradeesh": "I reproduce the same. Anyone working on this?\n. @postwait :point_up: We are using this package in production. Confirm the behavior and I can send a pull request.. I reproduce the same. Anyone working on this?\n. @postwait :point_up: We are using this package in production. Confirm the behavior and I can send a pull request.. ",
    "zcei": "Also faced this issue, when we had to failover our rabbit cluster.\n. Also faced this issue, when we had to failover our rabbit cluster.\n. ",
    "soggie": "We're making heavy use of this library as well, wouldn't mind to contribute. @postwait what do you think? \n. We're making heavy use of this library as well, wouldn't mind to contribute. @postwait what do you think? \n. ",
    "ronald05arias": "This change is very important. Services such as CloudAMQP from Heroku already migrated to the new version and won't let you connect.\n. This change is very important. Services such as CloudAMQP from Heroku already migrated to the new version and won't let you connect.\n. ",
    "fiddlerpianist": "Well, the problem with changing that is that i\"m not really sure what the upper bound is that Rabbit will send us. Setting `frame_max` on RabbitMQ doesn't seem to help, so perhaps it needs to be part of the negotiation process of the client as well? Pika (for instance) appears to allow you to set that as a connection parameter: http://pika.readthedocs.org/en/latest/modules/parameters.html  so I wonder if this is also possible from node-amqp? \n. Well, the problem with changing that is that i\"m not really sure what the upper bound is that Rabbit will send us. Setting `frame_max` on RabbitMQ doesn't seem to help, so perhaps it needs to be part of the negotiation process of the client as well? Pika (for instance) appears to allow you to set that as a connection parameter: http://pika.readthedocs.org/en/latest/modules/parameters.html  so I wonder if this is also possible from node-amqp? \n. ",
    "redben": "Is this one the roadmap ?\n. Is this one the roadmap ?\n. ",
    "algesten": "`q.shift()` is a terrible idea. combined with `prefetchCount` it's a bad bad combo. should be deprecated, shout warnings on use and be removed pronto.\n. `q.shift()` is a terrible idea. combined with `prefetchCount` it's a bad bad combo. should be deprecated, shout warnings on use and be removed pronto.\n. ",
    "chrono": "This issue was due to an invalid input validation on our behalf. We called `connection.queue(null, [...])`\r\n\r\nPerhaps, the library could do some validation of that parameter since this does lead to a crash.. This issue was due to an invalid input validation on our behalf. We called `connection.queue(null, [...])`\r\n\r\nPerhaps, the library could do some validation of that parameter since this does lead to a crash.. ",
    "xjewer": "I have same problem, ERROR:\"Unhandled connection error: INTERNAL_ERROR\" and reconnect amqp client. Don't send this option, if priority equals 0\n. I have same problem, ERROR:\"Unhandled connection error: INTERNAL_ERROR\" and reconnect amqp client. Don't send this option, if priority equals 0\n. ",
    "xaka": "It's implemented as RabbitMQ's extension:\n1. https://www.rabbitmq.com/dlx.html\n2. http://globaldev.co.uk/2014/07/back-off-and-retry-with-rabbitmq/\n. It's implemented as RabbitMQ's extension:\n1. https://www.rabbitmq.com/dlx.html\n2. http://globaldev.co.uk/2014/07/back-off-and-retry-with-rabbitmq/\n. ",
    "noodlefrenzy": "Great, thanks!  I'll take a look at what would be required.\n. Great, thanks!  I'll take a look at what would be required.\n. ",
    "hitesh1818": "Above issue arising when no queue found on the rabbitmq and i am trying to listen it in passive mode.\n. Can you please tell me from where i can add heartbeat i read your documentation but unable to find heartbeat option in config. Please help.\n. Thanks for your reply. I already did this stuff by opened your library\ncode.\n\nOn Mon, Mar 16, 2015 at 3:38 PM, tobias-neubert notifications@github.com\nwrote:\n\n> Well it is only mentioned in the describing test within the readme. It is\n> part of the options object that you pass to the createConnection function:\n> \n> var internalConnection = amqp.createConnection({\n> host: 'your-host',\n> port: 'your-port',\n> login: 'your-user',\n> password: 'your-password',\n> vhost: 'your-virtual-host',\n> heartbeat: 'your heartbeat in seconds'\n> });\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/postwait/node-amqp/issues/382#issuecomment-81556672.\n\n## \n\n_Thanks,_\nHitesh Dobariya,\nArtoon Solutions PVT. LTD\n. Above issue arising when no queue found on the rabbitmq and i am trying to listen it in passive mode.\n. Can you please tell me from where i can add heartbeat i read your documentation but unable to find heartbeat option in config. Please help.\n. Thanks for your reply. I already did this stuff by opened your library\ncode.\n\nOn Mon, Mar 16, 2015 at 3:38 PM, tobias-neubert notifications@github.com\nwrote:\n\n> Well it is only mentioned in the describing test within the readme. It is\n> part of the options object that you pass to the createConnection function:\n> \n> var internalConnection = amqp.createConnection({\n> host: 'your-host',\n> port: 'your-port',\n> login: 'your-user',\n> password: 'your-password',\n> vhost: 'your-virtual-host',\n> heartbeat: 'your heartbeat in seconds'\n> });\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/postwait/node-amqp/issues/382#issuecomment-81556672.\n\n## \n\n_Thanks,_\nHitesh Dobariya,\nArtoon Solutions PVT. LTD\n. ",
    "wei-lee": "@postwait  Thanks for pointing out the issue. Now using URL.parse instead.\n. @postwait  Thanks for pointing out the issue. Now using URL.parse instead.\n. ",
    "kronius": "Same trouble! \nCheck that \"replyTo\" value is string. It works for me :)\n. And me too! Somebody, are you here? We all need help about this issue :)\n. @tcort in your case, you should pass \"confirm\" option while declaring exchange \n_https://github.com/postwait/node-amqp#exchange_\nso, somthing like this:\n\n> connection.exchange(\n>    '< _someName_> ', \n>    { autoDelete:false, ... , **confirm:true** }, \n>    function onExchange(){...}\n> );\n\nI think,  it should h\u0443lp:)\n. Same trouble! \nCheck that \"replyTo\" value is string. It works for me :)\n. And me too! Somebody, are you here? We all need help about this issue :)\n. @tcort in your case, you should pass \"confirm\" option while declaring exchange \n_https://github.com/postwait/node-amqp#exchange_\nso, somthing like this:\n\n> connection.exchange(\n>    '< _someName_> ', \n>    { autoDelete:false, ... , **confirm:true** }, \n>    function onExchange(){...}\n> );\n\nI think,  it should h\u0443lp:)\n. ",
    "YEXINGZHE54": "the same problem, I wish to be notified if I pubilish a message when connection is broken. Instead, connection.on('error') seems to catch the problem, but, how could I know which message is not sent. Or, can publish task restarted after connection reestablished?\n. the same problem, I wish to be notified if I pubilish a message when connection is broken. Instead, connection.on('error') seems to catch the problem, but, how could I know which message is not sent. Or, can publish task restarted after connection reestablished?\n. ",
    "eguzki": "Same issue. Looking forward to having it fixed. I would expect that if connection is closed (as close event notifies), publish method's callback is called with err set to true. Or at least, being able to check connection status.\n. Same issue. Looking forward to having it fixed. I would expect that if connection is closed (as close event notifies), publish method's callback is called with err set to true. Or at least, being able to check connection status.\n. ",
    "andre1810": "+1\n. +1\n. ",
    "skysteve": "+1\n. +1\n. ",
    "robraux": ":+1: To this, there are a number of knock on effects I'm experiencing due to using module from npm. I'm using a commit# from master, but it's far from ideal. \n. :+1: To this, there are a number of knock on effects I'm experiencing due to using module from npm. I'm using a commit# from master, but it's far from ideal. \n. ",
    "tobias-neubert": "Hm, if I understand you correctly, try setting the heartbeat option for node amqp. It is not set per default, which causes the operating system to close an idle connection. \n. Well it is only mentioned in the describing test within the readme. It is part of the options object that you pass to the createConnection function:\n\nvar internalConnection = amqp.createConnection({\n            host: 'your-host',\n            port: 'your-port',\n            login: 'your-user',\n            password: 'your-password',\n            vhost: 'your-virtual-host',\n            heartbeat: 'your heartbeat in seconds'\n        });\n. https://github.com/postwait/node-amqp/pull/386\n. Hm, if I understand you correctly, try setting the heartbeat option for node amqp. It is not set per default, which causes the operating system to close an idle connection. \n. Well it is only mentioned in the describing test within the readme. It is part of the options object that you pass to the createConnection function:\n\nvar internalConnection = amqp.createConnection({\n            host: 'your-host',\n            port: 'your-port',\n            login: 'your-user',\n            password: 'your-password',\n            vhost: 'your-virtual-host',\n            heartbeat: 'your heartbeat in seconds'\n        });\n. https://github.com/postwait/node-amqp/pull/386\n. ",
    "gileze33": "I've been trying to nail down an issue with my rabbitmq instances having constantly growing memory to the point where it hits the watermark in a few days, under consistent loads.\n\nI've since notices that every single time I publish using node-amqp, I see more channels being opened, but those channels are never closed - seems like we've both hit the same problem. I'm going to try over the weekend to do some proper testing and see if I can come up with a fix in a PR.\n. I've been trying to nail down an issue with my rabbitmq instances having constantly growing memory to the point where it hits the watermark in a few days, under consistent loads.\n\nI've since notices that every single time I publish using node-amqp, I see more channels being opened, but those channels are never closed - seems like we've both hit the same problem. I'm going to try over the weekend to do some proper testing and see if I can come up with a fix in a PR.\n. ",
    "dabates": "I am also seeing this problem.. is there another AMQP library that should be used instead of this one?\n. Thanks @AVVS I'm also looking at bramqp and @squaremo 's amqp libraries \n. I am also seeing this problem.. is there another AMQP library that should be used instead of this one?\n. Thanks @AVVS I'm also looking at bramqp and @squaremo 's amqp libraries \n. ",
    "AVVS": "try amqp-coffee from dropbox\n. Try out dropbox/amqp-coffee - it's really good and implements most of the features of amqp/rabbit\n. try amqp-coffee from dropbox\n. Try out dropbox/amqp-coffee - it's really good and implements most of the features of amqp/rabbit\n. ",
    "hayzem": "I switched to wascally. It's pretty good. Especially what I like about it is that you can configure exchanges,queues, etc.  in one file. No need to reconfigure every time you need rabbitmq.\nShould I close the issue?\n. I switched to wascally. It's pretty good. Especially what I like about it is that you can configure exchanges,queues, etc.  in one file. No need to reconfigure every time you need rabbitmq.\nShould I close the issue?\n. ",
    "mbejda": "What a shame. Yea, i switched to Wascally also.\n. What a shame. Yea, i switched to Wascally also.\n. ",
    "mikeatlas": "I've attempted to keep a singleton connection to rabbit open, and within a tight callback burst (50k calls / second), this blows memory anyways:\n\n``` javascript\n.on(\"data\", function(data){         \n    rabbitMQExchange.publish('', data, {contentType: 'application/json'});    \n})\n```\n\nI don't understand how else to \"reuse channels\" when I've got only one instance of the exchange open and am simply calling `.publish()` heavily. Time to try another library I guess :( \n. For what it's worth, I used `memwatch-next` and did a heap dump before/after publishing ~50k messages. These are the results:\n\n``` json\n\"before\": {\n    \"nodes\": 141521,\n    \"size\": \"29.61 mb\",\n    \"size_bytes\": 31045056\n},\n\"after\": {\n    \"nodes\": 804911,\n    \"size\": \"86.8 mb\",\n    \"size_bytes\": 91011512\n}\n```\n\nA nice whopping 50mb - nearly 1mb per 1k messages. I should note that my messages are fairly short JSON objects themselves. Looking at the details of the heap dump, the worst heap growth offenders (>1mb) are:\n\n``` json\n\"details\": [\n  {\n      \"+\": 213898,\n      \"-\": 7889,\n      \"size\": \"7.4 mb\",\n      \"size_bytes\": 7762888,\n      \"what\": \"Array\"\n  },\n  {\n      \"+\": 154195,\n      \"-\": 7,\n      \"size\": \"7.06 mb\",\n      \"size_bytes\": 7401024,\n      \"what\": \"Buffer\"\n  },\n  {\n      \"+\": 154231,\n      \"-\": 65,\n      \"size\": \"10.59 mb\",\n      \"size_bytes\": 11099952,\n      \"what\": \"Closure\"\n  },\n  {\n      \"+\": 3509,\n      \"-\": 0,\n      \"size\": \"27.48 mb\",\n      \"size_bytes\": 28811264,\n      \"what\": \"Native\"\n  },\n  {\n      \"+\": 154191,\n      \"-\": 1,\n      \"size\": \"7.06 mb\",\n      \"size_bytes\": 7401056,\n      \"what\": \"WriteReq\"\n  },\n]\n```\n\nI've even tried narrowing down and simplifying the `publish` code myself, with a forced garbage collection at the end of every `publish`, no callbacks, no tasks, and still no difference in heap growth:\n\n``` javascript\n  publishToExchange: function (routingKey, data, theOptions, callback) {\n    var exchange = module.exports.rabbitMQExchange;\n    var options = _.extend({}, theOptions || {});\n\n    options.routingKey = routingKey;\n    options.exchange   = exchange.name;\n    options.mandatory  = options.mandatory ? true : false;\n    options.immediate  = options.immediate ? true : false;\n    options.reserved1  = 0;\n\n    var methods = require('./borrowed/amqp-definitions').methods;\n\n    exchange.connection._sendMethod(exchange.channel, methods.basicPublish, options);\n    exchange.connection._sendBody(exchange.channel, data, options);\n    new memwatch.gc(); // force a GC!\n  },\n```\n. So - at least on my end I can absolve `node-amqp` partially. Our rabbit server was on its knees, and barely responding (due to other queuing issues). What seems to be the case is that my `publish` closures  (native code + small bits of data) were potentially quickly accumulating on the stack. Hard to replicate now with our flailing server bounced. Regardless, my calls to `publish` were somehow either failing silently or lacking mechanism to eventually fail and be cleaned up by the GC. I'll bow out of this thread for now; in the process we switched to `amqplib/amqp.node`. As you can see above, I referenced other libraries tested such as `amqp-coffee`, both of those threw SSL/TLS errors trying to connect to our rabbit server (which has a self-signed cert; node-amqp does not complain about connecting with a self-signed cert while those other two libraries do). So that's an unrelated issue but another to pop off to an alternative library.\n. I've attempted to keep a singleton connection to rabbit open, and within a tight callback burst (50k calls / second), this blows memory anyways:\n\n``` javascript\n.on(\"data\", function(data){         \n    rabbitMQExchange.publish('', data, {contentType: 'application/json'});    \n})\n```\n\nI don't understand how else to \"reuse channels\" when I've got only one instance of the exchange open and am simply calling `.publish()` heavily. Time to try another library I guess :( \n. For what it's worth, I used `memwatch-next` and did a heap dump before/after publishing ~50k messages. These are the results:\n\n``` json\n\"before\": {\n    \"nodes\": 141521,\n    \"size\": \"29.61 mb\",\n    \"size_bytes\": 31045056\n},\n\"after\": {\n    \"nodes\": 804911,\n    \"size\": \"86.8 mb\",\n    \"size_bytes\": 91011512\n}\n```\n\nA nice whopping 50mb - nearly 1mb per 1k messages. I should note that my messages are fairly short JSON objects themselves. Looking at the details of the heap dump, the worst heap growth offenders (>1mb) are:\n\n``` json\n\"details\": [\n  {\n      \"+\": 213898,\n      \"-\": 7889,\n      \"size\": \"7.4 mb\",\n      \"size_bytes\": 7762888,\n      \"what\": \"Array\"\n  },\n  {\n      \"+\": 154195,\n      \"-\": 7,\n      \"size\": \"7.06 mb\",\n      \"size_bytes\": 7401024,\n      \"what\": \"Buffer\"\n  },\n  {\n      \"+\": 154231,\n      \"-\": 65,\n      \"size\": \"10.59 mb\",\n      \"size_bytes\": 11099952,\n      \"what\": \"Closure\"\n  },\n  {\n      \"+\": 3509,\n      \"-\": 0,\n      \"size\": \"27.48 mb\",\n      \"size_bytes\": 28811264,\n      \"what\": \"Native\"\n  },\n  {\n      \"+\": 154191,\n      \"-\": 1,\n      \"size\": \"7.06 mb\",\n      \"size_bytes\": 7401056,\n      \"what\": \"WriteReq\"\n  },\n]\n```\n\nI've even tried narrowing down and simplifying the `publish` code myself, with a forced garbage collection at the end of every `publish`, no callbacks, no tasks, and still no difference in heap growth:\n\n``` javascript\n  publishToExchange: function (routingKey, data, theOptions, callback) {\n    var exchange = module.exports.rabbitMQExchange;\n    var options = _.extend({}, theOptions || {});\n\n    options.routingKey = routingKey;\n    options.exchange   = exchange.name;\n    options.mandatory  = options.mandatory ? true : false;\n    options.immediate  = options.immediate ? true : false;\n    options.reserved1  = 0;\n\n    var methods = require('./borrowed/amqp-definitions').methods;\n\n    exchange.connection._sendMethod(exchange.channel, methods.basicPublish, options);\n    exchange.connection._sendBody(exchange.channel, data, options);\n    new memwatch.gc(); // force a GC!\n  },\n```\n. So - at least on my end I can absolve `node-amqp` partially. Our rabbit server was on its knees, and barely responding (due to other queuing issues). What seems to be the case is that my `publish` closures  (native code + small bits of data) were potentially quickly accumulating on the stack. Hard to replicate now with our flailing server bounced. Regardless, my calls to `publish` were somehow either failing silently or lacking mechanism to eventually fail and be cleaned up by the GC. I'll bow out of this thread for now; in the process we switched to `amqplib/amqp.node`. As you can see above, I referenced other libraries tested such as `amqp-coffee`, both of those threw SSL/TLS errors trying to connect to our rabbit server (which has a self-signed cert; node-amqp does not complain about connecting with a self-signed cert while those other two libraries do). So that's an unrelated issue but another to pop off to an alternative library.\n. ",
    "curb47": "This fixes our issue as well.  @postwait any chance of getting this merged and released?\n. This fixes our issue as well.  @postwait any chance of getting this merged and released?\n. ",
    "ryanbmilbourne": "I'm also seeing this issue and can replicate it consistently.  Would a maintainer be willing to comment?  It seems like the better behavior would be to either re-bind the channels or release them.\n. I'm also seeing this issue and can replicate it consistently.  Would a maintainer be willing to comment?  It seems like the better behavior would be to either re-bind the channels or release them.\n. ",
    "PritamUpadhyay": "Please read  **README** [here](https://github.com/postwait/node-amqp#connectionqueuename-options-opencallback)\n\n<h3> connection.queue(name[, options][, openCallback]) </h3> \n\n`passive`: boolean, default false. If set, the server will not create the queue. The client can use this to check whether a queue exists without modifying the server state.\n. Please read  **README** [here](https://github.com/postwait/node-amqp#connectionqueuename-options-opencallback)\n\n<h3> connection.queue(name[, options][, openCallback]) </h3> \n\n`passive`: boolean, default false. If set, the server will not create the queue. The client can use this to check whether a queue exists without modifying the server state.\n. ",
    "m2omou": "Yes I have read the readme, but that doesn't really help me, do you have any piece of code to explain it ? \n\nThat would be helpful thank you\n. Yes I have read the readme, but that doesn't really help me, do you have any piece of code to explain it ? \n\nThat would be helpful thank you\n. ",
    "v-yarotsky": "Might help with https://github.com/postwait/node-amqp/issues/373.\n. Might help with https://github.com/postwait/node-amqp/issues/373.\n. ",
    "WooDzu": "Hi @diegoaguilar.\nHave you managed to figure this out?\n. Well, I'm actually facing the same or similar issue. Have added extra \n`connection.on('error', function (e) {\n  console.log('AMQP', e.code, e.message);\n});\n`\nand what I'm getting is:\n`AMQP 404 NOT_FOUND - no exchange 'my_messages' in vhost '/'`\n\nThe only difference is that I create queue after exchange.\n. Hi @diegoaguilar.\nHave you managed to figure this out?\n. Well, I'm actually facing the same or similar issue. Have added extra \n`connection.on('error', function (e) {\n  console.log('AMQP', e.code, e.message);\n});\n`\nand what I'm getting is:\n`AMQP 404 NOT_FOUND - no exchange 'my_messages' in vhost '/'`\n\nThe only difference is that I create queue after exchange.\n. ",
    "diegoaguilar": "@WooDzu kind of, however I'd appreciate your guide and comments\n. @WooDzu kind of, however I'd appreciate your guide and comments\n. ",
    "jcollum": "This just happened to me: \n\n```\n\"Unmatched field {\"name\":\"routingKey\",\"domain\":\"shortstr\"}\"\n```\n\nVery confusing error message. Will update if I figure out what it means. \n. This just happened to me: \n\n```\n\"Unmatched field {\"name\":\"routingKey\",\"domain\":\"shortstr\"}\"\n```\n\nVery confusing error message. Will update if I figure out what it means. \n. ",
    "JunejaTung": "@jcollum  we try undo some code in the `publish` method, don't let message entry taskqueue, it runs ok!\n\n```\n    Exchange.prototype.publish = function (routingKey, data, options, callback) {\n  var self = this;\n\n  if (this.connection._blocked) {\n    if (callback) {\n      return callback(true, new Error('Connection is blocked, server reason: ' + this.connection._blockedReason));\n    } else {\n      return;\n    }\n  }\n\n  options = _.extend({}, options || {});\n  options.routingKey = routingKey;\n  options.exchange   = self.name;\n  options.mandatory  = options.mandatory ? true : false;\n  options.immediate  = options.immediate ? true : false;\n  options.reserved1  = 0;\n\n  var task = {};\n  //var task = this._taskPush(null, function () {\n    //self.connection._sendMethod(self.channel, methods.basicPublish, options);\n    // This interface is probably not appropriate for streaming large files.\n    // (Of course it's arguable about whether AMQP is the appropriate\n    // transport for large files.) The content header wants to know the size\n    // of the data before sending it - so there's no point in trying to have a\n    // general streaming interface - streaming messages of unknown size simply\n    // isn't possible with AMQP. This is all to say, don't send big messages.\n    // If you need to stream something large, chunk it yourself.\n    //self.connection._sendBody(self.channel, data, options);\n  //});\n  self.connection._sendMethod(self.channel, methods.basicPublish, options);\n  self.connection._sendBody(self.channel, data, options);\n  if (self.options.confirm) self._awaitConfirm(task, callback);\n  return task;\n}\n```\n. @jcollum  we try undo some code in the `publish` method, don't let message entry taskqueue, it runs ok!\n\n```\n    Exchange.prototype.publish = function (routingKey, data, options, callback) {\n  var self = this;\n\n  if (this.connection._blocked) {\n    if (callback) {\n      return callback(true, new Error('Connection is blocked, server reason: ' + this.connection._blockedReason));\n    } else {\n      return;\n    }\n  }\n\n  options = _.extend({}, options || {});\n  options.routingKey = routingKey;\n  options.exchange   = self.name;\n  options.mandatory  = options.mandatory ? true : false;\n  options.immediate  = options.immediate ? true : false;\n  options.reserved1  = 0;\n\n  var task = {};\n  //var task = this._taskPush(null, function () {\n    //self.connection._sendMethod(self.channel, methods.basicPublish, options);\n    // This interface is probably not appropriate for streaming large files.\n    // (Of course it's arguable about whether AMQP is the appropriate\n    // transport for large files.) The content header wants to know the size\n    // of the data before sending it - so there's no point in trying to have a\n    // general streaming interface - streaming messages of unknown size simply\n    // isn't possible with AMQP. This is all to say, don't send big messages.\n    // If you need to stream something large, chunk it yourself.\n    //self.connection._sendBody(self.channel, data, options);\n  //});\n  self.connection._sendMethod(self.channel, methods.basicPublish, options);\n  self.connection._sendBody(self.channel, data, options);\n  if (self.options.confirm) self._awaitConfirm(task, callback);\n  return task;\n}\n```\n. ",
    "isaacvale": "@JunejaTung @jcollum This also happened to me with the \"expiration\" field. After a little digging through the code it seems there is a rather strict data type check when serializing the header. All fields are checked against definitions located in \"amqp-definitions-0-9-1.js\".\n\nIn my case the \"expiration\" field is marked as \"shorstr\", which seems like a type-o. I've sent a pull request with the correction #426.\n\nNow, on the issued raised by @JunejaTung:\n\n> Sometimes exchange.publish got confused error. I can sure that routingKey is a string.\n\nit makes sense that an apparent \"random\" error occurs when type checking, but most likely in some cases the value just exceeds the length of 255 characters. Look at the validation in \" serializer.js\"\n\n> if (typeof(param) != \"string\" || param.length > 0xFF) {\n>      throw new Error(\"Unmatched field \" + JSON.stringify(field));\n> }\n. @JunejaTung @jcollum This also happened to me with the \"expiration\" field. After a little digging through the code it seems there is a rather strict data type check when serializing the header. All fields are checked against definitions located in \"amqp-definitions-0-9-1.js\".\n\nIn my case the \"expiration\" field is marked as \"shorstr\", which seems like a type-o. I've sent a pull request with the correction #426.\n\nNow, on the issued raised by @JunejaTung:\n\n> Sometimes exchange.publish got confused error. I can sure that routingKey is a string.\n\nit makes sense that an apparent \"random\" error occurs when type checking, but most likely in some cases the value just exceeds the length of 255 characters. Look at the validation in \" serializer.js\"\n\n> if (typeof(param) != \"string\" || param.length > 0xFF) {\n>      throw new Error(\"Unmatched field \" + JSON.stringify(field));\n> }\n. ",
    "EasyAsABC123": "I'm having the same issue except `param`'s value is `undefined` which obviously isn't a string\n. I'm having the same issue except `param`'s value is `undefined` which obviously isn't a string\n. ",
    "noamshemesh": ":+1: \n. :+1: \n. ",
    "cristiandouce": ":+1: that'd be great! \n. :disappointed: \n. :+1: that'd be great! \n. :disappointed: \n. ",
    "AbdelMat-CP": "Hi,\nIs it possible to publish version 0.2.5 to npm registry please ?\nWith node 5.x, we get some warnings about engine with the current version 0.2.4 : \n\nnpm WARN engine amqp@0.2.4: wanted: {\"node\":\"0.4 || 0.6 || 0.8 || 0.9 || 0.10 || 0.11 || 0.12\"} (current: {\"node\":\"5.4.1\",\"npm\":\"3.3.12\"})\n\nAnd another one with lodash module v1.3.1 that seems to be deprecated, you should use v3.0.0 :\n\nnpm WARN deprecated lodash@1.3.1: lodash@<2.0.0 is no longer maintained. Upgrade to lodash@^3.0.0\n. Hi,\nIs it possible to publish version 0.2.5 to npm registry please ?\nWith node 5.x, we get some warnings about engine with the current version 0.2.4 : \n\nnpm WARN engine amqp@0.2.4: wanted: {\"node\":\"0.4 || 0.6 || 0.8 || 0.9 || 0.10 || 0.11 || 0.12\"} (current: {\"node\":\"5.4.1\",\"npm\":\"3.3.12\"})\n\nAnd another one with lodash module v1.3.1 that seems to be deprecated, you should use v3.0.0 :\n\nnpm WARN deprecated lodash@1.3.1: lodash@<2.0.0 is no longer maintained. Upgrade to lodash@^3.0.0\n. ",
    "ryanlelek": "+1\n. +1\n. ",
    "msurguy": ":+1: please !\n. :+1: please !\n. ",
    "faguirre1": "Please publish this to npm\n. Please publish this to npm\n. ",
    "h2rd": "Please publish new version to npm\n. Please publish new version to npm\n. ",
    "stjohnjohnson": "@postwait can you help us here?\n. @postwait can you help us here?\n. ",
    "kkamkou": "up\n. up\n. ",
    "janflyborg": "It doesn't look that way. No actiivty here for a long time.\n. Thanks for the tip. I'l look into that library.\n. It doesn't look that way. No actiivty here for a long time.\n. Thanks for the tip. I'l look into that library.\n. ",
    "siboulet": "I'm also running in a similar issue. Depending of situation heartbeat does sometime seems to kick in ie. I did get \"no heartbeat or data in last xx seconds\" exception once, but most of the time I don't.\n\nListening for the \"close\" event I can see connection being closed between the 2 heartbeat, so I suspect the problem is with the `if(self.socket.readable)` check which no longer check heartbeat after socket is closed.\n\n@jclulow @chriswiggins did you find a solution to this problem?\n. Anyone tried the new heartbeatForceReconnect option introduced in the latest 0.2.6 release?\n\nhttps://github.com/postwait/node-amqp/commit/4a382125d18d74fdffa450afe5f46c0cff1aef57\n. I'm also running in a similar issue. Depending of situation heartbeat does sometime seems to kick in ie. I did get \"no heartbeat or data in last xx seconds\" exception once, but most of the time I don't.\n\nListening for the \"close\" event I can see connection being closed between the 2 heartbeat, so I suspect the problem is with the `if(self.socket.readable)` check which no longer check heartbeat after socket is closed.\n\n@jclulow @chriswiggins did you find a solution to this problem?\n. Anyone tried the new heartbeatForceReconnect option introduced in the latest 0.2.6 release?\n\nhttps://github.com/postwait/node-amqp/commit/4a382125d18d74fdffa450afe5f46c0cff1aef57\n. ",
    "jclulow": "@siboulet I'm working around it in my library -- https://github.com/joyent/node-urclient/blob/master/lib/mq.js#L362-L375\n. @siboulet I'm working around it in my library -- https://github.com/joyent/node-urclient/blob/master/lib/mq.js#L362-L375\n. ",
    "daxiang28": "I believe you simply set the 'deliveryMode' to 2 when you publish: \nhttps://github.com/postwait/node-amqp#exchangepublishroutingkey-message-options-callback\n\nThis is better described in the Rabbit.js [documentation](http://www.squaremobius.net/rabbit.js/):\n\n> The option 'persistent' relates both to the durable property of queues and to the deliveryMode property given to messages. If a socket is persistent, it will declare queues as durable, and send messages with deliveryMode of 2. The exceptions are SUB sockets, which don't declare their subscription queue as durable, although PUB sockets are allowed to publish persistent (deliveryMode=2) messages; and REQ sockets, which do declare the request queue (that they send to) as durable, but not their own reply queue.\n. I believe you simply set the 'deliveryMode' to 2 when you publish: \nhttps://github.com/postwait/node-amqp#exchangepublishroutingkey-message-options-callback\n\nThis is better described in the Rabbit.js [documentation](http://www.squaremobius.net/rabbit.js/):\n\n> The option 'persistent' relates both to the durable property of queues and to the deliveryMode property given to messages. If a socket is persistent, it will declare queues as durable, and send messages with deliveryMode of 2. The exceptions are SUB sockets, which don't declare their subscription queue as durable, although PUB sockets are allowed to publish persistent (deliveryMode=2) messages; and REQ sockets, which do declare the request queue (that they send to) as durable, but not their own reply queue.\n. ",
    "sempi": "You can pass in an array of hosts in the host field.\n. You can pass in an array of hosts in the host field.\n. ",
    "vinaysahuhbti": "@sempi thanks..\n. @sempi thanks..\n. ",
    "bwoodmansee": "This helped me - thank you!\n. This helped me - thank you!\n. ",
    "MarkHerhold": "I think this can be closed.\n. I think this can be closed.\n. ",
    "hamzaanjum": "I am using the code from this tutorials\n\nhttps://azure.microsoft.com/en-us/documentation/articles/iot-hub-node-node-getstarted/#receive-device-to-cloud-messages\n. I am using the code from this tutorials\n\nhttps://azure.microsoft.com/en-us/documentation/articles/iot-hub-node-node-getstarted/#receive-device-to-cloud-messages\n. ",
    "kfitzgerald": "Fixed in #448 . @postwait done!. Thanks @postwait !. Fixed in #448 . @postwait done!. Thanks @postwait !. ",
    "Seikho": "I've published type definitions to `@types/amqp`\r\n. I've published type definitions to `@types/amqp`\r\n. ",
    "Flet": "@postwait any chance this can be merged and published soon?. @postwait any chance this can be merged and published soon?. ",
    "mgoldsborough": "@postwait thanks for the reply. \r\n\r\nAs you suggested, I modified the code so it does not create the exchange each time.  And this resolved the  initial memory leak warning from node. I kept track of the listeners on the connection object and, when RMQ is running constantly, the listener count remains the same.\r\n\r\nHowever, if the RMQ server is bounced, it looks like the listener count begins to creep upwards, albeit at a slower rate.\r\n\r\nThe code I ran and resulting output is below. \r\n\r\n```\r\nconst EventEmitter = require('events'),\r\n      amqp = require('amqp');\r\n\r\nlet e = new EventEmitter();\r\n\r\nlet connectionOptions = {\r\n    url: 'amqp://guest:guest@127.0.0.1:5672'\r\n};\r\n\r\nlet options = {\r\n    reconnect: true,\r\n    reconnectBackoffStrategy: 'linear',\r\n    reconnectExponentialLimit: 2000,\r\n    reconnectBackoffTime: 1000\r\n};\r\n\r\nlet publishTimer = undefined;\r\n\r\nlet connection = amqp.createConnection(connectionOptions, options);\r\n\r\nconnection.on('error', (err) => {\r\n    console.error('Error connecting to AMQP broker (%s)', connectionOptions.url, err.message);\r\n});\r\n\r\nconnection.on('close', () => {\r\n    console.error('Connection to AMQP broker (%s) closed', connectionOptions.url);\r\n\r\n    // Stop publishing\r\n    if(publishTimer) clearInterval(publishTimer);\r\n\r\n    // Disconnect the connection. I found that if I didn't do this,\r\n    // the connection would not automatically reconect.\r\n    connection.disconnect();\r\n});\r\n\r\nconnection.on('connect', () => {\r\n    console.info('Connection made', connectionOptions.url);\r\n});\r\n\r\nconnection.on('ready', () => {\r\n    console.info('Publisher connection made to AMQP', connectionOptions.url);\r\n\r\n    e.emit('connected');\r\n});\r\n\r\n// Open the exechange\r\ne.on('connected', () => {\r\n    console.dir('got connected');\r\n\r\n    connection.exchange('', {confirm: true}, (exchange) => {\r\n        e.emit('opened', exchange);\r\n    });\r\n});\r\n\r\n// Once the exchange is opened, start interval to publish continously.\r\ne.on('opened', (exchange) => {\r\n    publishTimer = setInterval(() => {\r\n        console.dir('Number of error listeners: ' + connection.listeners('error').length);\r\n\r\n        exchange.publish('telemetry', {abc: 123}, {}, (err) => {\r\n            if(err) {\r\n                console.error('Unable to publish message to queue', 'telemetry', err.message);\r\n                console.dir(err);\r\n            } else {\r\n                console.log('Published!');\r\n            }\r\n        });\r\n    }, 2000);\r\n});\r\n\r\n// Interval to keep process running\r\nsetInterval(() => {\r\n    console.log('Heartbeat');\r\n}, 60000);\r\n```\r\n\r\nAnd here's the output. The comments (indicated by -->) in the file I added to help explain what was going on.\r\n```\r\nConnection made amqp://guest:guest@127.0.0.1:5672\r\nPublisher connection made to AMQP amqp://guest:guest@127.0.0.1:5672\r\n'got connected'\r\n'got opened'\r\n'Number of error listeners: 3'\r\nPublished!\r\n'Number of error listeners: 3'\r\nPublished!\r\n--> THE PREVIOUS 2 LINES REPEAT UNTIL RMQ IS STOPPED. NOTE, THE LISTENER COUNT STAYS CONSTANT\r\n--> RMQ SERVER STOPPED\r\nPublisher connection to AMQP broker (amqp://guest:guest@127.0.0.1:5672) closed\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) This socket has been ended by the other party\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) connect ECONNREFUSED 127.0.0.1:5672\r\nPublisher connection to AMQP broker (amqp://guest:guest@127.0.0.1:5672) closed\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) write after end\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) connect ECONNREFUSED 127.0.0.1:5672\r\n--> THE PREVIOUS 3 LINES ARE REPEATED UNTIL RMQ IS RESTARTED\r\n--> RMQ SERVER RE-STARTED\r\nPublisher connection made to AMQP amqp://guest:guest@127.0.0.1:5672\r\n'got connected'\r\n'got opened'\r\n'Number of error listeners: 4'\r\nPublished!\r\n'Number of error listeners: 4'\r\nPublished!\r\n--> THE PREVIOUS 2 LINES REPEAT UNTIL RMQ IS STOPPED\r\n--> NOTE THE INCREASE IN LISTENER COUNT FROM 3 TO 4\r\n--> RMQ SERVER STOPPED\r\nPublisher connection to AMQP broker (amqp://guest:guest@127.0.0.1:5672) closed\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) This socket has been ended by the other party\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) connect ECONNREFUSED 127.0.0.1:5672\r\nPublisher connection to AMQP broker (amqp://guest:guest@127.0.0.1:5672) closed\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) write after end\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) connect ECONNREFUSED 127.0.0.1:5672\r\n--> THE PREVIOUS 3 LINES ARE REPEATED UNTIL RMQ IS RESTARTED\r\n--> RMQ SERVER RE-STARTED\r\nPublisher connection made to AMQP amqp://guest:guest@127.0.0.1:5672\r\n'got connected'\r\n'got opened'\r\n'Number of error listeners: 5'\r\nPublished!\r\n'Number of error listeners: 5'\r\nPublished!\r\n```\r\n\r\nI ran the test a lot longer and the listener count kept increasing until I ultimately got the same node.js warning, ```(node) warning: possible EventEmitter memory leak detected. 11 error listeners added. Use emitter.setMaxListeners() to increase limit.```.\r\n\r\nAm I improperly handling connections/exchanges or is there a lower level bug in the reconnection logic as it pertains to handling event listeners?\r\n\r\nThanks.\r\n\r\n. @postwait thanks for the reply. \r\n\r\nAs you suggested, I modified the code so it does not create the exchange each time.  And this resolved the  initial memory leak warning from node. I kept track of the listeners on the connection object and, when RMQ is running constantly, the listener count remains the same.\r\n\r\nHowever, if the RMQ server is bounced, it looks like the listener count begins to creep upwards, albeit at a slower rate.\r\n\r\nThe code I ran and resulting output is below. \r\n\r\n```\r\nconst EventEmitter = require('events'),\r\n      amqp = require('amqp');\r\n\r\nlet e = new EventEmitter();\r\n\r\nlet connectionOptions = {\r\n    url: 'amqp://guest:guest@127.0.0.1:5672'\r\n};\r\n\r\nlet options = {\r\n    reconnect: true,\r\n    reconnectBackoffStrategy: 'linear',\r\n    reconnectExponentialLimit: 2000,\r\n    reconnectBackoffTime: 1000\r\n};\r\n\r\nlet publishTimer = undefined;\r\n\r\nlet connection = amqp.createConnection(connectionOptions, options);\r\n\r\nconnection.on('error', (err) => {\r\n    console.error('Error connecting to AMQP broker (%s)', connectionOptions.url, err.message);\r\n});\r\n\r\nconnection.on('close', () => {\r\n    console.error('Connection to AMQP broker (%s) closed', connectionOptions.url);\r\n\r\n    // Stop publishing\r\n    if(publishTimer) clearInterval(publishTimer);\r\n\r\n    // Disconnect the connection. I found that if I didn't do this,\r\n    // the connection would not automatically reconect.\r\n    connection.disconnect();\r\n});\r\n\r\nconnection.on('connect', () => {\r\n    console.info('Connection made', connectionOptions.url);\r\n});\r\n\r\nconnection.on('ready', () => {\r\n    console.info('Publisher connection made to AMQP', connectionOptions.url);\r\n\r\n    e.emit('connected');\r\n});\r\n\r\n// Open the exechange\r\ne.on('connected', () => {\r\n    console.dir('got connected');\r\n\r\n    connection.exchange('', {confirm: true}, (exchange) => {\r\n        e.emit('opened', exchange);\r\n    });\r\n});\r\n\r\n// Once the exchange is opened, start interval to publish continously.\r\ne.on('opened', (exchange) => {\r\n    publishTimer = setInterval(() => {\r\n        console.dir('Number of error listeners: ' + connection.listeners('error').length);\r\n\r\n        exchange.publish('telemetry', {abc: 123}, {}, (err) => {\r\n            if(err) {\r\n                console.error('Unable to publish message to queue', 'telemetry', err.message);\r\n                console.dir(err);\r\n            } else {\r\n                console.log('Published!');\r\n            }\r\n        });\r\n    }, 2000);\r\n});\r\n\r\n// Interval to keep process running\r\nsetInterval(() => {\r\n    console.log('Heartbeat');\r\n}, 60000);\r\n```\r\n\r\nAnd here's the output. The comments (indicated by -->) in the file I added to help explain what was going on.\r\n```\r\nConnection made amqp://guest:guest@127.0.0.1:5672\r\nPublisher connection made to AMQP amqp://guest:guest@127.0.0.1:5672\r\n'got connected'\r\n'got opened'\r\n'Number of error listeners: 3'\r\nPublished!\r\n'Number of error listeners: 3'\r\nPublished!\r\n--> THE PREVIOUS 2 LINES REPEAT UNTIL RMQ IS STOPPED. NOTE, THE LISTENER COUNT STAYS CONSTANT\r\n--> RMQ SERVER STOPPED\r\nPublisher connection to AMQP broker (amqp://guest:guest@127.0.0.1:5672) closed\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) This socket has been ended by the other party\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) connect ECONNREFUSED 127.0.0.1:5672\r\nPublisher connection to AMQP broker (amqp://guest:guest@127.0.0.1:5672) closed\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) write after end\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) connect ECONNREFUSED 127.0.0.1:5672\r\n--> THE PREVIOUS 3 LINES ARE REPEATED UNTIL RMQ IS RESTARTED\r\n--> RMQ SERVER RE-STARTED\r\nPublisher connection made to AMQP amqp://guest:guest@127.0.0.1:5672\r\n'got connected'\r\n'got opened'\r\n'Number of error listeners: 4'\r\nPublished!\r\n'Number of error listeners: 4'\r\nPublished!\r\n--> THE PREVIOUS 2 LINES REPEAT UNTIL RMQ IS STOPPED\r\n--> NOTE THE INCREASE IN LISTENER COUNT FROM 3 TO 4\r\n--> RMQ SERVER STOPPED\r\nPublisher connection to AMQP broker (amqp://guest:guest@127.0.0.1:5672) closed\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) This socket has been ended by the other party\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) connect ECONNREFUSED 127.0.0.1:5672\r\nPublisher connection to AMQP broker (amqp://guest:guest@127.0.0.1:5672) closed\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) write after end\r\nPublisher error connecting to AMQP broker (amqp://guest:guest@127.0.0.1:5672) connect ECONNREFUSED 127.0.0.1:5672\r\n--> THE PREVIOUS 3 LINES ARE REPEATED UNTIL RMQ IS RESTARTED\r\n--> RMQ SERVER RE-STARTED\r\nPublisher connection made to AMQP amqp://guest:guest@127.0.0.1:5672\r\n'got connected'\r\n'got opened'\r\n'Number of error listeners: 5'\r\nPublished!\r\n'Number of error listeners: 5'\r\nPublished!\r\n```\r\n\r\nI ran the test a lot longer and the listener count kept increasing until I ultimately got the same node.js warning, ```(node) warning: possible EventEmitter memory leak detected. 11 error listeners added. Use emitter.setMaxListeners() to increase limit.```.\r\n\r\nAm I improperly handling connections/exchanges or is there a lower level bug in the reconnection logic as it pertains to handling event listeners?\r\n\r\nThanks.\r\n\r\n. ",
    "rtorrero": "I'm also wondering the same. Did you find a solution?. I'm also wondering the same. Did you find a solution?. ",
    "mcgG": "Same issue, calling `disconnect()` will trigger `reconnect()` so a new socket will open, this will cause mocha (>= 3.x) unit test cannot exit properly without `--exit` . A temporary way to fix this issue is to call \r\n`self.connection.setImplOptions({reconnect: false});`\r\nbefore\r\n`connection.disconnect()`\r\nThen, connection will be reconnected by disconnect()'s exception. Same issue, calling `disconnect()` will trigger `reconnect()` so a new socket will open, this will cause mocha (>= 3.x) unit test cannot exit properly without `--exit` . A temporary way to fix this issue is to call \r\n`self.connection.setImplOptions({reconnect: false});`\r\nbefore\r\n`connection.disconnect()`\r\nThen, connection will be reconnected by disconnect()'s exception. ",
    "JimmyPruitt": "I figured it out. The `messageObject` also has a function called `reject`, to be used instead:\r\n\r\n```\r\nq.subscribe({ack: true}, (message, headers, info, messageObject) => {\r\n    messageObject.reject(true) // Will put the message back into the queue\r\n})\r\n```. I figured it out. The `messageObject` also has a function called `reject`, to be used instead:\r\n\r\n```\r\nq.subscribe({ack: true}, (message, headers, info, messageObject) => {\r\n    messageObject.reject(true) // Will put the message back into the queue\r\n})\r\n```. "
}