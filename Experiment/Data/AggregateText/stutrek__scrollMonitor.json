{
    "stutrek": "thank you\n. added to bower and npm too.\n. Thanks!\n. I used it because it's what Crockford uses to create new objects. \n\nhttp://www.room51.co.uk/js/beget.html\n\nIt is the correct use of the word beget because the scrollMonitor creates a new watcher object and hands it to you. Watch doesn't convey the idea that it's creating a new object.\n\nCreate may be a better word to use, since ES5 uses Object.create to make new objects. I'll probably alias that sometime soon.\n. Let me know what you think, you're not the first person to say this.\n. I like it.\n. The arguments for $.extend were in the wrong order in the pull request, causing offsets to be written over by the defaults. Pull to get the fix.\n. Thank you again.\n. iOS stops executing JavaScript while a scroll is in progress. setTimeout, setInterval, and scroll events are all halted until the scroll finishes.\n\nUnfortunately there is no good way around this. You might be able to intercept touches, emulate scroll events and implement your own momentum, but it is outside the scope of this project.\n. Harry! I have been excitedly watching your fork. Your additions look awesome, I will take a closer look tomorrow.\n. I have not forgotten this, but from a practical standpoint, why not just skip this one and go for the next pull request?\n. I'm sorry, I've been very busy lately. Opening day is coming up for MLB and my weekends have been packed.\n\nOverall I love your changes, this is something I really wanted the scrollMonitor to do. I just need to find some free time to test them before merging.\n. I finally got to looking at the changes to the API. I was expecting to create a new ScrollMonitor on a specific container then add watchers to it. Your method does have the advantage of never creating more than one instance per container and jQuery will clean up the memory for you, but if we can make a better API I think we can push that responsibility to the user. I would also like to remove the dependency on jQuery, but I accept that as reality right now.\n\nIt would be awesome if we can reliably have it automatically determine the scrolling container for the element you want to watch. It might also need to watch the container if it's double wrapped in overflow: scroll. \n\nIf that can't be made reliable it's a big enough improvement that we can rethink the API from the start and call it 2.0. Not long after I released it I wished I had made it scrollMonitor.watch instead of scrollMonitor.create, which would be a great candidate for a function that returns a new instance.\n\nRight now it's also missing horizontal scrolling, which is a big deal for Windows 8 apps.\n. Either this or your previous PR is the start of 2.0.\n\nIn terms of speed, there are only two times the scrollMonitor does any work. When elements are added and when a scroll happens. It's ok to be more liberal when elements are added. With some cacheing the performance implications of automatically detecting scroll containers would be negligible. Maybe we'll need to add a recalculateScrollContainer method to watchers in case you want to change the overflow of a parent.\n\nWe need to make sure that we don't slow down performance or memory usage during scroll events at all relative to the current 1.0 version. Run the stress test frequently to keep an eye on this.\n\nI didn't realize that getBoundingClientRect is in IE! Getting rid of jQuery will be easy!\n. This was integrated into version 1.0.10.\n. Good catch, thank you.\n. it's tagged and in npm\n. fixed with @kenzic 's pull request\n. Thanks!\n\nIt does suck that it doesn't just work in <=IE8, but adding the prototype is outside the scope of this project. I think changing to regular fors instead of forEaches is the way to go.\n\nIf you're up for changing that I'll accept the pull request.\n\nI don't want to use jQuery.each because I plan on removing the dependency on jQuery for version 2.\n. Looks great. Thank you.\n. I would keep an array of watchers and check the state of each one when the state of any of them change. You could sort them be watcher.top and take the first one that isInViewport. Iterating and checking boolean values is very cheap. \n. This demo might be of interest. http://sakabako.github.io/scrollMonitor/demos/list.html\n. You can prevent this by adding a doctype to your html document, just add `<!doctype html>` before the `<html>` tag. jQuery reports the size of the window incorrectly without a doctype. Adding it will probably fix other confusing issues you may be experiencing.\n\nHowever, you are correct that it should just work. I'll look for a fix.\n. A quick fix is to put the scrollMonitor tag above your require tag.\n\nI'm hesitant to have it always assign to a global because people will stop declaring the scrollMonitor as a dependency and their site will break when they remove whatever random module did declare it. If this gets some +1s, I will concede.\n\nIf it's loaded with an AMD loader, you can add this before your non-AMD code:\n\n``` javascript\nwindow.scrollMonitor = require('scrollMonitor/scrollMonitor');\n```\n\nI'm not certain what to do if it's loaded with a script tag after require is loaded because I don't know how require will identify it. If you can find out, please let me know.\n\nWhat library are you using that depends on the scroll monitor?\n. I have two goals for the scrollMonitor, one is to remove the dependency on jQuery. The other is the opposite, to make it a jQuery plugin. It sounds making it a plugin would solve the problem in your case (and 99% of everyone else's use cases). If you make make a jQuery plugin wrapper for it and send me a pull request I'll accept it.\n\nPersonally, I like the way Swipe did this.\n\nhttps://github.com/bradbirdsall/Swipe/blob/master/swipe.js#L556\n. If the jQuery plugin wrapper is inside the factory function, and the function still returns the scrollMonitor, it'll work both ways.\n. Implemented in v1.2.0. Thanks @oroce and @JaapRood!\n. I don't know. Maybe you can make it happen. If you can make it work there and still in modern browsers I'll accept a pull request.\n. Thank you @theorm! I was planning to do this!\n\nI have some android devices here, I'll give it a shot today or tomorrow.\n. I'm sorry, I didn't notice your update and I've been very busy at work, next week I will have more time. It's almost there. I'm very excited for this, I can guarantee that it'll be part of the library soon.\n\nThere's one tiny thing and one larger thing. Every time scrollTop() is called the DOM gets touched between one and six times. If you can use the cached value on exports.viewportTop in recalculateLocations the code will be faster.\n\nUnfortunately this is a library so it needs to support Internet Explorer. I think it just needs a check for attachEvent instead of addEventListener. The coding part will be trivial but testing will be time consuming. There are three options: download the VMs and run them (XP, 7 and 8.1, then IE version emulation), use browserstack for $19, or write unit tests and run them with testling. I am leaning toward testling because this needs unit tests anyway. I can make time for that this weekend.\n. I just want to update you on this: I didn't finish the unit tests, but they're on my list. I'll have some more time Sunday or Saturday if it's rainy.\n. This looks good, I used sea.js for a project and loved it a few years ago, when there was English documentation.\n\nI see you're using jQuery 1.7.2, can that be set to >= 1.2.6 with spm?\n. Thanks!\n. Tank you, Eduardo! I am on vacation but I'll merge when I get home.\n\n> On Jul 7, 2014, at 5:21 AM, Eduardo notifications@github.com wrote:\n> \n> I've just read the README and it's very complete. One minor issue though: on the Locking section the listeners (enterViewport / exitViewport) was swapped.\n> \n> You can merge this Pull Request by running\n> \n>   git pull https://github.com/eduardomb/scrollMonitor master\n> Or view, comment on, or merge it at:\n> \n>   https://github.com/sakabako/scrollMonitor/pull/24\n> \n> Commit Summary\n> \n> Swap enter/exit viewport methods on README example\n> File Changes\n> \n> M README.md (4)\n> Patch Links:\n> \n> https://github.com/sakabako/scrollMonitor/pull/24.patch\n> https://github.com/sakabako/scrollMonitor/pull/24.diff\n> \u2014\n> Reply to this email directly or view it on GitHub.\n. I'm sorry, the example is correct. It adds the fixed class when the element exits the viewport and removes it when it reenters.\n\nThanks for keeping an eye out!\n. #11 is a pull request that does just that. I haven't accepted it because I wanted it to determine the scroll container automatically and avoid additional dependency on jQuery.\n. This solution appears to be straightforward, but it brings ambiguity to the API. Should it measure the actual viewport or the container? What happens if the element is scrolled into the container, but the container is not in the viewport? What if the element is 100% in the container, but only 50% in the viewport? Should two separate sets of events cover these situations? \n\nI don't want to support this until it is done correctly, which may come soon(ish) since summer is over. I recommend using @hswolff's fork until then. I would appreciate your input on what you think is \"right\" for these situations. If I knew it would have implemented it.\n. Also, great work on the works in progress, @myconcretelab.\n. Here's the API I think is best. LMK if anyone interested in implementing it in a PR and I can help with a more specific spec with errors, etc.\n\n``` javascript\n// create an instance that watches scrolling of a specific element\nvar containerMonitor = scrollMonitor.createContainer(containerElement);\n\n// create watchers that watch the scrolling of that element\nvar watcher = containerMonitor.create(childElement);\nvar watcher2 = containerMonitor.create(otherChildElement);\n```\n\nThis is the smallest change that could be made to the API, it might even be a minor version since `scrollMonitor.create()` would just reference an instance that watches the window. The watcher creation API is the same if you're creating from the window or a different container. It also makes it simple to clean up after yourself, a .destroy method would remove all listeners from the DOM.\n\nThere is a wide consensus that it should only notify you when an element scrolls into its parent, and that the visibility of that parent is irrelevant.\n. EVERYONE! It's been almost a year, but we have substantial progress!!\r\n\r\nLeave your comments and concerns on stutrek/scrollMonitor#53\r\n\r\n. Implemented in version 1.2.0, check the readme for docs.. Good catch. I'll fix this weekend or accept a PR about it if you want to make the change.\n. fixed in 1.0.9\n. see #29 \n. Thanks for your usage and contribution. Can you tell me more about your use case? \n\nThe triggerCallbacks method was not meant to be called by the outside, as is specified in the documentation. I am having a hard time imagining a time when you would want the scrollMonitor to call 'enterViewport' when the element isn't in the viewport. Usually a better solution would be to hold on to your callbacks and call them when needed. If you are unable to do that, you can dig through the callbacks object, but don't expect forward compatibility.\n. Ahhh, I believe you're looking for scrollMonitor.recalculateLocations(). That will trigger any watchers that have changed.\n. You can run the tests with testling or testem, they need to be in a browser or scrolling is moot.\n. There is something wrong with the library, and you're most certainly not the first person to encouther it, but I think this PR is adding a hack to the scrollMonitor so I'm not going to accept it. You did bring to light a weakness in the library, and I am very thankful for that. This is the only way I get feedback. Unfortunately there needs to be some magic in when watchers get recalculated, and when it doesn't fit with your magic the situation becomes confusing.\n\nYou can use scrollMonitor.recalculateLocations(), or watcher.recalculateLocation(), or you can trigger a scroll event on the body (if as a side effect the document height changed).\n\nI do agree that there is a weakness in either the documentation, the API, or both. I am open to suggestions on how to fix that problem in a way that won't allow the scollMonitor to be used as an array of callbacks. I think finding a way to highlight scrollMonitor.recalculateLocations() or watcher.recalculateLocation() in the docs would solve the issue for people that have this problem in the future.\n\nI don't think that offering a way to trigger a single event is a good thing, especially if the item might not be in that state. I have worked with large codebases that use $(...).trigger(...) a lot and it leads to unpredictable behavior with tons of side effects. I don't want this library to encourage the same thing.\n. You can use function.bind or $.proxy for the this keyword.\n\nIf people +1 this or your bug I will concede.\n\n> On Oct 9, 2014, at 9:35 AM, walker flynn notifications@github.com wrote:\n> \n> If you add namespacing to trigger then you can limit those side effects. This can be done pretty simply, but would be a larger refactor. The main problem I've encountered trying to hold on to my call backs and invoke them manually is that I can no longer use the this key word. Which means I also have to keep track of which watcher I'm calling it on. Recalculate location doesn't work in my situation because there is a stateChange in the fixed element but not the watchedElement. I really think a trigger method is an expected feature, but I'll find a way.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Thank you. I'll merge and make a patch version later, probably after the holiday.\n. This is a hard one because requirejs needs the capitals. I made this before browserify and bower were big. If I had to do it again I would have named the file scrollmonitor.js without the camel case. However, I'm not going to make a major version change to do that.\n\nI honestly don't know what the best thing to do here is. If people +1 it I'll merge.\n. Updated patch version to v1.0.12\n. I have good news and bad news.\n\nThe good news is that in iOS 8 scroll events are triggered as the user scrolls. With time this issue will fall to the wayside.\n\nThe bad news is that in iOS 7 and before the browser will refuse to run any javascript at all between the time the user starts scrolling and when momentum finishes. All timers, requestAnimationFrame, events, and callbacks from ajax requests are halted. Android does the same.\n\nIt would be possible to make a library that intercepts the scrolls, uses RAF to change the scrollTop of the document and emulates momentum, but I that's outside the scope of this project.\n\nIf you're up for the challenge of making that library, you can use RAF and this library to determine your scrollTop values: https://github.com/arian/cubic-bezier\n\nA very accurate feeling equation for Android momentum is `bezier(0.103, 0.389, 0.307, 0.966)`. Determining the travel distance (epsilon) is harder. To do it accurately you need to hold on to the touch events as the user's finger is down and measure the distance between the most recent and the one that is at most 1/4 second old. I did it in my fork of Swiper, the code is buried in an imperative mess.\n. Pretty soon I'm going to have time to work on this, I was planning on adding something that will let you manually set the scrollTop so you can connect it to something like iscroll.\n\nZynga, of all companies, also has a very cool scroll product that uses transforms.\n\n> On Feb 12, 2015, at 5:53 AM, Quique Borred\u00e1 notifications@github.com wrote:\n> \n> Indeed, the changes to iOS 8 are going to be something big regarding scroll events. \n> Meanwhile, I've used iScroll in some other projects successfully .. it exposes a 'scroll' event more similar to the common onScroll behaviour we're used to .. \n> https://github.com/cubiq/iscroll\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. I was never able to make the time for it. Fortunately, for newer iOS devices, scroll events trigger on every frame.\n. Does anyone know if this is still an issue? @bensmeets?. Closing, Moore's Law solved this one.. I didn't, if it's still an issue hopefully someone finds it quickly. The new version should make it pretty easy to add a non-DOM scroll source.. You're right, it shouldn't be that way. If you make a PR that fixes this I'll accept and `npm publish`.\n\nStart with this branch if you can: https://github.com/sakabako/scrollMonitor/pull/33\n\nThanks\n. Thanks! I might not be able to handle this until next week, but it will make it.\n. Sorry guys, I'll do it now.\n. I see, the partially left event should not fire. I'll see if I can look this weekend. Thanks for a great bug report.\n. Thanks! I like this. The tests are an issue, I copied them from someone that didn't fully understand testem and it didn't help me understand testem either. The tests are the only thing holding this up. Until then `npm install -S jldec/scrollMonitor`\n. It's not, but there's enough interest that if someone updates a PR I'll accept it.. Thanks for the heads up. I changed my username a while ago and forgot to update the links. They're fixed now.\n. Closing as this functionality was removed.. Thanks! Would you mind squashing this to one commit?\n. Thanks!!\n. Thanks again. I updated it.\n. Which event are you talking about?\n\nI recommend using the `stateChange` or `visibilityChange` events and checking the state of the watcher instead of using the transition events because it significantly reduces the complexity of your code and eliminates the possibility of bugs like this.\n. Your code looks correct, are you rewriting innerHTML anywhere?\n. It only watches scroll events on the body. If you have an element with overflow: auto it will not work. This is something I plan on changing for version 2.\n. If you're still attempting this, overflow: auto works with the latest version. Offsets are meant for this purpose. https://github.com/stutrek/scrollMonitor#offsets\n. This is by design. Recalculating locations is very expensive, if you know it must be done you must call it directly.\n. As long as the locations relative to the top of the document don't change all is good. If you change the DOM or the height of things above without also changing the height of the whole document it will break.\n. It only watches the body, if you're watching a container it simply won't work. I have an API designed but no time to implement it\n. @adeopura4 version 1.2 works with arbitrary DOM elements in addition to the body. It might solve your problem now.. you have to tell it which callback you want to remove, it doesn't clear them all out like jquery does.\n\nYou can `monitor.destory()` if you want to destroy it.\n. The scrollMonitor is very fast. Your page will jank because of a gigantic body or intense CSS long before it janks because of the scrollMonitor. See the stress test. http://stutrek.github.io/scrollMonitor/demos/stress.html\n\nThere is no option for debouncing because it would provide no benefit. No element is entering then exiting the viewport in less time than the debouncing would cover. You can't get every scroll event from the monitor right now, only callbacks when the state of an item changes.\n\nAlso note that you are never limiting the time it takes a callback to fire, you're delaying the jank caused by slow code. If you're running into jank issues you should put calls to `console.profile('scroll callback')` and `console.profileEnd('scroll callback')` around your code to figure out what's slowing you down.\n. I see. You can use setTimeout (or `_.debounce`) and the state of the watcher to do this.\n\n``` javascript\nvar imageWatcher = scrollMonitor.create(img);\nimageWatcher.stateChange(_.debounce(function () {\n    if (imageWatcher.isInViewport) {\n        img.src = 'foo.png';\n        imageWatcher.destroy();\n    }\n}, 300));\n```\n\nDebouncing is a feature that's available in enough other places that I don't think it also needs to be provided here.\n. I apologize if I was curt, if you google articles about listening to scroll events almost all of them suggest debouncing or throttling in a very different way than you are. I hope you make the most of the library and thanks for participating.\n. \ud83d\ude2e\r\n\r\nIs it consistent between browsers?. Oops, published.. Thank you. That is exactly what happened. . The bower people fixed it. Run `bower cache clean` to get their update. . Full story: I changed my username a long time ago, and someone finally wised up to that. . Thanks for your interest!\r\n\r\nYou're absolutely right that es6 modules look a lot better and have advantages over require. [Initially I made it with es6 modules](https://github.com/stutrek/scrollMonitor/commit/f88afe9b9b066176778169750f66369390588eb6), but babel uses Object.defineProperties when it transpiles the code, which breaks in IE8. Since this is a library and I can't control what other people need to support, I decided not to break IE8. Most of the other things that are ugly come from performance tweaking, some of which was made to apply to a previous generation of browsers.\r\n\r\nFor the whitespace there's a utility called smudge that you can add to your git attributes file to change the indentation on your working copy. This gist sets up your git configs to use it. https://gist.github.com/stutrek/5ab23a0e05ce391e251e83b769c4079e. If you clean things up and add some comments I'd really appreciate that, but you'll have to work from a fork. Github won't let you make a PR if the source and target don't share a common ancestor. @stephenkingsley if you'd like a simple contribution that you can do without having to reformat the code, etc. you can add this: stutrek/scrollMonitor#56\r\n\r\nThere's a good method of feature detection here:\r\nhttps://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection. Unfortunately you cannot. It's a surprisingly rare feature request.. \ud83d\udc4d . If you were wondering, that alert is there to debug IE8.. If you make a PR and I'll almost definitely accept it.. Thanks for figuring it out. I'll leave this issue open for anyone else with this problem.. Oh my. Thank you!. Do you have source maps configured in webpack? It should be something along the lines of \r\n\r\n```\r\n    devtool: 'sourcemap'\r\n```. Yeah, you should use source maps to stop this error and for your own sanity. Right now it's looking for the source map that it would use if you used a script tag, which isn't being served. When webpack builds with a source map it's smart enough to use the bundled one.. Good catch! I'm on vacation I'll take a look next week.\n\nOn Mon, Mar 20, 2017 at 3:38 PM Ari Palo <notifications@github.com> wrote:\n\n> First, thanks for the awesome library. It does its job very well \ud83d\udc4d\n> ------------------------------\n>\n> Just to nitpick, the current implementation defines global variable\n> window.scrollMonitor explicitly in index.js#L10\n> <https://github.com/stutrek/scrollMonitor/blob/f88afe9b9b066176778169750f66369390588eb6/index.js#L10>\n> :\n>\n> if (isInBrowser) {\n>   window.scrollMonitor = scrollMonitor;\n> }\n>\n> This is somewhat unwanted functionality in AMD environments (especially\n> when one is developing cross-site widgets and want to avoid conflicts with\n> globals on host sites).\n>\n> As a solution, I propose we get rid of the explicit global\n> window.scrollMonitor definition and we let the Webpack Universal Module\n> Definition target template handle it *as you already use it*\n> <https://github.com/stutrek/scrollMonitor/blob/v1.2.3/webpack.config.js#L9-L11>\n> :\n>\n> (function webpackUniversalModuleDefinition(root, factory) {\n> \tif(typeof exports === 'object' && typeof module === 'object')\n> \t\tmodule.exports = factory();\n> \telse if(typeof define === 'function' && define.amd)\n> \t\tdefine([], factory);\n> \telse {\n> \t\tvar a = factory();\n> \t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n> \t}\n> })(this, function() {\n>   // the rest of the webpack bootstrap ...\n>   // actual scrollMonitor scripts ...\n>\n> Which basically checks if in:\n>\n>    1. CommonJS environment\n>    2. AMD environment\n>    3. Attach to root/global, which in browserland is window\n>    \u2026 and then initializes the library for the first environment it\n>    detects.\n>\n> ------------------------------\n> You can view, comment on, or merge this pull request online at:\n>\n>   https://github.com/stutrek/scrollMonitor/pull/62\n> Commit Summary\n>\n>    - Remove explicit window.scrollMonitor definition\n>\n> File Changes\n>\n>    - *M* index.js\n>    <https://github.com/stutrek/scrollMonitor/pull/62/files#diff-0> (4)\n>\n> Patch Links:\n>\n>    - https://github.com/stutrek/scrollMonitor/pull/62.patch\n>    - https://github.com/stutrek/scrollMonitor/pull/62.diff\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/stutrek/scrollMonitor/pull/62>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAUtfzWfTRSBFCOraC2001-bFkHiEeA6ks5rnp2OgaJpZM4MimuH>\n> .\n>\n. I see what you did here. Originally I had it like this, until #19. Initially I didn't implement it because, like you, I thought it was a little weird. Since then I ran into some use case myself (maybe it was testing? I can't remember) and I decided that pragmatism is the way to go: just let people use it like that. Unfortunately, now that it's like this (and I'm not saying it was a good idea), changing it back would be a major version change because someone might be using it... foolishly.\r\n\r\nThanks for the contribution. Keep making the world around you better.. Thanks for using this!\r\n\r\nI think you have a logic problem here. It's surprisingly hard to get everything right when using the specific events, I usually do an `elementWatcher.stateChange` and check the [boolean properties](https://github.com/stutrek/scrollMonitor#properties). You'll probably need to check `elementWatcher.isBelowViewport`.\r\n\r\nYou may need to use `elementWatcher.lock` or `elementWatcher.recalculate` at some point too.. You might need to use `scrollMonitor.recalculateLocations()` or `watcher.recalculateLocation()` after changing the DOM.. Call recalculateLocations again.. You have to call it when you collapse the content too.. I see. When it's recalculated it's already in the viewport because it has fixed positioning. Try watching the content rather than the button you're changing.. I think it's getting confused because you have an offset of -300 on an element that's smaller that 300px. Try removing that.. I'm assuming that fixed your issue. Closing.. are you destroying then recreating the elements? If so you'll also need to destroy and recreate the watchers.. Thanks! I'll take a look and probably add a link. Until then I'll leave this issue open so other people can find it.. Thank you! Someone made a request for this in #56 when version 2 came out, it's great to have the new feature.\r\n\r\nI have some requests, but they are all very minor.\r\n\r\n* `useCapture` is declared in an if statement and used in a following block. Although it works, please don't do this as it is confusing. You can declare it at the base level of the module instead, possibly with just the try/catch and no function call.\r\n* `isSupportsPassive` is grammatically incorrect, a better name would be `browserSupportsPassive` or `passiveIsSupported`. If you remove the function call this is no longer important.\r\n* Change spaces to tabs\r\n* Change double quotes to single quotes.. \ud83c\udf89 \ud83c\udf8a \ud83c\udf89 \r\n\r\nI'll test and merge soon. The best way to do this is to pass a debounced or throttled function into the scrollmonitor. Lodash and underscore both have great implementations of this.\r\n\r\nIf you have a situation where the scrollmonitor itself, not the callbacks applied to it, are causing a performance issue please send me some sample code.. I have no plans to, but a PR implementing it would be welcome.. Everything uses pixels. You can use `window.innerHeight` as a workaround. https://developer.mozilla.org/en-US/docs/Web/API/Window/innerHeight. thank you\n. added to bower and npm too.\n. Thanks!\n. I used it because it's what Crockford uses to create new objects. \n\nhttp://www.room51.co.uk/js/beget.html\n\nIt is the correct use of the word beget because the scrollMonitor creates a new watcher object and hands it to you. Watch doesn't convey the idea that it's creating a new object.\n\nCreate may be a better word to use, since ES5 uses Object.create to make new objects. I'll probably alias that sometime soon.\n. Let me know what you think, you're not the first person to say this.\n. I like it.\n. The arguments for $.extend were in the wrong order in the pull request, causing offsets to be written over by the defaults. Pull to get the fix.\n. Thank you again.\n. iOS stops executing JavaScript while a scroll is in progress. setTimeout, setInterval, and scroll events are all halted until the scroll finishes.\n\nUnfortunately there is no good way around this. You might be able to intercept touches, emulate scroll events and implement your own momentum, but it is outside the scope of this project.\n. Harry! I have been excitedly watching your fork. Your additions look awesome, I will take a closer look tomorrow.\n. I have not forgotten this, but from a practical standpoint, why not just skip this one and go for the next pull request?\n. I'm sorry, I've been very busy lately. Opening day is coming up for MLB and my weekends have been packed.\n\nOverall I love your changes, this is something I really wanted the scrollMonitor to do. I just need to find some free time to test them before merging.\n. I finally got to looking at the changes to the API. I was expecting to create a new ScrollMonitor on a specific container then add watchers to it. Your method does have the advantage of never creating more than one instance per container and jQuery will clean up the memory for you, but if we can make a better API I think we can push that responsibility to the user. I would also like to remove the dependency on jQuery, but I accept that as reality right now.\n\nIt would be awesome if we can reliably have it automatically determine the scrolling container for the element you want to watch. It might also need to watch the container if it's double wrapped in overflow: scroll. \n\nIf that can't be made reliable it's a big enough improvement that we can rethink the API from the start and call it 2.0. Not long after I released it I wished I had made it scrollMonitor.watch instead of scrollMonitor.create, which would be a great candidate for a function that returns a new instance.\n\nRight now it's also missing horizontal scrolling, which is a big deal for Windows 8 apps.\n. Either this or your previous PR is the start of 2.0.\n\nIn terms of speed, there are only two times the scrollMonitor does any work. When elements are added and when a scroll happens. It's ok to be more liberal when elements are added. With some cacheing the performance implications of automatically detecting scroll containers would be negligible. Maybe we'll need to add a recalculateScrollContainer method to watchers in case you want to change the overflow of a parent.\n\nWe need to make sure that we don't slow down performance or memory usage during scroll events at all relative to the current 1.0 version. Run the stress test frequently to keep an eye on this.\n\nI didn't realize that getBoundingClientRect is in IE! Getting rid of jQuery will be easy!\n. This was integrated into version 1.0.10.\n. Good catch, thank you.\n. it's tagged and in npm\n. fixed with @kenzic 's pull request\n. Thanks!\n\nIt does suck that it doesn't just work in <=IE8, but adding the prototype is outside the scope of this project. I think changing to regular fors instead of forEaches is the way to go.\n\nIf you're up for changing that I'll accept the pull request.\n\nI don't want to use jQuery.each because I plan on removing the dependency on jQuery for version 2.\n. Looks great. Thank you.\n. I would keep an array of watchers and check the state of each one when the state of any of them change. You could sort them be watcher.top and take the first one that isInViewport. Iterating and checking boolean values is very cheap. \n. This demo might be of interest. http://sakabako.github.io/scrollMonitor/demos/list.html\n. You can prevent this by adding a doctype to your html document, just add `<!doctype html>` before the `<html>` tag. jQuery reports the size of the window incorrectly without a doctype. Adding it will probably fix other confusing issues you may be experiencing.\n\nHowever, you are correct that it should just work. I'll look for a fix.\n. A quick fix is to put the scrollMonitor tag above your require tag.\n\nI'm hesitant to have it always assign to a global because people will stop declaring the scrollMonitor as a dependency and their site will break when they remove whatever random module did declare it. If this gets some +1s, I will concede.\n\nIf it's loaded with an AMD loader, you can add this before your non-AMD code:\n\n``` javascript\nwindow.scrollMonitor = require('scrollMonitor/scrollMonitor');\n```\n\nI'm not certain what to do if it's loaded with a script tag after require is loaded because I don't know how require will identify it. If you can find out, please let me know.\n\nWhat library are you using that depends on the scroll monitor?\n. I have two goals for the scrollMonitor, one is to remove the dependency on jQuery. The other is the opposite, to make it a jQuery plugin. It sounds making it a plugin would solve the problem in your case (and 99% of everyone else's use cases). If you make make a jQuery plugin wrapper for it and send me a pull request I'll accept it.\n\nPersonally, I like the way Swipe did this.\n\nhttps://github.com/bradbirdsall/Swipe/blob/master/swipe.js#L556\n. If the jQuery plugin wrapper is inside the factory function, and the function still returns the scrollMonitor, it'll work both ways.\n. Implemented in v1.2.0. Thanks @oroce and @JaapRood!\n. I don't know. Maybe you can make it happen. If you can make it work there and still in modern browsers I'll accept a pull request.\n. Thank you @theorm! I was planning to do this!\n\nI have some android devices here, I'll give it a shot today or tomorrow.\n. I'm sorry, I didn't notice your update and I've been very busy at work, next week I will have more time. It's almost there. I'm very excited for this, I can guarantee that it'll be part of the library soon.\n\nThere's one tiny thing and one larger thing. Every time scrollTop() is called the DOM gets touched between one and six times. If you can use the cached value on exports.viewportTop in recalculateLocations the code will be faster.\n\nUnfortunately this is a library so it needs to support Internet Explorer. I think it just needs a check for attachEvent instead of addEventListener. The coding part will be trivial but testing will be time consuming. There are three options: download the VMs and run them (XP, 7 and 8.1, then IE version emulation), use browserstack for $19, or write unit tests and run them with testling. I am leaning toward testling because this needs unit tests anyway. I can make time for that this weekend.\n. I just want to update you on this: I didn't finish the unit tests, but they're on my list. I'll have some more time Sunday or Saturday if it's rainy.\n. This looks good, I used sea.js for a project and loved it a few years ago, when there was English documentation.\n\nI see you're using jQuery 1.7.2, can that be set to >= 1.2.6 with spm?\n. Thanks!\n. Tank you, Eduardo! I am on vacation but I'll merge when I get home.\n\n> On Jul 7, 2014, at 5:21 AM, Eduardo notifications@github.com wrote:\n> \n> I've just read the README and it's very complete. One minor issue though: on the Locking section the listeners (enterViewport / exitViewport) was swapped.\n> \n> You can merge this Pull Request by running\n> \n>   git pull https://github.com/eduardomb/scrollMonitor master\n> Or view, comment on, or merge it at:\n> \n>   https://github.com/sakabako/scrollMonitor/pull/24\n> \n> Commit Summary\n> \n> Swap enter/exit viewport methods on README example\n> File Changes\n> \n> M README.md (4)\n> Patch Links:\n> \n> https://github.com/sakabako/scrollMonitor/pull/24.patch\n> https://github.com/sakabako/scrollMonitor/pull/24.diff\n> \u2014\n> Reply to this email directly or view it on GitHub.\n. I'm sorry, the example is correct. It adds the fixed class when the element exits the viewport and removes it when it reenters.\n\nThanks for keeping an eye out!\n. #11 is a pull request that does just that. I haven't accepted it because I wanted it to determine the scroll container automatically and avoid additional dependency on jQuery.\n. This solution appears to be straightforward, but it brings ambiguity to the API. Should it measure the actual viewport or the container? What happens if the element is scrolled into the container, but the container is not in the viewport? What if the element is 100% in the container, but only 50% in the viewport? Should two separate sets of events cover these situations? \n\nI don't want to support this until it is done correctly, which may come soon(ish) since summer is over. I recommend using @hswolff's fork until then. I would appreciate your input on what you think is \"right\" for these situations. If I knew it would have implemented it.\n. Also, great work on the works in progress, @myconcretelab.\n. Here's the API I think is best. LMK if anyone interested in implementing it in a PR and I can help with a more specific spec with errors, etc.\n\n``` javascript\n// create an instance that watches scrolling of a specific element\nvar containerMonitor = scrollMonitor.createContainer(containerElement);\n\n// create watchers that watch the scrolling of that element\nvar watcher = containerMonitor.create(childElement);\nvar watcher2 = containerMonitor.create(otherChildElement);\n```\n\nThis is the smallest change that could be made to the API, it might even be a minor version since `scrollMonitor.create()` would just reference an instance that watches the window. The watcher creation API is the same if you're creating from the window or a different container. It also makes it simple to clean up after yourself, a .destroy method would remove all listeners from the DOM.\n\nThere is a wide consensus that it should only notify you when an element scrolls into its parent, and that the visibility of that parent is irrelevant.\n. EVERYONE! It's been almost a year, but we have substantial progress!!\r\n\r\nLeave your comments and concerns on stutrek/scrollMonitor#53\r\n\r\n. Implemented in version 1.2.0, check the readme for docs.. Good catch. I'll fix this weekend or accept a PR about it if you want to make the change.\n. fixed in 1.0.9\n. see #29 \n. Thanks for your usage and contribution. Can you tell me more about your use case? \n\nThe triggerCallbacks method was not meant to be called by the outside, as is specified in the documentation. I am having a hard time imagining a time when you would want the scrollMonitor to call 'enterViewport' when the element isn't in the viewport. Usually a better solution would be to hold on to your callbacks and call them when needed. If you are unable to do that, you can dig through the callbacks object, but don't expect forward compatibility.\n. Ahhh, I believe you're looking for scrollMonitor.recalculateLocations(). That will trigger any watchers that have changed.\n. You can run the tests with testling or testem, they need to be in a browser or scrolling is moot.\n. There is something wrong with the library, and you're most certainly not the first person to encouther it, but I think this PR is adding a hack to the scrollMonitor so I'm not going to accept it. You did bring to light a weakness in the library, and I am very thankful for that. This is the only way I get feedback. Unfortunately there needs to be some magic in when watchers get recalculated, and when it doesn't fit with your magic the situation becomes confusing.\n\nYou can use scrollMonitor.recalculateLocations(), or watcher.recalculateLocation(), or you can trigger a scroll event on the body (if as a side effect the document height changed).\n\nI do agree that there is a weakness in either the documentation, the API, or both. I am open to suggestions on how to fix that problem in a way that won't allow the scollMonitor to be used as an array of callbacks. I think finding a way to highlight scrollMonitor.recalculateLocations() or watcher.recalculateLocation() in the docs would solve the issue for people that have this problem in the future.\n\nI don't think that offering a way to trigger a single event is a good thing, especially if the item might not be in that state. I have worked with large codebases that use $(...).trigger(...) a lot and it leads to unpredictable behavior with tons of side effects. I don't want this library to encourage the same thing.\n. You can use function.bind or $.proxy for the this keyword.\n\nIf people +1 this or your bug I will concede.\n\n> On Oct 9, 2014, at 9:35 AM, walker flynn notifications@github.com wrote:\n> \n> If you add namespacing to trigger then you can limit those side effects. This can be done pretty simply, but would be a larger refactor. The main problem I've encountered trying to hold on to my call backs and invoke them manually is that I can no longer use the this key word. Which means I also have to keep track of which watcher I'm calling it on. Recalculate location doesn't work in my situation because there is a stateChange in the fixed element but not the watchedElement. I really think a trigger method is an expected feature, but I'll find a way.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Thank you. I'll merge and make a patch version later, probably after the holiday.\n. This is a hard one because requirejs needs the capitals. I made this before browserify and bower were big. If I had to do it again I would have named the file scrollmonitor.js without the camel case. However, I'm not going to make a major version change to do that.\n\nI honestly don't know what the best thing to do here is. If people +1 it I'll merge.\n. Updated patch version to v1.0.12\n. I have good news and bad news.\n\nThe good news is that in iOS 8 scroll events are triggered as the user scrolls. With time this issue will fall to the wayside.\n\nThe bad news is that in iOS 7 and before the browser will refuse to run any javascript at all between the time the user starts scrolling and when momentum finishes. All timers, requestAnimationFrame, events, and callbacks from ajax requests are halted. Android does the same.\n\nIt would be possible to make a library that intercepts the scrolls, uses RAF to change the scrollTop of the document and emulates momentum, but I that's outside the scope of this project.\n\nIf you're up for the challenge of making that library, you can use RAF and this library to determine your scrollTop values: https://github.com/arian/cubic-bezier\n\nA very accurate feeling equation for Android momentum is `bezier(0.103, 0.389, 0.307, 0.966)`. Determining the travel distance (epsilon) is harder. To do it accurately you need to hold on to the touch events as the user's finger is down and measure the distance between the most recent and the one that is at most 1/4 second old. I did it in my fork of Swiper, the code is buried in an imperative mess.\n. Pretty soon I'm going to have time to work on this, I was planning on adding something that will let you manually set the scrollTop so you can connect it to something like iscroll.\n\nZynga, of all companies, also has a very cool scroll product that uses transforms.\n\n> On Feb 12, 2015, at 5:53 AM, Quique Borred\u00e1 notifications@github.com wrote:\n> \n> Indeed, the changes to iOS 8 are going to be something big regarding scroll events. \n> Meanwhile, I've used iScroll in some other projects successfully .. it exposes a 'scroll' event more similar to the common onScroll behaviour we're used to .. \n> https://github.com/cubiq/iscroll\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. I was never able to make the time for it. Fortunately, for newer iOS devices, scroll events trigger on every frame.\n. Does anyone know if this is still an issue? @bensmeets?. Closing, Moore's Law solved this one.. I didn't, if it's still an issue hopefully someone finds it quickly. The new version should make it pretty easy to add a non-DOM scroll source.. You're right, it shouldn't be that way. If you make a PR that fixes this I'll accept and `npm publish`.\n\nStart with this branch if you can: https://github.com/sakabako/scrollMonitor/pull/33\n\nThanks\n. Thanks! I might not be able to handle this until next week, but it will make it.\n. Sorry guys, I'll do it now.\n. I see, the partially left event should not fire. I'll see if I can look this weekend. Thanks for a great bug report.\n. Thanks! I like this. The tests are an issue, I copied them from someone that didn't fully understand testem and it didn't help me understand testem either. The tests are the only thing holding this up. Until then `npm install -S jldec/scrollMonitor`\n. It's not, but there's enough interest that if someone updates a PR I'll accept it.. Thanks for the heads up. I changed my username a while ago and forgot to update the links. They're fixed now.\n. Closing as this functionality was removed.. Thanks! Would you mind squashing this to one commit?\n. Thanks!!\n. Thanks again. I updated it.\n. Which event are you talking about?\n\nI recommend using the `stateChange` or `visibilityChange` events and checking the state of the watcher instead of using the transition events because it significantly reduces the complexity of your code and eliminates the possibility of bugs like this.\n. Your code looks correct, are you rewriting innerHTML anywhere?\n. It only watches scroll events on the body. If you have an element with overflow: auto it will not work. This is something I plan on changing for version 2.\n. If you're still attempting this, overflow: auto works with the latest version. Offsets are meant for this purpose. https://github.com/stutrek/scrollMonitor#offsets\n. This is by design. Recalculating locations is very expensive, if you know it must be done you must call it directly.\n. As long as the locations relative to the top of the document don't change all is good. If you change the DOM or the height of things above without also changing the height of the whole document it will break.\n. It only watches the body, if you're watching a container it simply won't work. I have an API designed but no time to implement it\n. @adeopura4 version 1.2 works with arbitrary DOM elements in addition to the body. It might solve your problem now.. you have to tell it which callback you want to remove, it doesn't clear them all out like jquery does.\n\nYou can `monitor.destory()` if you want to destroy it.\n. The scrollMonitor is very fast. Your page will jank because of a gigantic body or intense CSS long before it janks because of the scrollMonitor. See the stress test. http://stutrek.github.io/scrollMonitor/demos/stress.html\n\nThere is no option for debouncing because it would provide no benefit. No element is entering then exiting the viewport in less time than the debouncing would cover. You can't get every scroll event from the monitor right now, only callbacks when the state of an item changes.\n\nAlso note that you are never limiting the time it takes a callback to fire, you're delaying the jank caused by slow code. If you're running into jank issues you should put calls to `console.profile('scroll callback')` and `console.profileEnd('scroll callback')` around your code to figure out what's slowing you down.\n. I see. You can use setTimeout (or `_.debounce`) and the state of the watcher to do this.\n\n``` javascript\nvar imageWatcher = scrollMonitor.create(img);\nimageWatcher.stateChange(_.debounce(function () {\n    if (imageWatcher.isInViewport) {\n        img.src = 'foo.png';\n        imageWatcher.destroy();\n    }\n}, 300));\n```\n\nDebouncing is a feature that's available in enough other places that I don't think it also needs to be provided here.\n. I apologize if I was curt, if you google articles about listening to scroll events almost all of them suggest debouncing or throttling in a very different way than you are. I hope you make the most of the library and thanks for participating.\n. \ud83d\ude2e\r\n\r\nIs it consistent between browsers?. Oops, published.. Thank you. That is exactly what happened. . The bower people fixed it. Run `bower cache clean` to get their update. . Full story: I changed my username a long time ago, and someone finally wised up to that. . Thanks for your interest!\r\n\r\nYou're absolutely right that es6 modules look a lot better and have advantages over require. [Initially I made it with es6 modules](https://github.com/stutrek/scrollMonitor/commit/f88afe9b9b066176778169750f66369390588eb6), but babel uses Object.defineProperties when it transpiles the code, which breaks in IE8. Since this is a library and I can't control what other people need to support, I decided not to break IE8. Most of the other things that are ugly come from performance tweaking, some of which was made to apply to a previous generation of browsers.\r\n\r\nFor the whitespace there's a utility called smudge that you can add to your git attributes file to change the indentation on your working copy. This gist sets up your git configs to use it. https://gist.github.com/stutrek/5ab23a0e05ce391e251e83b769c4079e. If you clean things up and add some comments I'd really appreciate that, but you'll have to work from a fork. Github won't let you make a PR if the source and target don't share a common ancestor. @stephenkingsley if you'd like a simple contribution that you can do without having to reformat the code, etc. you can add this: stutrek/scrollMonitor#56\r\n\r\nThere's a good method of feature detection here:\r\nhttps://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection. Unfortunately you cannot. It's a surprisingly rare feature request.. \ud83d\udc4d . If you were wondering, that alert is there to debug IE8.. If you make a PR and I'll almost definitely accept it.. Thanks for figuring it out. I'll leave this issue open for anyone else with this problem.. Oh my. Thank you!. Do you have source maps configured in webpack? It should be something along the lines of \r\n\r\n```\r\n    devtool: 'sourcemap'\r\n```. Yeah, you should use source maps to stop this error and for your own sanity. Right now it's looking for the source map that it would use if you used a script tag, which isn't being served. When webpack builds with a source map it's smart enough to use the bundled one.. Good catch! I'm on vacation I'll take a look next week.\n\nOn Mon, Mar 20, 2017 at 3:38 PM Ari Palo <notifications@github.com> wrote:\n\n> First, thanks for the awesome library. It does its job very well \ud83d\udc4d\n> ------------------------------\n>\n> Just to nitpick, the current implementation defines global variable\n> window.scrollMonitor explicitly in index.js#L10\n> <https://github.com/stutrek/scrollMonitor/blob/f88afe9b9b066176778169750f66369390588eb6/index.js#L10>\n> :\n>\n> if (isInBrowser) {\n>   window.scrollMonitor = scrollMonitor;\n> }\n>\n> This is somewhat unwanted functionality in AMD environments (especially\n> when one is developing cross-site widgets and want to avoid conflicts with\n> globals on host sites).\n>\n> As a solution, I propose we get rid of the explicit global\n> window.scrollMonitor definition and we let the Webpack Universal Module\n> Definition target template handle it *as you already use it*\n> <https://github.com/stutrek/scrollMonitor/blob/v1.2.3/webpack.config.js#L9-L11>\n> :\n>\n> (function webpackUniversalModuleDefinition(root, factory) {\n> \tif(typeof exports === 'object' && typeof module === 'object')\n> \t\tmodule.exports = factory();\n> \telse if(typeof define === 'function' && define.amd)\n> \t\tdefine([], factory);\n> \telse {\n> \t\tvar a = factory();\n> \t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n> \t}\n> })(this, function() {\n>   // the rest of the webpack bootstrap ...\n>   // actual scrollMonitor scripts ...\n>\n> Which basically checks if in:\n>\n>    1. CommonJS environment\n>    2. AMD environment\n>    3. Attach to root/global, which in browserland is window\n>    \u2026 and then initializes the library for the first environment it\n>    detects.\n>\n> ------------------------------\n> You can view, comment on, or merge this pull request online at:\n>\n>   https://github.com/stutrek/scrollMonitor/pull/62\n> Commit Summary\n>\n>    - Remove explicit window.scrollMonitor definition\n>\n> File Changes\n>\n>    - *M* index.js\n>    <https://github.com/stutrek/scrollMonitor/pull/62/files#diff-0> (4)\n>\n> Patch Links:\n>\n>    - https://github.com/stutrek/scrollMonitor/pull/62.patch\n>    - https://github.com/stutrek/scrollMonitor/pull/62.diff\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/stutrek/scrollMonitor/pull/62>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAUtfzWfTRSBFCOraC2001-bFkHiEeA6ks5rnp2OgaJpZM4MimuH>\n> .\n>\n. I see what you did here. Originally I had it like this, until #19. Initially I didn't implement it because, like you, I thought it was a little weird. Since then I ran into some use case myself (maybe it was testing? I can't remember) and I decided that pragmatism is the way to go: just let people use it like that. Unfortunately, now that it's like this (and I'm not saying it was a good idea), changing it back would be a major version change because someone might be using it... foolishly.\r\n\r\nThanks for the contribution. Keep making the world around you better.. Thanks for using this!\r\n\r\nI think you have a logic problem here. It's surprisingly hard to get everything right when using the specific events, I usually do an `elementWatcher.stateChange` and check the [boolean properties](https://github.com/stutrek/scrollMonitor#properties). You'll probably need to check `elementWatcher.isBelowViewport`.\r\n\r\nYou may need to use `elementWatcher.lock` or `elementWatcher.recalculate` at some point too.. You might need to use `scrollMonitor.recalculateLocations()` or `watcher.recalculateLocation()` after changing the DOM.. Call recalculateLocations again.. You have to call it when you collapse the content too.. I see. When it's recalculated it's already in the viewport because it has fixed positioning. Try watching the content rather than the button you're changing.. I think it's getting confused because you have an offset of -300 on an element that's smaller that 300px. Try removing that.. I'm assuming that fixed your issue. Closing.. are you destroying then recreating the elements? If so you'll also need to destroy and recreate the watchers.. Thanks! I'll take a look and probably add a link. Until then I'll leave this issue open so other people can find it.. Thank you! Someone made a request for this in #56 when version 2 came out, it's great to have the new feature.\r\n\r\nI have some requests, but they are all very minor.\r\n\r\n* `useCapture` is declared in an if statement and used in a following block. Although it works, please don't do this as it is confusing. You can declare it at the base level of the module instead, possibly with just the try/catch and no function call.\r\n* `isSupportsPassive` is grammatically incorrect, a better name would be `browserSupportsPassive` or `passiveIsSupported`. If you remove the function call this is no longer important.\r\n* Change spaces to tabs\r\n* Change double quotes to single quotes.. \ud83c\udf89 \ud83c\udf8a \ud83c\udf89 \r\n\r\nI'll test and merge soon. The best way to do this is to pass a debounced or throttled function into the scrollmonitor. Lodash and underscore both have great implementations of this.\r\n\r\nIf you have a situation where the scrollmonitor itself, not the callbacks applied to it, are causing a performance issue please send me some sample code.. I have no plans to, but a PR implementing it would be welcome.. Everything uses pixels. You can use `window.innerHeight` as a workaround. https://developer.mozilla.org/en-US/docs/Web/API/Window/innerHeight. ",
    "dylang": "Ha, nice inspiration! \n\nLooks like he changed his mind about `beget`:\n\nhttp://javascript.crockford.com/prototypal.html\n\nStill, is it necessary to name the function based on the way the feature was implemented?  `$(selector)` creates a new object too, right? \n\n_Disclaimer: I discovered your script today thanks to NPM and I hope to try it out tonight. So I haven't used it yet so my naming suggestion might not be correct._\n. Ha, nice inspiration! \n\nLooks like he changed his mind about `beget`:\n\nhttp://javascript.crockford.com/prototypal.html\n\nStill, is it necessary to name the function based on the way the feature was implemented?  `$(selector)` creates a new object too, right? \n\n_Disclaimer: I discovered your script today thanks to NPM and I hope to try it out tonight. So I haven't used it yet so my naming suggestion might not be correct._\n. ",
    "hswolff": "Works for me.  Closing this one, opening new PR shortly.\n. Updated docs to reflect the updated API.  Let me know your thoughts.  Thank you.\n. No worries!  Excited to hear what you think when you can :)\n. Hey @sakabako thanks for the feedback!\n\nI tried to keep the API changes minimal as I didn't want to rock the boat too hard but I like your proposal to update the API with a 2.0 version release.  Perhaps we can take the work done in this PR as the beginning work for version 2.0?\n\nAutomatically determining the scrolling container may be a little expensive to calculate, I'd much prefer to push that decision to the user.\n\nI think it'd be very doable to remove the dependence on jQuery - only a few methods are used, which should be easy to include directly in scrollMonitor (although cross-browser regressions should be avoided).\n\nHorizontal scrolling will be a nice feature to add as well, if not for 2.0 then perhaps for a later version.\n. Just curious, how are we now able to use scrollMonitor with multiple containers on a page?\n. Works for me.  Closing this one, opening new PR shortly.\n. Updated docs to reflect the updated API.  Let me know your thoughts.  Thank you.\n. No worries!  Excited to hear what you think when you can :)\n. Hey @sakabako thanks for the feedback!\n\nI tried to keep the API changes minimal as I didn't want to rock the boat too hard but I like your proposal to update the API with a 2.0 version release.  Perhaps we can take the work done in this PR as the beginning work for version 2.0?\n\nAutomatically determining the scrolling container may be a little expensive to calculate, I'd much prefer to push that decision to the user.\n\nI think it'd be very doable to remove the dependence on jQuery - only a few methods are used, which should be easy to include directly in scrollMonitor (although cross-browser regressions should be avoided).\n\nHorizontal scrolling will be a nice feature to add as well, if not for 2.0 then perhaps for a later version.\n. Just curious, how are we now able to use scrollMonitor with multiple containers on a page?\n. ",
    "marcobarbosa": "I have the same question, the PR looks good but I can't find any functionality on listening to a container?\n. I have the same question, the PR looks good but I can't find any functionality on listening to a container?\n. ",
    "cesasol": "This branch was able to solve my issue where I have a container scrolling and not the html document itself. Thanks hswolff! Hope to see this function integrated sometime.\n. This branch was able to solve my issue where I have a container scrolling and not the html document itself. Thanks hswolff! Hope to see this function integrated sometime.\n. ",
    "afc163": "Count u tag `1.0.3`, please, i need it :)\n. We don't support loose version in dependencies for now (may be in next version). :weary: \n\njQuery@1.7.2 is most popular version in our community, so I set that version.\n. Count u tag `1.0.3`, please, i need it :)\n. We don't support loose version in dependencies for now (may be in next version). :weary: \n\njQuery@1.7.2 is most popular version in our community, so I set that version.\n. ",
    "kenzic": "@sakabako Changed the loops to regular fors.\n. @sakabako Changed the loops to regular fors.\n. ",
    "julien-c": "Ok, looks like jQuery Waypoints might be more suited to this particular use case. @sakabako I'd still be interested in having your opinion on this!\n\nBest,\nJ.\n. Ok, looks like jQuery Waypoints might be more suited to this particular use case. @sakabako I'd still be interested in having your opinion on this!\n\nBest,\nJ.\n. ",
    "lettertwo": ":thumbsup: thanks!\n. I was afraid it was going to be something dumb! Thanks for the quick fix, works flawlessly.\n. :thumbsup: thanks!\n. I was afraid it was going to be something dumb! Thanks for the quick fix, works flawlessly.\n. ",
    "matthewwithanm": "> What library are you using that depends on the scroll monitor?\n\nOne I'm writing (:\n\nI actually am using require in the project I'm working on. However, I don't want my library (a jQuery plugin) to be AMD-aware. (This is the same situation as non-AMD scripts that require jQuery\u2014like underscore or most jQuery plugins.) Since my plugin looks for scrollMonitor on the window object, I would expect to be able to just shim it (as one would with jQuery). However, since scrollMonitor doesn't export itself onto the window object like jQuery, it takes some extra configuration (the `init` function below):\n\n``` javascript\nrequire.config({\n    shim: {\n        'jquery.myplugin': {\n            deps: ['jquery', 'scrollMonitor'],\n            init: function ($, scrollMonitor) {\n                window.scrollMonitor = scrollMonitor;\n            }\n        }\n    }\n});\n```\n\nThis isn't the end of the world, but it's not exactly the most intuitive thing.\n. Hm, interesting. My use case might be a little out of the ordinary, but my project is actually using scrollMonitor both with and without jQuery! My project-specific code is all AMD and I have several views using scrollMonitor (in addition to the project-independent jQuery plugin which uses it). I suppose it wouldn't hurt for them all to use a jQuery plugin version of scrollMonitor though.\n. > What library are you using that depends on the scroll monitor?\n\nOne I'm writing (:\n\nI actually am using require in the project I'm working on. However, I don't want my library (a jQuery plugin) to be AMD-aware. (This is the same situation as non-AMD scripts that require jQuery\u2014like underscore or most jQuery plugins.) Since my plugin looks for scrollMonitor on the window object, I would expect to be able to just shim it (as one would with jQuery). However, since scrollMonitor doesn't export itself onto the window object like jQuery, it takes some extra configuration (the `init` function below):\n\n``` javascript\nrequire.config({\n    shim: {\n        'jquery.myplugin': {\n            deps: ['jquery', 'scrollMonitor'],\n            init: function ($, scrollMonitor) {\n                window.scrollMonitor = scrollMonitor;\n            }\n        }\n    }\n});\n```\n\nThis isn't the end of the world, but it's not exactly the most intuitive thing.\n. Hm, interesting. My use case might be a little out of the ordinary, but my project is actually using scrollMonitor both with and without jQuery! My project-specific code is all AMD and I have several views using scrollMonitor (in addition to the project-independent jQuery plugin which uses it). I suppose it wouldn't hurt for them all to use a jQuery plugin version of scrollMonitor though.\n. ",
    "oroce": "haha i just probably forgot to create the pr:D thanks @JaapRood \n. haha i just probably forgot to create the pr:D thanks @JaapRood \n. ",
    "obenjiro": "@stutrek  plz Close this issue. It's stupid to support browser that even Microsoft wants to die. @stutrek  plz Close this issue. It's stupid to support browser that even Microsoft wants to die. ",
    "theorm": "Thanks @sakabako, let me know if you find any issues. I'm happy to update the code.\n. I have updated the way `documentHeight` is calculated. After a closer look it turned out I did not do the right thing in the first attempt. This time I just copied the jQuery approach.\n. Thanks for the comment. Updated the code.\n. @sakabako , how is pull request looking now to you? Is it good to merge? \n. Good point about `scrollTop()`, I'll fix it today or tomorrow.\n\nSorry about IE support. I've been spoiled by not having to work with legacy IE versions and forgot that they attached events differently. I had a look at MDN and this is what they recommend [here](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.addEventListener):\n\n``` js\nif (el.addEventListener) {\n  el.addEventListener('click', modifyText, false); \n} else if (el.attachEvent)  {\n  el.attachEvent('onclick', modifyText);\n}\n```\n\nSeems pretty straightforward. But unit tests are good anyway.\n. Thanks @sakabako, let me know if you find any issues. I'm happy to update the code.\n. I have updated the way `documentHeight` is calculated. After a closer look it turned out I did not do the right thing in the first attempt. This time I just copied the jQuery approach.\n. Thanks for the comment. Updated the code.\n. @sakabako , how is pull request looking now to you? Is it good to merge? \n. Good point about `scrollTop()`, I'll fix it today or tomorrow.\n\nSorry about IE support. I've been spoiled by not having to work with legacy IE versions and forgot that they attached events differently. I had a look at MDN and this is what they recommend [here](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.addEventListener):\n\n``` js\nif (el.addEventListener) {\n  el.addEventListener('click', modifyText, false); \n} else if (el.attachEvent)  {\n  el.attachEvent('onclick', modifyText);\n}\n```\n\nSeems pretty straightforward. But unit tests are good anyway.\n. ",
    "myconcretelab": "Thank you for answer.\nIs'nt possible to keep jQuery out and change the container as a option, like top or bottom : \n\n```\n scrollMonitor.create( element, {top: 200, bottom: 50, container:element})\n```\n\n?\n. Hi, thanks for answer.\nBut i don't understand why you want to mix viewport AND container. In my mind, when we add a container in option it replace the viewport. So the \"only\" thing to calculate is if the element is in the container, not viewport. \n\n```\n<div class=\"container\">\n  <div class=\"element\"> ... </div>\n</div>\n\n<script>\nscrollMonitor.create( \".element\", {top: 200, bottom: 50, container:\".container\"});\n</script>\n```\n. Thank you for answer.\nIs'nt possible to keep jQuery out and change the container as a option, like top or bottom : \n\n```\n scrollMonitor.create( element, {top: 200, bottom: 50, container:element})\n```\n\n?\n. Hi, thanks for answer.\nBut i don't understand why you want to mix viewport AND container. In my mind, when we add a container in option it replace the viewport. So the \"only\" thing to calculate is if the element is in the container, not viewport. \n\n```\n<div class=\"container\">\n  <div class=\"element\"> ... </div>\n</div>\n\n<script>\nscrollMonitor.create( \".element\", {top: 200, bottom: 50, container:\".container\"});\n</script>\n```\n. ",
    "anthonybruno": "Any updates on this? Would love the ability to specify a container that didn't rely on jQuery.\n. Any updates on this? Would love the ability to specify a container that didn't rely on jQuery.\n. ",
    "igregson": "+1 for this, please :)\n. +1 for this, please :)\n. ",
    "kevinkl3": "This feature would be great!\n. This feature would be great!\n. ",
    "OverZealous": "Is there something that can be done to help with this?  I started using this (via an Angular module), which will have a massive effect on our application.\n\nBut I can only use it on scrolling elements\u2014our SPA doesn't use window scrolling at all.\n. Actually, this looks like it won't work for me even with that change, because it looks like it won't work well with items that dynamically change size (because you'd have to manually update the watcher).  Great library, though!\n. Is there something that can be done to help with this?  I started using this (via an Angular module), which will have a massive effect on our application.\n\nBut I can only use it on scrolling elements\u2014our SPA doesn't use window scrolling at all.\n. Actually, this looks like it won't work for me even with that change, because it looks like it won't work well with items that dynamically change size (because you'd have to manually update the watcher).  Great library, though!\n. ",
    "hoangnguyencong": "+1 for this. Pls :)\n. +1 for this. Pls :)\n. ",
    "ryannichols": "Agree with the previous in regards to being able to specify an element as opposed to the viewport. The container is what's important, that container can be any element - the default of which would be the viewport. Doesn't seem ambiguous at all to me.\n\nIf someone needs to know that the container itself is on or off the screen, then they should add a second watcher to the container. It should be up to the developer to track those states and write logic for what should happen in each case. \n. Agree with the previous in regards to being able to specify an element as opposed to the viewport. The container is what's important, that container can be any element - the default of which would be the viewport. Doesn't seem ambiguous at all to me.\n\nIf someone needs to know that the container itself is on or off the screen, then they should add a second watcher to the container. It should be up to the developer to track those states and write logic for what should happen in each case. \n. ",
    "bmoyet": "Thanks for your quick fix ! \n. Thanks for your quick fix ! \n. ",
    "walfly": "I don't think that argument holds a lot weight.  That's kind of like saying 'why does jquery have a trigger function?' there are plenty of times you may want to force an event or list of events to fire.\n\nThe particular instance I want to use it for is building a sticky menu.  I use scroll monitor to toggle the classes that add position fixed.  Under certain circumstances the page layout changes, these changes do not necessarily trigger a stateChange, and i need to alert the scroll menu to this change .  Maybe a better solution would be to make another method called trigger that handled firing events in the code.  Holding on to my callbacks adds a good deal of unnecessary complexity to my app, and digging through the callbacks is just nonsense.\n\nI can get behind not wanting to add this functionality to your triggercallbacks function, but having a way to programmatically trigger an event is a pretty common feature of any eventing system.  I've refactored it out into its own method and written a test.  How do you run the test suite. I'm getting \"window is not defined\" when i run mocha.\n. If you add namespacing to trigger then you can limit those side effects. This can be done pretty simply, but would be a larger refactor.  The main problem I've encountered trying to hold on to my call backs and invoke them manually is that I can no longer use the this key word.  Recalculate location doesn't work in my situation because there is a stateChange in the fixed element but not the watchedElement.  I really think a trigger method is an expected feature, but I'll find a way.\n. I don't think that argument holds a lot weight.  That's kind of like saying 'why does jquery have a trigger function?' there are plenty of times you may want to force an event or list of events to fire.\n\nThe particular instance I want to use it for is building a sticky menu.  I use scroll monitor to toggle the classes that add position fixed.  Under certain circumstances the page layout changes, these changes do not necessarily trigger a stateChange, and i need to alert the scroll menu to this change .  Maybe a better solution would be to make another method called trigger that handled firing events in the code.  Holding on to my callbacks adds a good deal of unnecessary complexity to my app, and digging through the callbacks is just nonsense.\n\nI can get behind not wanting to add this functionality to your triggercallbacks function, but having a way to programmatically trigger an event is a pretty common feature of any eventing system.  I've refactored it out into its own method and written a test.  How do you run the test suite. I'm getting \"window is not defined\" when i run mocha.\n. If you add namespacing to trigger then you can limit those side effects. This can be done pretty simply, but would be a larger refactor.  The main problem I've encountered trying to hold on to my call backs and invoke them manually is that I can no longer use the this key word.  Recalculate location doesn't work in my situation because there is a stateChange in the fixed element but not the watchedElement.  I really think a trigger method is an expected feature, but I'll find a way.\n. ",
    "emkay": "Thanks!\n\n> On Dec 23, 2014, at 4:05 PM, Stu Kabakoff notifications@github.com wrote:\n> \n> Thank you. I'll merge and make a patch version later, probably after the holiday.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. Thanks!\n\n> On Dec 23, 2014, at 4:05 PM, Stu Kabakoff notifications@github.com wrote:\n> \n> Thank you. I'll merge and make a patch version later, probably after the holiday.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n. ",
    "qborreda": "Indeed, the changes to iOS 8 are going to be something big regarding scroll events. \nMeanwhile, I've used iScroll in some other projects successfully .. it exposes a 'scroll' event more similar to the common onScroll behaviour we're used to .. \nhttps://github.com/cubiq/iscroll\n. Indeed, the changes to iOS 8 are going to be something big regarding scroll events. \nMeanwhile, I've used iScroll in some other projects successfully .. it exposes a 'scroll' event more similar to the common onScroll behaviour we're used to .. \nhttps://github.com/cubiq/iscroll\n. ",
    "twiro": "> _Is there a way to send an event during the active scrolling phase on iOS?_\n\nAny news on this? ScrollMonitor is a pretty awesome library, but would become even better when delivering the expected results in IOS8/9.\n. > _Is there a way to send an event during the active scrolling phase on iOS?_\n\nAny news on this? ScrollMonitor is a pretty awesome library, but would become even better when delivering the expected results in IOS8/9.\n. ",
    "bensmeets": "Take note, that the scroll events don't fire when you save the site \"to your dashboard\" (in iOS) and have the\n`<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">`\non.\n. Didn't have a chance to check if it still exists. Did you? If it's fixed, that would be great.. Take note, that the scroll events don't fire when you save the site \"to your dashboard\" (in iOS) and have the\n`<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">`\non.\n. Didn't have a chance to check if it still exists. Did you? If it's fixed, that would be great.. ",
    "MethodGrab": "Closing this as it's been merged.\n. :+1: \n. Thanks! :metal:\n. Closing this as it's been merged.\n. :+1: \n. Thanks! :metal:\n. ",
    "madbence": "Any progress on this @sakabako ?\n. Whoops, sorry, there is already #36 \n. Any progress on this @sakabako ?\n. Whoops, sorry, there is already #36 \n. ",
    "peduarte": "+1\n\nStill happening.\n\nHas anyone found a sensible solution for this?\n. +1\n\nStill happening.\n\nHas anyone found a sensible solution for this?\n. ",
    "Frozzy6": "+1\n. +1\n. ",
    "jldec": "@sakabako - thanks for clarifying - your interim suggestion makes sense.\n. @sakabako - thanks for clarifying - your interim suggestion makes sense.\n. ",
    "jamestowers": "Any update on this? I've got the same situation as @jldec. \r\n\r\nIs `jldec/scrollMonitor` up to date with master?. Any update on this? I've got the same situation as @jldec. \r\n\r\nIs `jldec/scrollMonitor` up to date with master?. ",
    "glkx": "Would be nice if destroy all function is included. Could definitely come in handy for websites that load new page through ajax.. Would be nice if destroy all function is included. Could definitely come in handy for websites that load new page through ajax.. ",
    "chrispreisler": "I would also love to get this feature. . I would also love to get this feature. . ",
    "edwardm": "cool, thanks for the quick response\n. cool, thanks for the quick response\n. ",
    "ChanOmegaWebDesign": "I have submitted a pull request fixing this issue.\n. Created a different pull request with only one commit.\n. No problem. By the way, the pages here http://stutrek.github.com/scrollMonitor/demos/ have not been updated.\n. I have submitted a pull request fixing this issue.\n. Created a different pull request with only one commit.\n. No problem. By the way, the pages here http://stutrek.github.com/scrollMonitor/demos/ have not been updated.\n. ",
    "janjaap": "No, I'm not doing anything of the kind.\nI thought it might had to do with other deps conflicting with scrollMonitor, but removing all other scripts doesn't change anything. Same for all browsers.\n\nI noticed, however, that when I turn off styling (in Firefox), events are fired like they should. I'll do some further digging to see which style rules cause this problem.\n. Damn, you're right. The `.section-container` element had `overflow-x: hidden`.\n. Closing this one, since it's expected behaviour.\n. No, I'm not doing anything of the kind.\nI thought it might had to do with other deps conflicting with scrollMonitor, but removing all other scripts doesn't change anything. Same for all browsers.\n\nI noticed, however, that when I turn off styling (in Firefox), events are fired like they should. I'll do some further digging to see which style rules cause this problem.\n. Damn, you're right. The `.section-container` element had `overflow-x: hidden`.\n. Closing this one, since it's expected behaviour.\n. ",
    "lunaroja": "\ud83d\udc4d \n. \ud83d\udc4d \n. ",
    "adeopura4": "Thank you for your response. If the locations are not recomputed upon scroll, the values of the isInViewport would be incorrect (as far as I understand). Isn't that the main purpose of the library? \n\nAppreciate your help. I am just trying to understand. \n. Thank you. In my case, I have a scroll bar but the exports.viewportTop and exports.viewportBottom remain fixed as I scroll. I am not certain why, but that is what is perhaps causing the watches to not recalculate. Thank you for the explanation.\n. Thank you for your response. If the locations are not recomputed upon scroll, the values of the isInViewport would be incorrect (as far as I understand). Isn't that the main purpose of the library? \n\nAppreciate your help. I am just trying to understand. \n. Thank you. In my case, I have a scroll bar but the exports.viewportTop and exports.viewportBottom remain fixed as I scroll. I am not certain why, but that is what is perhaps causing the watches to not recalculate. Thank you for the explanation.\n. ",
    "dmitry-dedukhin": "Hi!\r\nThe latest version 1.2.3 has the problem when container is not a document body, but I'm not sure that this is the same problem.\r\nI'm using es6 import.\r\nWhen container height is changed I call scrollMonitor.recalculateLocations() and this works only at first time. When container dimensions are changed again recalculateLocations doesn't work as expected. And all scroll monitoring is brooken.. Hi!\r\nThe latest version 1.2.3 has the problem when container is not a document body, but I'm not sure that this is the same problem.\r\nI'm using es6 import.\r\nWhen container height is changed I call scrollMonitor.recalculateLocations() and this works only at first time. When container dimensions are changed again recalculateLocations doesn't work as expected. And all scroll monitoring is brooken.. ",
    "dontboyle": "So I have to pass in the onEnterFunction to the .off?? \n\nGot it thanks!\n. @stutrek \n\nHey I appreciate the feedback so far - just wanted to let you know that the above is still not working properly. - Off does so I'm good to go, thought i'd leave this here however.\n\n```\nvar monitor = scrollMonitor.create(someElement);\nmonitor.on('enterViewport', onEnter); //works\n//monitor.off('enterViewport', onEnter); //works\nmonitor.destroy(); //doesn't work\n```\n. So I have to pass in the onEnterFunction to the .off?? \n\nGot it thanks!\n. @stutrek \n\nHey I appreciate the feedback so far - just wanted to let you know that the above is still not working properly. - Off does so I'm good to go, thought i'd leave this here however.\n\n```\nvar monitor = scrollMonitor.create(someElement);\nmonitor.on('enterViewport', onEnter); //works\n//monitor.off('enterViewport', onEnter); //works\nmonitor.destroy(); //doesn't work\n```\n. ",
    "Nolski": "It's unfortunate that you seem so set in your ways that you would not even stop to consider a feature request.\n\nI'm not quite sure what you mean when you're saying about page janking. debouncing would be used to _limit_ the speed of scrollMonitor. Perhaps an example would help illustrate the use of this option.\n\nLet's say I want to implement a lazy loader using scrollMonitor. This would be very easy to do using  `enterViewport` on every item that needs to be lazy loaded. However perhaps if the user is scrolling very fast, I don't want to lazy load every item the user scrolls over. Here would be a good time to use debounce to limit the amount of pending network connections going out for the lazy loaded images and only load the images necessary.\n. It's unfortunate that you seem so set in your ways that you would not even stop to consider a feature request.\n\nI'm not quite sure what you mean when you're saying about page janking. debouncing would be used to _limit_ the speed of scrollMonitor. Perhaps an example would help illustrate the use of this option.\n\nLet's say I want to implement a lazy loader using scrollMonitor. This would be very easy to do using  `enterViewport` on every item that needs to be lazy loaded. However perhaps if the user is scrolling very fast, I don't want to lazy load every item the user scrolls over. Here would be a good time to use debounce to limit the amount of pending network connections going out for the lazy loaded images and only load the images necessary.\n. ",
    "weotch": "Yeah, happening in latest chrome, firefox, safari as well as IE edge.. \ud83c\udf7b. Did you publish to npm?  Not seeing it there:\r\n\r\n![](http://yo.bkwld.com/1x3O2n1G3410/Image%202016-11-28%20at%202.19.33%20PM.png). Yeah, happening in latest chrome, firefox, safari as well as IE edge.. \ud83c\udf7b. Did you publish to npm?  Not seeing it there:\r\n\r\n![](http://yo.bkwld.com/1x3O2n1G3410/Image%202016-11-28%20at%202.19.33%20PM.png). ",
    "shahata": "Thanks! Since fix requires cache clean I suggest you'd also try to regain access to sakabako and delete this account.. Ahhh, you did delete it and someone recreated? I guess that's actually a github bug then.... Thanks! Since fix requires cache clean I suggest you'd also try to regain access to sakabako and delete this account.. Ahhh, you did delete it and someone recreated? I guess that's actually a github bug then.... ",
    "stephenkingsley": "I modified the code using es6 and make this project become beautiful. But I think I modified too much, so I created a new project to save it.\r\n\r\nbut in my opinions, I want to pr, so I think you can review [`in here`](https://github.com/stephenkingsley/awesome-scroll). And if you think this is good enough, I will come up with pr.\r\n\r\nSincerely, I want you can accept my code.. actually, I fork a branch to do this at first. But I think that is not a simple contribution, so I save in a new project, and not come up with pr. I think I will contribution in this project, and meanwhile maintain in my project.. I modified the code using es6 and make this project become beautiful. But I think I modified too much, so I created a new project to save it.\r\n\r\nbut in my opinions, I want to pr, so I think you can review [`in here`](https://github.com/stephenkingsley/awesome-scroll). And if you think this is good enough, I will come up with pr.\r\n\r\nSincerely, I want you can accept my code.. actually, I fork a branch to do this at first. But I think that is not a simple contribution, so I save in a new project, and not come up with pr. I think I will contribution in this project, and meanwhile maintain in my project.. ",
    "ferredel": "Actually it will be very usefull. Actually it will be very usefull. ",
    "jwebcat": "I have to agree horizontal scroll would be useful.. I have to agree horizontal scroll would be useful.. ",
    "mcfog": "+1 it would be super useful to carousel. +1 it would be super useful to carousel. ",
    "johanneslamers": "Yes please!. Yes please!. ",
    "ragefuljoe": "Tested a project we're working on, and same issue, no events in iOS if iframed. Has this been acknowledged?. @GordanRatkovic Dunno if you ever figured it out, but for anyone else having this issue, it is not problem with scrollMonitor, but rather how ios safari handles iframes.\r\n\r\nThe iframe size is not properly sized, and just ends up taking up the entire content size. This causes the animations to all be \"in view\" at load.\r\n\r\nSolution is to wrap all of the content in the iframe src (not in iframe) and give this wrapper the style\r\n`#wrap {\r\n      position: fixed;\r\n      top: 0;\r\n      right:0;\r\n      bottom:0;\r\n      left: 0;\r\n      overflow-y: scroll;\r\n      -webkit-overflow-scrolling: touch;\r\n    }`\r\n\r\n@stutrek I think this issue can be closed. Tested a project we're working on, and same issue, no events in iOS if iframed. Has this been acknowledged?. @GordanRatkovic Dunno if you ever figured it out, but for anyone else having this issue, it is not problem with scrollMonitor, but rather how ios safari handles iframes.\r\n\r\nThe iframe size is not properly sized, and just ends up taking up the entire content size. This causes the animations to all be \"in view\" at load.\r\n\r\nSolution is to wrap all of the content in the iframe src (not in iframe) and give this wrapper the style\r\n`#wrap {\r\n      position: fixed;\r\n      top: 0;\r\n      right:0;\r\n      bottom:0;\r\n      left: 0;\r\n      overflow-y: scroll;\r\n      -webkit-overflow-scrolling: touch;\r\n    }`\r\n\r\n@stutrek I think this issue can be closed. ",
    "kierenj": "Ah - I do for production deployment, but not for development.  I don't have a version running with the production deployment at the moment to check.  Is it required to do this?  . Ah - I do for production deployment, but not for development.  I don't have a version running with the production deployment at the moment to check.  Is it required to do this?  . ",
    "aripalo": "Enjoy your vacation! \ud83c\udf79  \r\n\r\nI can live with my fork (but I still think this is something that would be good to fix for others/future).. Totally understandable! \ud83d\udc4d  And as I said, I can live with my fork! . Enjoy your vacation! \ud83c\udf79  \r\n\r\nI can live with my fork (but I still think this is something that would be good to fix for others/future).. Totally understandable! \ud83d\udc4d  And as I said, I can live with my fork! . ",
    "mahboob-awan": "Problem is\r\n1 - sticky button work fine initially\r\n2 - but after load more contents, problem start appearing\r\n3 - Sticky button still considering old position.\r\n\r\n![](https://media.giphy.com/media/l4FGmMLiuqIthr49G/giphy.gif)\r\n\r\nCan You please integrate Your suggestion within [ JSFiddle Demo](https://jsfiddle.net/awan/er1uorxy/)\r\n\r\nThanks. Nice that `scrollMonitor.recalculateLocations()` or `watcher.recalculateLocation()` fixed the case mention in previous GIF but it does not restore sticky position after hide \"more contents\".\r\n\r\nSteps to reproduce it:\r\n1 - initially it stick properly\r\n2 - After adding `scrollMonitor.recalculateLocations()`, it sticky properly when load more contents\r\n3 - But if hide more contents, sticky element does not restore it's position.\r\n[source(JSFiddle)](https://jsfiddle.net/awan/er1uorxy/)\r\n\r\n![](https://media.giphy.com/media/3ohzdPcm5msKZYKYAE/giphy.gif). Kindly check current code that execute when user press \"Toggle more contents\"[BUTTON]\r\n```js\r\n button.onclick = function(){\r\n   document.getElementById(\"morecontents\").classList.toggle('hide');\r\n   scrollMonitor.recalculateLocations();//Sol#1\r\n    //elementWatcher.recalculateLocation()//Sol#2 - Same result as Sol#1\r\n  }\r\n```\r\n\r\nbut duplicating same call(again) also did not work:\r\n```js\r\n button.onclick = function(){\r\n   document.getElementById(\"morecontents\").classList.toggle('hide');\r\n   scrollMonitor.recalculateLocations();//Sol#1\r\n   scrollMonitor.recalculateLocations();\r\n    //elementWatcher.recalculateLocation()//Sol#2 - Same result as Sol#1\r\n  }\r\n```\r\n. But i am calling it, as same function is used to expand & collapse using **.toggle('hide');**\r\n```javascript\r\n button.onclick = function(){\r\n   document.getElementById(\"morecontents\").classList.toggle('hide');\r\n   scrollMonitor.recalculateLocations();//Sol#1\r\n    //elementWatcher.recalculateLocation()//Sol#2 - Same result as Sol#1\r\n  }\r\n```. Problem is\r\n1 - sticky button work fine initially\r\n2 - but after load more contents, problem start appearing\r\n3 - Sticky button still considering old position.\r\n\r\n![](https://media.giphy.com/media/l4FGmMLiuqIthr49G/giphy.gif)\r\n\r\nCan You please integrate Your suggestion within [ JSFiddle Demo](https://jsfiddle.net/awan/er1uorxy/)\r\n\r\nThanks. Nice that `scrollMonitor.recalculateLocations()` or `watcher.recalculateLocation()` fixed the case mention in previous GIF but it does not restore sticky position after hide \"more contents\".\r\n\r\nSteps to reproduce it:\r\n1 - initially it stick properly\r\n2 - After adding `scrollMonitor.recalculateLocations()`, it sticky properly when load more contents\r\n3 - But if hide more contents, sticky element does not restore it's position.\r\n[source(JSFiddle)](https://jsfiddle.net/awan/er1uorxy/)\r\n\r\n![](https://media.giphy.com/media/3ohzdPcm5msKZYKYAE/giphy.gif). Kindly check current code that execute when user press \"Toggle more contents\"[BUTTON]\r\n```js\r\n button.onclick = function(){\r\n   document.getElementById(\"morecontents\").classList.toggle('hide');\r\n   scrollMonitor.recalculateLocations();//Sol#1\r\n    //elementWatcher.recalculateLocation()//Sol#2 - Same result as Sol#1\r\n  }\r\n```\r\n\r\nbut duplicating same call(again) also did not work:\r\n```js\r\n button.onclick = function(){\r\n   document.getElementById(\"morecontents\").classList.toggle('hide');\r\n   scrollMonitor.recalculateLocations();//Sol#1\r\n   scrollMonitor.recalculateLocations();\r\n    //elementWatcher.recalculateLocation()//Sol#2 - Same result as Sol#1\r\n  }\r\n```\r\n. But i am calling it, as same function is used to expand & collapse using **.toggle('hide');**\r\n```javascript\r\n button.onclick = function(){\r\n   document.getElementById(\"morecontents\").classList.toggle('hide');\r\n   scrollMonitor.recalculateLocations();//Sol#1\r\n    //elementWatcher.recalculateLocation()//Sol#2 - Same result as Sol#1\r\n  }\r\n```. ",
    "proov": "As i can see, the problem does not come from ScrollMonitor but from Barba.js. If i reinit the function a bit later when the view is ready (after transition ended), then it's working as expected :)\r\n\r\nI'm gonna ask some help from the author of Barba.js :D\r\n\r\nThanks again for scrollMonitor, it's really easy to use, even for a newbie developper like me :D . As i can see, the problem does not come from ScrollMonitor but from Barba.js. If i reinit the function a bit later when the view is ready (after transition ended), then it's working as expected :)\r\n\r\nI'm gonna ask some help from the author of Barba.js :D\r\n\r\nThanks again for scrollMonitor, it's really easy to use, even for a newbie developper like me :D . ",
    "mspanish": "sorry, missed the thing about not putting in in the head. works like a charm now, thanks again!. sorry, missed the thing about not putting in in the head. works like a charm now, thanks again!. "
}