{
    "daviddahl": "You should perhaps try out \"reftests\": https://developer.mozilla.org/en-US/docs/Creating_reftest-based_unit_tests\n\nAll of Gecko's CSS is tested this way\n. You should perhaps try out \"reftests\": https://developer.mozilla.org/en-US/docs/Creating_reftest-based_unit_tests\n\nAll of Gecko's CSS is tested this way\n. ",
    "Rich-Harris": "Thanks, I wasn't aware of that. Could definitely come in handy. Reading around a bit though, reftests sound a bit hairy - lack of precise timing control, inconsistent approach to fuzzy matching... I'm inclined to put it on the 'one day' pile :)\n\nIn the meantime, I should probably close this issue - earlier today I added a basic [test.html](http://www.rich-harris.co.uk/ramjet/test.html) file ([source](https://github.com/Rich-Harris/ramjet/blob/master/demo/files/test.html)), which enables visual verification in any browser. Manual testing is a PITA but realistically I think it's the only option for now.\n. Fixed by @crohrer, released in 0.4.4\n. Relevant SO question: http://stackoverflow.com/questions/25086985/this-animation-flickers-at-the-end-in-ie-11\n\nUgh. Probably going to have to fall back to timer-based animations. By the sounds of it it's an IE11-only bug (don't have an IE10 VM to hand), so that'll involve some browser sniffing.\n\nSeriously, IE team, just go home. We would all be so much better off if you went and did something else that didn't involve software.\n. Ah, thanks, didn't think of the `position: fixed` case. The offset parent is only needed so ramjet can account for its top/left margin (which upsets the coordinates otherwise) - if the position is fixed then that's irrelevant anyway, so we presumably need to behave as if there was no margin.\n\nLeaving some breadcrumbs for myself: according to [this SO answer](http://stackoverflow.com/a/11639664/2742396) an element has no `offsetParent` if it's not a descendant of `<body>`, has `position: fixed`, or it or any ancestor has `display: none`.\n. Thanks guys! Didn't know that about the `version` field, that's good to know. Have registered the package with bower, and replaced the most recent tag so that it picks up the `bower.json` file.\n. I always forget that part. Thank you :)\n. I wondered how long it'd be before someone noticed that! \n\n> The bottom element should always be 100% opacity, only the top element should change.\n\nI was going to say that that would only solve cases where both elements had 100% opacity in their resting state, but then I realised that ramjet [isn't respecting opacity anyway](http://jsfiddle.net/rich_harris/7j7xk9gj/), so I just added a separate issue for that (#11). May have to have one rule for the both-100% situation, and another for everything else. Hmm.\n. That's totally brilliant! Thanks, I think that should do the trick.\n. Ah, I just realised where this gets tricky. If you transform `a` to `b`, and they're in different parts of the DOM, for them to be in the same wrapper element at least one of them has to move (right now, the clones are siblings of the originals). That would mean any cumulative opacity or transforms from their parent elements would have to be taken account of. Might get messy... will have to look into it\n. That's actually [what already happens](https://github.com/Rich-Harris/ramjet/blob/master/src/utils/node.js#L16-L18) - it's the nuclear option, but I found it necessary (though I can't remember why exactly - this was when I first started hacking on this idea several months ago!)\n\nI was thinking about this over the weekend. Appending both cloned elements to a single parent, which is then appended to `<body>`, _should_ work, if we calculate the cumulative opacity and transform matrix. (That's basically what already happens with SVG elements, albeit [imperfectly](https://github.com/Rich-Harris/ramjet/issues/6), but it's easier there because SVG elements have a `node.getScreenCTM()` method that returns the current screen-space transform matrix - it's tricker for HTML elements.)\n\nWhat you lose is\n- z-index (because there's no global stacking order you can inspect and modify - the rules for the application of z-index are pretty wild, IIRC)\n- clipping, e.g. if part of an element is outside a parent with `overflow: hidden`\n- possibly some other stuff we haven't thought of?\n\nMy hunch is that the trade-off is worth it, if it means better visual fidelity in all cases at the expense of some glitchiness in a small, contrived minority.\n. @DDKnoll have a look at #27 - it solves (or rather, will solve) both this and #11. As far as I can see it's the only way - any combination of opacities that are less than one will also be less than one (e.g. bottom layer = 0.9 + top layer = 0.9 = (1 - ((1 - 0.9) \\* (1 - 0.9))) = (1 - (0.1 \\* 0.1)) = 0.99, so the bottom layer _has_ to stay at 100% opaque.\n. Afraid I don't quite follow - as far as I can see, if both layers are less than 100% opaque then they'll be less than 100% opaque in combination, and you'll be able to see stuff underneath, which is exactly what we're trying to avoid. Unless I've misunderstood you?\n\nSVG will still work, it's just a matter of rejigging a few things (right now they get shoved in the same `<div>` as HTML elements, so they fail to render - they just need to be wrapped in an `<svg>` and have the appropriate transforms applied)\n. For most cases we can get the right effect by controlling the container element's opacity - by transitioning _that_ from the first element's opacity to the second element's opacity, and having the first element stay at 100% while the second element goes from 100% to 0%, you get the right effect:\n\n![ramjet-opacity-semi](https://cloud.githubusercontent.com/assets/1162160/7481056/457b12fe-f33b-11e4-8258-b42ccefad9a2.gif)\n\nThat breaks down when the second element has a background that isn't opaque (e.g. rgba colour or image with alpha channel). I was planning to work around that with a `crossfade` option that falls back to the current behaviour, to replace any jarring glitches with 'wrong, but in a way that most people won't notice' - if there's an easing formula that gets us closer to the intended effect then I'm definitely all ears!\n. > This branch is still duplicating into the new container, but it works without that\n\nThat's great, I was prepared to sacrifice things like filters and stacking order (which would affect a few cases) for the sake of more accurate total opacity (which affects all cases), but now it looks like there's no need. Still, it was a worthwhile diversion - I _think_ I now know how to do SVG transitions with CSS animations as a result.\n. hmm, that's odd, it should build & serve the demo when you run `gobble` (or `npm start`, which does the same thing but without using any global packages). Just to eliminate the possibility of a corrupted node_modules folder, could you try...\n\n```\n$ cd /Users/bparks/gitrepos/ramjet_morph_dom_elements\n$ rm -rf node_modules\n$ npm i\n$ npm start\n```\n\n...and see what happens?\n. Thanks @crohrer :metal: For some reason I thought there'd be more to it than that! Released as 0.4.4\n. It'd be easy enough to implement, definitely. Only thing is that it would mean that we couldn't then use the arguments to `done` for anything else, if we came up with a better use for them, so we'd need to be sure that it was worthwhile, especially since we've got `.bind`. Personally I've only ever used a closure for `done`...\n\n``` js\nvar from = someNode;\nvar to = someOtherNode;\n\nramjet.transform( from, to, {\n  done: function () {\n    // we can already access `from` and `to` here...\n    // no need to have them as arguments\n  }\n});\n```\n\n...so there's not much to be gained in that scenario. But I'd be interested to see examples where passing the arguments in would make life easier?\n. :+1: \n. Thanks for the PR! Unfortunately I can't merge this - without the source code, the translation will get nuked by Travis CI as soon as new code gets pushed to the repo. We would need to store the translations in a separate data file somehow, and update the build process to accommodate it. I'll try and set that up in the near future.\n. Do the artifacts appear with any elements in particular? I'm wondering (hoping!) if it's the same bug as #6 - I've just tried Firefox 37 on Android 5 and it seems to work okay apart from that, so hopefully it isn't some impossible-to-reproduce Heisenbug\n. (sorry, should have been clearer - the SVG bug is the one that appears when scrolling during a transition into/out of the purple box on the homepage)\n. Yes! Last night I created a new [border-radius branch](https://github.com/Rich-Harris/ramjet/tree/border-radius) to try and solve this issue. It's not totally straightforward - if the elements are the same shape, it works...\n\n![border-radius](https://cloud.githubusercontent.com/assets/1162160/7458641/f7466bf6-f263-11e4-847c-c9f1c5e2152a.gif)\n\n...but if they're a different shape, the transform stretches the corners so they don't overlap:\n\n![border-radius2](https://cloud.githubusercontent.com/assets/1162160/7458649/0d7f61de-f264-11e4-8606-fd7eb57aef78.gif)\n\n(It's subtle, but you can probably see what I'm talking about - the corners don't _quite_ line up.) So we'll have to compensate for the transform when setting the border-radius (I didn't realise this until just now, but [you can use two radii for each corner](https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius), which is exactly what we need to compensate for the 'stretch', which is great news because it means that this is in fact possible.)\n\nHopefully I'll get a chance to work on this soon.\n\nAnyway, to your example: is the original border radius preserved, at least? It looks as though it isn't, but when I do the same thing locally I can see the blue circle beneath the translucent green square. Which is odd...\n. Right, I think I've got this sussed:\n\n![brad](https://cloud.githubusercontent.com/assets/1162160/7465563/34eb8554-f2a0-11e4-8586-5a72cc311583.gif)\n\nYou can also see it in action on the [ramjet homepage](http://www.rich-harris.co.uk/ramjet/) (iOS grid example at the bottom). Released in 0.4.5\n. Thanks, this is great! The rgba blending looks spiffy, and I would never have figured out that compositing formula. I've merged this in to the `opacity` branch, need to tidy up a few other things before it goes into `master`\n. @williammalo that's a very good point... it should probably auto-detect when it can use compositor-only features, and allow a `compositorOnly: true` option (suggestions for better names welcome)\n. @babakness Good question! I've been a little quite on this repo lately as I've been working on some other projects, but I do have an experimental branch which gets us halfway there.\n\nIt's a little tricky though. Because the elements could be inside layers of elements with their own transformations, and they then need to be transformed _further_ so that they can move as one, it's not practical to describe the start and end transformations as a series of `rotate`/`scale`/`translate` commands - instead we have to multiply transformation matrices.\n\nThis makes rotation difficult, because if you interpolate between two transformation matrices that describe different rotations, the effect doesn't look like rotation, because the corners of the box travel in a straight line to their destination. It looks more like shearing than rotation. The best we can hope for is to use [matrix decomposition](http://en.wikipedia.org/wiki/Matrix_decomposition) to figure out a path that looks more natural. That's my plan, anyway. (A long time ago, I wrote a small matrix utility library which [does decomposition among other things](https://github.com/Rich-Harris/Neo/blob/master/Neo.js#L454-L842). Hopefully the code still works...)\n\nThis is what the experimental branch looks like right now:\n\n![transform](https://cloud.githubusercontent.com/assets/1162160/7694349/0c7f1ac8-fdad-11e4-9b8a-d299954c6976.gif)\n\nWith matrix decomposition it should look slightly better. (The next trick will be to get it working with 3d transforms...)\n\nUnfortunately, rotating 720 degrees is totally impossible with this technique. As soon as you go past 180 degrees you lose information (i.e. 240 degrees is assumed to mean -120 degrees, and 360 degrees means no change) - there's just no way to recover it. I've wondered about providing a hook for a custom interpolation function which would be able to do that sort of ad hoc transformation - possibly in a future version.\n. @Martin-Pitt Unfortunately the problem is that we don't have access to the original transform strings - ramjet has to use the transform reported by `getComputedStyle` (otherwise you can only detect transforms applied as inline styles), and `getComputedStyle` converts everything to `matrix(...)`. I guess you could try and figure things out on a 'best effort' basis (reading inline styles and `<style>` tags, making AJAX requests for linked stylesheets and parsing their contents), but it would add a huge amount of complexity, where as a hook that allowed developers to supply their own interpolator would solve the problem (at the cost of a little bit more work for the developer) without any of that brittle magic.\n. Hey - thanks for this, it sounds like there are two separate bugs that need solving. The next version will be a lot smarter about dealing with existing CSS transforms, but I don't think it currently accounts for preserve-3d, so that's something I'll need to look at. Hoping to get a chance to work on this stuff in the next few days, sorry for the delay in the meantime!\n. I did wonder about using web animations under the hood. As an internal implementation detail, it didn't really make sense as there are no performance benefits over CSS animations (as far as I can see), while the polyfill introduces a severe penalty because the animations are timer-based IIRC and have to run on the main thread.\n\nBut you make an interesting case about composition. I was planning to (eventually) make `ramjet.transform` return an object with things like `pause` and `reverse` methods - perhaps it would make more sense if that object was compatible with the web animations API. Definitely worth looking into for a future release\n. @sithmel Guilt is the default emotion for open source maintainers!\n\n> Sorry to have broken \"The Counted\" in the last update\n\nNonsense \u2013 you didn't break anything (sorry if I gave the impression I was blaming you), I broke it by not putting tests in place to begin with! It never saw production, it just meant I couldn't update to 0.4.7. I didn't get round to trying `appendToBody` \u2013 I'm hoping we'll be able to get Ramjet to figure out the right behaviour for any combination of fixed/static/relative etc (I just ran into another issue, probably introduced with this PR, involving relatively positioned children of statically positioned parents. I can fix the isolated test case I've got locally, but need to beef up the test suite to ensure it doesn't break anything else).\n. Thanks for the PR! This is actually deliberate though: `jsnext:main` is only interested in the module format (i.e. ES modules as opposed to AMD/CJS/UMD/globals), not the content of the code itself. The rationale is that I should be able to use ES module aware tooling (Rollup, Webpack 2) to bundle my app for delivery without having to compile my dependencies (which may be on a different Babel version to me, or have different config, or need specific plugins, or any of the other hundreds of things that can cause problems). Not compiling dependencies also makes builds a lot quicker.\n. It sounds like your best bet is probably to set the opacity of the target element to 1, run ramjet, set opacity back to 0, _then_ fade in:\n\n``` js\ntarget.style.opacity = 1;\nramjet.transform(source, target, {...});\ntarget.style.opacity = 0;\n\nfadeIn(target);\n```\n. Thanks, I wasn't aware of that. Could definitely come in handy. Reading around a bit though, reftests sound a bit hairy - lack of precise timing control, inconsistent approach to fuzzy matching... I'm inclined to put it on the 'one day' pile :)\n\nIn the meantime, I should probably close this issue - earlier today I added a basic [test.html](http://www.rich-harris.co.uk/ramjet/test.html) file ([source](https://github.com/Rich-Harris/ramjet/blob/master/demo/files/test.html)), which enables visual verification in any browser. Manual testing is a PITA but realistically I think it's the only option for now.\n. Fixed by @crohrer, released in 0.4.4\n. Relevant SO question: http://stackoverflow.com/questions/25086985/this-animation-flickers-at-the-end-in-ie-11\n\nUgh. Probably going to have to fall back to timer-based animations. By the sounds of it it's an IE11-only bug (don't have an IE10 VM to hand), so that'll involve some browser sniffing.\n\nSeriously, IE team, just go home. We would all be so much better off if you went and did something else that didn't involve software.\n. Ah, thanks, didn't think of the `position: fixed` case. The offset parent is only needed so ramjet can account for its top/left margin (which upsets the coordinates otherwise) - if the position is fixed then that's irrelevant anyway, so we presumably need to behave as if there was no margin.\n\nLeaving some breadcrumbs for myself: according to [this SO answer](http://stackoverflow.com/a/11639664/2742396) an element has no `offsetParent` if it's not a descendant of `<body>`, has `position: fixed`, or it or any ancestor has `display: none`.\n. Thanks guys! Didn't know that about the `version` field, that's good to know. Have registered the package with bower, and replaced the most recent tag so that it picks up the `bower.json` file.\n. I always forget that part. Thank you :)\n. I wondered how long it'd be before someone noticed that! \n\n> The bottom element should always be 100% opacity, only the top element should change.\n\nI was going to say that that would only solve cases where both elements had 100% opacity in their resting state, but then I realised that ramjet [isn't respecting opacity anyway](http://jsfiddle.net/rich_harris/7j7xk9gj/), so I just added a separate issue for that (#11). May have to have one rule for the both-100% situation, and another for everything else. Hmm.\n. That's totally brilliant! Thanks, I think that should do the trick.\n. Ah, I just realised where this gets tricky. If you transform `a` to `b`, and they're in different parts of the DOM, for them to be in the same wrapper element at least one of them has to move (right now, the clones are siblings of the originals). That would mean any cumulative opacity or transforms from their parent elements would have to be taken account of. Might get messy... will have to look into it\n. That's actually [what already happens](https://github.com/Rich-Harris/ramjet/blob/master/src/utils/node.js#L16-L18) - it's the nuclear option, but I found it necessary (though I can't remember why exactly - this was when I first started hacking on this idea several months ago!)\n\nI was thinking about this over the weekend. Appending both cloned elements to a single parent, which is then appended to `<body>`, _should_ work, if we calculate the cumulative opacity and transform matrix. (That's basically what already happens with SVG elements, albeit [imperfectly](https://github.com/Rich-Harris/ramjet/issues/6), but it's easier there because SVG elements have a `node.getScreenCTM()` method that returns the current screen-space transform matrix - it's tricker for HTML elements.)\n\nWhat you lose is\n- z-index (because there's no global stacking order you can inspect and modify - the rules for the application of z-index are pretty wild, IIRC)\n- clipping, e.g. if part of an element is outside a parent with `overflow: hidden`\n- possibly some other stuff we haven't thought of?\n\nMy hunch is that the trade-off is worth it, if it means better visual fidelity in all cases at the expense of some glitchiness in a small, contrived minority.\n. @DDKnoll have a look at #27 - it solves (or rather, will solve) both this and #11. As far as I can see it's the only way - any combination of opacities that are less than one will also be less than one (e.g. bottom layer = 0.9 + top layer = 0.9 = (1 - ((1 - 0.9) \\* (1 - 0.9))) = (1 - (0.1 \\* 0.1)) = 0.99, so the bottom layer _has_ to stay at 100% opaque.\n. Afraid I don't quite follow - as far as I can see, if both layers are less than 100% opaque then they'll be less than 100% opaque in combination, and you'll be able to see stuff underneath, which is exactly what we're trying to avoid. Unless I've misunderstood you?\n\nSVG will still work, it's just a matter of rejigging a few things (right now they get shoved in the same `<div>` as HTML elements, so they fail to render - they just need to be wrapped in an `<svg>` and have the appropriate transforms applied)\n. For most cases we can get the right effect by controlling the container element's opacity - by transitioning _that_ from the first element's opacity to the second element's opacity, and having the first element stay at 100% while the second element goes from 100% to 0%, you get the right effect:\n\n![ramjet-opacity-semi](https://cloud.githubusercontent.com/assets/1162160/7481056/457b12fe-f33b-11e4-8258-b42ccefad9a2.gif)\n\nThat breaks down when the second element has a background that isn't opaque (e.g. rgba colour or image with alpha channel). I was planning to work around that with a `crossfade` option that falls back to the current behaviour, to replace any jarring glitches with 'wrong, but in a way that most people won't notice' - if there's an easing formula that gets us closer to the intended effect then I'm definitely all ears!\n. > This branch is still duplicating into the new container, but it works without that\n\nThat's great, I was prepared to sacrifice things like filters and stacking order (which would affect a few cases) for the sake of more accurate total opacity (which affects all cases), but now it looks like there's no need. Still, it was a worthwhile diversion - I _think_ I now know how to do SVG transitions with CSS animations as a result.\n. hmm, that's odd, it should build & serve the demo when you run `gobble` (or `npm start`, which does the same thing but without using any global packages). Just to eliminate the possibility of a corrupted node_modules folder, could you try...\n\n```\n$ cd /Users/bparks/gitrepos/ramjet_morph_dom_elements\n$ rm -rf node_modules\n$ npm i\n$ npm start\n```\n\n...and see what happens?\n. Thanks @crohrer :metal: For some reason I thought there'd be more to it than that! Released as 0.4.4\n. It'd be easy enough to implement, definitely. Only thing is that it would mean that we couldn't then use the arguments to `done` for anything else, if we came up with a better use for them, so we'd need to be sure that it was worthwhile, especially since we've got `.bind`. Personally I've only ever used a closure for `done`...\n\n``` js\nvar from = someNode;\nvar to = someOtherNode;\n\nramjet.transform( from, to, {\n  done: function () {\n    // we can already access `from` and `to` here...\n    // no need to have them as arguments\n  }\n});\n```\n\n...so there's not much to be gained in that scenario. But I'd be interested to see examples where passing the arguments in would make life easier?\n. :+1: \n. Thanks for the PR! Unfortunately I can't merge this - without the source code, the translation will get nuked by Travis CI as soon as new code gets pushed to the repo. We would need to store the translations in a separate data file somehow, and update the build process to accommodate it. I'll try and set that up in the near future.\n. Do the artifacts appear with any elements in particular? I'm wondering (hoping!) if it's the same bug as #6 - I've just tried Firefox 37 on Android 5 and it seems to work okay apart from that, so hopefully it isn't some impossible-to-reproduce Heisenbug\n. (sorry, should have been clearer - the SVG bug is the one that appears when scrolling during a transition into/out of the purple box on the homepage)\n. Yes! Last night I created a new [border-radius branch](https://github.com/Rich-Harris/ramjet/tree/border-radius) to try and solve this issue. It's not totally straightforward - if the elements are the same shape, it works...\n\n![border-radius](https://cloud.githubusercontent.com/assets/1162160/7458641/f7466bf6-f263-11e4-847c-c9f1c5e2152a.gif)\n\n...but if they're a different shape, the transform stretches the corners so they don't overlap:\n\n![border-radius2](https://cloud.githubusercontent.com/assets/1162160/7458649/0d7f61de-f264-11e4-8606-fd7eb57aef78.gif)\n\n(It's subtle, but you can probably see what I'm talking about - the corners don't _quite_ line up.) So we'll have to compensate for the transform when setting the border-radius (I didn't realise this until just now, but [you can use two radii for each corner](https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius), which is exactly what we need to compensate for the 'stretch', which is great news because it means that this is in fact possible.)\n\nHopefully I'll get a chance to work on this soon.\n\nAnyway, to your example: is the original border radius preserved, at least? It looks as though it isn't, but when I do the same thing locally I can see the blue circle beneath the translucent green square. Which is odd...\n. Right, I think I've got this sussed:\n\n![brad](https://cloud.githubusercontent.com/assets/1162160/7465563/34eb8554-f2a0-11e4-8586-5a72cc311583.gif)\n\nYou can also see it in action on the [ramjet homepage](http://www.rich-harris.co.uk/ramjet/) (iOS grid example at the bottom). Released in 0.4.5\n. Thanks, this is great! The rgba blending looks spiffy, and I would never have figured out that compositing formula. I've merged this in to the `opacity` branch, need to tidy up a few other things before it goes into `master`\n. @williammalo that's a very good point... it should probably auto-detect when it can use compositor-only features, and allow a `compositorOnly: true` option (suggestions for better names welcome)\n. @babakness Good question! I've been a little quite on this repo lately as I've been working on some other projects, but I do have an experimental branch which gets us halfway there.\n\nIt's a little tricky though. Because the elements could be inside layers of elements with their own transformations, and they then need to be transformed _further_ so that they can move as one, it's not practical to describe the start and end transformations as a series of `rotate`/`scale`/`translate` commands - instead we have to multiply transformation matrices.\n\nThis makes rotation difficult, because if you interpolate between two transformation matrices that describe different rotations, the effect doesn't look like rotation, because the corners of the box travel in a straight line to their destination. It looks more like shearing than rotation. The best we can hope for is to use [matrix decomposition](http://en.wikipedia.org/wiki/Matrix_decomposition) to figure out a path that looks more natural. That's my plan, anyway. (A long time ago, I wrote a small matrix utility library which [does decomposition among other things](https://github.com/Rich-Harris/Neo/blob/master/Neo.js#L454-L842). Hopefully the code still works...)\n\nThis is what the experimental branch looks like right now:\n\n![transform](https://cloud.githubusercontent.com/assets/1162160/7694349/0c7f1ac8-fdad-11e4-9b8a-d299954c6976.gif)\n\nWith matrix decomposition it should look slightly better. (The next trick will be to get it working with 3d transforms...)\n\nUnfortunately, rotating 720 degrees is totally impossible with this technique. As soon as you go past 180 degrees you lose information (i.e. 240 degrees is assumed to mean -120 degrees, and 360 degrees means no change) - there's just no way to recover it. I've wondered about providing a hook for a custom interpolation function which would be able to do that sort of ad hoc transformation - possibly in a future version.\n. @Martin-Pitt Unfortunately the problem is that we don't have access to the original transform strings - ramjet has to use the transform reported by `getComputedStyle` (otherwise you can only detect transforms applied as inline styles), and `getComputedStyle` converts everything to `matrix(...)`. I guess you could try and figure things out on a 'best effort' basis (reading inline styles and `<style>` tags, making AJAX requests for linked stylesheets and parsing their contents), but it would add a huge amount of complexity, where as a hook that allowed developers to supply their own interpolator would solve the problem (at the cost of a little bit more work for the developer) without any of that brittle magic.\n. Hey - thanks for this, it sounds like there are two separate bugs that need solving. The next version will be a lot smarter about dealing with existing CSS transforms, but I don't think it currently accounts for preserve-3d, so that's something I'll need to look at. Hoping to get a chance to work on this stuff in the next few days, sorry for the delay in the meantime!\n. I did wonder about using web animations under the hood. As an internal implementation detail, it didn't really make sense as there are no performance benefits over CSS animations (as far as I can see), while the polyfill introduces a severe penalty because the animations are timer-based IIRC and have to run on the main thread.\n\nBut you make an interesting case about composition. I was planning to (eventually) make `ramjet.transform` return an object with things like `pause` and `reverse` methods - perhaps it would make more sense if that object was compatible with the web animations API. Definitely worth looking into for a future release\n. @sithmel Guilt is the default emotion for open source maintainers!\n\n> Sorry to have broken \"The Counted\" in the last update\n\nNonsense \u2013 you didn't break anything (sorry if I gave the impression I was blaming you), I broke it by not putting tests in place to begin with! It never saw production, it just meant I couldn't update to 0.4.7. I didn't get round to trying `appendToBody` \u2013 I'm hoping we'll be able to get Ramjet to figure out the right behaviour for any combination of fixed/static/relative etc (I just ran into another issue, probably introduced with this PR, involving relatively positioned children of statically positioned parents. I can fix the isolated test case I've got locally, but need to beef up the test suite to ensure it doesn't break anything else).\n. Thanks for the PR! This is actually deliberate though: `jsnext:main` is only interested in the module format (i.e. ES modules as opposed to AMD/CJS/UMD/globals), not the content of the code itself. The rationale is that I should be able to use ES module aware tooling (Rollup, Webpack 2) to bundle my app for delivery without having to compile my dependencies (which may be on a different Babel version to me, or have different config, or need specific plugins, or any of the other hundreds of things that can cause problems). Not compiling dependencies also makes builds a lot quicker.\n. It sounds like your best bet is probably to set the opacity of the target element to 1, run ramjet, set opacity back to 0, _then_ fade in:\n\n``` js\ntarget.style.opacity = 1;\nramjet.transform(source, target, {...});\ntarget.style.opacity = 0;\n\nfadeIn(target);\n```\n. ",
    "dbkaplun": ":+1:\n. :+1:\n. ",
    "Merri": "I managed to get into state where I have two animations happening one after the another while scrolling during transition from SVG element to another; as if there were two of the same animations running.\n\nAnother issue I've noticed that the animation may suddenly go at double speed after scrolling during SVG element transition, which seems like a slightly different issue.\n\nAll this happened on the ramjet homepage and on Firefox.\n. I managed to get into state where I have two animations happening one after the another while scrolling during transition from SVG element to another; as if there were two of the same animations running.\n\nAnother issue I've noticed that the animation may suddenly go at double speed after scrolling during SVG element transition, which seems like a slightly different issue.\n\nAll this happened on the ramjet homepage and on Firefox.\n. ",
    "sithmel": "position: fixed issue is fixed\n. This should be fixed in this PR #38\n. it is on master now\n. not really a ramjet issue here .... if someone is willing to wrap ramjet in an angularjs directive is more than welcome!\n. I do love using jQuery but I don't think this is a good idea. Why instead you create a jQuery plugin for using ramjet in that context ? Something like:\n\n```\n$('#a').ramjetTransform({to: $('#b')});\n```\n. Hi, I don't think we should include this inside the library. Interoperability should work on DOM level. It is very easy using ramjet with jQuery doing:\n\n```\nramjet.transform( $('#a').get(0), $('#b').get(0) );\n```\n. I think this should be fixed using appendToBody: true (currently on master). I am closing the issue, if you still se any problem it would be helpful having a test case.\n. The different way to calculate the offset is not working on the demo. I am investigating, in the mean time I close this PR.\n. The second one works using the appendToBody option.\nhttp://jsfiddle.net/ckmpv5gd/3/\nI think it should be the default. I'd like to build a test page with all possible variations (positions, margins, scrolling translations etc.) for checking that it is working in any case.\n. I would suggest to use the overrideClone function for creating a clone that includes the scroll. I am closing it but open to further discussion ...\n. Can you please test if this is happening with the current master? it remember to have fixed it...\n. Don't worry! I was not sure to have fixed it ;-)\n. I have reimplemented that changing the name to \"postClone\"\n. thanks for noticing and fixing that  ;-)\n. @Rich-Harris Thank you for going on with this.\nNow I am the one feeling guilty of not having time to work on this project.\n\nSorry to have broken \"The Counted\" in the last update. I guess the combination of \"having the cloned nodes as sibling of the original one\" and \"the way in which I changed how to compute the position of fixed nodes\" was not compatible.\nHave you tried using the option \"appendToBody\" with this ?\n\nOne of my ideas was to factor out the code used for cloning. This could be reused for other crazy effects like making divs boucing around the screen.\n\nI hope to be able to work again on that as soon as possible.\n. thanks!\n. position: fixed issue is fixed\n. This should be fixed in this PR #38\n. it is on master now\n. not really a ramjet issue here .... if someone is willing to wrap ramjet in an angularjs directive is more than welcome!\n. I do love using jQuery but I don't think this is a good idea. Why instead you create a jQuery plugin for using ramjet in that context ? Something like:\n\n```\n$('#a').ramjetTransform({to: $('#b')});\n```\n. Hi, I don't think we should include this inside the library. Interoperability should work on DOM level. It is very easy using ramjet with jQuery doing:\n\n```\nramjet.transform( $('#a').get(0), $('#b').get(0) );\n```\n. I think this should be fixed using appendToBody: true (currently on master). I am closing the issue, if you still se any problem it would be helpful having a test case.\n. The different way to calculate the offset is not working on the demo. I am investigating, in the mean time I close this PR.\n. The second one works using the appendToBody option.\nhttp://jsfiddle.net/ckmpv5gd/3/\nI think it should be the default. I'd like to build a test page with all possible variations (positions, margins, scrolling translations etc.) for checking that it is working in any case.\n. I would suggest to use the overrideClone function for creating a clone that includes the scroll. I am closing it but open to further discussion ...\n. Can you please test if this is happening with the current master? it remember to have fixed it...\n. Don't worry! I was not sure to have fixed it ;-)\n. I have reimplemented that changing the name to \"postClone\"\n. thanks for noticing and fixing that  ;-)\n. @Rich-Harris Thank you for going on with this.\nNow I am the one feeling guilty of not having time to work on this project.\n\nSorry to have broken \"The Counted\" in the last update. I guess the combination of \"having the cloned nodes as sibling of the original one\" and \"the way in which I changed how to compute the position of fixed nodes\" was not compatible.\nHave you tried using the option \"appendToBody\" with this ?\n\nOne of my ideas was to factor out the code used for cloning. This could be reused for other crazy effects like making divs boucing around the screen.\n\nI hope to be able to work again on that as soon as possible.\n. thanks!\n. ",
    "mmmeff": ":+1:\n. :+1:\n. ",
    "MadLittleMods": ":+1: I am running into this with `position: fixed`. @sithmel's PR #38 works great!\n. :+1: I am running into this with `position: fixed`. @sithmel's PR #38 works great!\n. ",
    "TrySound": "@huntie Remove minified version from main\n. @huntie Read [spec](https://github.com/bower/bower.json-spec#main)\n. @huntie In practice I get all packages by main-bower-files and concat them. So, I don't need duplicating.\n. @huntie And add author info and ignored fields like `bower init` https://github.com/TrySound/skrollr-decks/blob/master/bower.json\n. @huntie And version field isn't need. bower autoloads by git tags. Sorry, forgot.\n. @huntie https://github.com/bower/bower.json-spec#repository\n. @Rich-Harris Could be merged :)\n. @huntie Remove minified version from main\n. @huntie Read [spec](https://github.com/bower/bower.json-spec#main)\n. @huntie In practice I get all packages by main-bower-files and concat them. So, I don't need duplicating.\n. @huntie And add author info and ignored fields like `bower init` https://github.com/TrySound/skrollr-decks/blob/master/bower.json\n. @huntie And version field isn't need. bower autoloads by git tags. Sorry, forgot.\n. @huntie https://github.com/bower/bower.json-spec#repository\n. @Rich-Harris Could be merged :)\n. ",
    "huntie": "@TrySound Is it not better to include both and leave this up to the user? Quite a few Bower packages include multiple main files in this manner.\n. @TrySound I see - amending now!\n. Changes are pushed - single main file, explicit homepage link, author information, and ignored paths.\n\nThanks @TrySound - I learnt some things :)\n. @TrySound That's good \u2014 updated. Equally the homepage field defaults to the repo homepage, but there's a separate site in this case. Nice to have stuff defined in the repo once :)\n. @TrySound Is it not better to include both and leave this up to the user? Quite a few Bower packages include multiple main files in this manner.\n. @TrySound I see - amending now!\n. Changes are pushed - single main file, explicit homepage link, author information, and ignored paths.\n\nThanks @TrySound - I learnt some things :)\n. @TrySound That's good \u2014 updated. Equally the homepage field defaults to the repo homepage, but there's a separate site in this case. Nice to have stuff defined in the repo once :)\n. ",
    "williammalo": "You could wrap both elements in another element and set the opacity on that\nFor example:\nelement 1 has 50% opacity\nelement 2 has 75% opacity\nTo transition them:\ntransition element 1 from 100% to 0%\nkeep element 2 at 100% opacity\ntransition the wrapper from 50% to 75%\n\nIt would fix both bugs.\n. I'm literally giggling of excitement and my coworkers are looking at me funny.\n. I know it's really hacky, but how about something like this?\nhttp://html2canvas.hertzen.com\n. You could put the styles of the cloned elements in their style attributes.\nCode example:\n\n```\nvar flattenStyles = function(foo){\n    var bla=window.getComputedStyle(foo);\n    Object.getOwnPropertyNames(window.getComputedStyle(foo))\n        .filter(function(a){return isNaN(parseFloat(a))})\n        .forEach(function(a){foo.style[a]=bla[a]});\n}\n```\n\nRun something similar on every element of the clone, and then you can place the element anywhere and the styles will work.\n. This stuff is way more complicated than I would have expected, I'm happy you are making this library so I don't have to :D\nYou are doing a great service to mankind.\n. YAY!\n. Doesn't changing the background color trigger a paint and make the animation slow? (This also applies to border radius) is there an option to disable it for \u00a0performance reasons?\n\nOn Wed, May 6, 2015 at 6:57 AM, Rich Harris notifications@github.com\nwrote:\n\n> ## Thanks, this is great! The rgba blending looks spiffy, and I would never have figured out that compositing formula. I've merged this in to the `opacity` branch, need to tidy up a few other things before it goes into `master`\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/Rich-Harris/ramjet/pull/28#issuecomment-99417609\n. Does this work with nodelists as well?\n. @MrAlexLau no, I mean https://developer.mozilla.org/en/docs/Web/API/NodeList\n. You could wrap both elements in another element and set the opacity on that\nFor example:\nelement 1 has 50% opacity\nelement 2 has 75% opacity\nTo transition them:\ntransition element 1 from 100% to 0%\nkeep element 2 at 100% opacity\ntransition the wrapper from 50% to 75%\n\nIt would fix both bugs.\n. I'm literally giggling of excitement and my coworkers are looking at me funny.\n. I know it's really hacky, but how about something like this?\nhttp://html2canvas.hertzen.com\n. You could put the styles of the cloned elements in their style attributes.\nCode example:\n\n```\nvar flattenStyles = function(foo){\n    var bla=window.getComputedStyle(foo);\n    Object.getOwnPropertyNames(window.getComputedStyle(foo))\n        .filter(function(a){return isNaN(parseFloat(a))})\n        .forEach(function(a){foo.style[a]=bla[a]});\n}\n```\n\nRun something similar on every element of the clone, and then you can place the element anywhere and the styles will work.\n. This stuff is way more complicated than I would have expected, I'm happy you are making this library so I don't have to :D\nYou are doing a great service to mankind.\n. YAY!\n. Doesn't changing the background color trigger a paint and make the animation slow? (This also applies to border radius) is there an option to disable it for \u00a0performance reasons?\n\nOn Wed, May 6, 2015 at 6:57 AM, Rich Harris notifications@github.com\nwrote:\n\n> ## Thanks, this is great! The rgba blending looks spiffy, and I would never have figured out that compositing formula. I've merged this in to the `opacity` branch, need to tidy up a few other things before it goes into `master`\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/Rich-Harris/ramjet/pull/28#issuecomment-99417609\n. Does this work with nodelists as well?\n. @MrAlexLau no, I mean https://developer.mozilla.org/en/docs/Web/API/NodeList\n. ",
    "DDKnoll": "I'm pretty sure theres a solvable formula for the opacity of the bottom and top layers at a given time T such that the bottom layer is 50% visible at T=.5 and the top layer is 50% visible. This should work even if you're transitioning from opacity levels != 1.   I was working on it a little bit and I'm pretty sure I'm on track for a solution.  This formula would also solve bug #11 .\n. I'm pretty positive the bottom layer doesn't have to be 100% opaque, and thats what I'm trying to nail down.  Say you are transition between .5 opacity on the first element and 1 opacity on the second element.  Then at the halfway point of the animation, where time T = .5 then you should be able to calculate two opacity values such that their combined opacity =.75 and the bottom one is still 50% visible.  So at that time the bottom element might have opacity .6 and the top layer has opacity .3 which would get you close to .75 opacity (I'm still working on the calculation, need to figure out the compositing formula).\n\nDoes that make sense?  If this works then you shouldn't have to lose the SVG support.\n. Right, so the problem is rather easy when you're transitioning from opacity 1 to 1.  Then you just make the bottom layer 100% and transition the top layer. But it gets much harder when you're transitioning from  one partially opaque element to another.  In this case you can't just make the bottom layer 100% because it needs to know how to transition evenly between the two values.\n\nI think theres a formula that can solve this perfectly.  So in your getKeyframes function, it would have a much smarter opacity value than just using (t) and (1-t).  It would handle cases where elements have different opacity levels and transition them smoothly.\n. Hmm... well I have a formula that works by transitioning the opacity of the child elements. It has the added benefit of also being able to animate the alpha channel of rgba backgroundColors. I don't think there is anything that can be done for transitioning something like an image (png) with a transparent background, but that is a whole different bucket of crabs.  I think in that case you just fallback to using the `crossfade` option.\n\nIt also can work without creating a new container for the new elements.  Do you think there is a benefit of creating the new container?  I'm not sure if its a good thing or a bad thing...  definitely has different behaviour when parent elements have filters, clip paths, overflow:hidden, etc.\n\nEither way... I'll push a branch once I have these changes finished tonight and you can see which you prefer.\n. Alright, I pushed the code for animating both rgba backgrounds and opacities so that they blend when they composite.  I haven't tested yet on IE, but was able to do Safari, Firefox, Chrome, Chrome for Android, and mobile Safari.\n\n![animating-rgba](https://cloud.githubusercontent.com/assets/495226/7488097/92a3072e-f379-11e4-8ba2-b38e7692d921.gif)\n\nThis branch is still duplicating into the new container, but it works without that.  You can decide if thats the method you want to use or not.  Heres the link to the pull request... https://github.com/Rich-Harris/ramjet/pull/28\n. That is true.  Most of the time, I would prefer to drop a couple of frames on that animation than to have it look broken by skipping them. @Rich-Harris, good call on allowing them to be disabled with `compositorOnly: true`.\n\nThe way I wrote it, the backgroundColor will only be written to the keyframes when one of the nodes has a background alpha value less than 1 (the backgroundColors variables will be false if they don't need to animate.)  https://github.com/Rich-Harris/ramjet/blob/opacity/src/transformers/KeyframeTransformer.js#L99\n\nWe could do the same thing for border radius, where we only transition them when the elements have different border-radiuses.\n. I'm pretty sure theres a solvable formula for the opacity of the bottom and top layers at a given time T such that the bottom layer is 50% visible at T=.5 and the top layer is 50% visible. This should work even if you're transitioning from opacity levels != 1.   I was working on it a little bit and I'm pretty sure I'm on track for a solution.  This formula would also solve bug #11 .\n. I'm pretty positive the bottom layer doesn't have to be 100% opaque, and thats what I'm trying to nail down.  Say you are transition between .5 opacity on the first element and 1 opacity on the second element.  Then at the halfway point of the animation, where time T = .5 then you should be able to calculate two opacity values such that their combined opacity =.75 and the bottom one is still 50% visible.  So at that time the bottom element might have opacity .6 and the top layer has opacity .3 which would get you close to .75 opacity (I'm still working on the calculation, need to figure out the compositing formula).\n\nDoes that make sense?  If this works then you shouldn't have to lose the SVG support.\n. Right, so the problem is rather easy when you're transitioning from opacity 1 to 1.  Then you just make the bottom layer 100% and transition the top layer. But it gets much harder when you're transitioning from  one partially opaque element to another.  In this case you can't just make the bottom layer 100% because it needs to know how to transition evenly between the two values.\n\nI think theres a formula that can solve this perfectly.  So in your getKeyframes function, it would have a much smarter opacity value than just using (t) and (1-t).  It would handle cases where elements have different opacity levels and transition them smoothly.\n. Hmm... well I have a formula that works by transitioning the opacity of the child elements. It has the added benefit of also being able to animate the alpha channel of rgba backgroundColors. I don't think there is anything that can be done for transitioning something like an image (png) with a transparent background, but that is a whole different bucket of crabs.  I think in that case you just fallback to using the `crossfade` option.\n\nIt also can work without creating a new container for the new elements.  Do you think there is a benefit of creating the new container?  I'm not sure if its a good thing or a bad thing...  definitely has different behaviour when parent elements have filters, clip paths, overflow:hidden, etc.\n\nEither way... I'll push a branch once I have these changes finished tonight and you can see which you prefer.\n. Alright, I pushed the code for animating both rgba backgrounds and opacities so that they blend when they composite.  I haven't tested yet on IE, but was able to do Safari, Firefox, Chrome, Chrome for Android, and mobile Safari.\n\n![animating-rgba](https://cloud.githubusercontent.com/assets/495226/7488097/92a3072e-f379-11e4-8ba2-b38e7692d921.gif)\n\nThis branch is still duplicating into the new container, but it works without that.  You can decide if thats the method you want to use or not.  Heres the link to the pull request... https://github.com/Rich-Harris/ramjet/pull/28\n. That is true.  Most of the time, I would prefer to drop a couple of frames on that animation than to have it look broken by skipping them. @Rich-Harris, good call on allowing them to be disabled with `compositorOnly: true`.\n\nThe way I wrote it, the backgroundColor will only be written to the keyframes when one of the nodes has a background alpha value less than 1 (the backgroundColors variables will be false if they don't need to animate.)  https://github.com/Rich-Harris/ramjet/blob/opacity/src/transformers/KeyframeTransformer.js#L99\n\nWe could do the same thing for border radius, where we only transition them when the elements have different border-radiuses.\n. ",
    "bradparks": "hmmm.... not sure what the difference was, but that did the trick... thanks!\n. yeah, i think you're totally right... especially given the fact that maybe something else could be passed in laster on that might be more relevant... thanks again!\n. hmmm.... not sure what the difference was, but that did the trick... thanks!\n. yeah, i think you're totally right... especially given the fact that maybe something else could be passed in laster on that might be more relevant... thanks again!\n. ",
    "lishengzxc": "Well, if you need help, I will help you as much as I can, ramjet is intersting, hahaaaa :)\nps: Please pardon me for my broken English \n. Well, if you need help, I will help you as much as I can, ramjet is intersting, hahaaaa :)\nps: Please pardon me for my broken English \n. ",
    "paldepind": "It seems to be impossible for me to reproduce the artifacts I saw, today. I think you can close this :)\n. It seems to be impossible for me to reproduce the artifacts I saw, today. I think you can close this :)\n. ",
    "moimael": "I can reproduce every time on last Firefox desktop release (47.0). Here is a screencast of the issue : \n[screencast here](https://vid.me/ve9A)\n. I can reproduce every time on last Firefox desktop release (47.0). Here is a screencast of the issue : \n[screencast here](https://vid.me/ve9A)\n. ",
    "julesbou": "works like a charm :)\n. works like a charm :)\n. ",
    "ghost": "In case you didn't see it already, it looks like ngAnimate 1.4 basically does this with the ng-animate-ref feature. \n. In case you didn't see it already, it looks like ngAnimate 1.4 basically does this with the ng-animate-ref feature. \n. ",
    "rbenjamint": "Can you post a code-sample? would help us a lot! Tnx anyway\n. Can you post a code-sample? would help us a lot! Tnx anyway\n. ",
    "homerjam": "This works for me, any chance of getting it merged?\n\nOne question, should the from/to elements be hidden whilst the animation runs?\n. This works for me, any chance of getting it merged?\n\nOne question, should the from/to elements be hidden whilst the animation runs?\n. ",
    "afc163": "ping~\n. ping~\n. ",
    "MrAlexLau": "@sithmel - yes I like your idea better. What I originally proposed could easily become a leaky abstraction.\n. @williammalo - by nodelists, you mean if `$('.some-selector')` matches more than one element? It does not, it naively picks the first element that matches the selector. \n\nThe reason I opted for that is because it didn't seem to jive with the general purpose of ramjet to transform one element into another (not a list of elements into one). \n. Ah, no it just handles jQuery elements.\n. @sithmel - yes I like your idea better. What I originally proposed could easily become a leaky abstraction.\n. @williammalo - by nodelists, you mean if `$('.some-selector')` matches more than one element? It does not, it naively picks the first element that matches the selector. \n\nThe reason I opted for that is because it didn't seem to jive with the general purpose of ramjet to transform one element into another (not a list of elements into one). \n. Ah, no it just handles jQuery elements.\n. ",
    "babakness": "@Rich-Harris Cool! I think I understand what you're saying. \n\n``` css\ntransform: rotate(45deg);\ntransform: rotate(720deg);\ntransform: matrix(0.707106781186549, 0.707106781186547, -0.707106781186547, 0.707106781186549, 0, 0);\n```\n\nare all the same. I was thinking that the text of the original css would be preserved but its not! \n\nThe shearing effect looks great too, more like morphing than rotating. It has a more liquid feel. Actually wiggling and jiggling the end points of the animation, sort of like the demos do spatially, but with a shear effect, would be lively and organic. \n\nThanks for the info, I learned from this!\n. @Rich-Harris Cool! I think I understand what you're saying. \n\n``` css\ntransform: rotate(45deg);\ntransform: rotate(720deg);\ntransform: matrix(0.707106781186549, 0.707106781186547, -0.707106781186547, 0.707106781186549, 0, 0);\n```\n\nare all the same. I was thinking that the text of the original css would be preserved but its not! \n\nThe shearing effect looks great too, more like morphing than rotating. It has a more liquid feel. Actually wiggling and jiggling the end points of the animation, sort of like the demos do spatially, but with a shear effect, would be lively and organic. \n\nThanks for the info, I learned from this!\n. ",
    "Martin-Pitt": "Hi @Rich-Harris, last year I\u00a0began working on a material design inspired view transition library and one of the big challenges was animating transforms.\n\nActually, it turns out that it IS practical to interpret start/end transformations as a series of transform function as that was the point of transform function lists.\n\nHere is the URL to the official W3C standard on interpolation transforms, along with a snippet of the important bit:\nhttp://www.w3.org/TR/css3-transforms/#interpolation-of-transforms\n\n> Four rules for interpolating transform lists:\n> - If both lists are none, return nothing.\n> - If one of the lists is none, create a equivalent identity list, continue to next rule.\n> - If both lists have the same amount of arguments (having a common primitive), interpolate each pair of transform function and return computed value.\n> - else in worst case, convert both lists to matrices and interpolate those, return computed value.\n\nHere is a library I had worked on in the past that interpolated transform strings using the above rules:\nhttps://gist.github.com/Martin-Pitt/3a6f2168a03a7502575a\nIt is incomplete and only supports common set of transform functions but has worked really well for me.\n\nRecently for my library though and for future proofing I have switched over entirely to the Web Animations API, which has it's own handler which I would also recommend checking out:\nhttps://github.com/web-animations/web-animations-js/blob/master/src/transform-handler.js\n\nOn my day job as a mobile web app developer I have found the libraries efficient enough to create very smooth animations.\n. I just ran this script in the console for github here:\n\n```\nvar test = document.querySelector('.comment-form-textarea');\nvar s = document.styleSheets.length;\nwhile(s-->0)\n{\n  var styleSheet = document.styleSheets[s];\n  var r = styleSheet.cssRules.length;\n  while(r-->0)\n  {\n    var rule = styleSheet.cssRules[r];\n    if(test.matches(rule.selectorText))\n    {\n      console.log(rule.selectorText, rule.style.transform);\n      break;\n    }\n  }\n}\n```\n\noutput\n\n```\n.comment-form-textarea translateZ(0px)\n```\n\nDo-able?\nCompatibility for .cssRules: http://www.quirksmode.org/dom/w3c_css.html#t10\n. Hi @Rich-Harris, last year I\u00a0began working on a material design inspired view transition library and one of the big challenges was animating transforms.\n\nActually, it turns out that it IS practical to interpret start/end transformations as a series of transform function as that was the point of transform function lists.\n\nHere is the URL to the official W3C standard on interpolation transforms, along with a snippet of the important bit:\nhttp://www.w3.org/TR/css3-transforms/#interpolation-of-transforms\n\n> Four rules for interpolating transform lists:\n> - If both lists are none, return nothing.\n> - If one of the lists is none, create a equivalent identity list, continue to next rule.\n> - If both lists have the same amount of arguments (having a common primitive), interpolate each pair of transform function and return computed value.\n> - else in worst case, convert both lists to matrices and interpolate those, return computed value.\n\nHere is a library I had worked on in the past that interpolated transform strings using the above rules:\nhttps://gist.github.com/Martin-Pitt/3a6f2168a03a7502575a\nIt is incomplete and only supports common set of transform functions but has worked really well for me.\n\nRecently for my library though and for future proofing I have switched over entirely to the Web Animations API, which has it's own handler which I would also recommend checking out:\nhttps://github.com/web-animations/web-animations-js/blob/master/src/transform-handler.js\n\nOn my day job as a mobile web app developer I have found the libraries efficient enough to create very smooth animations.\n. I just ran this script in the console for github here:\n\n```\nvar test = document.querySelector('.comment-form-textarea');\nvar s = document.styleSheets.length;\nwhile(s-->0)\n{\n  var styleSheet = document.styleSheets[s];\n  var r = styleSheet.cssRules.length;\n  while(r-->0)\n  {\n    var rule = styleSheet.cssRules[r];\n    if(test.matches(rule.selectorText))\n    {\n      console.log(rule.selectorText, rule.style.transform);\n      break;\n    }\n  }\n}\n```\n\noutput\n\n```\n.comment-form-textarea translateZ(0px)\n```\n\nDo-able?\nCompatibility for .cssRules: http://www.quirksmode.org/dom/w3c_css.html#t10\n. ",
    "DavidCRivera": "I think I'm having this same problem. It looks like, at least for me, it has to do with scrolling. I have one of my elements within a scrollable div. And when I transition with ramjet, it seems to be transition to/from that object's original position before scrolling, not its current position. It seems like only the clone of the original object does this, not the other object. i.e. transition from a to b, a animates correctly to b's updated position, but the clone of b animates to b's former position.\n\nEDIT:\nLooks like it was resolved by making sure that the container for my divs that were going to transition was set to 'position: relative.'\n\nMight want to give that a try if you're having this problem.\n. I think I'm having this same problem. It looks like, at least for me, it has to do with scrolling. I have one of my elements within a scrollable div. And when I transition with ramjet, it seems to be transition to/from that object's original position before scrolling, not its current position. It seems like only the clone of the original object does this, not the other object. i.e. transition from a to b, a animates correctly to b's updated position, but the clone of b animates to b's former position.\n\nEDIT:\nLooks like it was resolved by making sure that the container for my divs that were going to transition was set to 'position: relative.'\n\nMight want to give that a try if you're having this problem.\n. ",
    "imperator-maximus": "thanks for feedback. I checked my code and there wasn't any scrollable div. But I found the problem now. I had in a parent of the source element a \"transform-style: preserve-3d;\". This was the reason for the problem in Chrome. In my code I can change this so this is solved for me.\n. thanks for feedback. I checked my code and there wasn't any scrollable div. But I found the problem now. I had in a parent of the source element a \"transform-style: preserve-3d;\". This was the reason for the problem in Chrome. In my code I can change this so this is solved for me.\n. ",
    "weislanes": "Yes, that would be very helpful as spent a similar amount of time figuring this out. Thanks for the jsfiddle.\n. Yes, that would be very helpful as spent a similar amount of time figuring this out. Thanks for the jsfiddle.\n. ",
    "bfred-it": "This seems to work for me, although I haven't tested it thoroughly (edit: in fact it fixes the second demo but not the first one)\n\n```\nclone.style.top = top  - offsetParentBcr.top - parseInt( style.marginTop, 10 ) + 'px';\nclone.style.left = left  - offsetParentBcr.left - parseInt( style.marginLeft, 10 ) + 'px';\n```\n. It looks like the first demo now works, but the second one doesn't.\n. @electerious that might be because the element you selected doesn't have a parent, which means make sure you append the element to the page first.\n. That threw me in a loop. It makes sense though.\n. This seems to work for me, although I haven't tested it thoroughly (edit: in fact it fixes the second demo but not the first one)\n\n```\nclone.style.top = top  - offsetParentBcr.top - parseInt( style.marginTop, 10 ) + 'px';\nclone.style.left = left  - offsetParentBcr.left - parseInt( style.marginLeft, 10 ) + 'px';\n```\n. It looks like the first demo now works, but the second one doesn't.\n. @electerious that might be because the element you selected doesn't have a parent, which means make sure you append the element to the page first.\n. That threw me in a loop. It makes sense though.\n. ",
    "electerious": "Same problem for me.\n\nError:\n\n``` js\nTypeError: null is not an object (evaluating 'offsetParent.getBoundingClientRect')\n```\n\nCode:\n\n``` js\nlet ramjet = require('ramjet'),\n    $      = require('jquery')\n\nramjet.transform($('.a').get(0), $('.b').get(0))\n```\n\nTested in Safari and Chrome on OS X.\n. @bfred-it The element is already on the page and has a parent.\n\nTransforming to `.fixedBasket__badge` works fine.\n\n![rentastic](https://cloud.githubusercontent.com/assets/499088/9980399/6c8fa5b6-5f98-11e5-89b4-01d8c3e3fbde.png)\n. The code has changed. Can't reproduce it anymore, sorry. I guess it had something to do with `position: fixed` of the `fixedBasket`-element.\n. Same problem for me.\n\nError:\n\n``` js\nTypeError: null is not an object (evaluating 'offsetParent.getBoundingClientRect')\n```\n\nCode:\n\n``` js\nlet ramjet = require('ramjet'),\n    $      = require('jquery')\n\nramjet.transform($('.a').get(0), $('.b').get(0))\n```\n\nTested in Safari and Chrome on OS X.\n. @bfred-it The element is already on the page and has a parent.\n\nTransforming to `.fixedBasket__badge` works fine.\n\n![rentastic](https://cloud.githubusercontent.com/assets/499088/9980399/6c8fa5b6-5f98-11e5-89b4-01d8c3e3fbde.png)\n. The code has changed. Can't reproduce it anymore, sorry. I guess it had something to do with `position: fixed` of the `fixedBasket`-element.\n. ",
    "pra85": "No problems :+1: \n. No problems :+1: \n. ",
    "mrmartineau": "thanks @Rich-Harris. it looks better now.\n. thanks @Rich-Harris. it looks better now.\n. "
}