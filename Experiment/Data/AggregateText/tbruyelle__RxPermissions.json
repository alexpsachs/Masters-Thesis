{
    "tbruyelle": "Thank you !\n. Thanks it's more clean\n. Well it was something I expected, because I totally neglect lifecycle handling... until now :)\nI will try to find a solution.\n. OK it will be hard to fix that problem properly. \n\nRxjava and activity/fragment lifecycle have been discussed a lot and as far as I know there is no clean solution. \n\nWe can easily prevent the crash by making `RxPermissions` a singleton, so after the rotation change and the user answers to the permission request, the corresponding subject is found. But when the lib emits the response, the observer is still linked to the old activity, so it has no effect to the current new activity.\n\nThe main problem here is we have _rebind_ the subscription in the newly created activity, after the rotation change. This can be done manually by the user, he unsubscribes when the activity dies and resubscribe when the new activity pops. But I don't like that since it adds too much code for the user.\n\nIf someone has a good idea, it would be pleasure to hear.\n. Wow thank you all for taking your time to give help.\n\nAbout making `RxPermissions` survives the activity lifecycle, a simple singleton seems good enough (I tested that in a [branch](https://github.com/tbruyelle/RxPermissions/compare/lifecycle)).\n\nAs @dlew and I said, the main problem is really to _rebind_ the subscription after the death/rebirth of the activity, and I'm more and more convinced this is not possible easily. The main goal of this library is to keep things simple and to provide `Observable`s. So I start to think about trade-offs.\n\nWhen you request a permission, the framework starts a activity called `.permission.ui.GrantPermissionsActivity` (I saw that in logcat), this activity shows a dialog and survives the rotation change. But if it doesn't survive, there is no more issue ! The user will have to re-trigger the permission request, but I don't think this is really embarrassing.\nSo the question is, can I alter that activity's lifecycle, or maybe more plausible ask it to kill itself when I detect the rotation change ?\n\nWDYT ? \n. Just release a new version 0.2.0 : \n- `RxPermissions` is now a singleton gettable with `getInstance(Context)`. This fix the crash.\n- Add an internal activity to handle the `onRequestPermissionsResult` so it's no more needed to override this method in the user acitivity.\n\nThat said, the problem about detached subscriber on rotation change is still there.\n. @domsu Yeah this is something to which I already thought, and this is easy to implement with RxJava. We just add a `doOnSubscribe(lock)` and a `doOnTerminate/doOnUnscubscibe(unlock)` to the observable.\n\nBut it can be intrusive, maybe we could make it optional ? As you said it's not a good pattern, but if it shock anyone, I'm ready to implement it, as a recommended option. \n. @andaag Yep I agree. So 2 solutions, put the project to the trash or add hacky trade-offs...\n\nI prefer the solution 2 because for me the project brings more good than harm. \n\nit doesn't bother me to lock the rotation during the permission request. And if for some rooted devices it's not possible to lock the rotation, the users will have to request the permission twice, this doesn't matter.\nFor other configuration changes, like language change, same thing. I mean, it's not very common that a user changes the language while an app is requesting a permission.\n\nBy explicitly warning the library's users of these trade-offs, I think we can move forward.\n. @dlew Actually with the shadow activity introduced in version 0.2.0, we have such tool ! Nice. \n\nAbout 3, I have no control on the runtime permission request (other than create a new one), I can't cancel or resume it. The permission request is resumed automatically after a configuration change. \n\n#### Anyway, a solution begins to take shape :\n1. **a permission request is triggered** : `RxPermissions` registers a subject associated with that permission and requests the framework : the runtime permission popup appears.\n2. **a configuration change occurs** : `RxPermissions` unsubscribes all registered subjects, but keeps in memory the pending requests. It will survive the configuration change because it's a singleton since 0.2.0.\n   The runtime permissions popup is paused and will be resumed automatically.\n3. **the app restarts** : The permission request is redone by the app (this is actually the only requirement, but as @dlew said it's a logical outcome), `RxPermissions` _remembers_ a pending request has been done for this permission, and registers a new subject for it, **but** doesn't request the framework a second time (otherwise the result would be another runtime permissions popup).\n   The runtime permissions popup is resumed and displayed again.\n4. **user answers to the permission request** : `RxPermissions.onRequestPermissionsResult` is invoked, the lib finds the corresponding subject and emits the user response. \n\nThat sounds not bad...\n. Interesting, but I'm not sure to understand how things are connected together.\n. Nice, please link the library when it's ready. \nAbout the name, sorry I have no idea.\n. I pushed a PR #14 that aims to fix the issue. I would appreciate if some of you review it.\n\nThe fix removes some flexibility to the lib but I didn't find anything better.\n\nThe good news is for clients who request the permission during activity/fragment/view start, nothing change, it will  work as these.\nFor client who request the permission after a particular event, there is some breaking changes :\n- Firstly, they need to move the request call in one of the activity/fragment/view start method.\n- Secondly, they need to add an extra parameter to the `request` or `requestEach` method : an `Observable` that represents that particular event. See the PR for details.\n\nExample from the sample app, the click event is transformed to an observable with `RxBinding` :\n\n``` java\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.act_main);\n\n         // com.jakewharton.rxbinding.view.RxView is perfect to represent the event needed\n        Observable<Object> trigger = RxView.clicks(findViewById(R.id.enableCamera));\n\n         RxPermissions.getInstance(this)\n                .request(trigger, Manifest.permission.CAMERA)\n                .subscribe(granted -> {\n```\n. @andaag Thanks for the help but I think I found a solution which bring less changes on the client side.\n. > For just glancing at the code, I'm guessing your using the permission itself as an identifier for the request? That means you can only request a permission from one place in the app. If you want the camera permission in 3 different places your gonna need another identifier.\n\nI think it should work. From the beginning the lib has been designed with concurrent access in focus. For instance, if there's 3 camera permission requests from 3 different places, the same observable is returned to the subscribers. So when the user's answer is caught, all subscribers will receive it. \n\nThat said, if the requests are done very simultaneously, it won't work as expected since I forgot to use `synchronized`... That's another small improvement.\n. I uploaded a snapshot version\n\n``` gradle\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.4.0@aar'\n```\n. @andaag I tested a little more and it works also if you make the permission request in `View.onFinishInflate` or any methods invoked during the app initialization.\n\nSo you're not limited to `onCreate`/`onResume`.\n. > you never remove anything from mSubjects it'll leak.\n\nWhen the lib receives the permission request answer, the subject receives `onComplete` which unsubscribe all subscribers, and is removed from the list.\nhttps://github.com/tbruyelle/RxPermissions/blob/lifecycle-handling/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L274\n. Yes you're right, I probably should make `RxPermissions.onDestroy()` `public`, to unsubscribe all subjects.\n. @andaag Thanks for the report, I noticed that bug last friday. The issue is due to the `take(1)` which prevents the trigger observable to emit more than one item. I removed it here 2455bcf21d5ac9adc82e6f89786d6de2a085b89c but now I have to fix the `request` method which doesn't work any more. \n\nIndeed, `take(1)` was here to ensure the sequence was completed, this is mandatory because `request` use `toList()` to transform the original sequence to a single boolean (`toList()` requires completed sequence or else it emits nothing).\n\nI have an idea of the final fix, I'll publish it today.\n. So version 0.4.1 brings some other fixes, including the one mentioned by @andaag \n\n``` gradle\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.4.1@aar'\n```\n\nI think I'll soon merge the PR #14 \n. Good point. \n\nDo you know if there's relation between `PackageManager.checkPermission` and `Context.checkSelfPermission()` ?\n\nMy first attempt to fix thgis issue is to check `PackageManager.checkPermission` only pre-M but I have a doubt, maybe I should check it for all versions ?\n. @ffgiraldez Yes I saw that but I didn't use it to prevent an external dependency and also because I thought it's easy to implement.\n\nBut I wasn't aware of the `PackageManager.checkPermission` thing. I would like to see the source of `ContextCompat.checkSelfPermissions()` but it seems it's not released yet (https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/content/ContextCompat.java)\n. [`ContextCompat.checkSelfPermissions()`](https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/content/ContextCompat.java#L382) is now visible, but there is no call to `PackageManage.checkPermission()`.\n. Closed because no idea of what to do here\n. It depends on the usage. Most of the time I think people only want to know if the user has granted all the requested permissions. So a simple boolean is enough.\n\nThat said, your proposal is good. What if we add another method to the API, let's say `requestDetailed()` which returns an `Observable<Map<String,Boolean>>`  ?\n. I'm not sure about the map thing. Are you saying the method should return `Observable<HashMap<String, Boolean>>` rather than `Observable<Map<String, Boolean>>` ?\n. Yep agree with @alorma. \nUntil now I never heard of that kind of rule. And in this library's context, I don't see any benefit for the consumer to explicitly know the concrete type of the `Map`.\n. Not silly at all, but interesting. This is absolutely feasible with RxJava.\n\nIf I'm right,  `permission.shouldRequestAgain()` is related to `shouldShowRequestPermissionRationale`. I started a basic support for this method in #8, but implemented it differently. I chose to create a independent method so you can mix the observables, like [here](https://github.com/tbruyelle/RxPermissions/pull/9/files#diff-dd59e011627697b372d3b0429739ae71R35).\n\nwhat is the way you prefer ?\n. Yes there is less code in theory but what do you do mostly if `shouldShowRequestPermissionRationale` returns `true` ? \nYou show the user an explanation with a dialog and once he agrees, request the permission a second time. That's why I did it like that. \n\nThat said, I'm not 100% sure this is the best way.\n. I just create that PR, please tell me if this fits your needs. \nPlease comment on the PR.\n. Released in version 0.3.0\n. Thank you for your time, I started a similar feature in a [branch](https://github.com/tbruyelle/RxPermissions/compare/shadowActivity), and actually it doesn't solve the problem.\n\nTake the sample app, remove previously granted permission, run it and click on the button. Then if you rotate the device while the permission popup is displayed, and grant or deny the permission, nothing will happen. This is because the function attached to the `Observable` is linked to the destroyed activity, and it has no effect to the new one.\n\nThe main problem is really to _rebind_ that function from the destroyed activity to the new one. And I'm not even sure it's possible.\n\nThat said, I like the invisible/shadow activity idea, so I'll probably use your PR later, and merge it with my branch.\n. > I think that this library should not be concerned with managing the observable for the consume\n\nYeah you're probably right, but I'm disappointed because this will complicate a lot the usage of the library.\n. Implemented in ef4aed66a57c52f06b9679c2acac376a7d62c433\n\nThanks anyway\n. Thanks\n. Good point\n. I created a PR with a basic support, wdyt ? \nPlease comment on the PR.\n. Released in version 0.3.0\n. Yes we need to fix #3 to have a stable release.\n. The screen rotation is only the visible part of the iceberg, we need to handle every configuration changes.\nSo no, locking the rotation change in your app is not enough.\n\nHowever, since 0.2.0, there is no more crash, but the `onNext`'s code you registered before the configuration change will never be executed.\n. Thanks for the compliment ^^ \nI hope we will find a proper solution.\n. Well I'm not sure to see the benefit also. \nPlus I hate fragments.\n. (@digitalbuddha That's also what I did with my job's app. Now I use only activities and views, and I feel better. No more weird exceptions and other horrible things.)\n. Good point @andretietz, and I've just noticed that `Fragment` have also a `onRequestPermissionResult` method. So it seems feasible, and would probably has a smaller footprint than the activity.\n. I'm working on #3 currently, so feel free to send a PR if you can. That would be nice, thanks in advance.\n. @richarddd thanks for that\n. Closed for no activity\n. This is code generated by Android Studio, I hope it's correct :D\n. The goal of `RxPermissions` is not to handle `onActivityResult`. Maybe you could create an other library for that.\n. ok, first you don't need to check the sdk version, it's handled by the library. If `Build.VERSION.SDK_INT < 23`, the observer will immediately receive a granted result.\n\nSecondly, it seems you're not well informed about runtime permissions. Only a  part of the permissions requires a request : the dangerous ones, as Google names them [1]. \n\nAbout the crash itself, I think it's exactly because you request permissions that don't need to be requested. Try to filter the parameter list with only _dangerous_ permissions and it should work.\n\nThat said you pointed a weakness in the library that needs a fix. Thanks !\n\n[1] https://developer.android.com/guide/topics/security/permissions.html#normal-dangerous\n. After some tests, there is finally no issue in requesting non-dangerous permissions, but the framework will always answer the permission is not granted. The answer is propagated without change by the library.\n\nCould you tell me if you still have the issue with the last version of `RxPermissions` ?\n. Closed for no activity\n. No, the `minSdkVersion` to use this library is 9\n\nI will add that in the README.\n. What do you want me to check ? `mCtx.checkSelfPermission(permission)` is not even a call to this library.\n. I know I use it.\nThe method `hasPermission_` is only called if current sdk is >=23.\n. > if targetSdk is not 23, permissions dialog is always not showing .\n\nFair enough since runtime permissions are only available for target 23.\n. Thanks!\n. As you can see, this method is not public. It's invoked internally by the `ShadowActivity`.\n\nI document only the public API.\n. Interesting. The documentation I found [1] on `@RequiresPermission` doesn't tell how it works, so I can't figure out how to handle that.\n\nI'll try to look further.\n\n[1] http://tools.android.com/tech-docs/support-annotations\n. No sorry, I didn't.\n. Thanks for the report. \n\nI also read that post, and unlike `ActivityCompat`, `RxPermissions` doesn't delegate the permission request to `PackageManager` but returns true immediatly. So this issue is already handled.\n. No problem\n. Because I'm lazy. Maven central needs more than just an aar.\n. That would be nice\n\nLe lun. 23 nov. 2015 18:28, Saad Farooq notifications@github.com a \u00e9crit :\n\n> Got it... will try to put up a PR when I get the time\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/21#issuecomment-159003300\n> .\n. Thanks @eleventigers \n\n@martyglaubitz if you're OK with the implementation, please close the issue.\n. I discover this method, it sounds very similar to `shouldShowRequestPermissionRationale()`.\n\nI don't know if it should be implemented in the library, the only benefit in that case would be to handle the sdk version.\n. Fixed in 0.5.0\n. Very clean PR thanks !\n. Is there a reason why you used variadic parameters in `isRevoled` ? (other than replicating `isGranted`'s signature)\n\nI'm asking you that because in the current code state there's no good reason to use variadic parameters for both `isResolved` and `isGranted`. I would like to change that and use a standard parameter, a permission.\n. I will :)\n. 0.5.0 deployed with your PR and without variadic param.\n. 1. It prevents to leak an `Activity` if the user passes that kind of class in the method invocation.\n2. What do you mean ?\n3. Not planned, I'm not sure of what benefits can bring a Kotlin version of the library.\n4. What are you talking about ? Please detail.\n. 1. I know RxLifecycle, but I don't see the benefits of an integration with RxPermissions.\n2. Support lib hides the result of version check, whereas I need the information to feed the `Observables`. The lib manipulates `Observables`, Support lib doesn't. \n. Could you make an unique PR with the version upgrade and the fix on subjects ?\nYou can push that [commit](https://github.com/PavelSynek/RxPermissions/commit/201ded6014d1bda43be84e0d184f917cf928561f) into your branch `rxjava110` and close #26. That should be ok.\n\nThanks in advance\n. No need to squash thx\n. Of course, but you have to do it yourself.\n. No I don't want to add this kind of feature in the library. I don't want UI dependency.\n. If I need to show an explanation before ask permissions, I would show a dialog with the explanation and trigger the permission request on dialog dismiss.\n. Already fixed in #24, but I need to release it. I will do it asap,\n. 0.5.1 released, it should fix your problem.\n. If you use Android Studio, type `new Ctrl+Space` and it will suggest the correct class to implement.\n. Ok I removed retro lambda usage from the sample app.\n. Done\n. Well, I also use the library to request multiple times a critical permission, but I don't have the problem you describe. That said I'm not using those damned fragments.\n\nRather than removing the `onDestroy` content, could you try to wipe the subject list at the end of `RxPermissions.onDestroy()` :\n\n``` diff\n void onDestroy() {\n        log(\"onDestroy\");\n        // Invoke onCompleted on all registered subjects.\n        // This should un-subscribe the observers.\n        for (Subject subject : mSubjects.values()) {\n            subject.onCompleted();\n        }\n+      mSubjects.clear();\n    }\n```\n\nTell me if it fixes your issue.\n. Oh I think I get it this time. So as you explained there's no reason why an activity started with `FLAG_ACTIVITY_NEW_TASK` propagate a `onDestroy` event to a singleton like the `RxPermissions` class.\n\nI think we can safely remove the `ShadowActivity.onDestroy` method.\n\nCould you check if it's OK for you and then open a PR ? I will try to release it quickly.\n. Sorry I'm going to reverse that change because it breaks configuration change handling.\n\nWhen you request a permission, you see the permission dialog, if before answer you rotate your phone, your app is restarted and the permission dialog pops again automatically (it's not because of RxPermissions). If you answer at this time, the rx chaining should be invoked properly, but not any more since that change.\n. Please keep `RxPermissions.onDestroy()` it can be usefull to invoke it manually.\nEnsure also the tests are passing.\n\nThanks in advance\n. Ok version 0.5.2 has been deployed to bintray with your fix. Thanks for the contribution!\n. Thanks for that, but I didn't manage to upload an artifact.\n\nFirst I fixed the package name (see 08b227cea808ca9fcf6d8b3e499c8488c6337c87)\n\nI filled my bintray user and api key, generated the pom and jar with the `install` task (maybe there's a task which do not copy the files in `~/.m2` ?), and tried to upload with `bintrayUpload` task. It returns me success but then I can't find the artifact in jcenter.\n\nIf I rerun `bintrayUpload` I got an error telling me the artifact already exists.\n\n``` sh\n* What went wrong:\nExecution failed for task ':rxpermissions:bintrayUpload'.\n> Could not upload to 'https://api.bintray.com/content/tbruyelle/tbruyelle/RxPermissions/0.5.2/com/tbruyelle/rxpermissions/rxpermissions/0.5.2/rxpermissions-0.5.2.aar': HTTP/1.1 409 Conflict [message:Unable to upload files: An artifact with the path 'com/tbruyelle/rxpermissions/rxpermissions/0.5.2/rxpermissions-0.5.2.aar' already exists]\n```\n. > The first time (and that's the step missing), you have to link your repo with jcenter, here in linked to, add to jcenter. Just fill the form and usually in a few hours will be available :)\n\nOk thanks I did'nt know that.\n\n> You can do directly a gradlew bintrayUpload and will generate the pom and jar and upload it directly.\n\nWell, I'm not sure : \n\n``` bash\n$ ./gradlew clean rxpermissions:bintrayUpload\nParallel execution with configuration on demand is an incubating feature.\nIncremental java compilation is an incubating feature.\n:rxpermissions:clean\n:sample:clean UP-TO-DATE\n:rxpermissions:clean UP-TO-DATE\n:rxpermissions:bintrayUpload:rxpermissions:bintrayUpload: file /home/tbruyelle/projects/rxpermissions/lib/build/libs/rxpermissions-0.5.2-javadoc.jar could not be found.\n:rxpermissions:bintrayUpload: file /home/tbruyelle/projects/rxpermissions/lib/build/libs/rxpermissions-0.5.2-sources.jar could not be found.\n:rxpermissions:bintrayUpload: file /home/tbruyelle/projects/rxpermissions/lib/build/outputs/aar/rxpermissions-release.aar could not be found.\n FAILED\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task ':rxpermissions:bintrayUpload'.\n> java.io.FileNotFoundException: /home/tbruyelle/projects/rxpermissions/lib/build/poms/pom-default.xml (No such file or directory)\n\n* Try:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\nBUILD FAILED\n```\n. Well sorry I'm still stuck because there's no pom/jar generated with the `bintrayUpload` task.\n\nCan you test again with the `jcenter` branch of that repo ?\n. Thank you for you time, I finally find the problem I have on my machine it's because my gradle.properties has the following feature enabled : `org.gradle.configureondemande`. If I disable it the pom and jars are correctly generated. Don't ask me why I enabled this feature, I can't remember !!\n\nSo I managed to upload the artifact to bintray and I asked a link to jcenter. Wait and see ^^\n. Ok so my repo is still not linked, this is probably because only version 0.5.2 has the requirements for jcenter linkability (pom and jar stuff).\n\nI can't delete old versions because other people may use them, so I have 2 options\n- manually add bintrayUplload functionnality to each tags (should take some time...)\n- create an other repo with only version 0.5.2 (but I'll loose all my repo stats and at next version some users will complain about missing artfiact because they have kept the original repo).\n\nShort, this is annoying... Maybe you have better idea ?\n. > I can generate the source jars for the other versions and send them to you (should be apply those commits after the tags of each version and generate).\n\nYou're nice, but that's fine thank you. I will do it if necessary. I'll wait tomorrow.\n. It's me who thank you for the contribution, I merged the `jcenter` branch so this PR can be closed.\n. Well that's weird, you get that error because the code is executed on a pre-6 version of Android. This isn't supposed to happen, in `RxPermissions` the version is checked before invoking that method.\n\nYou're not trying to start the `ShadowActivity` manually don't you ?\n. That shouldn't happen, do you see this error frequently in your crashlytics?\n. Closed for no response from submitter \n. Use last version please.\n. I'm not sure your way works when a configuration change occurs.\n\nCan you test that : \n\nAsk for a permission not granted yet with your method, see the permission dialog appear, don't answer but rotate your device to trigger a config change, then answer to the permission dialog. If ok your answer should be take into account. If nothing happen, then it means your way doesn't work.\n. Wow thanks dude I'm pleasantly surprised. I was aware of the `compose` method, I use it for life-cycle handling, but I didn't know it could be useful in that case.\n\nThat's a lot better than that ugly method signature `request(trigger, permissions)`.\n\nI will integrate that in the framework.\n. That's a little crazy but you gave me the idea to deprecate all current methods and expose only 2 new methods : \n\n``` java\n public static Observable.Transformer<Object, Boolean> ensure(final Context ctx, final String... permissions) {\n        return new Observable.Transformer<Object, Boolean>() {\n            @Override\n            public Observable<Boolean> call(Observable<Object> o) {\n                return RxPermissions.getInstance(ctx).request(o, permissions);\n            }\n        };\n    }\n\n    public static Observable.Transformer<Object, Permission> ensureEach(final Context ctx, final String... permissions) {\n        return new Observable.Transformer<Object, Permission>() {\n            @Override\n            public Observable<Permission> call(Observable<Object> o) {\n                return RxPermissions.getInstance(ctx).requestEach(o, permissions);\n            }\n        };\n    }\n```\n\nFor permissions request that requires immediately trigger (without a button), users would have to do something like : \n\n``` java\nObservable.just(null) // Too bad there's no something like Observable.always()\n     .compose(RxPermissions.ensure(this, perms))\n    .subscribe( granted -> {\n});\n```\n\nThe major benefit of that refactoring is it forces the user to use the library correctly. Indeed currently it's possible to write the following code : \n\n``` java\nbtn.setOnClickListener(v -> RxPermissions.getInstance(this).request(perm).subscribe( { ... ] )\n```\n\nBut that code doesn't handle configuration change during permission request. So by exposing only _composable_ methods, I make this impossible. What do you think ?\n\nI still have other checks to do but this sounds very promising.\n. > permissions are requested usually just before they're needed\n\nunless they're critical permissions https://www.youtube.com/watch?v=iZqDdvhTZj0\n. Fixed with #38 \n. I agree with you, I integrated your changes in a new branch where I'm trying to refactor/simplify the lib usage. Thanks for the contrib\n. Merged with #38\n. I understand your point but the major benefit of that refactoring is it forces the user to use the library correctly. Indeed currently it's possible to write the following code : \n\n``` java\nbtn.setOnClickListener(v -> RxPermissions.getInstance(this).request(perm).subscribe( { ... ] )\n```\n\nBut that code is wrong, it doesn't handle configuration change during permission request. So by exposing only _composable_ methods, I make this impossible. \n. Yes it's not impossible but in that case I think the user really looks for problems !\n\nI agree `oservable.just(null).compose(...)` is ugly, as a replacement we can provide an observable method like you suggested it but I want to make sure there's no possible mistake  in its usage. I don't like very much `requestWithoutTrigger()`, I still prefer `request`. \n. @patloew So I undeleted `request` and `requestEach` methods, but only the version without trigger. Sounds fine to you ?\n. Do you see it ? The theme used for this activity is already transparent\n. I never noticed that problem, and I tested also on N5.\n\nAre you sure it's not something due to the moment you request the permission ? I would like to have some details of your usage.\n. Well not sure if it's related to your ptoblem but you shouldn't condition the permission request with `savedInstanceState == null`. In case of configuration change, the lib won't work properly.\n\nDo you use the last version 0.6.1 ?\n. Did you move the call ouside the `if (savedInstanceState == null)` ?\n. This is already the case, I don't understand why you need to override it. Moreover Fullscreen is not necessary.\n\nhttps://github.com/tbruyelle/RxPermissions/blob/master/lib/src/main/AndroidManifest.xml#L11\n\nAnyway it works for you, fine.\n. Interesting, I missed that test. I'll look into it.\n. With \"do not keep activities\" enabled, it works with a standard config change (screen rotate for instance) but not with the steps you described.\nSo a config change doesn't kill your activity like the home button followed by back from recent app, that's frustrating. The proof is `ShadowActivity.onDestroy` isn't invoked from the framework in that second case. Without that call, `RxPermissions` isn't able to remind previous permission requests, causing the issue you created.\n\nDo you know why in that case the android lifecycle is ignored ?\n. Ok I'll move it to `onStop()` probably.\n. Released in version 0.6.1, thanks for the report.\n. I'm not sure this is relevant to request FINE and COARSE permissions at the same time. \n\nMoreover I don't see the true benefit of your change. I think this is trivial enough to ask multiple permissions without showing it in the sample app.\n. I fixed the issue, can you check if it's ok with the HEAD version ?\n. Awesome thanks !\n. The crash was introduced with 88d83bb3c07f3bd1aaa6852ce37427c9928d9860 where I moved code from `onDestroy` to `onStop`.\n\nQuick solution is to move the client code in `onStart` rather than `onCreate` but I dislike the idea. Too bad we can't rely on `onDestroy`, since this is the only method in the lifecycle where it is certain that `onCreate` will be invoked on back. With `onStop`, it can be `onCreate` or `onStart`, it depends... Android lifecycle is really a fucking disaster, so tired of fighting against it for years...\n\nI try to find an other fix.\n. Yes it's important for a feature that begin to annoy me : multiple request handling. \n\nBut I'm going to take my axe, remove that feature and at the same time some complicated code. I don't think people uses it. Even me I'm not using it any more.\n. I'm not talking about multiple requests when you provide 2 or more parameters, I'm talking about multiple requests done at the same time for the same permission in 2 different places of your code. \nSo, do you really use that feature ?\n. > I can hardly imagine a case when it could be inevitably needed\n\nI agree, I was probably drunk when I decided to handle that.\n\nI pushed a fix to master, could you check if it's ok (also if possible the last test you made about multiple permissions request ?) \n\nThanks in advance!\n. Good!\n\nAbout the last issue, I tried to reproduce with sample app, by adding a second permission to the parameter list, with DNKA on, but it worked mostly as expected (mostly because the result was delivered 2 times instead of one to the subscriber, will see if I can improve that).\n\nWhen you said _requested simultaneously_ you mean by passing more than one parameter ?\n. Done, new version is 0.7.0 since a _feature_ has been removed.\n. No of course it's not by design ^^, it's a bug, probably duplicate with #42.\n. Deployed a new version 0.7.0 that should fix that. Please check.\n. Can you post more code ? I need to understand where and when the library is invoked.\n. Why do you need a second call for the same permission ?\n. I think you should request the permission only one time.\n. Yes but it may be not possible since RxPermission had to deal first with configuration changes. \n. > If I want to deny this permission again\n\nIts up to the user to grant or deny, you have no control on that.\n. Good question, I presume no but I didn't test with proguard. Could you check that ?\n. It seems the rules are not specific to rx-permissions but more to rx-java, in that case I don't think I should document them. Users simply refer to the rx-java documentation for that purpose.\n. You're probably right, but I didn't find official documentation about proguard rules in the rx-java project. Did you ?\n. Do you answer to the permission dialog on 1. ?\n. Ok there's probably a bug but the case you described is kindy weird... Why the user would go to the settings _before_ answering the permission dialog ?\n. Can you provide a detailled stack trace please?\n. Ok I think I understand. \nWhen you update the app's permissions in the settings, your app is killed, and in that case RxPermissions doesn't save the current state, but the framework save the permission request and so restore it when the user is back.\n\nRxPermissions should probably save the state when the app is killed, and restore it after. If you have some time to develop a fix, I could merge it. I don't have the time for the moment sorry.\n. @AAverin Note that the bug affects only devices with sdk >= 23\n. @AAverin Agree I want to resolve it but until now nobody found an acceptable fix.\n. Fixed in 0.8.0\n. Your fix prevents the crash but the user response is not propagated to the subscriber, so there's still a problem.\n\nMoreover it breaks the lifecycle handling. If the user rotates the screen during a permission request, and then answers to the dialog, his reponse is also not propagated to the subscriber, because of your cancel.\n. Can you explain a little bit the steps to reproduce ?\n. Thanks, sorry for the delay I will probably check that on next week.\n. I don't see the `ShadowActivity` in the recent apps, how do you see it ?\n. Ok so you're talking about your app activity. In that case can you reproduce the case with the sample app ?\n. The library doesn't provide any UI stuff. Its up to you to code your own dialog, toast, snackbar...\n. `RxPermissions.shouldShowRequestPermissionRationale` doesn't need `ShadowActivity` because no activity results are delivered. \n\nAbout documentation, you're right the existence of the method should be mentionned in the README. About how to use it, it simply wraps `Activity.shouldShowRequestPermissionRationnale` in an observable so I invite you to read the documentation of the android framework.\nHTH\n. When the permission request is triggered by an action menu, you're right it's not trivial to implement it during an initialization phase.\n\nAlthough it's not ideal, I suggest to use a _subject_ to register the permission request during the initialization phase of the activity, and then emit an arbitrary item in that _subject_ in the menu click listener when you want to trigger the permission request.\n\nI can provide an example if necessary. Or if you find a better way to do that let me know.\n. Fine, that's also how I use it. \nI would like to provide a better way but it would require dependencies to menu listeners and things like that and so finally I prefer no.\n. Good question, I don't know. On my side I didn't reuse the subject. Not sure if it's good or bad...\n. I didn't understand \n. Close because no response\n. I use the library inside a project monitored with leakcanary and no leak\nwere detected.\n\nLe mer. 25 mai 2016 10:05, Binasphere notifications@github.com a \u00e9crit :\n\n> I didn't see unsubscribe() be called in the sample. Will the permission\n> Subjects leak the memory of Activity if I don't unsubscribe it?\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/52\n. Yep https://github.com/tbruyelle/RxPermissions/blob/4c4d4e1e84ad1fcf390342c493c8ed09b5e613ca/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L291\n. Interesting fix thanks, I have to take time to test it, but I couldn't do that before next week. I'll let you know.\n. So I updated the sample app to test your fix (see branch fix46). I added an other permission to the requested list.\n\nThen : \n- Launch the sample\n- Click on Enable Camera\n- Allow the first permission\n- While the second permission is requested, go to the settings and deny the first\n- Back to the app, and allow the second permission. At this time without your fix, I agree the app crashes. With your fix there's no crash but there's also no emission of the response to the subscriber, as you mentionned it.\n\nSo sorry but I'm not going to merge that PR, I prefer a visible crash than a ghost partial fix.\n. @artesa So you're telling me that 202 users have this strange behavior of moving to the settings and revoking a permission during a permission request... That's really weird. I suspect it's something else.\n. I understand, but this PR only hides the crashes and doesn't solve the problem.\n. @NitroXenon I have 0 with 2k of active users daily.\n. So I should have about 40 instances of this exception. What I mean is\nthere's maybe something wrong with how you use the library.\n\nLe mar. 16 ao\u00fbt 2016 02:44, Peter Chan notifications@github.com a \u00e9crit :\n\n> @tbruyelle https://github.com/tbruyelle I have 20k of active users\n> daily...\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/pull/53#issuecomment-239971503,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAFoeBwVtdnUrUp0QTs5691OynutZ3BYks5qgQfRgaJpZM4IpFBb\n> .\n. > I think the amount of crashes depends a lot on how much app uses rx_permissions lib, so you can't make extrapolations like this.\n\nThat's exactly what I mean by \"something wrong\", why your app needs to use the runtime permissions so often ? Usually, it's only a couple of times, once the permissions are set for your app, the framework stops request the user again and again, and so the case where that problem occurs never happens again.\n. Finally merged that PR, before the release, can you @tarasantoshchuk re-check the result if what you expect ? I just moved the hacky code in a specific class.\n. Thanks for checking, it's available now, the new version is 0.8.0.\n\nLe lun. 17 oct. 2016 \u00e0 12:56, Taras Antoshchuk notifications@github.com a\n\u00e9crit :\n\n> @tbruyelle https://github.com/tbruyelle\n> I've rechecked the fix and reviewed your refactoring commit.\n> Everything is ok.\n> \n> When we can expect the new version of lib (with this fix)?\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/pull/53#issuecomment-254176296,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAFoeLhiBEJ4LPubrjpXvewhnZIYt9hGks5q01RVgaJpZM4IpFBb\n> .\n. What I did in my app in that case is showing a single rationale for all requested permissions. It's simple but the caveat is you don't have the detail of which permissions has been revoked. So you can only display a message like \"some critical permissions have been revoked, please go to the settings and fix that\".\n\nHere is a sample code of the method which is passed to the subscribe of `request`. I used a snackbar for the user feedback : \n\n``` java\nprivate void onPermissionResult(Boolean granted) {\n        if (granted) {\n           // OK\n            return;\n        }\n        // Test whether the user clicked on \"never ask again\",\n        // adapt the action according to that.\n        RxPermissions.getInstance(this)\n                .shouldShowRequestPermissionRationale(this, CRITICAL_PERMISSIONS)\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(should -> {\n                    SnackBar.Builder snack = new SnackBar.Builder(this)\n                            .withMessageId(R.string.permission_required)\n                            .withDuration(SnackBar.PERMANENT_SNACK)\n                            .withStyle(SnackBar.Style.ALERT);\n                    if (should) {\n                        // \"never ask again\" not clicked, ask the user to retry the permission request.\n                        snack.withActionMessageId(R.string.reask)\n                                .withOnClickListener(token -> {\n                                            // Ask again for permissions                                          \n                                        }\n                                );\n                    } else {\n                        // \"never ask again\" clicked, ask the user to fix that in the app settings.\n                        snack\n                                .withActionMessageId(R.string.settings)\n                                .withOnClickListener(token -> {\n                                            // Open the app settings\n                                            AndroidUtils.startAppDetailsActivity(this);\n                                        }\n                                );\n                    }\n                    snack.show();\n                });\n\n    }\n```\n. Please refer a context\n. Closed because no response\n. That's weird, how did you declare the permission in the manifest file ?\n. Closed because no response \n. ?\n. Thanks\n. > since ShadowActivity is public class (and not package-protected) some of library users might start ShadowActivity directly in their code\n\nThat's crazy\n\n> Maybe we should make ShadowActivity package-protected?\n\nwhy not\n. Good job thank you\n. Thanks for the report and the analysis. \nSo the framework did not show the permission dialog again after a pause if the resume is done threw a deep link. RxPermissions should cancel any pending permission request in that case. Do you know how it can detect that ?\n. Sorry I have no idea\n. Because you can't mock static method with mockito, I suggest you to declare a method like that in your activity : \n\n``` java\npublic RxPermissions rxPermissions() {\n  return RxPermission.getInstance(this);\n}\n```\n\nUse this method everywhere you need RxPermissions and then in your test you can simply mock like that : \n\n``` java\nRxPermissions rxPermissions = mock(RxPermissions.class);\nwhen(activity.rxPermissions()).thenReturn(rxPermissions);\nwhen(rxPermissions.request(anything()).thenReturn(Observable.just(true));\n```\n\nHTH\n. Nice one, but that's a breaking change (I think `Single` didn't exist when the lib was created).\nI will keep that in my mind thanks. \n. The change will come with RxJava2 (see #71)\n. There's also `RxPermissions.shouldShowRequestPermissionRationale()` if you need to stay in the rx world.\n. I think that's a good idea.\n\nWe could add an extra field to the `Permission` object to handle that.\n. will be release in 0.8.0.\nYou now have a new field `shoudlShowRequestPermissionRationale` to the `Permission` object.\n. You don't need to get the instance of RxPermission during an init phase, it's required when you invoke methods from that instance.\n. That requirement is due to the permission request dialog, which is displayed by the framework when you call `request/ensure` and the permission is not granted or not denied permanently. If an activity recreation occurs when that dialog is displayed, then the dialog is restored but there's absolutely no way to get that information from the framework. \n\nThe only solution is so to invoke the `request/ensure` in a init phase, and in that case there's a little complex mechanism, which detects pending permission requests.\n\nThat requirement is clearly the ugliest thing in that library, and there is a long thread about that in #3, but despite the intervention of famous android developers, no better solution could be found.\n. I linked this issue in the readme.\n. Although your changes refer to good old java practices, I don't want to merge them because I think they do not promote code readability.\n. Yes I think that's definitevely something RxPermissions should support.\n\nI read some days ago the content of RxJava2 and it's a full rewrite, so I wonder how library like RxPermissions should publish new version that breaks everything. I don't want to change the package name or the artifactId. Maybe a jump to version 1.0 is enough to warn the user about the big changes ?\n. RxAndroid is part of the ReactiveX organisation so it sounds logic it adopted the same way.\n\nI don't think I can use the `io.reactivex` package, and I don't want to rename the package to something like `org.tbruyelle` because it doesn't mean anything. Changing artifact id to something like `RxPermissions2` is much more meaningful but that's ugly.\n. Ok for changing the package name to `com.tbruyelle.rxpermissions2`, that's the best alternative I think. \nI'm curious to see how it will be handled in [RxBinding](https://github.com/JakeWharton/RxBinding/issues/281).\n. Not me\n. I won't have the time to start that in the next weeks. \n\nI linked issue #65 about `Single<Boolean>` usage instead of `Observable<Boolean>`, I said this will come with rxJava2. But after some experiences I found something annoying with `Single`, they don't have `filter` operator. It's logic but for the permission request workflow, it can be annoying to don't have the `filter` operator. \n. As we discussed, I'm ok for a different package name, like `com.tbruyelle.rxpermissions2` and so support both versions in parallel.\n\nI understand your request to distribute your work on one of your repository, and if you really want to do so that's ok. But I'm not sure the community will gain from that. There will be 2 different repositories for the same project, it will be confusing. As you like.\n. Wow you're quick, thanks!\n2.x branch is ready.\n. @gengjiawen That's right, I don't understand why, the files are here... https://dl.bintray.com/tbruyelle/tbruyelle/com/tbruyelle/rxpermissions2/rxpermissions/0.7.1/\n. Maybe it's because it's a different package ...\n. Strange, I asked to bintray to understand, I'm waiting for their response.\n. My config is OK since I managed to upload the legacy version at the same time.\nhttps://jcenter.bintray.com/com/tbruyelle/rxpermissions/rxpermissions/0.7.1/rxpermissions-0.7.1.pom\n. Got my answer from bintray, I have to create an other package and ask for jcenter link. Stay tuned\n. @gengjiawen Request approved by bintray, please retry (I can't be myself for the moment)\n. Fixed now with version 0.8.1 \n. Could you post more code plz ? The problem you have goes against the basic behavior of the library so I suspect there's something wrong in your code. \n. I don't see any RxPermissions code in your gist.\n. Your code in `CommonUtils` about RxPermissions is completely wrong, you need to learn more about asynchronous programming and how RxJava works.\nLook at the code in the sample app and follow it.\n\nI close the issue because it's not related to RxPermissions.\n. And good luck :)\n. I redirected you to the sample app, do the same and it will work.\n\nSorry I don't have the time to explain.\n. I think Nougat is not enough to enable Java 8 features, Jack compiler must also enabled as well.\n. Good catch\n. But undoable since the transformers are parametized.\n. Thanks but you need to fix and update the tests.\n. The feature has been suggested and approved in #68  :)\n. From https://developer.android.com/training/permissions/requesting.html\n\n> To help find situations where the user might need an explanation, Android provides a utiltity method, shouldShowRequestPermissionRationale(). This method returns true if the app has requested this permission previously and the user denied the request.\n> \n> Note: If the user turned down the permission request in the past and chose the Don't ask again option in the permission request system dialog, this method returns false. The method also returns false if a device policy prohibits the app from having that permission.\n\nSo in your case, the first time the user denied the request, the method should return true. Unless you have a device policy which prohibits the app from having the camera permission, or unless there's something wrong in your implementation (but didn't find what).\n\nOther thing, I think you should check if permission is granted first, because in that case it's possible that `shouldShowRequestPermissionRationale` returns false.\n. That's weird because that's not what the documentation say...\n\n> This method returns true if the app has requested this permission **previously** and the user denied the request.\n\nMoreover on my app I get the expected result by invoking that method _after_ I request the persmissions (I use `RxPermissions.shouldShowRequestPermissionRationale()`)\n. The behavior you described for _after the permission_ sounds correct to me, and fit the documention. Is it what you experienced with your case ?\n. By doing it _before_ we break what most users will expect from that value.\n\n@vanniktech So you want to know when the user has clicked on \"Never ask again\", that's simple, the code below should work with the _after_ way : \n\n``` java\n.subscribe(permission -> {\n    if (permission.granted)  {\n      // All good\n    } else if (permission.shouldShowRequestPermissionRationale)\n      // Denied permission without ask never again\n    } else {\n      // Denied permission with ask never again      \n      // Need to go to the settings\n    }\n  });\n```\n\nThat's currently what I do in my app and it works like a charm.\n. @tarasantoshchuk \n\n> also we should rename Permission#shouldShowRequestPermissionRationale to something like Permission#deniedForever. This way the meaning of the field will be obvious for user.\n\nI disagree, by keeping the name we don't have to maintain an extra documentation. Users should know about `shouldShowRequestPermissionRationale`.\n. @vanniktech \n\n> If you just pressed the deny button and checked \"don't ask again\" I don't want to navigate the user into the settings. However if the user comes back and then presses that button and the Android Dialog can't be shown anymore since the user pressed \"don't ask again\" then I need to navigate the user into the settings.\n\nWhy having a separate behavior between the first time the user denied with \"don't ask again\" and the second time ?\n\nBoth time you should display a snackbar or something like that, telling him he has to go to the settings if he finally changed his mind, with a button that brings him to the settings.\n. > Maybe both values should be taken into permission. The value before asking the permission and the value after the user did that.\n\nNope I don't want that. The expected behavior according to the android documentation is to invoke `shouldShowRequestPermissionRationale` after a request, not before. Moreover this will be horrible with variable name like `*before` and `*after`.\n\nYou'll have to add extra code in your app to handle your case.\n. I read your sample code again, and even with the _before_ way, I'm not sure this will fit your need because `shouldShowRequestPermissionRationale` can return false in 3 cases : \n- user clicks on never ask again\n- permission has never been asked\n- permission is already granted\n\n``` java\nrxPermissions.requestEach(Manifest.permission.CAMERA)\n  .first()\n  .toSingle()\n  .subscribe(permission -> {\n    if (!permission.shouldShowRequestPermissionRationale) {\n      // Need to go to the settings\n      // Or the permission has never been asked\n      // Or the permission is already granted\n    } else if (permission.granted) {\n      // All good\n    } else {\n      // Denied permission\n    }\n  });\n\n})\n```\n. I merged your PR but moved the `shouldShowRequestPermissionRationale` invocation after the `requestPermissions`. Thanks for the contribution.\n. I don't understand why there's an infinite loop, but I see something wrong in your code. \n\nIn the first `flatMap` you shouldn't return `null` but `Observable.empty()`. But actually you don't even need the `switchEmpty` operator, just return `locationUpdatesObservable` instead of `null` in the first `flatMap`.\n. ``` java\n.filter(granted -> granted)\n```\n. In case of deny, the chain stops at the filter. There's probably something else in your code that requests the permission again and again.\n. Closed for no activity\n. Please remove .DS_store file\n. > Anything that is stopping this?\n\nNo, I wanted to find the time to review with a minimal knowledge of rxJava2, but I'm very busy for the moment. Let's merge it and see what's coming.\n. I knew I missed something, the package name didn't change. It should be `com.tbruyelle.rxpermissions2` \n. I fixed that in `master` and `2.x` branches.\n. Possible duplicate of #46\n. #46  is now fixed, please try again with version 0.8.0\n. There is `RxPermissions.isGranted` method that calls internally`ContextCompat.checkSelfPermission` but it doesn't return an `Observable`, so you have to do it yourself.\n\n``` java\nObservable.just(RxPermissions.isGranted(...))\n```\n. Ok I see. What's the benefit of such feature ? \n. I don't see how the permission could be revoked at runtime. When you revoke a permission for an app in the settings, the app is killed by the framework.\n. By design, the process of permission request is hard-linked to the `Activity` (sadly like too much things in the Android framework). \n\nWhat you could try is sharing a subject between your activity and your data layer, observe that subject in the data layer and feed it in the activity when a permission is granted. Not sure if it's possible that said, I don't know your achitecture.\n. And sharing a subject is probably over-engineering. \n. Well, I think we have to move forward about this issue, and this is probably the simplest way. Thanks for the contribution.\nI would like to have review from people involved in #46, @tarasantoshchuk ? @artesa ? @NitroXenon ? WDYT?\n. I think finally I'm going to accept @tarasantoshchuk's PR (#53) because it's more accurate. Sorry for the very long delay... I'll probably merge it on monday.\n. Please join a screenshot, I don't understand.\n. Should be fixed since we don't use an activity any more for requesting permission.. Because it would be cumbersome to start an activity just for that. I only need the activity as a parameter, I don't need to catch the activity result like `request` or `ensure`.\n. > 0.8.0 needs rxjava 1.x version, while 0.8.1 needs rxjava 2.x version.\n\nNot really. RxJava version is handled by the package name.\nfor RxJava 1.x use `compile 'com.tbruyelle.rxpermissions:rxpermissions:0.8.0@aar'`\nfor RxJava 2.x `compile 'com.tbruyelle.rxpermissions2:rxpermissions:0.8.1@aar'`\n. `rxPermissions.request(Manifest.permission.CAMERA).subscribe()` compiles. \n. > I guess I need to include the rxJava itself as a dependency?\n\nNo, that's not required, Gradle do it for you. Package changes between RxJava1 and RxJava2, that's probably why you get this error.\n. You can also have this kind of exception if you don't follow the library guidelines.\n. We can't emit an error precisely because we can't find the subject for the requested permission.\n. Your code seems to gather all conditions to trigger the biggest flaw of this library : configuration change handling. As you read in #3 there's no workaround, so we have the choice to follow the guidelines or to stop using `RxPermissions`.\n. Not relevant\n. Sounds cool. Can you explain what the benefit of using a retained fragment, and what are the rotating screen issues you fixed ?\n. Fine, I have to do some tests. \n. Sorry for the delay. \n\nI briefly started some tests and first of all I got a crash in the sample app, when I return to the sample app after tweaking the app permissions in the settings. `RxPermissions.getInstance` returned null so a NPE raised. \n\nIt seems there's a bug in the  `newInstance` detection.\n\nTo reproduce : \n- open the Sample app\n- Open the settings and go to applications>RxPermissions Sample>permissions and update the permissions\n- return to the Sample app -> crash\n. Ok since you moved the subjects list in the fragment, there's no need to have `RxPermissions.onRequestPermissionResults()`, everything can be done in the fragment if I'm right.\n\nI'm still testing.\n. Another issue, if you invoke `requestEach` directly in your activity `onCreate`, there's a crash because `RxPermissionsFragment.getActivity()` returns null. It seems the fragment is not yet attached to the activity at this time (aahh that's why I love fragment...)\n\nTo reproduce, change the sample app `MainActivity` like that : \n\n``` java\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        final RxPermissions rxPermissions = RxPermissions.newInstance(this);\n        rxPermissions.setLogging(true);\n\n        setContentView(R.layout.act_main);\n        surfaceView = (SurfaceView) findViewById(R.id.surfaceView);\n\n                rxPermissions.requestEach(Manifest.permission.CAMERA)\n                        .subscribe(new Action1<Permission>() {\n                                       @Override\n                                       public void call(Permission permission) {\n                                           Log.i(TAG, \"Permission result \" + permission);\n                                           if (permission.granted) {\n                                               Toast.makeText(MainActivity.this,\n                                                       \"Camera permission granted\",\n                                                       Toast.LENGTH_SHORT).show();\n                                               releaseCamera();\n                                               camera = Camera.open(0);\n                                               try {\n                                                   camera.setPreviewDisplay(surfaceView.getHolder());\n                                                   camera.startPreview();\n                                               } catch (IOException e) {\n                                                   Log.e(TAG, \"Error while trying to display the camera preview\", e);\n                                               }\n                                           } else if (permission.shouldShowRequestPermissionRationale) {\n                                               // Denied permission without ask never again\n                                               Toast.makeText(MainActivity.this,\n                                                       \"Denied permission without ask never again\",\n                                                       Toast.LENGTH_SHORT).show();\n                                           } else {\n                                               // Denied permission with ask never again\n                                               // Need to go to the settings\n                                               Toast.makeText(MainActivity.this,\n                                                       \"Permission denied, can't enable the camera\",\n                                                       Toast.LENGTH_SHORT).show();\n                                           }\n                                       }\n                                   },\n                                new Action1<Throwable>() {\n                                    @Override\n                                    public void call(Throwable t) {\n                                        Log.e(TAG, \"onError\", t);  // <--- crash is reported here\n                                    }\n                                },\n                                new Action0() {\n                                    @Override\n                                    public void call() {\n                                        Log.i(TAG, \"OnComplete\");\n                                    }\n                                });\n}\n\n```\n. Np, the PR is promising, I hope it can remove the biggest drawback of the library : having to subscribe during the init phase.\n. Sure, for the moment I try to find the time to complete the tests, sry for\nthe delay.\n\nLe jeu. 10 nov. 2016 23:21, Eduardo Alejandro Pool Ak\u00e9 <\nnotifications@github.com> a \u00e9crit :\n\n> @tbruyelle https://github.com/tbruyelle let me know if you need any\n> change for this PR please.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/pull/91#issuecomment-259824931,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAFoePlWgTPju5O_3IhVzurULi_PH1acks5q85jKgaJpZM4Km2OR\n> .\n. I completed some tests about config change and it's ok. \nNow I'm worried about the breaking change you introduced by removing the hability to get the singleton instance of `RxPermissions`. Is it really necessary ?\n\nOther subject, the changes need to ported also in the `2.x` branch, and that's a boring job.\n. > I can rollback the renaming from RxPermissions.newInstance(activity) to RxPermissions.getInstance(activity)\n\nThat would break the contract because as you said it's no more a singleton. I prefer to have a simple constructor rather than `newInstance`.\n\n> Regarding 2.x I can create a new branch from 2.x, apply these changes on that branch and create another PR against 2.x branch.\n\nGreat, let's do this. Thanks in advance\n. Well I'm not sure, wdyt? \n. Ok let's merge it\n. Ready in version 0.9.0 (not 0.8.3 because of the breaking change)\n. And thanks for the awesome work!\n. > Permission is banned in android 5.1\n\nWhat do you mean  ?\n. Closed  no feedback from op. You can use `requestEach` which emits similar results but returns an observable rather than a transformer. See the readme just before the _Important read_ section.\n. It seems to be something linked to your fragment usage, not RxPermissions.\n. Closed no feedback from op. I updated to 1.2.2 and so far so good c8e57f063785202d033f4ae47e833bfcc4c80a84\n. I've just uploaded version 0.8.2 with rxJava 1.2.2 dependency if you want to check\n. Thanks for the PR but the problem is now probably fixed in version 0.9.0, where we don't use activities any more. Could you check ?\n. Well sorry but as `requestPermissions()` is a method attached to an `Activity` (and not a `Context`) I don't feel bad about requiring an Activity for the constructor argument.\r\n. Closed no response from op. Thx @epool. I'll fix the README.. You have the problem only when debugging?. When you request the permission, `onPause` is executed in your activity, do you execute specific code in there?. Ok, @epool do you think it could come from the fragment ?\r\n\r\n@ersin-ertan Can you check if you have a similar behavior with version 0.8.2 please ? You'll have to change `new RxPermissions(this)` with `RxPermissions.getInstance(this)`.. Fine, so problem solved ?. > I wouldn't think so, but I'm not sure what you as a library developer could do to prevent this problem.\r\n\r\nYes, that's what I mean by 'problem solved'\r\n\r\n> Having the noHistory option is important for some apps, would you know of any possible solutions?\r\n\r\nNo idea but I found this on stack : \r\nhttp://stackoverflow.com/questions/35151233/requesting-android-m-permissions-from-activity-with-nohistory-true-and-or-show?rq=1. \"Always ask\" ? Where is that setting ?. Sorry but the library won't support this kind of manufacturer custom dev.\n\nLe jeu. 24 nov. 2016 14:57, Liverm0r <notifications@github.com> a \u00e9crit :\n\n> Yes, If I set \"allowed\" or \"refused\" the behavior is as it should be.\n>\n> \u2014\n> You are receiving this because you commented.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tbruyelle/RxPermissions/issues/100#issuecomment-262781775>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAFoeIrIzPF74sKLeE949zSbIlKz6kiYks5rBZe9gaJpZM4K5jgx>\n> .\n>\n. It is lightweight, it requires no declaration in manifest, it fixes a small ui bug.  What's your opinion about that ?. That said @epool, is it possible for you to apply the change in the `2.x` please ?. No need to be sorry, thanks!. You're not the first and I'm sorry.\r\nThat said I don't understand why you perform something that can lead to an UI interaction in a Service.. > @vanniktech @epool You should almost always be using the support library Fragments\r\n\r\nIn theory that makes sense but having the support library as a dependency in a library project can be a PITA for some users.. > Well, basically I have an ongoing location sharing service. And if a user goes to the app's settings and disables the location permission, I want the app to prompt the user to re-enable the location permission\r\n\r\nThanks I understand, but where does the request permission dialog appear when you request a permission from a Service ? I mean, if you are in an different app, the dialog appears in front of it ?. Well I'm pretty sure it's not something that Google would approve XD.. IMAO the best way is to pop a notification indicating the permission change, the notif click launches an activity explaining why the permission is required and allow to request again.. @epool ping, did you find the time to work on the 2.x branch ?. You have to use `ensureEach`, which provides more information. In particular it gives you the result of `shouldShowRequestPermissionRationale`.\r\nCheck the readme.. Gn\u00e9?. I'll add the missing tag. About the 2.x branch, @epool is working on it, thanks to him.. Cause I didn't switch to rxjava2 yet in my projects. The 2.x branch is not something I planned.. Well this bug is hard-boiled. We had it in the past and did ugly fixes to remove it. I really though it won't come back since we use a fragment and not an activity. But the Android framework is definitively not a good friend. \r\n\r\nI'll commit a fix to ignore the crash, because now I'm tired.. Fixed in version 0.9.1. Well the less ugly way would be to move that methods static...\r\n\r\nIs it very annoying to do it yourself ?\r\n\r\n```java\r\nObservable.just( context.checkSelfPermission(p) == PackageManager.PERMISSION_GRANTED ) \r\n``` . Ok, I'll wait your PR to see.. Version 0.9.1 fixes that exception.. Great job thank you. \r\n(Ping @epool : job done ^^). There's no need of static method for that.. I'll fix the README. @epool Any idea ?. Closed because no response from op. Please provide the code, sry for the delay. Reopen the issue at the same time.. Since we use a fragment to request the permission, `RxPermissions` now needs an activity.\r\nIt may be a constraint, but an activity is also needed if you request the permission with the core methods.\r\n\r\nAbout your problem with Dagger, I suggest to create an other module in your activity, or to remove `RxPermissions` from injected dependencies, and create it manually.. Try `rxPermissions.request(Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE)`. \r\nYou will receive a compiled result of user answers.\r\n\r\n. You can't merge 2.x and master branches. One is dedicated to Rxjava2 and the other to Rxjava1.. Why did you change the author ids ?\r\nWhat is the purpose of that PR?. Please create a clean PR with the only the changes you want. I close this one for now.. No you can't, `shouldShowRequestPermissionRationale()` is an `Activity` method.. Thanks a lot for this change and for the explanations :). 0.9.3 has been upload for master and 2.x branch.. Dup of #142 . Yes it makes sense, I thought about that too but it would introduce a breaking change without real benefit (`Single` class didn't exist when I started the library).. Ow I think there's a PR for that... #121 . You probably do something wrong with your fragment usage to have this exception, anyway, version 0.9.2 now perform `commitAllowingStateLoss`.. Just added the tag v0.9.3. About the change log I'm sorry for the moment I don't have the time to maintain it.. I dont think `RxPermissions` is currently not compatible with the Support lib.. I know that, but that doesn't mean the lib isn't compatible with the support lib.. So is there good reason to use the support library ?. No you can use it in a fragment. Write the error handler to catch the\nexception and report it please.\n\nLe jeu. 23 mars 2017 \u00e0 03:07, naivor <notifications@github.com> a \u00e9crit :\n\n> When i use RxPermissions in Fragment,i get a exception, the log is\n> rx.exceptions.OnErrorNotImplementedException: xxx\n>\n> Is RxPermissions can only use in Activity?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tbruyelle/RxPermissions/issues/130>, or mute the\n> thread\n> <https://github.com/notifications/unsubscribe-auth/AAFoeK5sppco3QY6u98EESRkkOVha01qks5rodPUgaJpZM4MmEZr>\n> .\n>\n. You should force the version 0.9.3 for the library. . There's possibly a breaking change between 0.7 and 0.9.3. You have no other choice than trying  to update the library code.. Thank you for the replies, I close the issue. Sounds legit, please submit a PR and I'll merge it.. The lib is there https://bintray.com/tbruyelle/tbruyelle/RxPermissions2/0.9.3, maybe jcenter had connectivity issues during your attempt. Please try again and let me know.. Didn't understand what's your problem.. It's in the README, use `requestEach/ensureEach` to have a detailled object of what happened during the permission request.. This is the normal behavior. If the user has clicked \"never ask again\" and if the permission is critical for your app, you have to invite the user to go to the settings and to change manually the permissions of your app. There's no other alternatives.. Thanks for the PR, I will have time to review it at the end of the week. Stay tuned.. Ty!. 0.9.4 contains the PR. Fragments are really a plague !. Sorry I have no idea, community pushed me to use fragments for this lib (originally it was an Activity), and I finally accepted but I regret. I don't use fragment from ages, so sorry I can't help you.. This lib doesn't handle Xiaomi specific permission system.. Ty!. Didn't understand your first point.. I disagree. From the android doc : \r\n\r\n> You should do this only if you do not have the permission.\r\n\r\nhttps://developer.android.com/reference/android/app/Activity.html#shouldShowRequestPermissionRationale(java.lang.String). > firstly , the \"isGranted\" is true , and then the phone show the permission dialog\r\n\r\nNo. The `Action1` is only invoked when user has answered all permission dialog requests.. Why do you have a Samsung you're a developer isn't it ? xD. Yes that's strange, it's the first time someone raise me this kind of issue. I don't think it's the first time the library is used on a S7.\r\n\r\nThis only occurs the first time you request the permission ?. So it's when the dialog appears, maybe Samsung broke something in the lifecycle during this process.\r\nAre you sure you perform the `request` in an initialization phase ?. Do you request inside a click listener ? If yes it's not an initialization phase and you will have the same problem on any device if you rotate the screen while the permission dialog is shown.\r\n\r\nTry to follow the example in the README : \r\n\r\n```java\r\n// Must be done during an initialization phase like onCreate\r\nRxView.clicks(findViewById(R.id.enableCamera))\r\n    .compose(rxPermissions.ensure(Manifest.permission.CAMERA))\r\n    .subscribe( ... )\r\n```. @lopspower so did you fix the issue with my last comment ?. Gne. Please read the README and look at the sample project, you would find out.. Why?. Details?. It seems you use the wrong version, `Flowable` is part of `rxjava-2`. Use `com.tbruyelle.rxpermissions2:rxpermissions`. The API already provides the hability to pass multiple permissions in the arguments.\r\n\r\nAbout the Android O Permission changes : https://developer.android.com/about/versions/oreo/android-8.0-changes.html#rmp\r\n\r\nI don't think there's something to change in this library for that. WDYT ?. It's rxjava1 on `master` branch, and rxjava2 on `2.x` branch.. I don't know is this required for APACHE2 license ?. @dsaff @nmulcahey thank you guys, I've just added it to the README.. No you can't. Dup of #142 . No, I don't want to add complex features like that.. This may be a bug that occurs only on some manufacturer OS. Sorry I can't do anything for that.. Speak english please. Is it something new ? Can you link me the doc please ?. Ok there's nothing new, the lib already handles `shouldShowRequestPermissionRationale`.. > If needed, here's a class that has all the groups and their permissions:\r\n\r\nIs it a class from the framework ?. Well it should be !\r\nYou can create a PR on this if you want.. That would be nice, but this requires to maintain the list carefully, for instance when a new permission is added to the framework ?. OK fine.\r\n\r\n`@StringDef` is an android feature, why didn't they add this on their own permission definition, that's a shame.. The library won't handle it.. There's no such bug in the library.\r\nDont forget to declare the permissions in your manifest.\r\n. Thank you !\n. Thanks it's more clean\n. Well it was something I expected, because I totally neglect lifecycle handling... until now :)\nI will try to find a solution.\n. OK it will be hard to fix that problem properly. \n\nRxjava and activity/fragment lifecycle have been discussed a lot and as far as I know there is no clean solution. \n\nWe can easily prevent the crash by making `RxPermissions` a singleton, so after the rotation change and the user answers to the permission request, the corresponding subject is found. But when the lib emits the response, the observer is still linked to the old activity, so it has no effect to the current new activity.\n\nThe main problem here is we have _rebind_ the subscription in the newly created activity, after the rotation change. This can be done manually by the user, he unsubscribes when the activity dies and resubscribe when the new activity pops. But I don't like that since it adds too much code for the user.\n\nIf someone has a good idea, it would be pleasure to hear.\n. Wow thank you all for taking your time to give help.\n\nAbout making `RxPermissions` survives the activity lifecycle, a simple singleton seems good enough (I tested that in a [branch](https://github.com/tbruyelle/RxPermissions/compare/lifecycle)).\n\nAs @dlew and I said, the main problem is really to _rebind_ the subscription after the death/rebirth of the activity, and I'm more and more convinced this is not possible easily. The main goal of this library is to keep things simple and to provide `Observable`s. So I start to think about trade-offs.\n\nWhen you request a permission, the framework starts a activity called `.permission.ui.GrantPermissionsActivity` (I saw that in logcat), this activity shows a dialog and survives the rotation change. But if it doesn't survive, there is no more issue ! The user will have to re-trigger the permission request, but I don't think this is really embarrassing.\nSo the question is, can I alter that activity's lifecycle, or maybe more plausible ask it to kill itself when I detect the rotation change ?\n\nWDYT ? \n. Just release a new version 0.2.0 : \n- `RxPermissions` is now a singleton gettable with `getInstance(Context)`. This fix the crash.\n- Add an internal activity to handle the `onRequestPermissionsResult` so it's no more needed to override this method in the user acitivity.\n\nThat said, the problem about detached subscriber on rotation change is still there.\n. @domsu Yeah this is something to which I already thought, and this is easy to implement with RxJava. We just add a `doOnSubscribe(lock)` and a `doOnTerminate/doOnUnscubscibe(unlock)` to the observable.\n\nBut it can be intrusive, maybe we could make it optional ? As you said it's not a good pattern, but if it shock anyone, I'm ready to implement it, as a recommended option. \n. @andaag Yep I agree. So 2 solutions, put the project to the trash or add hacky trade-offs...\n\nI prefer the solution 2 because for me the project brings more good than harm. \n\nit doesn't bother me to lock the rotation during the permission request. And if for some rooted devices it's not possible to lock the rotation, the users will have to request the permission twice, this doesn't matter.\nFor other configuration changes, like language change, same thing. I mean, it's not very common that a user changes the language while an app is requesting a permission.\n\nBy explicitly warning the library's users of these trade-offs, I think we can move forward.\n. @dlew Actually with the shadow activity introduced in version 0.2.0, we have such tool ! Nice. \n\nAbout 3, I have no control on the runtime permission request (other than create a new one), I can't cancel or resume it. The permission request is resumed automatically after a configuration change. \n\n#### Anyway, a solution begins to take shape :\n1. **a permission request is triggered** : `RxPermissions` registers a subject associated with that permission and requests the framework : the runtime permission popup appears.\n2. **a configuration change occurs** : `RxPermissions` unsubscribes all registered subjects, but keeps in memory the pending requests. It will survive the configuration change because it's a singleton since 0.2.0.\n   The runtime permissions popup is paused and will be resumed automatically.\n3. **the app restarts** : The permission request is redone by the app (this is actually the only requirement, but as @dlew said it's a logical outcome), `RxPermissions` _remembers_ a pending request has been done for this permission, and registers a new subject for it, **but** doesn't request the framework a second time (otherwise the result would be another runtime permissions popup).\n   The runtime permissions popup is resumed and displayed again.\n4. **user answers to the permission request** : `RxPermissions.onRequestPermissionsResult` is invoked, the lib finds the corresponding subject and emits the user response. \n\nThat sounds not bad...\n. Interesting, but I'm not sure to understand how things are connected together.\n. Nice, please link the library when it's ready. \nAbout the name, sorry I have no idea.\n. I pushed a PR #14 that aims to fix the issue. I would appreciate if some of you review it.\n\nThe fix removes some flexibility to the lib but I didn't find anything better.\n\nThe good news is for clients who request the permission during activity/fragment/view start, nothing change, it will  work as these.\nFor client who request the permission after a particular event, there is some breaking changes :\n- Firstly, they need to move the request call in one of the activity/fragment/view start method.\n- Secondly, they need to add an extra parameter to the `request` or `requestEach` method : an `Observable` that represents that particular event. See the PR for details.\n\nExample from the sample app, the click event is transformed to an observable with `RxBinding` :\n\n``` java\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.act_main);\n\n         // com.jakewharton.rxbinding.view.RxView is perfect to represent the event needed\n        Observable<Object> trigger = RxView.clicks(findViewById(R.id.enableCamera));\n\n         RxPermissions.getInstance(this)\n                .request(trigger, Manifest.permission.CAMERA)\n                .subscribe(granted -> {\n```\n. @andaag Thanks for the help but I think I found a solution which bring less changes on the client side.\n. > For just glancing at the code, I'm guessing your using the permission itself as an identifier for the request? That means you can only request a permission from one place in the app. If you want the camera permission in 3 different places your gonna need another identifier.\n\nI think it should work. From the beginning the lib has been designed with concurrent access in focus. For instance, if there's 3 camera permission requests from 3 different places, the same observable is returned to the subscribers. So when the user's answer is caught, all subscribers will receive it. \n\nThat said, if the requests are done very simultaneously, it won't work as expected since I forgot to use `synchronized`... That's another small improvement.\n. I uploaded a snapshot version\n\n``` gradle\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.4.0@aar'\n```\n. @andaag I tested a little more and it works also if you make the permission request in `View.onFinishInflate` or any methods invoked during the app initialization.\n\nSo you're not limited to `onCreate`/`onResume`.\n. > you never remove anything from mSubjects it'll leak.\n\nWhen the lib receives the permission request answer, the subject receives `onComplete` which unsubscribe all subscribers, and is removed from the list.\nhttps://github.com/tbruyelle/RxPermissions/blob/lifecycle-handling/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L274\n. Yes you're right, I probably should make `RxPermissions.onDestroy()` `public`, to unsubscribe all subjects.\n. @andaag Thanks for the report, I noticed that bug last friday. The issue is due to the `take(1)` which prevents the trigger observable to emit more than one item. I removed it here 2455bcf21d5ac9adc82e6f89786d6de2a085b89c but now I have to fix the `request` method which doesn't work any more. \n\nIndeed, `take(1)` was here to ensure the sequence was completed, this is mandatory because `request` use `toList()` to transform the original sequence to a single boolean (`toList()` requires completed sequence or else it emits nothing).\n\nI have an idea of the final fix, I'll publish it today.\n. So version 0.4.1 brings some other fixes, including the one mentioned by @andaag \n\n``` gradle\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.4.1@aar'\n```\n\nI think I'll soon merge the PR #14 \n. Good point. \n\nDo you know if there's relation between `PackageManager.checkPermission` and `Context.checkSelfPermission()` ?\n\nMy first attempt to fix thgis issue is to check `PackageManager.checkPermission` only pre-M but I have a doubt, maybe I should check it for all versions ?\n. @ffgiraldez Yes I saw that but I didn't use it to prevent an external dependency and also because I thought it's easy to implement.\n\nBut I wasn't aware of the `PackageManager.checkPermission` thing. I would like to see the source of `ContextCompat.checkSelfPermissions()` but it seems it's not released yet (https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/content/ContextCompat.java)\n. [`ContextCompat.checkSelfPermissions()`](https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/content/ContextCompat.java#L382) is now visible, but there is no call to `PackageManage.checkPermission()`.\n. Closed because no idea of what to do here\n. It depends on the usage. Most of the time I think people only want to know if the user has granted all the requested permissions. So a simple boolean is enough.\n\nThat said, your proposal is good. What if we add another method to the API, let's say `requestDetailed()` which returns an `Observable<Map<String,Boolean>>`  ?\n. I'm not sure about the map thing. Are you saying the method should return `Observable<HashMap<String, Boolean>>` rather than `Observable<Map<String, Boolean>>` ?\n. Yep agree with @alorma. \nUntil now I never heard of that kind of rule. And in this library's context, I don't see any benefit for the consumer to explicitly know the concrete type of the `Map`.\n. Not silly at all, but interesting. This is absolutely feasible with RxJava.\n\nIf I'm right,  `permission.shouldRequestAgain()` is related to `shouldShowRequestPermissionRationale`. I started a basic support for this method in #8, but implemented it differently. I chose to create a independent method so you can mix the observables, like [here](https://github.com/tbruyelle/RxPermissions/pull/9/files#diff-dd59e011627697b372d3b0429739ae71R35).\n\nwhat is the way you prefer ?\n. Yes there is less code in theory but what do you do mostly if `shouldShowRequestPermissionRationale` returns `true` ? \nYou show the user an explanation with a dialog and once he agrees, request the permission a second time. That's why I did it like that. \n\nThat said, I'm not 100% sure this is the best way.\n. I just create that PR, please tell me if this fits your needs. \nPlease comment on the PR.\n. Released in version 0.3.0\n. Thank you for your time, I started a similar feature in a [branch](https://github.com/tbruyelle/RxPermissions/compare/shadowActivity), and actually it doesn't solve the problem.\n\nTake the sample app, remove previously granted permission, run it and click on the button. Then if you rotate the device while the permission popup is displayed, and grant or deny the permission, nothing will happen. This is because the function attached to the `Observable` is linked to the destroyed activity, and it has no effect to the new one.\n\nThe main problem is really to _rebind_ that function from the destroyed activity to the new one. And I'm not even sure it's possible.\n\nThat said, I like the invisible/shadow activity idea, so I'll probably use your PR later, and merge it with my branch.\n. > I think that this library should not be concerned with managing the observable for the consume\n\nYeah you're probably right, but I'm disappointed because this will complicate a lot the usage of the library.\n. Implemented in ef4aed66a57c52f06b9679c2acac376a7d62c433\n\nThanks anyway\n. Thanks\n. Good point\n. I created a PR with a basic support, wdyt ? \nPlease comment on the PR.\n. Released in version 0.3.0\n. Yes we need to fix #3 to have a stable release.\n. The screen rotation is only the visible part of the iceberg, we need to handle every configuration changes.\nSo no, locking the rotation change in your app is not enough.\n\nHowever, since 0.2.0, there is no more crash, but the `onNext`'s code you registered before the configuration change will never be executed.\n. Thanks for the compliment ^^ \nI hope we will find a proper solution.\n. Well I'm not sure to see the benefit also. \nPlus I hate fragments.\n. (@digitalbuddha That's also what I did with my job's app. Now I use only activities and views, and I feel better. No more weird exceptions and other horrible things.)\n. Good point @andretietz, and I've just noticed that `Fragment` have also a `onRequestPermissionResult` method. So it seems feasible, and would probably has a smaller footprint than the activity.\n. I'm working on #3 currently, so feel free to send a PR if you can. That would be nice, thanks in advance.\n. @richarddd thanks for that\n. Closed for no activity\n. This is code generated by Android Studio, I hope it's correct :D\n. The goal of `RxPermissions` is not to handle `onActivityResult`. Maybe you could create an other library for that.\n. ok, first you don't need to check the sdk version, it's handled by the library. If `Build.VERSION.SDK_INT < 23`, the observer will immediately receive a granted result.\n\nSecondly, it seems you're not well informed about runtime permissions. Only a  part of the permissions requires a request : the dangerous ones, as Google names them [1]. \n\nAbout the crash itself, I think it's exactly because you request permissions that don't need to be requested. Try to filter the parameter list with only _dangerous_ permissions and it should work.\n\nThat said you pointed a weakness in the library that needs a fix. Thanks !\n\n[1] https://developer.android.com/guide/topics/security/permissions.html#normal-dangerous\n. After some tests, there is finally no issue in requesting non-dangerous permissions, but the framework will always answer the permission is not granted. The answer is propagated without change by the library.\n\nCould you tell me if you still have the issue with the last version of `RxPermissions` ?\n. Closed for no activity\n. No, the `minSdkVersion` to use this library is 9\n\nI will add that in the README.\n. What do you want me to check ? `mCtx.checkSelfPermission(permission)` is not even a call to this library.\n. I know I use it.\nThe method `hasPermission_` is only called if current sdk is >=23.\n. > if targetSdk is not 23, permissions dialog is always not showing .\n\nFair enough since runtime permissions are only available for target 23.\n. Thanks!\n. As you can see, this method is not public. It's invoked internally by the `ShadowActivity`.\n\nI document only the public API.\n. Interesting. The documentation I found [1] on `@RequiresPermission` doesn't tell how it works, so I can't figure out how to handle that.\n\nI'll try to look further.\n\n[1] http://tools.android.com/tech-docs/support-annotations\n. No sorry, I didn't.\n. Thanks for the report. \n\nI also read that post, and unlike `ActivityCompat`, `RxPermissions` doesn't delegate the permission request to `PackageManager` but returns true immediatly. So this issue is already handled.\n. No problem\n. Because I'm lazy. Maven central needs more than just an aar.\n. That would be nice\n\nLe lun. 23 nov. 2015 18:28, Saad Farooq notifications@github.com a \u00e9crit :\n\n> Got it... will try to put up a PR when I get the time\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/21#issuecomment-159003300\n> .\n. Thanks @eleventigers \n\n@martyglaubitz if you're OK with the implementation, please close the issue.\n. I discover this method, it sounds very similar to `shouldShowRequestPermissionRationale()`.\n\nI don't know if it should be implemented in the library, the only benefit in that case would be to handle the sdk version.\n. Fixed in 0.5.0\n. Very clean PR thanks !\n. Is there a reason why you used variadic parameters in `isRevoled` ? (other than replicating `isGranted`'s signature)\n\nI'm asking you that because in the current code state there's no good reason to use variadic parameters for both `isResolved` and `isGranted`. I would like to change that and use a standard parameter, a permission.\n. I will :)\n. 0.5.0 deployed with your PR and without variadic param.\n. 1. It prevents to leak an `Activity` if the user passes that kind of class in the method invocation.\n2. What do you mean ?\n3. Not planned, I'm not sure of what benefits can bring a Kotlin version of the library.\n4. What are you talking about ? Please detail.\n. 1. I know RxLifecycle, but I don't see the benefits of an integration with RxPermissions.\n2. Support lib hides the result of version check, whereas I need the information to feed the `Observables`. The lib manipulates `Observables`, Support lib doesn't. \n. Could you make an unique PR with the version upgrade and the fix on subjects ?\nYou can push that [commit](https://github.com/PavelSynek/RxPermissions/commit/201ded6014d1bda43be84e0d184f917cf928561f) into your branch `rxjava110` and close #26. That should be ok.\n\nThanks in advance\n. No need to squash thx\n. Of course, but you have to do it yourself.\n. No I don't want to add this kind of feature in the library. I don't want UI dependency.\n. If I need to show an explanation before ask permissions, I would show a dialog with the explanation and trigger the permission request on dialog dismiss.\n. Already fixed in #24, but I need to release it. I will do it asap,\n. 0.5.1 released, it should fix your problem.\n. If you use Android Studio, type `new Ctrl+Space` and it will suggest the correct class to implement.\n. Ok I removed retro lambda usage from the sample app.\n. Done\n. Well, I also use the library to request multiple times a critical permission, but I don't have the problem you describe. That said I'm not using those damned fragments.\n\nRather than removing the `onDestroy` content, could you try to wipe the subject list at the end of `RxPermissions.onDestroy()` :\n\n``` diff\n void onDestroy() {\n        log(\"onDestroy\");\n        // Invoke onCompleted on all registered subjects.\n        // This should un-subscribe the observers.\n        for (Subject subject : mSubjects.values()) {\n            subject.onCompleted();\n        }\n+      mSubjects.clear();\n    }\n```\n\nTell me if it fixes your issue.\n. Oh I think I get it this time. So as you explained there's no reason why an activity started with `FLAG_ACTIVITY_NEW_TASK` propagate a `onDestroy` event to a singleton like the `RxPermissions` class.\n\nI think we can safely remove the `ShadowActivity.onDestroy` method.\n\nCould you check if it's OK for you and then open a PR ? I will try to release it quickly.\n. Sorry I'm going to reverse that change because it breaks configuration change handling.\n\nWhen you request a permission, you see the permission dialog, if before answer you rotate your phone, your app is restarted and the permission dialog pops again automatically (it's not because of RxPermissions). If you answer at this time, the rx chaining should be invoked properly, but not any more since that change.\n. Please keep `RxPermissions.onDestroy()` it can be usefull to invoke it manually.\nEnsure also the tests are passing.\n\nThanks in advance\n. Ok version 0.5.2 has been deployed to bintray with your fix. Thanks for the contribution!\n. Thanks for that, but I didn't manage to upload an artifact.\n\nFirst I fixed the package name (see 08b227cea808ca9fcf6d8b3e499c8488c6337c87)\n\nI filled my bintray user and api key, generated the pom and jar with the `install` task (maybe there's a task which do not copy the files in `~/.m2` ?), and tried to upload with `bintrayUpload` task. It returns me success but then I can't find the artifact in jcenter.\n\nIf I rerun `bintrayUpload` I got an error telling me the artifact already exists.\n\n``` sh\n* What went wrong:\nExecution failed for task ':rxpermissions:bintrayUpload'.\n> Could not upload to 'https://api.bintray.com/content/tbruyelle/tbruyelle/RxPermissions/0.5.2/com/tbruyelle/rxpermissions/rxpermissions/0.5.2/rxpermissions-0.5.2.aar': HTTP/1.1 409 Conflict [message:Unable to upload files: An artifact with the path 'com/tbruyelle/rxpermissions/rxpermissions/0.5.2/rxpermissions-0.5.2.aar' already exists]\n```\n. > The first time (and that's the step missing), you have to link your repo with jcenter, here in linked to, add to jcenter. Just fill the form and usually in a few hours will be available :)\n\nOk thanks I did'nt know that.\n\n> You can do directly a gradlew bintrayUpload and will generate the pom and jar and upload it directly.\n\nWell, I'm not sure : \n\n``` bash\n$ ./gradlew clean rxpermissions:bintrayUpload\nParallel execution with configuration on demand is an incubating feature.\nIncremental java compilation is an incubating feature.\n:rxpermissions:clean\n:sample:clean UP-TO-DATE\n:rxpermissions:clean UP-TO-DATE\n:rxpermissions:bintrayUpload:rxpermissions:bintrayUpload: file /home/tbruyelle/projects/rxpermissions/lib/build/libs/rxpermissions-0.5.2-javadoc.jar could not be found.\n:rxpermissions:bintrayUpload: file /home/tbruyelle/projects/rxpermissions/lib/build/libs/rxpermissions-0.5.2-sources.jar could not be found.\n:rxpermissions:bintrayUpload: file /home/tbruyelle/projects/rxpermissions/lib/build/outputs/aar/rxpermissions-release.aar could not be found.\n FAILED\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task ':rxpermissions:bintrayUpload'.\n> java.io.FileNotFoundException: /home/tbruyelle/projects/rxpermissions/lib/build/poms/pom-default.xml (No such file or directory)\n\n* Try:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\nBUILD FAILED\n```\n. Well sorry I'm still stuck because there's no pom/jar generated with the `bintrayUpload` task.\n\nCan you test again with the `jcenter` branch of that repo ?\n. Thank you for you time, I finally find the problem I have on my machine it's because my gradle.properties has the following feature enabled : `org.gradle.configureondemande`. If I disable it the pom and jars are correctly generated. Don't ask me why I enabled this feature, I can't remember !!\n\nSo I managed to upload the artifact to bintray and I asked a link to jcenter. Wait and see ^^\n. Ok so my repo is still not linked, this is probably because only version 0.5.2 has the requirements for jcenter linkability (pom and jar stuff).\n\nI can't delete old versions because other people may use them, so I have 2 options\n- manually add bintrayUplload functionnality to each tags (should take some time...)\n- create an other repo with only version 0.5.2 (but I'll loose all my repo stats and at next version some users will complain about missing artfiact because they have kept the original repo).\n\nShort, this is annoying... Maybe you have better idea ?\n. > I can generate the source jars for the other versions and send them to you (should be apply those commits after the tags of each version and generate).\n\nYou're nice, but that's fine thank you. I will do it if necessary. I'll wait tomorrow.\n. It's me who thank you for the contribution, I merged the `jcenter` branch so this PR can be closed.\n. Well that's weird, you get that error because the code is executed on a pre-6 version of Android. This isn't supposed to happen, in `RxPermissions` the version is checked before invoking that method.\n\nYou're not trying to start the `ShadowActivity` manually don't you ?\n. That shouldn't happen, do you see this error frequently in your crashlytics?\n. Closed for no response from submitter \n. Use last version please.\n. I'm not sure your way works when a configuration change occurs.\n\nCan you test that : \n\nAsk for a permission not granted yet with your method, see the permission dialog appear, don't answer but rotate your device to trigger a config change, then answer to the permission dialog. If ok your answer should be take into account. If nothing happen, then it means your way doesn't work.\n. Wow thanks dude I'm pleasantly surprised. I was aware of the `compose` method, I use it for life-cycle handling, but I didn't know it could be useful in that case.\n\nThat's a lot better than that ugly method signature `request(trigger, permissions)`.\n\nI will integrate that in the framework.\n. That's a little crazy but you gave me the idea to deprecate all current methods and expose only 2 new methods : \n\n``` java\n public static Observable.Transformer<Object, Boolean> ensure(final Context ctx, final String... permissions) {\n        return new Observable.Transformer<Object, Boolean>() {\n            @Override\n            public Observable<Boolean> call(Observable<Object> o) {\n                return RxPermissions.getInstance(ctx).request(o, permissions);\n            }\n        };\n    }\n\n    public static Observable.Transformer<Object, Permission> ensureEach(final Context ctx, final String... permissions) {\n        return new Observable.Transformer<Object, Permission>() {\n            @Override\n            public Observable<Permission> call(Observable<Object> o) {\n                return RxPermissions.getInstance(ctx).requestEach(o, permissions);\n            }\n        };\n    }\n```\n\nFor permissions request that requires immediately trigger (without a button), users would have to do something like : \n\n``` java\nObservable.just(null) // Too bad there's no something like Observable.always()\n     .compose(RxPermissions.ensure(this, perms))\n    .subscribe( granted -> {\n});\n```\n\nThe major benefit of that refactoring is it forces the user to use the library correctly. Indeed currently it's possible to write the following code : \n\n``` java\nbtn.setOnClickListener(v -> RxPermissions.getInstance(this).request(perm).subscribe( { ... ] )\n```\n\nBut that code doesn't handle configuration change during permission request. So by exposing only _composable_ methods, I make this impossible. What do you think ?\n\nI still have other checks to do but this sounds very promising.\n. > permissions are requested usually just before they're needed\n\nunless they're critical permissions https://www.youtube.com/watch?v=iZqDdvhTZj0\n. Fixed with #38 \n. I agree with you, I integrated your changes in a new branch where I'm trying to refactor/simplify the lib usage. Thanks for the contrib\n. Merged with #38\n. I understand your point but the major benefit of that refactoring is it forces the user to use the library correctly. Indeed currently it's possible to write the following code : \n\n``` java\nbtn.setOnClickListener(v -> RxPermissions.getInstance(this).request(perm).subscribe( { ... ] )\n```\n\nBut that code is wrong, it doesn't handle configuration change during permission request. So by exposing only _composable_ methods, I make this impossible. \n. Yes it's not impossible but in that case I think the user really looks for problems !\n\nI agree `oservable.just(null).compose(...)` is ugly, as a replacement we can provide an observable method like you suggested it but I want to make sure there's no possible mistake  in its usage. I don't like very much `requestWithoutTrigger()`, I still prefer `request`. \n. @patloew So I undeleted `request` and `requestEach` methods, but only the version without trigger. Sounds fine to you ?\n. Do you see it ? The theme used for this activity is already transparent\n. I never noticed that problem, and I tested also on N5.\n\nAre you sure it's not something due to the moment you request the permission ? I would like to have some details of your usage.\n. Well not sure if it's related to your ptoblem but you shouldn't condition the permission request with `savedInstanceState == null`. In case of configuration change, the lib won't work properly.\n\nDo you use the last version 0.6.1 ?\n. Did you move the call ouside the `if (savedInstanceState == null)` ?\n. This is already the case, I don't understand why you need to override it. Moreover Fullscreen is not necessary.\n\nhttps://github.com/tbruyelle/RxPermissions/blob/master/lib/src/main/AndroidManifest.xml#L11\n\nAnyway it works for you, fine.\n. Interesting, I missed that test. I'll look into it.\n. With \"do not keep activities\" enabled, it works with a standard config change (screen rotate for instance) but not with the steps you described.\nSo a config change doesn't kill your activity like the home button followed by back from recent app, that's frustrating. The proof is `ShadowActivity.onDestroy` isn't invoked from the framework in that second case. Without that call, `RxPermissions` isn't able to remind previous permission requests, causing the issue you created.\n\nDo you know why in that case the android lifecycle is ignored ?\n. Ok I'll move it to `onStop()` probably.\n. Released in version 0.6.1, thanks for the report.\n. I'm not sure this is relevant to request FINE and COARSE permissions at the same time. \n\nMoreover I don't see the true benefit of your change. I think this is trivial enough to ask multiple permissions without showing it in the sample app.\n. I fixed the issue, can you check if it's ok with the HEAD version ?\n. Awesome thanks !\n. The crash was introduced with 88d83bb3c07f3bd1aaa6852ce37427c9928d9860 where I moved code from `onDestroy` to `onStop`.\n\nQuick solution is to move the client code in `onStart` rather than `onCreate` but I dislike the idea. Too bad we can't rely on `onDestroy`, since this is the only method in the lifecycle where it is certain that `onCreate` will be invoked on back. With `onStop`, it can be `onCreate` or `onStart`, it depends... Android lifecycle is really a fucking disaster, so tired of fighting against it for years...\n\nI try to find an other fix.\n. Yes it's important for a feature that begin to annoy me : multiple request handling. \n\nBut I'm going to take my axe, remove that feature and at the same time some complicated code. I don't think people uses it. Even me I'm not using it any more.\n. I'm not talking about multiple requests when you provide 2 or more parameters, I'm talking about multiple requests done at the same time for the same permission in 2 different places of your code. \nSo, do you really use that feature ?\n. > I can hardly imagine a case when it could be inevitably needed\n\nI agree, I was probably drunk when I decided to handle that.\n\nI pushed a fix to master, could you check if it's ok (also if possible the last test you made about multiple permissions request ?) \n\nThanks in advance!\n. Good!\n\nAbout the last issue, I tried to reproduce with sample app, by adding a second permission to the parameter list, with DNKA on, but it worked mostly as expected (mostly because the result was delivered 2 times instead of one to the subscriber, will see if I can improve that).\n\nWhen you said _requested simultaneously_ you mean by passing more than one parameter ?\n. Done, new version is 0.7.0 since a _feature_ has been removed.\n. No of course it's not by design ^^, it's a bug, probably duplicate with #42.\n. Deployed a new version 0.7.0 that should fix that. Please check.\n. Can you post more code ? I need to understand where and when the library is invoked.\n. Why do you need a second call for the same permission ?\n. I think you should request the permission only one time.\n. Yes but it may be not possible since RxPermission had to deal first with configuration changes. \n. > If I want to deny this permission again\n\nIts up to the user to grant or deny, you have no control on that.\n. Good question, I presume no but I didn't test with proguard. Could you check that ?\n. It seems the rules are not specific to rx-permissions but more to rx-java, in that case I don't think I should document them. Users simply refer to the rx-java documentation for that purpose.\n. You're probably right, but I didn't find official documentation about proguard rules in the rx-java project. Did you ?\n. Do you answer to the permission dialog on 1. ?\n. Ok there's probably a bug but the case you described is kindy weird... Why the user would go to the settings _before_ answering the permission dialog ?\n. Can you provide a detailled stack trace please?\n. Ok I think I understand. \nWhen you update the app's permissions in the settings, your app is killed, and in that case RxPermissions doesn't save the current state, but the framework save the permission request and so restore it when the user is back.\n\nRxPermissions should probably save the state when the app is killed, and restore it after. If you have some time to develop a fix, I could merge it. I don't have the time for the moment sorry.\n. @AAverin Note that the bug affects only devices with sdk >= 23\n. @AAverin Agree I want to resolve it but until now nobody found an acceptable fix.\n. Fixed in 0.8.0\n. Your fix prevents the crash but the user response is not propagated to the subscriber, so there's still a problem.\n\nMoreover it breaks the lifecycle handling. If the user rotates the screen during a permission request, and then answers to the dialog, his reponse is also not propagated to the subscriber, because of your cancel.\n. Can you explain a little bit the steps to reproduce ?\n. Thanks, sorry for the delay I will probably check that on next week.\n. I don't see the `ShadowActivity` in the recent apps, how do you see it ?\n. Ok so you're talking about your app activity. In that case can you reproduce the case with the sample app ?\n. The library doesn't provide any UI stuff. Its up to you to code your own dialog, toast, snackbar...\n. `RxPermissions.shouldShowRequestPermissionRationale` doesn't need `ShadowActivity` because no activity results are delivered. \n\nAbout documentation, you're right the existence of the method should be mentionned in the README. About how to use it, it simply wraps `Activity.shouldShowRequestPermissionRationnale` in an observable so I invite you to read the documentation of the android framework.\nHTH\n. When the permission request is triggered by an action menu, you're right it's not trivial to implement it during an initialization phase.\n\nAlthough it's not ideal, I suggest to use a _subject_ to register the permission request during the initialization phase of the activity, and then emit an arbitrary item in that _subject_ in the menu click listener when you want to trigger the permission request.\n\nI can provide an example if necessary. Or if you find a better way to do that let me know.\n. Fine, that's also how I use it. \nI would like to provide a better way but it would require dependencies to menu listeners and things like that and so finally I prefer no.\n. Good question, I don't know. On my side I didn't reuse the subject. Not sure if it's good or bad...\n. I didn't understand \n. Close because no response\n. I use the library inside a project monitored with leakcanary and no leak\nwere detected.\n\nLe mer. 25 mai 2016 10:05, Binasphere notifications@github.com a \u00e9crit :\n\n> I didn't see unsubscribe() be called in the sample. Will the permission\n> Subjects leak the memory of Activity if I don't unsubscribe it?\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/52\n. Yep https://github.com/tbruyelle/RxPermissions/blob/4c4d4e1e84ad1fcf390342c493c8ed09b5e613ca/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L291\n. Interesting fix thanks, I have to take time to test it, but I couldn't do that before next week. I'll let you know.\n. So I updated the sample app to test your fix (see branch fix46). I added an other permission to the requested list.\n\nThen : \n- Launch the sample\n- Click on Enable Camera\n- Allow the first permission\n- While the second permission is requested, go to the settings and deny the first\n- Back to the app, and allow the second permission. At this time without your fix, I agree the app crashes. With your fix there's no crash but there's also no emission of the response to the subscriber, as you mentionned it.\n\nSo sorry but I'm not going to merge that PR, I prefer a visible crash than a ghost partial fix.\n. @artesa So you're telling me that 202 users have this strange behavior of moving to the settings and revoking a permission during a permission request... That's really weird. I suspect it's something else.\n. I understand, but this PR only hides the crashes and doesn't solve the problem.\n. @NitroXenon I have 0 with 2k of active users daily.\n. So I should have about 40 instances of this exception. What I mean is\nthere's maybe something wrong with how you use the library.\n\nLe mar. 16 ao\u00fbt 2016 02:44, Peter Chan notifications@github.com a \u00e9crit :\n\n> @tbruyelle https://github.com/tbruyelle I have 20k of active users\n> daily...\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/pull/53#issuecomment-239971503,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAFoeBwVtdnUrUp0QTs5691OynutZ3BYks5qgQfRgaJpZM4IpFBb\n> .\n. > I think the amount of crashes depends a lot on how much app uses rx_permissions lib, so you can't make extrapolations like this.\n\nThat's exactly what I mean by \"something wrong\", why your app needs to use the runtime permissions so often ? Usually, it's only a couple of times, once the permissions are set for your app, the framework stops request the user again and again, and so the case where that problem occurs never happens again.\n. Finally merged that PR, before the release, can you @tarasantoshchuk re-check the result if what you expect ? I just moved the hacky code in a specific class.\n. Thanks for checking, it's available now, the new version is 0.8.0.\n\nLe lun. 17 oct. 2016 \u00e0 12:56, Taras Antoshchuk notifications@github.com a\n\u00e9crit :\n\n> @tbruyelle https://github.com/tbruyelle\n> I've rechecked the fix and reviewed your refactoring commit.\n> Everything is ok.\n> \n> When we can expect the new version of lib (with this fix)?\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/pull/53#issuecomment-254176296,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAFoeLhiBEJ4LPubrjpXvewhnZIYt9hGks5q01RVgaJpZM4IpFBb\n> .\n. What I did in my app in that case is showing a single rationale for all requested permissions. It's simple but the caveat is you don't have the detail of which permissions has been revoked. So you can only display a message like \"some critical permissions have been revoked, please go to the settings and fix that\".\n\nHere is a sample code of the method which is passed to the subscribe of `request`. I used a snackbar for the user feedback : \n\n``` java\nprivate void onPermissionResult(Boolean granted) {\n        if (granted) {\n           // OK\n            return;\n        }\n        // Test whether the user clicked on \"never ask again\",\n        // adapt the action according to that.\n        RxPermissions.getInstance(this)\n                .shouldShowRequestPermissionRationale(this, CRITICAL_PERMISSIONS)\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(should -> {\n                    SnackBar.Builder snack = new SnackBar.Builder(this)\n                            .withMessageId(R.string.permission_required)\n                            .withDuration(SnackBar.PERMANENT_SNACK)\n                            .withStyle(SnackBar.Style.ALERT);\n                    if (should) {\n                        // \"never ask again\" not clicked, ask the user to retry the permission request.\n                        snack.withActionMessageId(R.string.reask)\n                                .withOnClickListener(token -> {\n                                            // Ask again for permissions                                          \n                                        }\n                                );\n                    } else {\n                        // \"never ask again\" clicked, ask the user to fix that in the app settings.\n                        snack\n                                .withActionMessageId(R.string.settings)\n                                .withOnClickListener(token -> {\n                                            // Open the app settings\n                                            AndroidUtils.startAppDetailsActivity(this);\n                                        }\n                                );\n                    }\n                    snack.show();\n                });\n\n    }\n```\n. Please refer a context\n. Closed because no response\n. That's weird, how did you declare the permission in the manifest file ?\n. Closed because no response \n. ?\n. Thanks\n. > since ShadowActivity is public class (and not package-protected) some of library users might start ShadowActivity directly in their code\n\nThat's crazy\n\n> Maybe we should make ShadowActivity package-protected?\n\nwhy not\n. Good job thank you\n. Thanks for the report and the analysis. \nSo the framework did not show the permission dialog again after a pause if the resume is done threw a deep link. RxPermissions should cancel any pending permission request in that case. Do you know how it can detect that ?\n. Sorry I have no idea\n. Because you can't mock static method with mockito, I suggest you to declare a method like that in your activity : \n\n``` java\npublic RxPermissions rxPermissions() {\n  return RxPermission.getInstance(this);\n}\n```\n\nUse this method everywhere you need RxPermissions and then in your test you can simply mock like that : \n\n``` java\nRxPermissions rxPermissions = mock(RxPermissions.class);\nwhen(activity.rxPermissions()).thenReturn(rxPermissions);\nwhen(rxPermissions.request(anything()).thenReturn(Observable.just(true));\n```\n\nHTH\n. Nice one, but that's a breaking change (I think `Single` didn't exist when the lib was created).\nI will keep that in my mind thanks. \n. The change will come with RxJava2 (see #71)\n. There's also `RxPermissions.shouldShowRequestPermissionRationale()` if you need to stay in the rx world.\n. I think that's a good idea.\n\nWe could add an extra field to the `Permission` object to handle that.\n. will be release in 0.8.0.\nYou now have a new field `shoudlShowRequestPermissionRationale` to the `Permission` object.\n. You don't need to get the instance of RxPermission during an init phase, it's required when you invoke methods from that instance.\n. That requirement is due to the permission request dialog, which is displayed by the framework when you call `request/ensure` and the permission is not granted or not denied permanently. If an activity recreation occurs when that dialog is displayed, then the dialog is restored but there's absolutely no way to get that information from the framework. \n\nThe only solution is so to invoke the `request/ensure` in a init phase, and in that case there's a little complex mechanism, which detects pending permission requests.\n\nThat requirement is clearly the ugliest thing in that library, and there is a long thread about that in #3, but despite the intervention of famous android developers, no better solution could be found.\n. I linked this issue in the readme.\n. Although your changes refer to good old java practices, I don't want to merge them because I think they do not promote code readability.\n. Yes I think that's definitevely something RxPermissions should support.\n\nI read some days ago the content of RxJava2 and it's a full rewrite, so I wonder how library like RxPermissions should publish new version that breaks everything. I don't want to change the package name or the artifactId. Maybe a jump to version 1.0 is enough to warn the user about the big changes ?\n. RxAndroid is part of the ReactiveX organisation so it sounds logic it adopted the same way.\n\nI don't think I can use the `io.reactivex` package, and I don't want to rename the package to something like `org.tbruyelle` because it doesn't mean anything. Changing artifact id to something like `RxPermissions2` is much more meaningful but that's ugly.\n. Ok for changing the package name to `com.tbruyelle.rxpermissions2`, that's the best alternative I think. \nI'm curious to see how it will be handled in [RxBinding](https://github.com/JakeWharton/RxBinding/issues/281).\n. Not me\n. I won't have the time to start that in the next weeks. \n\nI linked issue #65 about `Single<Boolean>` usage instead of `Observable<Boolean>`, I said this will come with rxJava2. But after some experiences I found something annoying with `Single`, they don't have `filter` operator. It's logic but for the permission request workflow, it can be annoying to don't have the `filter` operator. \n. As we discussed, I'm ok for a different package name, like `com.tbruyelle.rxpermissions2` and so support both versions in parallel.\n\nI understand your request to distribute your work on one of your repository, and if you really want to do so that's ok. But I'm not sure the community will gain from that. There will be 2 different repositories for the same project, it will be confusing. As you like.\n. Wow you're quick, thanks!\n2.x branch is ready.\n. @gengjiawen That's right, I don't understand why, the files are here... https://dl.bintray.com/tbruyelle/tbruyelle/com/tbruyelle/rxpermissions2/rxpermissions/0.7.1/\n. Maybe it's because it's a different package ...\n. Strange, I asked to bintray to understand, I'm waiting for their response.\n. My config is OK since I managed to upload the legacy version at the same time.\nhttps://jcenter.bintray.com/com/tbruyelle/rxpermissions/rxpermissions/0.7.1/rxpermissions-0.7.1.pom\n. Got my answer from bintray, I have to create an other package and ask for jcenter link. Stay tuned\n. @gengjiawen Request approved by bintray, please retry (I can't be myself for the moment)\n. Fixed now with version 0.8.1 \n. Could you post more code plz ? The problem you have goes against the basic behavior of the library so I suspect there's something wrong in your code. \n. I don't see any RxPermissions code in your gist.\n. Your code in `CommonUtils` about RxPermissions is completely wrong, you need to learn more about asynchronous programming and how RxJava works.\nLook at the code in the sample app and follow it.\n\nI close the issue because it's not related to RxPermissions.\n. And good luck :)\n. I redirected you to the sample app, do the same and it will work.\n\nSorry I don't have the time to explain.\n. I think Nougat is not enough to enable Java 8 features, Jack compiler must also enabled as well.\n. Good catch\n. But undoable since the transformers are parametized.\n. Thanks but you need to fix and update the tests.\n. The feature has been suggested and approved in #68  :)\n. From https://developer.android.com/training/permissions/requesting.html\n\n> To help find situations where the user might need an explanation, Android provides a utiltity method, shouldShowRequestPermissionRationale(). This method returns true if the app has requested this permission previously and the user denied the request.\n> \n> Note: If the user turned down the permission request in the past and chose the Don't ask again option in the permission request system dialog, this method returns false. The method also returns false if a device policy prohibits the app from having that permission.\n\nSo in your case, the first time the user denied the request, the method should return true. Unless you have a device policy which prohibits the app from having the camera permission, or unless there's something wrong in your implementation (but didn't find what).\n\nOther thing, I think you should check if permission is granted first, because in that case it's possible that `shouldShowRequestPermissionRationale` returns false.\n. That's weird because that's not what the documentation say...\n\n> This method returns true if the app has requested this permission **previously** and the user denied the request.\n\nMoreover on my app I get the expected result by invoking that method _after_ I request the persmissions (I use `RxPermissions.shouldShowRequestPermissionRationale()`)\n. The behavior you described for _after the permission_ sounds correct to me, and fit the documention. Is it what you experienced with your case ?\n. By doing it _before_ we break what most users will expect from that value.\n\n@vanniktech So you want to know when the user has clicked on \"Never ask again\", that's simple, the code below should work with the _after_ way : \n\n``` java\n.subscribe(permission -> {\n    if (permission.granted)  {\n      // All good\n    } else if (permission.shouldShowRequestPermissionRationale)\n      // Denied permission without ask never again\n    } else {\n      // Denied permission with ask never again      \n      // Need to go to the settings\n    }\n  });\n```\n\nThat's currently what I do in my app and it works like a charm.\n. @tarasantoshchuk \n\n> also we should rename Permission#shouldShowRequestPermissionRationale to something like Permission#deniedForever. This way the meaning of the field will be obvious for user.\n\nI disagree, by keeping the name we don't have to maintain an extra documentation. Users should know about `shouldShowRequestPermissionRationale`.\n. @vanniktech \n\n> If you just pressed the deny button and checked \"don't ask again\" I don't want to navigate the user into the settings. However if the user comes back and then presses that button and the Android Dialog can't be shown anymore since the user pressed \"don't ask again\" then I need to navigate the user into the settings.\n\nWhy having a separate behavior between the first time the user denied with \"don't ask again\" and the second time ?\n\nBoth time you should display a snackbar or something like that, telling him he has to go to the settings if he finally changed his mind, with a button that brings him to the settings.\n. > Maybe both values should be taken into permission. The value before asking the permission and the value after the user did that.\n\nNope I don't want that. The expected behavior according to the android documentation is to invoke `shouldShowRequestPermissionRationale` after a request, not before. Moreover this will be horrible with variable name like `*before` and `*after`.\n\nYou'll have to add extra code in your app to handle your case.\n. I read your sample code again, and even with the _before_ way, I'm not sure this will fit your need because `shouldShowRequestPermissionRationale` can return false in 3 cases : \n- user clicks on never ask again\n- permission has never been asked\n- permission is already granted\n\n``` java\nrxPermissions.requestEach(Manifest.permission.CAMERA)\n  .first()\n  .toSingle()\n  .subscribe(permission -> {\n    if (!permission.shouldShowRequestPermissionRationale) {\n      // Need to go to the settings\n      // Or the permission has never been asked\n      // Or the permission is already granted\n    } else if (permission.granted) {\n      // All good\n    } else {\n      // Denied permission\n    }\n  });\n\n})\n```\n. I merged your PR but moved the `shouldShowRequestPermissionRationale` invocation after the `requestPermissions`. Thanks for the contribution.\n. I don't understand why there's an infinite loop, but I see something wrong in your code. \n\nIn the first `flatMap` you shouldn't return `null` but `Observable.empty()`. But actually you don't even need the `switchEmpty` operator, just return `locationUpdatesObservable` instead of `null` in the first `flatMap`.\n. ``` java\n.filter(granted -> granted)\n```\n. In case of deny, the chain stops at the filter. There's probably something else in your code that requests the permission again and again.\n. Closed for no activity\n. Please remove .DS_store file\n. > Anything that is stopping this?\n\nNo, I wanted to find the time to review with a minimal knowledge of rxJava2, but I'm very busy for the moment. Let's merge it and see what's coming.\n. I knew I missed something, the package name didn't change. It should be `com.tbruyelle.rxpermissions2` \n. I fixed that in `master` and `2.x` branches.\n. Possible duplicate of #46\n. #46  is now fixed, please try again with version 0.8.0\n. There is `RxPermissions.isGranted` method that calls internally`ContextCompat.checkSelfPermission` but it doesn't return an `Observable`, so you have to do it yourself.\n\n``` java\nObservable.just(RxPermissions.isGranted(...))\n```\n. Ok I see. What's the benefit of such feature ? \n. I don't see how the permission could be revoked at runtime. When you revoke a permission for an app in the settings, the app is killed by the framework.\n. By design, the process of permission request is hard-linked to the `Activity` (sadly like too much things in the Android framework). \n\nWhat you could try is sharing a subject between your activity and your data layer, observe that subject in the data layer and feed it in the activity when a permission is granted. Not sure if it's possible that said, I don't know your achitecture.\n. And sharing a subject is probably over-engineering. \n. Well, I think we have to move forward about this issue, and this is probably the simplest way. Thanks for the contribution.\nI would like to have review from people involved in #46, @tarasantoshchuk ? @artesa ? @NitroXenon ? WDYT?\n. I think finally I'm going to accept @tarasantoshchuk's PR (#53) because it's more accurate. Sorry for the very long delay... I'll probably merge it on monday.\n. Please join a screenshot, I don't understand.\n. Should be fixed since we don't use an activity any more for requesting permission.. Because it would be cumbersome to start an activity just for that. I only need the activity as a parameter, I don't need to catch the activity result like `request` or `ensure`.\n. > 0.8.0 needs rxjava 1.x version, while 0.8.1 needs rxjava 2.x version.\n\nNot really. RxJava version is handled by the package name.\nfor RxJava 1.x use `compile 'com.tbruyelle.rxpermissions:rxpermissions:0.8.0@aar'`\nfor RxJava 2.x `compile 'com.tbruyelle.rxpermissions2:rxpermissions:0.8.1@aar'`\n. `rxPermissions.request(Manifest.permission.CAMERA).subscribe()` compiles. \n. > I guess I need to include the rxJava itself as a dependency?\n\nNo, that's not required, Gradle do it for you. Package changes between RxJava1 and RxJava2, that's probably why you get this error.\n. You can also have this kind of exception if you don't follow the library guidelines.\n. We can't emit an error precisely because we can't find the subject for the requested permission.\n. Your code seems to gather all conditions to trigger the biggest flaw of this library : configuration change handling. As you read in #3 there's no workaround, so we have the choice to follow the guidelines or to stop using `RxPermissions`.\n. Not relevant\n. Sounds cool. Can you explain what the benefit of using a retained fragment, and what are the rotating screen issues you fixed ?\n. Fine, I have to do some tests. \n. Sorry for the delay. \n\nI briefly started some tests and first of all I got a crash in the sample app, when I return to the sample app after tweaking the app permissions in the settings. `RxPermissions.getInstance` returned null so a NPE raised. \n\nIt seems there's a bug in the  `newInstance` detection.\n\nTo reproduce : \n- open the Sample app\n- Open the settings and go to applications>RxPermissions Sample>permissions and update the permissions\n- return to the Sample app -> crash\n. Ok since you moved the subjects list in the fragment, there's no need to have `RxPermissions.onRequestPermissionResults()`, everything can be done in the fragment if I'm right.\n\nI'm still testing.\n. Another issue, if you invoke `requestEach` directly in your activity `onCreate`, there's a crash because `RxPermissionsFragment.getActivity()` returns null. It seems the fragment is not yet attached to the activity at this time (aahh that's why I love fragment...)\n\nTo reproduce, change the sample app `MainActivity` like that : \n\n``` java\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        final RxPermissions rxPermissions = RxPermissions.newInstance(this);\n        rxPermissions.setLogging(true);\n\n        setContentView(R.layout.act_main);\n        surfaceView = (SurfaceView) findViewById(R.id.surfaceView);\n\n                rxPermissions.requestEach(Manifest.permission.CAMERA)\n                        .subscribe(new Action1<Permission>() {\n                                       @Override\n                                       public void call(Permission permission) {\n                                           Log.i(TAG, \"Permission result \" + permission);\n                                           if (permission.granted) {\n                                               Toast.makeText(MainActivity.this,\n                                                       \"Camera permission granted\",\n                                                       Toast.LENGTH_SHORT).show();\n                                               releaseCamera();\n                                               camera = Camera.open(0);\n                                               try {\n                                                   camera.setPreviewDisplay(surfaceView.getHolder());\n                                                   camera.startPreview();\n                                               } catch (IOException e) {\n                                                   Log.e(TAG, \"Error while trying to display the camera preview\", e);\n                                               }\n                                           } else if (permission.shouldShowRequestPermissionRationale) {\n                                               // Denied permission without ask never again\n                                               Toast.makeText(MainActivity.this,\n                                                       \"Denied permission without ask never again\",\n                                                       Toast.LENGTH_SHORT).show();\n                                           } else {\n                                               // Denied permission with ask never again\n                                               // Need to go to the settings\n                                               Toast.makeText(MainActivity.this,\n                                                       \"Permission denied, can't enable the camera\",\n                                                       Toast.LENGTH_SHORT).show();\n                                           }\n                                       }\n                                   },\n                                new Action1<Throwable>() {\n                                    @Override\n                                    public void call(Throwable t) {\n                                        Log.e(TAG, \"onError\", t);  // <--- crash is reported here\n                                    }\n                                },\n                                new Action0() {\n                                    @Override\n                                    public void call() {\n                                        Log.i(TAG, \"OnComplete\");\n                                    }\n                                });\n}\n\n```\n. Np, the PR is promising, I hope it can remove the biggest drawback of the library : having to subscribe during the init phase.\n. Sure, for the moment I try to find the time to complete the tests, sry for\nthe delay.\n\nLe jeu. 10 nov. 2016 23:21, Eduardo Alejandro Pool Ak\u00e9 <\nnotifications@github.com> a \u00e9crit :\n\n> @tbruyelle https://github.com/tbruyelle let me know if you need any\n> change for this PR please.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/pull/91#issuecomment-259824931,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAFoePlWgTPju5O_3IhVzurULi_PH1acks5q85jKgaJpZM4Km2OR\n> .\n. I completed some tests about config change and it's ok. \nNow I'm worried about the breaking change you introduced by removing the hability to get the singleton instance of `RxPermissions`. Is it really necessary ?\n\nOther subject, the changes need to ported also in the `2.x` branch, and that's a boring job.\n. > I can rollback the renaming from RxPermissions.newInstance(activity) to RxPermissions.getInstance(activity)\n\nThat would break the contract because as you said it's no more a singleton. I prefer to have a simple constructor rather than `newInstance`.\n\n> Regarding 2.x I can create a new branch from 2.x, apply these changes on that branch and create another PR against 2.x branch.\n\nGreat, let's do this. Thanks in advance\n. Well I'm not sure, wdyt? \n. Ok let's merge it\n. Ready in version 0.9.0 (not 0.8.3 because of the breaking change)\n. And thanks for the awesome work!\n. > Permission is banned in android 5.1\n\nWhat do you mean  ?\n. Closed  no feedback from op. You can use `requestEach` which emits similar results but returns an observable rather than a transformer. See the readme just before the _Important read_ section.\n. It seems to be something linked to your fragment usage, not RxPermissions.\n. Closed no feedback from op. I updated to 1.2.2 and so far so good c8e57f063785202d033f4ae47e833bfcc4c80a84\n. I've just uploaded version 0.8.2 with rxJava 1.2.2 dependency if you want to check\n. Thanks for the PR but the problem is now probably fixed in version 0.9.0, where we don't use activities any more. Could you check ?\n. Well sorry but as `requestPermissions()` is a method attached to an `Activity` (and not a `Context`) I don't feel bad about requiring an Activity for the constructor argument.\r\n. Closed no response from op. Thx @epool. I'll fix the README.. You have the problem only when debugging?. When you request the permission, `onPause` is executed in your activity, do you execute specific code in there?. Ok, @epool do you think it could come from the fragment ?\r\n\r\n@ersin-ertan Can you check if you have a similar behavior with version 0.8.2 please ? You'll have to change `new RxPermissions(this)` with `RxPermissions.getInstance(this)`.. Fine, so problem solved ?. > I wouldn't think so, but I'm not sure what you as a library developer could do to prevent this problem.\r\n\r\nYes, that's what I mean by 'problem solved'\r\n\r\n> Having the noHistory option is important for some apps, would you know of any possible solutions?\r\n\r\nNo idea but I found this on stack : \r\nhttp://stackoverflow.com/questions/35151233/requesting-android-m-permissions-from-activity-with-nohistory-true-and-or-show?rq=1. \"Always ask\" ? Where is that setting ?. Sorry but the library won't support this kind of manufacturer custom dev.\n\nLe jeu. 24 nov. 2016 14:57, Liverm0r <notifications@github.com> a \u00e9crit :\n\n> Yes, If I set \"allowed\" or \"refused\" the behavior is as it should be.\n>\n> \u2014\n> You are receiving this because you commented.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tbruyelle/RxPermissions/issues/100#issuecomment-262781775>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAFoeIrIzPF74sKLeE949zSbIlKz6kiYks5rBZe9gaJpZM4K5jgx>\n> .\n>\n. It is lightweight, it requires no declaration in manifest, it fixes a small ui bug.  What's your opinion about that ?. That said @epool, is it possible for you to apply the change in the `2.x` please ?. No need to be sorry, thanks!. You're not the first and I'm sorry.\r\nThat said I don't understand why you perform something that can lead to an UI interaction in a Service.. > @vanniktech @epool You should almost always be using the support library Fragments\r\n\r\nIn theory that makes sense but having the support library as a dependency in a library project can be a PITA for some users.. > Well, basically I have an ongoing location sharing service. And if a user goes to the app's settings and disables the location permission, I want the app to prompt the user to re-enable the location permission\r\n\r\nThanks I understand, but where does the request permission dialog appear when you request a permission from a Service ? I mean, if you are in an different app, the dialog appears in front of it ?. Well I'm pretty sure it's not something that Google would approve XD.. IMAO the best way is to pop a notification indicating the permission change, the notif click launches an activity explaining why the permission is required and allow to request again.. @epool ping, did you find the time to work on the 2.x branch ?. You have to use `ensureEach`, which provides more information. In particular it gives you the result of `shouldShowRequestPermissionRationale`.\r\nCheck the readme.. Gn\u00e9?. I'll add the missing tag. About the 2.x branch, @epool is working on it, thanks to him.. Cause I didn't switch to rxjava2 yet in my projects. The 2.x branch is not something I planned.. Well this bug is hard-boiled. We had it in the past and did ugly fixes to remove it. I really though it won't come back since we use a fragment and not an activity. But the Android framework is definitively not a good friend. \r\n\r\nI'll commit a fix to ignore the crash, because now I'm tired.. Fixed in version 0.9.1. Well the less ugly way would be to move that methods static...\r\n\r\nIs it very annoying to do it yourself ?\r\n\r\n```java\r\nObservable.just( context.checkSelfPermission(p) == PackageManager.PERMISSION_GRANTED ) \r\n``` . Ok, I'll wait your PR to see.. Version 0.9.1 fixes that exception.. Great job thank you. \r\n(Ping @epool : job done ^^). There's no need of static method for that.. I'll fix the README. @epool Any idea ?. Closed because no response from op. Please provide the code, sry for the delay. Reopen the issue at the same time.. Since we use a fragment to request the permission, `RxPermissions` now needs an activity.\r\nIt may be a constraint, but an activity is also needed if you request the permission with the core methods.\r\n\r\nAbout your problem with Dagger, I suggest to create an other module in your activity, or to remove `RxPermissions` from injected dependencies, and create it manually.. Try `rxPermissions.request(Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE)`. \r\nYou will receive a compiled result of user answers.\r\n\r\n. You can't merge 2.x and master branches. One is dedicated to Rxjava2 and the other to Rxjava1.. Why did you change the author ids ?\r\nWhat is the purpose of that PR?. Please create a clean PR with the only the changes you want. I close this one for now.. No you can't, `shouldShowRequestPermissionRationale()` is an `Activity` method.. Thanks a lot for this change and for the explanations :). 0.9.3 has been upload for master and 2.x branch.. Dup of #142 . Yes it makes sense, I thought about that too but it would introduce a breaking change without real benefit (`Single` class didn't exist when I started the library).. Ow I think there's a PR for that... #121 . You probably do something wrong with your fragment usage to have this exception, anyway, version 0.9.2 now perform `commitAllowingStateLoss`.. Just added the tag v0.9.3. About the change log I'm sorry for the moment I don't have the time to maintain it.. I dont think `RxPermissions` is currently not compatible with the Support lib.. I know that, but that doesn't mean the lib isn't compatible with the support lib.. So is there good reason to use the support library ?. No you can use it in a fragment. Write the error handler to catch the\nexception and report it please.\n\nLe jeu. 23 mars 2017 \u00e0 03:07, naivor <notifications@github.com> a \u00e9crit :\n\n> When i use RxPermissions in Fragment,i get a exception, the log is\n> rx.exceptions.OnErrorNotImplementedException: xxx\n>\n> Is RxPermissions can only use in Activity?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tbruyelle/RxPermissions/issues/130>, or mute the\n> thread\n> <https://github.com/notifications/unsubscribe-auth/AAFoeK5sppco3QY6u98EESRkkOVha01qks5rodPUgaJpZM4MmEZr>\n> .\n>\n. You should force the version 0.9.3 for the library. . There's possibly a breaking change between 0.7 and 0.9.3. You have no other choice than trying  to update the library code.. Thank you for the replies, I close the issue. Sounds legit, please submit a PR and I'll merge it.. The lib is there https://bintray.com/tbruyelle/tbruyelle/RxPermissions2/0.9.3, maybe jcenter had connectivity issues during your attempt. Please try again and let me know.. Didn't understand what's your problem.. It's in the README, use `requestEach/ensureEach` to have a detailled object of what happened during the permission request.. This is the normal behavior. If the user has clicked \"never ask again\" and if the permission is critical for your app, you have to invite the user to go to the settings and to change manually the permissions of your app. There's no other alternatives.. Thanks for the PR, I will have time to review it at the end of the week. Stay tuned.. Ty!. 0.9.4 contains the PR. Fragments are really a plague !. Sorry I have no idea, community pushed me to use fragments for this lib (originally it was an Activity), and I finally accepted but I regret. I don't use fragment from ages, so sorry I can't help you.. This lib doesn't handle Xiaomi specific permission system.. Ty!. Didn't understand your first point.. I disagree. From the android doc : \r\n\r\n> You should do this only if you do not have the permission.\r\n\r\nhttps://developer.android.com/reference/android/app/Activity.html#shouldShowRequestPermissionRationale(java.lang.String). > firstly , the \"isGranted\" is true , and then the phone show the permission dialog\r\n\r\nNo. The `Action1` is only invoked when user has answered all permission dialog requests.. Why do you have a Samsung you're a developer isn't it ? xD. Yes that's strange, it's the first time someone raise me this kind of issue. I don't think it's the first time the library is used on a S7.\r\n\r\nThis only occurs the first time you request the permission ?. So it's when the dialog appears, maybe Samsung broke something in the lifecycle during this process.\r\nAre you sure you perform the `request` in an initialization phase ?. Do you request inside a click listener ? If yes it's not an initialization phase and you will have the same problem on any device if you rotate the screen while the permission dialog is shown.\r\n\r\nTry to follow the example in the README : \r\n\r\n```java\r\n// Must be done during an initialization phase like onCreate\r\nRxView.clicks(findViewById(R.id.enableCamera))\r\n    .compose(rxPermissions.ensure(Manifest.permission.CAMERA))\r\n    .subscribe( ... )\r\n```. @lopspower so did you fix the issue with my last comment ?. Gne. Please read the README and look at the sample project, you would find out.. Why?. Details?. It seems you use the wrong version, `Flowable` is part of `rxjava-2`. Use `com.tbruyelle.rxpermissions2:rxpermissions`. The API already provides the hability to pass multiple permissions in the arguments.\r\n\r\nAbout the Android O Permission changes : https://developer.android.com/about/versions/oreo/android-8.0-changes.html#rmp\r\n\r\nI don't think there's something to change in this library for that. WDYT ?. It's rxjava1 on `master` branch, and rxjava2 on `2.x` branch.. I don't know is this required for APACHE2 license ?. @dsaff @nmulcahey thank you guys, I've just added it to the README.. No you can't. Dup of #142 . No, I don't want to add complex features like that.. This may be a bug that occurs only on some manufacturer OS. Sorry I can't do anything for that.. Speak english please. Is it something new ? Can you link me the doc please ?. Ok there's nothing new, the lib already handles `shouldShowRequestPermissionRationale`.. > If needed, here's a class that has all the groups and their permissions:\r\n\r\nIs it a class from the framework ?. Well it should be !\r\nYou can create a PR on this if you want.. That would be nice, but this requires to maintain the list carefully, for instance when a new permission is added to the framework ?. OK fine.\r\n\r\n`@StringDef` is an android feature, why didn't they add this on their own permission definition, that's a shame.. The library won't handle it.. There's no such bug in the library.\r\nDont forget to declare the permissions in your manifest.\r\n. ",
    "Gi-lo": "I had a similar idea building such a library for `onActivityResult()`handling. Sadly I also stumbled across the rotation issue and never had the chance to really think about a suitable solution.\n\nHowever:\nI also cannot come up with a solution where you keep the current flow `rx. request().subscribe()`. \n\nMaybe @dlew , @passsy or @mttkay can share some input here. I think there once was a RxAndroid issue where configuration change has been discussed. However I am not able to find it anymore.\n. @tbruyelle I do **not** think force closing the permission dialog is a legit option. Also you are completely right with pointing out that the retriggering of the permission request is the one breaking the flow we want.\n\nAt work we ended up using a `RxAppCompatActivity` exposing an `onPermisssionResultsReceivedObservable()` . So we also broke the `requestPermissions().subscribe()` flow. I really don't think it is possible to keep it without having to `attach/register` and `detach/unregister` the activity on the `RxPermission` instance. \n. I once wrote a class called 'LifecycleExtension' where you have one method called 'onLifecycleEventReceived'. I used the RxLifecycleFragment provided in RXLifecycle to provide the correct events. Since that I was able to use composition over inheritence for everything that depends on the lifecycle eg. Butterknife, Tracking and much more. Also those Lifecycle objects are heavily testable. Long story short, a base Activity that has for every callback it implements an observable as well, is something that we should love to use. \n. I had a similar idea building such a library for `onActivityResult()`handling. Sadly I also stumbled across the rotation issue and never had the chance to really think about a suitable solution.\n\nHowever:\nI also cannot come up with a solution where you keep the current flow `rx. request().subscribe()`. \n\nMaybe @dlew , @passsy or @mttkay can share some input here. I think there once was a RxAndroid issue where configuration change has been discussed. However I am not able to find it anymore.\n. @tbruyelle I do **not** think force closing the permission dialog is a legit option. Also you are completely right with pointing out that the retriggering of the permission request is the one breaking the flow we want.\n\nAt work we ended up using a `RxAppCompatActivity` exposing an `onPermisssionResultsReceivedObservable()` . So we also broke the `requestPermissions().subscribe()` flow. I really don't think it is possible to keep it without having to `attach/register` and `detach/unregister` the activity on the `RxPermission` instance. \n. I once wrote a class called 'LifecycleExtension' where you have one method called 'onLifecycleEventReceived'. I used the RxLifecycleFragment provided in RXLifecycle to provide the correct events. Since that I was able to use composition over inheritence for everything that depends on the lifecycle eg. Butterknife, Tracking and much more. Also those Lifecycle objects are heavily testable. Long story short, a base Activity that has for every callback it implements an observable as well, is something that we should love to use. \n. ",
    "eleventigers": "One way to handle is store observable outside the activity and resubscribe to it when needed. Since the original RxPermissions is bound to the consumer activity, I decided to try out using an invisible activity to handle all this. Seems to be working pretty well and rotation handling is possible when using RxPermissions singleton (or just cached somewhere) bound to an application context. PR coming soon ;]\n. My solution using Dagger 2 scopes is quite simple. `RxPermissions` is scoped by the application context (`@AppScope`) while `Observable<Boolean>` is scoped per activity with a `.cache()` operator applied. When #6 proxy activity is recreated on rotation, consumer activity and its scope is recreated too but the `RxPermissions` stays the same instance to receive the results. Although the new activity scope request a new observable from `RxPermisssions`, `.cache()` makes sure the result is stored before the consumer (a presenter in my case) is resubscribed. Once the presenter wakes up in `onResume` it subscribes to the observable and enjoys the result :D\n. Yes, the sample app is leaking the subscription. I think that this library should not be concerned with managing the observable for the consumer. If the observable is kept somewhere (and cache() applied) consumer activity can resubscribe to it after recreation?\n. @tbruyelle no problem, hopefully I can contribute more in the future ;]\n. @andretietz the main benefit of using the headless activity approach is the ability to invoke the dialog from a plain `Context` instead of forcing everyone into using fragments or tying the flow to a particular activity.\n. @andretietz how could a fragment be used without an activity (supplied by library or else)? Isn't a FragmentManager required to use a headless fragment?\n. I am not sure if that would be a tidier approach. Also, this would make it easier for a user to leak activity which is not fun obviously. \n\n@andretietz  I don't specifically see any real benefits when using fragments here. To address your stack point, the shadow activity can probably be declared with the [noHistory](http://developer.android.com/reference/android/R.styleable.html#AndroidManifestActivity_noHistory) flag? Also, could you eleborate on you Manifest entry point?\n. @martyglaubitz https://github.com/tbruyelle/RxPermissions/blob/8116cfa74b4a71ae526ca44629b88eb3843e10de/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L244\n. @tbruyelle it was merely to match the current API but yes, I agree, variadics should not be used here. Hopefully you can resolve this with the next major bump ;]\n. Awesome, thanks!\n. One way to handle is store observable outside the activity and resubscribe to it when needed. Since the original RxPermissions is bound to the consumer activity, I decided to try out using an invisible activity to handle all this. Seems to be working pretty well and rotation handling is possible when using RxPermissions singleton (or just cached somewhere) bound to an application context. PR coming soon ;]\n. My solution using Dagger 2 scopes is quite simple. `RxPermissions` is scoped by the application context (`@AppScope`) while `Observable<Boolean>` is scoped per activity with a `.cache()` operator applied. When #6 proxy activity is recreated on rotation, consumer activity and its scope is recreated too but the `RxPermissions` stays the same instance to receive the results. Although the new activity scope request a new observable from `RxPermisssions`, `.cache()` makes sure the result is stored before the consumer (a presenter in my case) is resubscribed. Once the presenter wakes up in `onResume` it subscribes to the observable and enjoys the result :D\n. Yes, the sample app is leaking the subscription. I think that this library should not be concerned with managing the observable for the consumer. If the observable is kept somewhere (and cache() applied) consumer activity can resubscribe to it after recreation?\n. @tbruyelle no problem, hopefully I can contribute more in the future ;]\n. @andretietz the main benefit of using the headless activity approach is the ability to invoke the dialog from a plain `Context` instead of forcing everyone into using fragments or tying the flow to a particular activity.\n. @andretietz how could a fragment be used without an activity (supplied by library or else)? Isn't a FragmentManager required to use a headless fragment?\n. I am not sure if that would be a tidier approach. Also, this would make it easier for a user to leak activity which is not fun obviously. \n\n@andretietz  I don't specifically see any real benefits when using fragments here. To address your stack point, the shadow activity can probably be declared with the [noHistory](http://developer.android.com/reference/android/R.styleable.html#AndroidManifestActivity_noHistory) flag? Also, could you eleborate on you Manifest entry point?\n. @martyglaubitz https://github.com/tbruyelle/RxPermissions/blob/8116cfa74b4a71ae526ca44629b88eb3843e10de/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L244\n. @tbruyelle it was merely to match the current API but yes, I agree, variadics should not be used here. Hopefully you can resolve this with the next major bump ;]\n. Awesome, thanks!\n. ",
    "passsy": "as @tbruyelle said it can only be solved with a Singleton (, supporting only a single instance like @eleventigers did) or with a lot of code the user has to put into his activity. I solved such problems in the past by using a presenter (MVP) for my activity which gets passed to the new created Activity after a configuration change with [`onRetainNonConfigurationInstance()`](http://developer.android.com/reference/android/app/Activity.html#onRetainNonConfigurationInstance%28%29). Because I retain the presenter instance I can hold a reference to the `RxPremissions` instance there. Not sure if this solves this problem here. Somebody could try this with a simple [Mosby](https://github.com/sockeqwe/mosby) MVP implementation.\n\nThis is just a workaround and no fix for this library.\n. This is not a good idea. There are other configuration changes than the orientation change, such as a language change or docking a hardware keyboard. This lib needs a solution which targets all configuration changes. \nLocking the orientation is by the way not guaranteed. There are non root apps in the play store working around those restrictions. \n. @dlew I would appreciate such an Activity/Fragment where you can observe every lifecycle method. Currently it's impossible to use composition over inheritance for fragments and activities. I saw/build many libs requiring the user to call a delegate in ~10 lifecycle methods to make them work or extend their `LibXyzActivity`. There was a `RxFragment` earlier in RxAndroid (not forwarding all lifecycle events and NonConfigurationInstance was missing) which could be a start. Personally I would build it without Rx in the first step to make it universal usable.\n\nWith a `ComposableActivity` we could write plugins which could be used to bind multiple libs logic to activities.\n\nLibs that could profit from this:\n- [mosby](https://github.com/sockeqwe/mosby) @sockeqwe \n- [flow](https://github.com/square/flow/) @loganj\n- [compartment](https://github.com/grandstaish/compartment) @grandstaish \n- AppCompat :P not really but they are using a delegate too [AppCompatPreferenceActivity source](https://android.googlesource.com/platform/development/+/master/samples/Support7Demos/src/com/example/android/supportv7/app/AppCompatPreferenceActivity.java)\n- two internal libs from me\n- many others\n\nThis looks like a solution but is not maintained: https://github.com/BoD/android-activitylifecyclecallbacks-compat\n. as @tbruyelle said it can only be solved with a Singleton (, supporting only a single instance like @eleventigers did) or with a lot of code the user has to put into his activity. I solved such problems in the past by using a presenter (MVP) for my activity which gets passed to the new created Activity after a configuration change with [`onRetainNonConfigurationInstance()`](http://developer.android.com/reference/android/app/Activity.html#onRetainNonConfigurationInstance%28%29). Because I retain the presenter instance I can hold a reference to the `RxPremissions` instance there. Not sure if this solves this problem here. Somebody could try this with a simple [Mosby](https://github.com/sockeqwe/mosby) MVP implementation.\n\nThis is just a workaround and no fix for this library.\n. This is not a good idea. There are other configuration changes than the orientation change, such as a language change or docking a hardware keyboard. This lib needs a solution which targets all configuration changes. \nLocking the orientation is by the way not guaranteed. There are non root apps in the play store working around those restrictions. \n. @dlew I would appreciate such an Activity/Fragment where you can observe every lifecycle method. Currently it's impossible to use composition over inheritance for fragments and activities. I saw/build many libs requiring the user to call a delegate in ~10 lifecycle methods to make them work or extend their `LibXyzActivity`. There was a `RxFragment` earlier in RxAndroid (not forwarding all lifecycle events and NonConfigurationInstance was missing) which could be a start. Personally I would build it without Rx in the first step to make it universal usable.\n\nWith a `ComposableActivity` we could write plugins which could be used to bind multiple libs logic to activities.\n\nLibs that could profit from this:\n- [mosby](https://github.com/sockeqwe/mosby) @sockeqwe \n- [flow](https://github.com/square/flow/) @loganj\n- [compartment](https://github.com/grandstaish/compartment) @grandstaish \n- AppCompat :P not really but they are using a delegate too [AppCompatPreferenceActivity source](https://android.googlesource.com/platform/development/+/master/samples/Support7Demos/src/com/example/android/supportv7/app/AppCompatPreferenceActivity.java)\n- two internal libs from me\n- many others\n\nThis looks like a solution but is not maintained: https://github.com/BoD/android-activitylifecyclecallbacks-compat\n. ",
    "dlew": "IMO, if you want an `Observable`-based solution, there are two things you'll need to do:\n1. Persist request state in `onSaveInstanceState()` (in a `Parcelable` or similar) and restore it again in `onCreate()`.\n2. Require re-subscription on recreation.\n\nIf you do the first step, then you can skip having to store the `Observable` altogether since you could just create a new one on recreation. It also gets rid of the need for a singleton.\n\nAs for why the second is necessary: The core problem is that you want a `Subscription` to outlast the `Activity` lifecycle, which just isn't going to happen. Even if you persist the `Observable`, the `Subscription` will necessarily need to be recreated along with the new `Activity`, since the old `Subscriber` will have no references to the new `Activity`.\n\n(You could try to reattach the `Subscriber` to the new `Activity` but in what way is that better than simply recreating the `Subscription`?)\n\n---\n\nOf course this comes with all sorts of anti-fun changes to this lib, since users would have to implement `onSaveInstanceState()` and resubscription themselves.\n\nFWIW, this is why I ended up not going the `Observable` route for my own permission handling code. I'm not saying this library isn't feasible, but there's a lot of plumbing necessary due to the lack of good `Activity`/`Fragment` lifecycle listeners.\n. @mttkay I almost used retained fragments, but I found I was actually writing _more_ code than just solving it by hand.\n. I've been toying with the idea of creating some base Activity/Fragments that would allow you to observe all possible onEvents. With such a tool on hand, this wouldn't be nearly as bad:\n1. You could handle configuration changes in the background.\n2. You can automatically unsubscribe when the Activity dies.\n3. You can simply resume permission request on demand.\n\nIt would still require a re-subscription to the Observable, but that's a logical outcome of wanting to have an Observable last longer than the Activity it was created within.\n. I'll bump this up in my priorities and work out a draft this week. I think there could be a lot of benefit out there for it.\n. IMO, if you want an `Observable`-based solution, there are two things you'll need to do:\n1. Persist request state in `onSaveInstanceState()` (in a `Parcelable` or similar) and restore it again in `onCreate()`.\n2. Require re-subscription on recreation.\n\nIf you do the first step, then you can skip having to store the `Observable` altogether since you could just create a new one on recreation. It also gets rid of the need for a singleton.\n\nAs for why the second is necessary: The core problem is that you want a `Subscription` to outlast the `Activity` lifecycle, which just isn't going to happen. Even if you persist the `Observable`, the `Subscription` will necessarily need to be recreated along with the new `Activity`, since the old `Subscriber` will have no references to the new `Activity`.\n\n(You could try to reattach the `Subscriber` to the new `Activity` but in what way is that better than simply recreating the `Subscription`?)\n\n---\n\nOf course this comes with all sorts of anti-fun changes to this lib, since users would have to implement `onSaveInstanceState()` and resubscription themselves.\n\nFWIW, this is why I ended up not going the `Observable` route for my own permission handling code. I'm not saying this library isn't feasible, but there's a lot of plumbing necessary due to the lack of good `Activity`/`Fragment` lifecycle listeners.\n. @mttkay I almost used retained fragments, but I found I was actually writing _more_ code than just solving it by hand.\n. I've been toying with the idea of creating some base Activity/Fragments that would allow you to observe all possible onEvents. With such a tool on hand, this wouldn't be nearly as bad:\n1. You could handle configuration changes in the background.\n2. You can automatically unsubscribe when the Activity dies.\n3. You can simply resume permission request on demand.\n\nIt would still require a re-subscription to the Observable, but that's a logical outcome of wanting to have an Observable last longer than the Activity it was created within.\n. I'll bump this up in my priorities and work out a draft this week. I think there could be a lot of benefit out there for it.\n. ",
    "mttkay": "FWIW, we found a very workable solution by using retained fragments and\nReplaySubjects. The key idea being that the retained fragment state\npersists the observable across rotation changes, and the replay subject\nmakes sure that by unsubscribing/resubscribing throughout the rotation, the\nsubscriber won't miss out on any notifications.\n\nI guess there's any number of other ways to solve that problem. I believe I\nremember Jake saying that they solved it with Dagger singletons. They would\nessentially keep sequences around in the object graph (which survives the\nActivity), and a caching layer can ensure that you don't re-trigger\nexpensive network calls or the like.\n\nI haven't yet heard of a \"canonical\" way of dealing with the problem.\n\nOn Thu, Oct 1, 2015 at 3:29 PM Daniel Lew notifications@github.com wrote:\n\n> IMO, if you want an Observable-based solution, there are two things\n> you'll need to do:\n> 1. Persist request state in onSaveInstanceState() (in a Parcelable or\n>    similar) and restore it again in onCreate().\n> 2. Require re-subscription on recreation.\n> \n> If you do the first step, then you can skip having to store the Observable\n> altogether since you could just create a new one on recreation. It also\n> gets rid of the need for a singleton.\n> \n> As for why the second is necessary: The core problem is that you want a\n> Subscription to outlast the Activity lifecycle, which just isn't going to\n> happen. Even if you persist the Observable, the Subscription will\n> necessarily need to be recreated along with the new Activity, since the\n> old Subscriber will have no references to the new Activity.\n> \n> (You could try to reattach the Subscriber to the new Activity but in what\n> way is that better than simply recreating the Subscription?)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/3#issuecomment-144726228\n> .\n. FWIW, we found a very workable solution by using retained fragments and\nReplaySubjects. The key idea being that the retained fragment state\npersists the observable across rotation changes, and the replay subject\nmakes sure that by unsubscribing/resubscribing throughout the rotation, the\nsubscriber won't miss out on any notifications.\n\nI guess there's any number of other ways to solve that problem. I believe I\nremember Jake saying that they solved it with Dagger singletons. They would\nessentially keep sequences around in the object graph (which survives the\nActivity), and a caching layer can ensure that you don't re-trigger\nexpensive network calls or the like.\n\nI haven't yet heard of a \"canonical\" way of dealing with the problem.\n\nOn Thu, Oct 1, 2015 at 3:29 PM Daniel Lew notifications@github.com wrote:\n\n> IMO, if you want an Observable-based solution, there are two things\n> you'll need to do:\n> 1. Persist request state in onSaveInstanceState() (in a Parcelable or\n>    similar) and restore it again in onCreate().\n> 2. Require re-subscription on recreation.\n> \n> If you do the first step, then you can skip having to store the Observable\n> altogether since you could just create a new one on recreation. It also\n> gets rid of the need for a singleton.\n> \n> As for why the second is necessary: The core problem is that you want a\n> Subscription to outlast the Activity lifecycle, which just isn't going to\n> happen. Even if you persist the Observable, the Subscription will\n> necessarily need to be recreated along with the new Activity, since the\n> old Subscriber will have no references to the new Activity.\n> \n> (You could try to reattach the Subscriber to the new Activity but in what\n> way is that better than simply recreating the Subscription?)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/3#issuecomment-144726228\n> .\n. ",
    "sockeqwe": "I haven't found time to use this library yet, but from what I see I have to agree with @Gi-lo ... I don't see another easy and reliable way ...\n\nWe could improve that: Instead of having a `RxAppCompatActivity`  as base class we could do something super lazy and add an invisible Fragment (no UI) to get access to `Fragment.onRequestPermissionsResult()` callback (and other lifecycle events if needed). So we could change the api of this library to something like `rxPermissions.with(activity).request(Manifest.permission.CAMERA)` where `withActivity(FragmentActivity)` would attach the invisible fragment or reuse the already attached fragment. I think that would go into the direction @dlew was suggesting (i.e. saving the state into a bundle).\n\nHowever, that would mean that this library would depend on Fragments and FragmentActivity which I really dislike in general.\n. Could the observable not be shared somehow by using one of rx java's share operations? In that case it wouldn't make any difference if the observable gets unsubscribed and resubscribed after screen orientation changes, right?\n\nHowever, in the unlikely case that the activity goes in background before the user grants/denies permission, because the user starts another App (i.e. open a push notification), the hosting activity could be destroyed if the app goes in background ... Hence, I think that saving the instance state in a bundle is the right way to go ... I have something like restoring / recreating an Observable from Bundle and share that observable with multiple subscribers in mind.\n. I haven't found time to use this library yet, but from what I see I have to agree with @Gi-lo ... I don't see another easy and reliable way ...\n\nWe could improve that: Instead of having a `RxAppCompatActivity`  as base class we could do something super lazy and add an invisible Fragment (no UI) to get access to `Fragment.onRequestPermissionsResult()` callback (and other lifecycle events if needed). So we could change the api of this library to something like `rxPermissions.with(activity).request(Manifest.permission.CAMERA)` where `withActivity(FragmentActivity)` would attach the invisible fragment or reuse the already attached fragment. I think that would go into the direction @dlew was suggesting (i.e. saving the state into a bundle).\n\nHowever, that would mean that this library would depend on Fragments and FragmentActivity which I really dislike in general.\n. Could the observable not be shared somehow by using one of rx java's share operations? In that case it wouldn't make any difference if the observable gets unsubscribed and resubscribed after screen orientation changes, right?\n\nHowever, in the unlikely case that the activity goes in background before the user grants/denies permission, because the user starts another App (i.e. open a push notification), the hosting activity could be destroyed if the app goes in background ... Hence, I think that saving the instance state in a bundle is the right way to go ... I have something like restoring / recreating an Observable from Bundle and share that observable with multiple subscribers in mind.\n. ",
    "domsu": "I know that this is not good pattern, but what do you think about this:\n\nAfter permission request is send we lock current rotation in activity that send request and ShadowActivity.\n\nAfter we deliver permission repsonse to subscriber we unlock rotation.\n. I know that this is not good pattern, but what do you think about this:\n\nAfter permission request is send we lock current rotation in activity that send request and ShadowActivity.\n\nAfter we deliver permission repsonse to subscriber we unlock rotation.\n. ",
    "andaag": "This can't be solved.. If you shoot off another activity you always risk being garbage collected, that means the observable will disappear. You can't solve that as you cant serialize an observable mid stream.\n. @tbruyelle \n1. User clicks something that requires a permission\n2. Permission dialog pops up\n3. User leaves app to google what the permission means.\n4. Browser requires memory and app gets removed from active memory.\n5. User jumps back in app, clicks accept, but everything is serialized, and rx breaks.\n\nThis is a very special case, but it is a case... Might be worth it for some people to use rx anyway though, and know that that case wont be handled very well.\n. What we're going to do at my company to use rx for this kind of flow (locationsettings for example). Is to simply return an exception in onError in these cases. So one needs to manually support handling \"out of activity\" type actions.\n\nOne can stick a bundle in savedInstanceState and pickup that bundle in onActivityResult, that bundle should contain enough information to continue the rx mid flow (this means you'd need to have multiple chained observables for the original request). \n\nChances are we're gonnna post that bundle/an object on an event bus and pick it up in the same location that we do the original request. To keep the logic for handling it in the same place.\n. Example gist : https://gist.github.com/andaag/cb3e3ded2d8d21f02388\n. We wrote code for this for changing location settings, and I've now used the approach for permissions as well. Since we've code the code already written I'll stick it into a library and put it on github probably sometime tomorrow.\n\nIt's the best workaround to the problem of serialization I've been able to come up with atleast.\n\n//Edit : very open for suggestions for names on this as well :p. RxActivityRestart/RxWithSerialization?...\n. https://bintray.com/finnandroid/maven/rxactivityresponse/0.1/view#files\nhttps://github.com/finn-no/rxactivityresponse\n\nI'll push out a library to support google play settings next week. So one can do things like\n\n```\nRxLocation.get(restartHandler).subscribe(v -> {})\n```\n\nAnd get a flow that first asks for location, then asks for gps enabled, then gets a location and returns it. Safe from activity restarts/rotations halfway through.\n\nWe would have made this a PR, but it's an entirely different approach. With it's own pro's and con's. (Pro's being it'll always work, con being it's more work to support it. Chances are some users would be happy to cover the 95% case). However we'll be using this solution to solve other problems as well. For example getting a picture from the gallery, where your app is fairly likely to be dumped from memory halfway through the process.\n. @tbruyelle Hm, that would work, but it puts some pretty big limits on code structure. We have an app with 100+ views (using views instead of fragments as well), and having all of our permission related code in the single activity onCreate isn't really an option. It is considerably easier for those where that is an option though.\n\nFor just glancing at the code, I'm guessing your using the permission itself as an identifier for the request? That means you can only request a permission from one place in the app. If you want the camera permission in 3 different places your gonna need another identifier.\n. Right you are... That.. is a better solution.\n\nI had a look at it, and overall it looks fine, but since the singleton is a static referanse and you never remove anything from mSubjects it'll leak. I dont see any other choice here but to remove from that on unsubscribe and require clients to implement that. (Or hold a weak ref to subscribers, but that'll require the activity to hold an active referance to it or be GC'd. Cant be an inner referance).\n\nSince this is a better approach I'd like to extend this to support onActivityResult as well. Making a seperate issue for that though to keep this on task. See #15 \n. I'm on my phone right now, so reviewing code is a bit tricky. I'm talking about the case where the user doesn't trigger the action that requires the permission. In that case you are holding the observer which is an inner function holding the activity right? \n. That'll break if you use it in fragments with the same activity though. \n\nI guess it's possible to make a destroy that takes the view / fragment / activity as id and destroy(id), but unsubscribe might be just as clean... Not sure really. \n. Also, another idea... Just an idea, I can't really decide whether or not I like it better.\n\nIf instead of a trigger you hold the subscription. Then you could make the observable a field, and in onClick trigger a .subscribe. Then you dont need RxView for anything.\n\nI can't decide if I like this or not, but since I can't decide I figured I'd mention it and you can think it over as well :p. I think it might be better at dealing with special cases, for example if you want to immediately start showing a spinner, then request permission or something like that.\n. Also, currently the branch doesn't allow you to click the button more than once. Not an issue with \"turn camera on\" functionality, but it'll break a whole lot of other flows.\n. Might not need to share much code really... The only thing would be the shadow activity, and that isn't much to just duplicate :p\n. This can't be solved.. If you shoot off another activity you always risk being garbage collected, that means the observable will disappear. You can't solve that as you cant serialize an observable mid stream.\n. @tbruyelle \n1. User clicks something that requires a permission\n2. Permission dialog pops up\n3. User leaves app to google what the permission means.\n4. Browser requires memory and app gets removed from active memory.\n5. User jumps back in app, clicks accept, but everything is serialized, and rx breaks.\n\nThis is a very special case, but it is a case... Might be worth it for some people to use rx anyway though, and know that that case wont be handled very well.\n. What we're going to do at my company to use rx for this kind of flow (locationsettings for example). Is to simply return an exception in onError in these cases. So one needs to manually support handling \"out of activity\" type actions.\n\nOne can stick a bundle in savedInstanceState and pickup that bundle in onActivityResult, that bundle should contain enough information to continue the rx mid flow (this means you'd need to have multiple chained observables for the original request). \n\nChances are we're gonnna post that bundle/an object on an event bus and pick it up in the same location that we do the original request. To keep the logic for handling it in the same place.\n. Example gist : https://gist.github.com/andaag/cb3e3ded2d8d21f02388\n. We wrote code for this for changing location settings, and I've now used the approach for permissions as well. Since we've code the code already written I'll stick it into a library and put it on github probably sometime tomorrow.\n\nIt's the best workaround to the problem of serialization I've been able to come up with atleast.\n\n//Edit : very open for suggestions for names on this as well :p. RxActivityRestart/RxWithSerialization?...\n. https://bintray.com/finnandroid/maven/rxactivityresponse/0.1/view#files\nhttps://github.com/finn-no/rxactivityresponse\n\nI'll push out a library to support google play settings next week. So one can do things like\n\n```\nRxLocation.get(restartHandler).subscribe(v -> {})\n```\n\nAnd get a flow that first asks for location, then asks for gps enabled, then gets a location and returns it. Safe from activity restarts/rotations halfway through.\n\nWe would have made this a PR, but it's an entirely different approach. With it's own pro's and con's. (Pro's being it'll always work, con being it's more work to support it. Chances are some users would be happy to cover the 95% case). However we'll be using this solution to solve other problems as well. For example getting a picture from the gallery, where your app is fairly likely to be dumped from memory halfway through the process.\n. @tbruyelle Hm, that would work, but it puts some pretty big limits on code structure. We have an app with 100+ views (using views instead of fragments as well), and having all of our permission related code in the single activity onCreate isn't really an option. It is considerably easier for those where that is an option though.\n\nFor just glancing at the code, I'm guessing your using the permission itself as an identifier for the request? That means you can only request a permission from one place in the app. If you want the camera permission in 3 different places your gonna need another identifier.\n. Right you are... That.. is a better solution.\n\nI had a look at it, and overall it looks fine, but since the singleton is a static referanse and you never remove anything from mSubjects it'll leak. I dont see any other choice here but to remove from that on unsubscribe and require clients to implement that. (Or hold a weak ref to subscribers, but that'll require the activity to hold an active referance to it or be GC'd. Cant be an inner referance).\n\nSince this is a better approach I'd like to extend this to support onActivityResult as well. Making a seperate issue for that though to keep this on task. See #15 \n. I'm on my phone right now, so reviewing code is a bit tricky. I'm talking about the case where the user doesn't trigger the action that requires the permission. In that case you are holding the observer which is an inner function holding the activity right? \n. That'll break if you use it in fragments with the same activity though. \n\nI guess it's possible to make a destroy that takes the view / fragment / activity as id and destroy(id), but unsubscribe might be just as clean... Not sure really. \n. Also, another idea... Just an idea, I can't really decide whether or not I like it better.\n\nIf instead of a trigger you hold the subscription. Then you could make the observable a field, and in onClick trigger a .subscribe. Then you dont need RxView for anything.\n\nI can't decide if I like this or not, but since I can't decide I figured I'd mention it and you can think it over as well :p. I think it might be better at dealing with special cases, for example if you want to immediately start showing a spinner, then request permission or something like that.\n. Also, currently the branch doesn't allow you to click the button more than once. Not an issue with \"turn camera on\" functionality, but it'll break a whole lot of other flows.\n. Might not need to share much code really... The only thing would be the shadow activity, and that isn't much to just duplicate :p\n. ",
    "Rainer-Lang": "+1 \n. But is there a way to integrate it seamless into the lib? \n. I understand you. \nBut maybe you could give a tipp to do it with your lib. \n. +1 \n. But is there a way to integrate it seamless into the lib? \n. I understand you. \nBut maybe you could give a tipp to do it with your lib. \n. ",
    "ffgiraldez": "Using `ContextCompat` and `ActivityCompat` instead of activity directly will automatic grant access on pre M\nthe android training https://developer.android.com/intl/es/training/permissions/requesting.html use them\n. Using `ContextCompat` and `ActivityCompat` instead of activity directly will automatic grant access on pre M\nthe android training https://developer.android.com/intl/es/training/permissions/requesting.html use them\n. ",
    "vanniktech": "Yup that'd work. Though I think it should return the concrete type of the map. So if the library would internally use HashMap it should also return HashMap type. That way the consumer of the library knows what he's working with.\n. Exactly. That way the consumer knows he gets HashMap hence he knows the implementation details. Methods should always accept the most abstract input (Collection, Map, ...) but return the most concrete return type (ArrayList, HashSet, HashMap, TreeMap).\n. One question though. There's an `onDestroy` method in the RxPermissions class however it is not called in the sample app, do I need to call the `onDestroy` method or not? A little bit more information about that method would be splendid.\n. Oh okay my bad. Thanks! :)\n. Yeah I don't know it either. I know that I could disable the check with\n\n``` java\n// noinspection ResourceType\ntakePicture();\n```\n. @tbruyelle anything you found out on this one? I guess the lib itself can't really do much in this case.\n. Then let's leave it and close this one.\n. Oh ok then sorry for opening the issue.\n. As far as I understood it there can be policies which do deny you to use that particular permission. The only thing that I do not know is whether `shouldShowRequestPermissionRationale` checks the `isPermissionRevokedByPolicy` internally or not.\n. So basically when calling `request`, `ensure` or the methods alike of `RxPermission` I need to have an activity that is visible?\n. Alright that makes it clear. Maybe this should be added to the README.\n. From my side this issue could be closed. It's up to you whether you want to update the javadoc and README or not.\n. > I don't want to change the package name or the artifactId\n\nThat's basically the way to go. Also RxAndroid does it that way 2 branches (1.x and 2.x) with different package ids + artifact ids.\n. Well since Rx1 & Rx2 are binary incompatible and have a different package names it's super impractical to have a library that's capable of running both versions.\n\nHow about:\n`com.tbruyelle.rxpermissions` becomes `com.tbruyelle.rxpermissions2`\n`com.tbruyelle.rxpermissions:rxpermissions:0.7.0@aar` becomes `com.tbruyelle.rxpermissions:rxpermissions2:0.7.0@aar`\n\nVersion 1 would be in 1.x branch, Version 2 in 2.x branch. Also I would not say that this project is any different from RxAndroid. Both rely on RxJava and build on top of it.\n. Pretty sure Jake will follow his [own advice](http://jakewharton.com/java-interoperability-policy-for-major-version-updates/)\n. Is someone already working on porting it?\n. I might find some time next week if no one else has started on it\n. Yeah it makes hardly sense to filter one emitted item. Worst case `request(..).toObservable().filter(..)` can be done.\n\nAre you willing to support both RxJava versions in parallel meaning different package name + artifact id or should I fork it and distribute the RxJava 2 part?\n. Can you create a corresponding 2.x branch? I've got a first version ready\n. Created a PR: #80 - happy to receive some feedback\n. I know. ObservableTransformer got changed.\n. https://github.com/vanniktech/RxPermissions/pull/2 although generics are still failing in tests\n. @tbruyelle I know but I first wanted to hear whether this is a change / enhancement that is wanted or not before investing more time in tests.\n. Alright cool maybe you can help me with the following:\n\nConsider a button 'I allow camera permission'.\n- If you press the button for the first time the normal Android Permission Dialog is shown. You deny it.\n- Next time you press it you deny it again with \"don't ask again'.\n- Now if you press it a third time you won't get the dialog anymore because you pressed \"don't ask again\". The only way to enable the permission now is to go to the settings.\n\nI'm trying to implement the above UI example and I'm having a hard time with it.\n\n``` java\nrxPermissions.requestEach(Manifest.permission.CAMERA)\n  .first()\n  .toSingle()\n  .subscribe(permission -> {\n    if (!permission.shouldShowRequestPermissionRationale) {\n      // Need to go to the settings\n    } else if (permission.granted) {\n      // All good\n    } else {\n      // Denied permission\n    }\n  });\n```\n\nThe problem is that even the first time I click on \"don't ask again\" I end up in `// Need to go to the settings` and that's not desired behavior as I only want to go into the settings the next time he presses that button.\n\nAny thoughts on that?\n. I think the `shouldShowRequestPermissionRationale` check would need to be done before asking for the permission. Doing it after the permission has been allowed / denied is one step to late. What do you think?\n. What works for me now is doing the work of the `shouldShowRequestPermissionRationale` array in `handleIntent()` instead. Basically before requesting I check the rationale status for every permission.\n. Maybe the documentation is wrong?\n\nExecuting `shouldShowRequestPermissionRationale` after the permission:\n- If you press the button for the first time the normal Android Permission Dialog is shown. You deny it. **returns true**\n- Next time you press it you deny it again with \"don't ask again'. **returns false**\n- Now if you press it a third time you won't get the dialog anymore because you pressed \"don't ask again\". The only way to enable the permission now is to go to the setting **returns false**\n\nExecuting `shouldShowRequestPermissionRationale` before the permission:\n- If you press the button for the first time the normal Android Permission Dialog is shown. You deny it. **returns true**\n- Next time you press it you deny it again with \"don't ask again'. **returns true**\n- Now if you press it a third time you won't get the dialog anymore because you pressed \"don't ask again\". The only way to enable the permission now is to go to the setting **returns false**\n\nI'd argue that this is expected behavior.\n. Yup that is the one. `after` does not work for my use case. `before` does. Now the question is which should be implemented in the library? I'm voting for the `before` case however others may have a different opinion.\n. Well it's not ambiguous before the request. If you have checked \"don't ask again\" you'll still end up in `onPermissionResult` and will get a granted of `false`. \n\nPlus the first time it may be that `shouldShowRequest` is false which is not wanted however you can't choose \"don't ask again\" the first time.\n. @tbruyelle If you just pressed the deny button and checked \"don't ask again\" I don't want to navigate the user into the settings. However if the user comes back and then presses that button and the Android Dialog can't be shown anymore since the user pressed \"don't ask again\" then I need to navigate the user into the settings.\n. Well because that separate behavior is wanted and with asking `before` the permission you are able to do that.\n\nMaybe both values should be taken into permission. The value before asking the permission and the value after the user did that.\n. Alright fair enough. Though adding this extra code is super clunky as I need to get a reference to an Activity after that permission request is done and check that state and then I also need to persist it because otherwise I can't differentiate between the events.\n\nI'll just stick with my fork and have a local copy of this library with the modification that I need then.\n. The thing is though that when you request the permission for the first time you'll always get a response back (either granted or not granted). Also the first time I still get `shouldShowRequestPermissionRationale=true`\n. Plus it's probably smarter to do the `if (granted)` check first so that `shouldShowRequestPermissionRationale` does not go into our way.\n. Not from my side. I'll leave it up to the repo owners. Also I'm now using RxPermissions with Rx2 support containing this in my own fork. (Distributed via jitpack for now)\n. Nope moved away from Rx1\n. Weird tests are locally passing on my machine.\n. Updated now to RC3 which also works fine. Anything that is stopping this?\n. That's true\n. On first glance the idea seems smart although I'm not so sure whether this can have any drawbacks since it's still a Fragment and they behave oddly. At least that's how I feel about them. I try to avoid them as much as I can.\r\n\r\nAlso this 'hack' of a transparent activity is quite common, no? I've seen it already in a few other places as well.\r\n\r\nAlso before I was able to use RxPermissions regardless of an activity being present or not which means I was able to use it in Services and other places where no activity is present.\r\n\r\nNow even for checking whether a permission is granted or not it needs a fragment.\r\n\r\nAlso I'm not sure whether the library should use the 'real' fragments or `v4` fragments and whether or not by using both as a consumer things could get mingled up.\r\n\r\nAnother thing that I've seen often times is that devs are manually manipulating the fragment stack e.g. via pushing or popping fragments. So in theory could this change go and break if someone suddenly tries to pop the fragment while the permission request is in process or was just recently started?. Alright cool @epool, thanks for answering my questions. . Yup that'd work. Though I think it should return the concrete type of the map. So if the library would internally use HashMap it should also return HashMap type. That way the consumer of the library knows what he's working with.\n. Exactly. That way the consumer knows he gets HashMap hence he knows the implementation details. Methods should always accept the most abstract input (Collection, Map, ...) but return the most concrete return type (ArrayList, HashSet, HashMap, TreeMap).\n. One question though. There's an `onDestroy` method in the RxPermissions class however it is not called in the sample app, do I need to call the `onDestroy` method or not? A little bit more information about that method would be splendid.\n. Oh okay my bad. Thanks! :)\n. Yeah I don't know it either. I know that I could disable the check with\n\n``` java\n// noinspection ResourceType\ntakePicture();\n```\n. @tbruyelle anything you found out on this one? I guess the lib itself can't really do much in this case.\n. Then let's leave it and close this one.\n. Oh ok then sorry for opening the issue.\n. As far as I understood it there can be policies which do deny you to use that particular permission. The only thing that I do not know is whether `shouldShowRequestPermissionRationale` checks the `isPermissionRevokedByPolicy` internally or not.\n. So basically when calling `request`, `ensure` or the methods alike of `RxPermission` I need to have an activity that is visible?\n. Alright that makes it clear. Maybe this should be added to the README.\n. From my side this issue could be closed. It's up to you whether you want to update the javadoc and README or not.\n. > I don't want to change the package name or the artifactId\n\nThat's basically the way to go. Also RxAndroid does it that way 2 branches (1.x and 2.x) with different package ids + artifact ids.\n. Well since Rx1 & Rx2 are binary incompatible and have a different package names it's super impractical to have a library that's capable of running both versions.\n\nHow about:\n`com.tbruyelle.rxpermissions` becomes `com.tbruyelle.rxpermissions2`\n`com.tbruyelle.rxpermissions:rxpermissions:0.7.0@aar` becomes `com.tbruyelle.rxpermissions:rxpermissions2:0.7.0@aar`\n\nVersion 1 would be in 1.x branch, Version 2 in 2.x branch. Also I would not say that this project is any different from RxAndroid. Both rely on RxJava and build on top of it.\n. Pretty sure Jake will follow his [own advice](http://jakewharton.com/java-interoperability-policy-for-major-version-updates/)\n. Is someone already working on porting it?\n. I might find some time next week if no one else has started on it\n. Yeah it makes hardly sense to filter one emitted item. Worst case `request(..).toObservable().filter(..)` can be done.\n\nAre you willing to support both RxJava versions in parallel meaning different package name + artifact id or should I fork it and distribute the RxJava 2 part?\n. Can you create a corresponding 2.x branch? I've got a first version ready\n. Created a PR: #80 - happy to receive some feedback\n. I know. ObservableTransformer got changed.\n. https://github.com/vanniktech/RxPermissions/pull/2 although generics are still failing in tests\n. @tbruyelle I know but I first wanted to hear whether this is a change / enhancement that is wanted or not before investing more time in tests.\n. Alright cool maybe you can help me with the following:\n\nConsider a button 'I allow camera permission'.\n- If you press the button for the first time the normal Android Permission Dialog is shown. You deny it.\n- Next time you press it you deny it again with \"don't ask again'.\n- Now if you press it a third time you won't get the dialog anymore because you pressed \"don't ask again\". The only way to enable the permission now is to go to the settings.\n\nI'm trying to implement the above UI example and I'm having a hard time with it.\n\n``` java\nrxPermissions.requestEach(Manifest.permission.CAMERA)\n  .first()\n  .toSingle()\n  .subscribe(permission -> {\n    if (!permission.shouldShowRequestPermissionRationale) {\n      // Need to go to the settings\n    } else if (permission.granted) {\n      // All good\n    } else {\n      // Denied permission\n    }\n  });\n```\n\nThe problem is that even the first time I click on \"don't ask again\" I end up in `// Need to go to the settings` and that's not desired behavior as I only want to go into the settings the next time he presses that button.\n\nAny thoughts on that?\n. I think the `shouldShowRequestPermissionRationale` check would need to be done before asking for the permission. Doing it after the permission has been allowed / denied is one step to late. What do you think?\n. What works for me now is doing the work of the `shouldShowRequestPermissionRationale` array in `handleIntent()` instead. Basically before requesting I check the rationale status for every permission.\n. Maybe the documentation is wrong?\n\nExecuting `shouldShowRequestPermissionRationale` after the permission:\n- If you press the button for the first time the normal Android Permission Dialog is shown. You deny it. **returns true**\n- Next time you press it you deny it again with \"don't ask again'. **returns false**\n- Now if you press it a third time you won't get the dialog anymore because you pressed \"don't ask again\". The only way to enable the permission now is to go to the setting **returns false**\n\nExecuting `shouldShowRequestPermissionRationale` before the permission:\n- If you press the button for the first time the normal Android Permission Dialog is shown. You deny it. **returns true**\n- Next time you press it you deny it again with \"don't ask again'. **returns true**\n- Now if you press it a third time you won't get the dialog anymore because you pressed \"don't ask again\". The only way to enable the permission now is to go to the setting **returns false**\n\nI'd argue that this is expected behavior.\n. Yup that is the one. `after` does not work for my use case. `before` does. Now the question is which should be implemented in the library? I'm voting for the `before` case however others may have a different opinion.\n. Well it's not ambiguous before the request. If you have checked \"don't ask again\" you'll still end up in `onPermissionResult` and will get a granted of `false`. \n\nPlus the first time it may be that `shouldShowRequest` is false which is not wanted however you can't choose \"don't ask again\" the first time.\n. @tbruyelle If you just pressed the deny button and checked \"don't ask again\" I don't want to navigate the user into the settings. However if the user comes back and then presses that button and the Android Dialog can't be shown anymore since the user pressed \"don't ask again\" then I need to navigate the user into the settings.\n. Well because that separate behavior is wanted and with asking `before` the permission you are able to do that.\n\nMaybe both values should be taken into permission. The value before asking the permission and the value after the user did that.\n. Alright fair enough. Though adding this extra code is super clunky as I need to get a reference to an Activity after that permission request is done and check that state and then I also need to persist it because otherwise I can't differentiate between the events.\n\nI'll just stick with my fork and have a local copy of this library with the modification that I need then.\n. The thing is though that when you request the permission for the first time you'll always get a response back (either granted or not granted). Also the first time I still get `shouldShowRequestPermissionRationale=true`\n. Plus it's probably smarter to do the `if (granted)` check first so that `shouldShowRequestPermissionRationale` does not go into our way.\n. Not from my side. I'll leave it up to the repo owners. Also I'm now using RxPermissions with Rx2 support containing this in my own fork. (Distributed via jitpack for now)\n. Nope moved away from Rx1\n. Weird tests are locally passing on my machine.\n. Updated now to RC3 which also works fine. Anything that is stopping this?\n. That's true\n. On first glance the idea seems smart although I'm not so sure whether this can have any drawbacks since it's still a Fragment and they behave oddly. At least that's how I feel about them. I try to avoid them as much as I can.\r\n\r\nAlso this 'hack' of a transparent activity is quite common, no? I've seen it already in a few other places as well.\r\n\r\nAlso before I was able to use RxPermissions regardless of an activity being present or not which means I was able to use it in Services and other places where no activity is present.\r\n\r\nNow even for checking whether a permission is granted or not it needs a fragment.\r\n\r\nAlso I'm not sure whether the library should use the 'real' fragments or `v4` fragments and whether or not by using both as a consumer things could get mingled up.\r\n\r\nAnother thing that I've seen often times is that devs are manually manipulating the fragment stack e.g. via pushing or popping fragments. So in theory could this change go and break if someone suddenly tries to pop the fragment while the permission request is in process or was just recently started?. Alright cool @epool, thanks for answering my questions. . ",
    "alorma": "Not agree with `HashMap` return.\n\nIt's better to work with interfaces rather than implementations, if in a future it changes to LinkedMap, clients should changes the implementation\n. Not agree with `HashMap` return.\n\nIt's better to work with interfaces rather than implementations, if in a future it changes to LinkedMap, clients should changes the implementation\n. ",
    "dadino": "I'm still at the start with RxJava so this may sound silly.\nWouldn't it be correct to have a .subscribe event for every permission?\n\n```\nRxPermissions.getInstance(context) \n            .request(Manifest.permission.CAMERA,\n                   Manifest.permission.READ_PHONE_STATE)\n            .subscribe(permission -> {\n                if (permission.isGranted()) {\n                   // Permission granted\n                } else if (permission.shouldRequestAgain()){\n                   // Permission was denied, but you could request it again\n                } else {\n                   // Permission was denied and the user doesn't want to be bothered\n                }\n            });\n\nclass Permission{\n  String permission;\n  int state; //granted, denied, denied_could_request_again\n}\n```\n\nYou could also call onCompleted and pass a List<Permission> if you want them together.\n. Yes they are related, just wrong spelling on my part.\nMy way should be less code to write and maybe a little more readable, but, again, I've been using RxJava for 3 days, I don't understand best practices.\n. Looks good.\n. I'm still at the start with RxJava so this may sound silly.\nWouldn't it be correct to have a .subscribe event for every permission?\n\n```\nRxPermissions.getInstance(context) \n            .request(Manifest.permission.CAMERA,\n                   Manifest.permission.READ_PHONE_STATE)\n            .subscribe(permission -> {\n                if (permission.isGranted()) {\n                   // Permission granted\n                } else if (permission.shouldRequestAgain()){\n                   // Permission was denied, but you could request it again\n                } else {\n                   // Permission was denied and the user doesn't want to be bothered\n                }\n            });\n\nclass Permission{\n  String permission;\n  int state; //granted, denied, denied_could_request_again\n}\n```\n\nYou could also call onCompleted and pass a List<Permission> if you want them together.\n. Yes they are related, just wrong spelling on my part.\nMy way should be less code to write and maybe a little more readable, but, again, I've been using RxJava for 3 days, I don't understand best practices.\n. Looks good.\n. ",
    "Tony---Zhang": "Good point\n. :facepunch: \n. When will this PR go to production?\n. Good point\n. :facepunch: \n. When will this PR go to production?\n. ",
    "ghost": ":+1:\n. I've tried with Manifest.permission.ACCESS_COARSE_LOCATION in one place and Manifest.permission.CAMERA in another, both of them are throwing the code I've put when it's not granted without prompting the popup.\n. I've found what the issue is, apparently the uses-permission had maxSdk to 23 and it was preventing it to behave correctly. My bad, sorry for the inconvenience. You can close this issue and great work with the library!\n. :+1:\n. I've tried with Manifest.permission.ACCESS_COARSE_LOCATION in one place and Manifest.permission.CAMERA in another, both of them are throwing the code I've put when it's not granted without prompting the popup.\n. I've found what the issue is, apparently the uses-permission had maxSdk to 23 and it was preventing it to behave correctly. My bad, sorry for the inconvenience. You can close this issue and great work with the library!\n. ",
    "BenGroot": "I'm sorry, I see that you're working on solutions to fix the rotation issue. I'll go through that thread to check the current status.\n. What if your app doesn't support screen rotation, are you confident to use it then?\n. Clear, thanks! \nI can see that you're already looking at it with a lot of really smart people (including yourself). Although, I'll try to contribute if possible.\n. I'm sorry, I see that you're working on solutions to fix the rotation issue. I'll go through that thread to check the current status.\n. What if your app doesn't support screen rotation, are you confident to use it then?\n. Clear, thanks! \nI can see that you're already looking at it with a lot of really smart people (including yourself). Although, I'll try to contribute if possible.\n. ",
    "andretietz": "you don't force users into using fragments, just because your library is using it. It can be completely independent of using fragments or not. clearly the library is using fragments then, but this is totally fine, the developer don't need to care\n. correct, but only to get the actual instance of the fragment. So initializing, you would have todo in each activity of course (or let some DI handle this for you ;) )\n\nyou do it with the context as well, so there's no disadvantage as far as I see. but you're reusing the fragment, instead of creating new activities\n. I am not saying that this is a bad solution, I just wanted to discuss this a bit in detail.\n@eleventigers No history would be a better solution, since right now, it's \"new_task\"\nhttps://github.com/tbruyelle/RxPermissions/blob/master/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L161\n@tbruyelle hating fragments is sadly not a reason ;)\n. I agree, with your opinion about fragments in case of UI Fragments (Even though, it's still a good option for phone/tablet layouts i.e. master-detail), we try to avoid those @ work as well. But since this isn't directly UI related, I think it's worth considering, therefore the discussion.\n. That's what I was talking about ;)\n. sorry\n. Yeah, sorry, sometimes my eyes play with me..., havn't seen the \"result\" variable after the 31 :D\n. you don't force users into using fragments, just because your library is using it. It can be completely independent of using fragments or not. clearly the library is using fragments then, but this is totally fine, the developer don't need to care\n. correct, but only to get the actual instance of the fragment. So initializing, you would have todo in each activity of course (or let some DI handle this for you ;) )\n\nyou do it with the context as well, so there's no disadvantage as far as I see. but you're reusing the fragment, instead of creating new activities\n. I am not saying that this is a bad solution, I just wanted to discuss this a bit in detail.\n@eleventigers No history would be a better solution, since right now, it's \"new_task\"\nhttps://github.com/tbruyelle/RxPermissions/blob/master/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L161\n@tbruyelle hating fragments is sadly not a reason ;)\n. I agree, with your opinion about fragments in case of UI Fragments (Even though, it's still a good option for phone/tablet layouts i.e. master-detail), we try to avoid those @ work as well. But since this isn't directly UI related, I think it's worth considering, therefore the discussion.\n. That's what I was talking about ;)\n. sorry\n. Yeah, sorry, sometimes my eyes play with me..., havn't seen the \"result\" variable after the 31 :D\n. ",
    "digitalbuddha": "It's not that people hate fragments for no reason, it's because fragments have weird illegalstateexceptions and unexpected lifecycle weirdness (on destroy not being called and the like).  Fragments are the #1 cause of bugs within the NY Times app and why we are moving  away from them. \n. It's not that people hate fragments for no reason, it's because fragments have weird illegalstateexceptions and unexpected lifecycle weirdness (on destroy not being called and the like).  Fragments are the #1 cause of bugs within the NY Times app and why we are moving  away from them. \n. ",
    "richarddd": "Just a heads up regarding noHistory flag and requesting permissions. There is a bug in Android preventing the result callback to execute while using \"noHistory\" https://code.google.com/p/android-developer-preview/issues/detail?id=2915\n. Just a heads up regarding noHistory flag and requesting permissions. There is a bug in Android preventing the result callback to execute while using \"noHistory\" https://code.google.com/p/android-developer-preview/issues/detail?id=2915\n. ",
    "hanibalsk": "I had same error today in Craslytics(lg_h815 - Android 6.0):\n\n```\nFatal Exception: java.lang.RuntimeException\nFailure delivering result ResultInfo{who=@android:requestPermissions:, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS (has extras) }} to activity {xxx/com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n Raw\nandroid.app.ActivityThread.deliverResults (ActivityThread.java:3742)\ncom.android.internal.os.ZygoteInit.main (ZygoteInit.java:620)\n\nCaused by java.lang.IllegalStateException\ncom.tbruyelle.rxpermissions.RxPermissions.onRequestPermissionsResult (RxPermissions.java:286)\ncom.tbruyelle.rxpermissions.ShadowActivity.onRequestPermissionsResult (ShadowActivity.java:32)\nandroid.app.Activity.dispatchRequestPermissionsResult (Activity.java:6588)\nandroid.app.Activity.dispatchActivityResult (Activity.java:6467)\nandroid.app.ActivityThread.deliverResults (ActivityThread.java:3738)\nandroid.app.ActivityThread.handleSendResult (ActivityThread.java:3785)\nandroid.app.ActivityThread.access$1400 (ActivityThread.java:157)\nandroid.app.ActivityThread$H.handleMessage (ActivityThread.java:1405)\nandroid.os.Handler.dispatchMessage (Handler.java:102)\nandroid.os.Looper.loop (Looper.java:148)\nandroid.app.ActivityThread.main (ActivityThread.java:5525)\njava.lang.reflect.Method.invoke (Method.java)\ncom.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:730)\ncom.android.internal.os.ZygoteInit.main (ZygoteInit.java:620)\n```\n. I had same error today in Craslytics(lg_h815 - Android 6.0):\n\n```\nFatal Exception: java.lang.RuntimeException\nFailure delivering result ResultInfo{who=@android:requestPermissions:, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS (has extras) }} to activity {xxx/com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n Raw\nandroid.app.ActivityThread.deliverResults (ActivityThread.java:3742)\ncom.android.internal.os.ZygoteInit.main (ZygoteInit.java:620)\n\nCaused by java.lang.IllegalStateException\ncom.tbruyelle.rxpermissions.RxPermissions.onRequestPermissionsResult (RxPermissions.java:286)\ncom.tbruyelle.rxpermissions.ShadowActivity.onRequestPermissionsResult (ShadowActivity.java:32)\nandroid.app.Activity.dispatchRequestPermissionsResult (Activity.java:6588)\nandroid.app.Activity.dispatchActivityResult (Activity.java:6467)\nandroid.app.ActivityThread.deliverResults (ActivityThread.java:3738)\nandroid.app.ActivityThread.handleSendResult (ActivityThread.java:3785)\nandroid.app.ActivityThread.access$1400 (ActivityThread.java:157)\nandroid.app.ActivityThread$H.handleMessage (ActivityThread.java:1405)\nandroid.os.Handler.dispatchMessage (Handler.java:102)\nandroid.os.Looper.loop (Looper.java:148)\nandroid.app.ActivityThread.main (ActivityThread.java:5525)\njava.lang.reflect.Method.invoke (Method.java)\ncom.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:730)\ncom.android.internal.os.ZygoteInit.main (ZygoteInit.java:620)\n```\n. ",
    "VitalyKolchenko": "+1 Same error on Samsyng galaxy edge 7 in crashlytics \n\nFatal Exception: java.lang.RuntimeException: Unable to resume activity {com.bound360.temed.patient/com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.RuntimeException: Failure delivering result ResultInfo{who=@android:requestPermissions:, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS VirtualScreenParam=Params{mDisplayId=-1, null, mFlags=0x00000000)} (has extras) }} to activity {com.bound360.temed.patient/com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:4156)\n       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:4250)\n       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3361)\n       at android.app.ActivityThread.access$1100(ActivityThread.java:222)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1795)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:158)\n       at android.app.ActivityThread.main(ActivityThread.java:7229)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\nCaused by java.lang.RuntimeException: Failure delivering result ResultInfo{who=@android:requestPermissions:, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS VirtualScreenParam=Params{mDisplayId=-1, null, mFlags=0x00000000)} (has extras) }} to activity {com.bound360.temed.patient/com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n       at android.app.ActivityThread.deliverResults(ActivityThread.java:4925)\n       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:4142)\n       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:4250)\n       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3361)\n       at android.app.ActivityThread.access$1100(ActivityThread.java:222)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1795)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:158)\n       at android.app.ActivityThread.main(ActivityThread.java:7229)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\nCaused by java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n       at com.tbruyelle.rxpermissions.RxPermissions.onRequestPermissionsResult(RxPermissions.java:286)\n       at com.tbruyelle.rxpermissions.ShadowActivity.onRequestPermissionsResult(ShadowActivity.java:32)\n       at android.app.Activity.dispatchRequestPermissionsResult(Activity.java:7263)\n       at android.app.Activity.dispatchActivityResult(Activity.java:7141)\n       at android.app.ActivityThread.deliverResults(ActivityThread.java:4921)\n       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:4142)\n       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:4250)\n       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3361)\n       at android.app.ActivityThread.access$1100(ActivityThread.java:222)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1795)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:158)\n       at android.app.ActivityThread.main(ActivityThread.java:7229)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\n. +1 Same error on Samsyng galaxy edge 7 in crashlytics \n\nFatal Exception: java.lang.RuntimeException: Unable to resume activity {com.bound360.temed.patient/com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.RuntimeException: Failure delivering result ResultInfo{who=@android:requestPermissions:, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS VirtualScreenParam=Params{mDisplayId=-1, null, mFlags=0x00000000)} (has extras) }} to activity {com.bound360.temed.patient/com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:4156)\n       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:4250)\n       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3361)\n       at android.app.ActivityThread.access$1100(ActivityThread.java:222)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1795)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:158)\n       at android.app.ActivityThread.main(ActivityThread.java:7229)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\nCaused by java.lang.RuntimeException: Failure delivering result ResultInfo{who=@android:requestPermissions:, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS VirtualScreenParam=Params{mDisplayId=-1, null, mFlags=0x00000000)} (has extras) }} to activity {com.bound360.temed.patient/com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n       at android.app.ActivityThread.deliverResults(ActivityThread.java:4925)\n       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:4142)\n       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:4250)\n       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3361)\n       at android.app.ActivityThread.access$1100(ActivityThread.java:222)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1795)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:158)\n       at android.app.ActivityThread.main(ActivityThread.java:7229)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\nCaused by java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n       at com.tbruyelle.rxpermissions.RxPermissions.onRequestPermissionsResult(RxPermissions.java:286)\n       at com.tbruyelle.rxpermissions.ShadowActivity.onRequestPermissionsResult(ShadowActivity.java:32)\n       at android.app.Activity.dispatchRequestPermissionsResult(Activity.java:7263)\n       at android.app.Activity.dispatchActivityResult(Activity.java:7141)\n       at android.app.ActivityThread.deliverResults(ActivityThread.java:4921)\n       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:4142)\n       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:4250)\n       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3361)\n       at android.app.ActivityThread.access$1100(ActivityThread.java:222)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1795)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:158)\n       at android.app.ActivityThread.main(ActivityThread.java:7229)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\n. ",
    "kcmk": "Please check it.\n\nmCtx.checkSelfPermission(permission) always return 0 when I set targetSdk 22 \n. ```\n@TargetApi(Build.VERSION_CODES.M)\n    private boolean hasPermission_(String... permissions) {\n        for (String permission : permissions) {\n            if (mCtx.checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        return true;\n    }\n```\n\nin RxPermissions.java\n. (compileSdk 23) current sdk 23 (nexus5 android 6.0) but targetSdk 18 in gradle and `hasPermission_` is always return 0.\n\nif targetSdk is not 23, permissions dialog is not showing never .\n\nI will update my app and Do I have to set targetSdk 23. I want to still granted permissions.\n. Please check it.\n\nmCtx.checkSelfPermission(permission) always return 0 when I set targetSdk 22 \n. ```\n@TargetApi(Build.VERSION_CODES.M)\n    private boolean hasPermission_(String... permissions) {\n        for (String permission : permissions) {\n            if (mCtx.checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        return true;\n    }\n```\n\nin RxPermissions.java\n. (compileSdk 23) current sdk 23 (nexus5 android 6.0) but targetSdk 18 in gradle and `hasPermission_` is always return 0.\n\nif targetSdk is not 23, permissions dialog is not showing never .\n\nI will update my app and Do I have to set targetSdk 23. I want to still granted permissions.\n. ",
    "saadfarooq": "Got it... will try to put up a PR when I get the time\n. Got it... will try to put up a PR when I get the time\n. ",
    "martyglaubitz": "oh there it is, very well...\n. oh there it is, very well...\n. ",
    "chond": "To solve the problem, this is the best thing\n. To solve the problem, this is the best thing\n. ",
    "PrashamTrivedi": "Point 2: trello's rxlifecycle library is developed to listen to activity or fragment and they will unsubscribe automatically once (certain event or) activity or fragment ends. I recommend you to check it out, and check if it can be integrated nicely.\n\nPoint 4: in the code there is a check for is marshmallow, and use it to get return permission granted or not. While support library does it. Why don't delegate this to support library rather than doing it manually?\n. Point 2: trello's rxlifecycle library is developed to listen to activity or fragment and they will unsubscribe automatically once (certain event or) activity or fragment ends. I recommend you to check it out, and check if it can be integrated nicely.\n\nPoint 4: in the code there is a check for is marshmallow, and use it to get return permission granted or not. While support library does it. Why don't delegate this to support library rather than doing it manually?\n. ",
    "PaulWoitaschek": "> 1. How about a Kotlin sibling of this library?\n\nJava is fully interoperable with kotlin. You can access every method in the library easily from Kotlin. \n. Lambdas are pretty much the standard.\n\nEspecially now as Jack is coming out every developer who doesn't understand lambdas should just learn them. Its just a language feature. RxJava is unreadable without them.\n. I'm seeing that crash in [my audibook player](https://github.com/PaulWoitaschek/MaterialAudiobookPlayer) too.\n\nIts a 4.3.1  Batmobile generic XT320 device.\nI'm pretty sure [none of my used libraries](https://github.com/PaulWoitaschek/MaterialAudiobookPlayer/blob/develop/audiobook/build.gradle#L48) are starting the activity.\n. Nope, but the same device has a extremely weird behavior at some other place. I think if there are no furhter reports its safe to ignore this issue.\n\nAt another place one of my activities gets started with a missing key in its intent. (I only create an intent through a static factory and never overwrite it so that can't be possible)\n. Also it seems the rxjava2 package is diverging and stuck at 0.8.2 while the rxjava 1 version is at 0.9.0.. Why don't you just maintain the rxjava 2 version and let people use the [interop library](https://github.com/akarnokd/RxJava2Interop)?. Use the existing RxJava operators.\r\n\r\n```java\r\nrxPermissions.request(WRITE_EXTERNAL)\r\n  .filter(granted -> granted)\r\n  .flatMap(ignore -> rxPermissions.request(CAMERA)\r\n  .filter(granted -> granted)\r\n  ...\r\n```. The benefit is that it's clear what will be returned. As .request returns an Observable I assumed that there is an update whenever that permission is granted.\r\n\r\nI'd make a PR for that if this is wanted.. > 1. How about a Kotlin sibling of this library?\n\nJava is fully interoperable with kotlin. You can access every method in the library easily from Kotlin. \n. Lambdas are pretty much the standard.\n\nEspecially now as Jack is coming out every developer who doesn't understand lambdas should just learn them. Its just a language feature. RxJava is unreadable without them.\n. I'm seeing that crash in [my audibook player](https://github.com/PaulWoitaschek/MaterialAudiobookPlayer) too.\n\nIts a 4.3.1  Batmobile generic XT320 device.\nI'm pretty sure [none of my used libraries](https://github.com/PaulWoitaschek/MaterialAudiobookPlayer/blob/develop/audiobook/build.gradle#L48) are starting the activity.\n. Nope, but the same device has a extremely weird behavior at some other place. I think if there are no furhter reports its safe to ignore this issue.\n\nAt another place one of my activities gets started with a missing key in its intent. (I only create an intent through a static factory and never overwrite it so that can't be possible)\n. Also it seems the rxjava2 package is diverging and stuck at 0.8.2 while the rxjava 1 version is at 0.9.0.. Why don't you just maintain the rxjava 2 version and let people use the [interop library](https://github.com/akarnokd/RxJava2Interop)?. Use the existing RxJava operators.\r\n\r\n```java\r\nrxPermissions.request(WRITE_EXTERNAL)\r\n  .filter(granted -> granted)\r\n  .flatMap(ignore -> rxPermissions.request(CAMERA)\r\n  .filter(granted -> granted)\r\n  ...\r\n```. The benefit is that it's clear what will be returned. As .request returns an Observable I assumed that there is an update whenever that permission is granted.\r\n\r\nI'd make a PR for that if this is wanted.. ",
    "PavelSynek": "Done, I can squash if needed.\n. Done, I can squash if needed.\n. ",
    "AeonDave": "there are too many problems right now for lambda expression in android studio.\nctrl+space shows many class but do not suggest the correct one to implement.\nplesae add just an easy sample so we can understand. Thank you\n. there are too many problems right now for lambda expression in android studio.\nctrl+space shows many class but do not suggest the correct one to implement.\nplesae add just an easy sample so we can understand. Thank you\n. ",
    "jasondelport": "+1 \n\nI use Ben Manes gradle versions plugin to check what is the latest version of my dependencies and the only dependency I have found that it can't detect is this one. \n\nhttps://github.com/ben-manes/gradle-versions-plugin\n\nGreat project by the way, much appreciated. :)\n. +1 \n\nI use Ben Manes gradle versions plugin to check what is the latest version of my dependencies and the only dependency I have found that it can't detect is this one. \n\nhttps://github.com/ben-manes/gradle-versions-plugin\n\nGreat project by the way, much appreciated. :)\n. ",
    "patloew": "I tried your fix, but it didn\u2019t work.\n\n```\nD/MainFragment: [@Observable :: @InClass -> MainFragment :: @Method -> getPermissionsObservable()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onSubscribe()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onNext() -> false]\nD/MainFragment: [@Observable#getPermissionsObservable -> @SubscribeOn -> main :: @ObserveOn -> main]\nD/MainFragment: [@Observable#getPermissionsObservable -> onUnsubscribe()]\nD/MainFragment: [@Observable :: @InClass -> MainFragment :: @Method -> getPermissionsObservable()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onSubscribe()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onCompleted()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onTerminate()]\nD/MainFragment: [@Observable#getPermissionsObservable -> @Emitted -> 0 elements :: @Time -> 223 ms]\nD/MainFragment: [@Observable#getPermissionsObservable ->  :: @ObserveOn -> main]\nD/MainFragment: [@Observable#getPermissionsObservable -> onUnsubscribe()]\n```\n\nThe problem with this is that still `onDestroy()` gets called before `onRequestPermissionResult()`:\n\n```\nD/RxPermissions: Requesting permissions android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: startShadowActivity android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: onRequestPermissionsResult  android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: Requesting permissions android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: startShadowActivity android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: onDestroy\nD/RxPermissions: onRequestPermissionsResult  android.permission.ACCESS_FINE_LOCATION\n```\n\nIn this case, the subject is not available anymore in `onRequestPermissionResult()`, therefore throwing an exception:\n\n```\njava.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n```\n. Was solved by #33.\n. In `onDestroy()` you call `onCompleted()` on all subjects for unsubscribing. However, in my opinion, users should unsubscribe their Subscriptions anyway, when their Activity gets destroyed (e.g. with a `CompositeSubscription`).\n\nWouldn\u2019t it be better to have a separate list, which contains all subjects that did not receive a result from permission requests? I created pull request #37 for implementing this. This way, configuration changes are handled correctly, while also fixing this issue.\n. I added `onDestroy()` again in `RxPermissions`, as it was before, which also fixes the tests. However, since the method was not public, it can not be invoked by users. If you wish so, you should make the method public, after merging.\n. I like the idea, but I think it\u2019s also quite common to request permissions without any trigger. Therefore I think it would be best to keep the `request(final String... permissions)` method, which directly returns an Observable, in addition to the Transformers.\n. It\u2019s not entirely impossible to use the lib in a wrong way, even with your changes, e.g.:\n\n``` java\nbtn.setOnClickListener(v -> Observable.just(null).compose(rxPermissions.ensure(Manifest.permission.CAMERA)).subscribe());\n```\n\nI guess using the lib like this would not be common, but my point is: Why trade convenience and a more elegant solution because of something that\u2019s explained in the readme anyway. And like I said, I think requesting permissions without a trigger is a pretty common use case. `Observable.just(null).compose(...)` feels wrong, in my opinion. To make it more clear, you could name the method `requestWithoutTrigger(...)`.\n. I tried your fix, but it didn\u2019t work.\n\n```\nD/MainFragment: [@Observable :: @InClass -> MainFragment :: @Method -> getPermissionsObservable()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onSubscribe()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onNext() -> false]\nD/MainFragment: [@Observable#getPermissionsObservable -> @SubscribeOn -> main :: @ObserveOn -> main]\nD/MainFragment: [@Observable#getPermissionsObservable -> onUnsubscribe()]\nD/MainFragment: [@Observable :: @InClass -> MainFragment :: @Method -> getPermissionsObservable()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onSubscribe()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onCompleted()]\nD/MainFragment: [@Observable#getPermissionsObservable -> onTerminate()]\nD/MainFragment: [@Observable#getPermissionsObservable -> @Emitted -> 0 elements :: @Time -> 223 ms]\nD/MainFragment: [@Observable#getPermissionsObservable ->  :: @ObserveOn -> main]\nD/MainFragment: [@Observable#getPermissionsObservable -> onUnsubscribe()]\n```\n\nThe problem with this is that still `onDestroy()` gets called before `onRequestPermissionResult()`:\n\n```\nD/RxPermissions: Requesting permissions android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: startShadowActivity android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: onRequestPermissionsResult  android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: Requesting permissions android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: startShadowActivity android.permission.ACCESS_FINE_LOCATION\nD/RxPermissions: onDestroy\nD/RxPermissions: onRequestPermissionsResult  android.permission.ACCESS_FINE_LOCATION\n```\n\nIn this case, the subject is not available anymore in `onRequestPermissionResult()`, therefore throwing an exception:\n\n```\njava.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n```\n. Was solved by #33.\n. In `onDestroy()` you call `onCompleted()` on all subjects for unsubscribing. However, in my opinion, users should unsubscribe their Subscriptions anyway, when their Activity gets destroyed (e.g. with a `CompositeSubscription`).\n\nWouldn\u2019t it be better to have a separate list, which contains all subjects that did not receive a result from permission requests? I created pull request #37 for implementing this. This way, configuration changes are handled correctly, while also fixing this issue.\n. I added `onDestroy()` again in `RxPermissions`, as it was before, which also fixes the tests. However, since the method was not public, it can not be invoked by users. If you wish so, you should make the method public, after merging.\n. I like the idea, but I think it\u2019s also quite common to request permissions without any trigger. Therefore I think it would be best to keep the `request(final String... permissions)` method, which directly returns an Observable, in addition to the Transformers.\n. It\u2019s not entirely impossible to use the lib in a wrong way, even with your changes, e.g.:\n\n``` java\nbtn.setOnClickListener(v -> Observable.just(null).compose(rxPermissions.ensure(Manifest.permission.CAMERA)).subscribe());\n```\n\nI guess using the lib like this would not be common, but my point is: Why trade convenience and a more elegant solution because of something that\u2019s explained in the readme anyway. And like I said, I think requesting permissions without a trigger is a pretty common use case. `Observable.just(null).compose(...)` feels wrong, in my opinion. To make it more clear, you could name the method `requestWithoutTrigger(...)`.\n. ",
    "hellohelloye": "is the permission dialog automatically generated when you \r\n\r\nrxPermissions.request(Manifest.permission.RECORD_AUDIO).subscribe(new Action1<Boolean>() {\r\n            @Override\r\n            public void call(Boolean aBoolean) {\r\n                Log.d(getClass().getSimpleName(), \"inside call\"); } });\r\n\r\nor you need to create the permission dialog view by yourself?\r\n\r\nP.S. my environment:\r\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.9.3@aar'\r\ncompile 'io.reactivex:rxjava:1.2.2'. is the permission dialog automatically generated when you \r\n\r\nrxPermissions.request(Manifest.permission.RECORD_AUDIO).subscribe(new Action1<Boolean>() {\r\n            @Override\r\n            public void call(Boolean aBoolean) {\r\n                Log.d(getClass().getSimpleName(), \"inside call\"); } });\r\n\r\nor you need to create the permission dialog view by yourself?\r\n\r\nP.S. my environment:\r\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.9.3@aar'\r\ncompile 'io.reactivex:rxjava:1.2.2'. ",
    "GreenDeveloperMukesh": "I get This issues while using this code in 4.4 Kitkat\r\n RxPermissions rxPermissions = new RxPermissions(SplashActivity.this);         rxPermissions.setLogging(true);\r\n\r\nE: FATAL EXCEPTION: main\r\n   Process: com.package.test, PID: 8860\r\n   java.lang.VerifyError\r\n\r\nAre there any solutions for this ????\r\n\r\n. I get This issues while using this code in 4.4 Kitkat\r\n RxPermissions rxPermissions = new RxPermissions(SplashActivity.this);         rxPermissions.setLogging(true);\r\n\r\nE: FATAL EXCEPTION: main\r\n   Process: com.package.test, PID: 8860\r\n   java.lang.VerifyError\r\n\r\nAre there any solutions for this ????\r\n\r\n. ",
    "nhpatt": "Sorry I didn't explain the process :(\n\nYou can do directly a gradlew bintrayUpload and will generate the pom and jar and upload it directly. The correct route is this one: https://bintray.com/tbruyelle/tbruyelle/RxPermissions/0.5.2/view#files/com/tbruyelle/rxpermissions/0.5.2 (those are in the correct folder).\n\nThe first time (and that's the step missing), you have to link your repo with jcenter, [here](https://bintray.com/tbruyelle/tbruyelle/RxPermissions/view) in linked to, add to jcenter. Just fill the form and usually in a few hours will be available :)\n\nThe bintray tasks always fails if the version is already uploaded (you can delete the files/version and reupload).\n\nThis POM is in the wrong place: https://bintray.com/tbruyelle/tbruyelle/RxPermissions/0.5.2/view#files/com/tbruyelle/rxpermissions/rxpermissions/0.5.2 and I think that's the strange behaviour of the lib/rxpermissions folder.\n. I've pushed a commit to force downloading the latest platform that (I think) was causing the travisci error because of lint.\n\nIt's strange that _./gradlew bintrayUpload_ doesn't work on your machine before generating the pom and jar before :( I've tried in my machine and with parallel enabled and that target calls to generate the jar/pom (tried also deleting the files)...\n\nDid you try to link with jcenter? I haven't seen the files so I suppose something went wrong :( did they respond with any problems? I'm willing to help in whatever you need :)\n. Do you need help? I can try to clarify whatever you want :)\n. I've tested the jcenter branch with a fresh clone with my computer and in a colleague's computer with my local.properties (against this repo: https://bintray.com/nhpatt/tbruyelle/RxPermissions/) and seems to work fine.\n\nI'll enumerate the steps I followed:\n- I remove the 0.52 version from bintray (because if not I received a \"HTTP/1.1 409 Conflict [message:Unable to upload files...\"\n- I execute \"./gradlew bintrayUpload\" in the repository root (you don't have to be in the library folder or specify the library project) and automatically creates the aar and the jar for the sources and uploads them to bintray.\n\nI'm a bit lost about why it could be failing in your machine, can you post the full stacktrace of the error? I tried before with the parallel computation. The stack you posted is missing a lot of steps, do you have a specific gradle configuration?\n\nCan you try \"./gradlew bintrayUpload\" in the root of the repository or in a new cloned repo?\n. Great :) Let's hope everything is fine :D\n. I'm afraid not.\n\nI can generate the source jars for the other versions and send them to you (should be apply those commits after the tags of each version and generate).\n\nSometimes it takes more to link and they send you a notification in bintray when they've finished, I would wait at least a day, hopefully they can link just from 0.5.2 version...\n. I saw that you uploaded all the versions (sorry for the troubles) and the library is now synced (https://jcenter.bintray.com/com/tbruyelle/rxpermissions/rxpermissions/).\n\nThank you very much! :)\n. Sorry I didn't explain the process :(\n\nYou can do directly a gradlew bintrayUpload and will generate the pom and jar and upload it directly. The correct route is this one: https://bintray.com/tbruyelle/tbruyelle/RxPermissions/0.5.2/view#files/com/tbruyelle/rxpermissions/0.5.2 (those are in the correct folder).\n\nThe first time (and that's the step missing), you have to link your repo with jcenter, [here](https://bintray.com/tbruyelle/tbruyelle/RxPermissions/view) in linked to, add to jcenter. Just fill the form and usually in a few hours will be available :)\n\nThe bintray tasks always fails if the version is already uploaded (you can delete the files/version and reupload).\n\nThis POM is in the wrong place: https://bintray.com/tbruyelle/tbruyelle/RxPermissions/0.5.2/view#files/com/tbruyelle/rxpermissions/rxpermissions/0.5.2 and I think that's the strange behaviour of the lib/rxpermissions folder.\n. I've pushed a commit to force downloading the latest platform that (I think) was causing the travisci error because of lint.\n\nIt's strange that _./gradlew bintrayUpload_ doesn't work on your machine before generating the pom and jar before :( I've tried in my machine and with parallel enabled and that target calls to generate the jar/pom (tried also deleting the files)...\n\nDid you try to link with jcenter? I haven't seen the files so I suppose something went wrong :( did they respond with any problems? I'm willing to help in whatever you need :)\n. Do you need help? I can try to clarify whatever you want :)\n. I've tested the jcenter branch with a fresh clone with my computer and in a colleague's computer with my local.properties (against this repo: https://bintray.com/nhpatt/tbruyelle/RxPermissions/) and seems to work fine.\n\nI'll enumerate the steps I followed:\n- I remove the 0.52 version from bintray (because if not I received a \"HTTP/1.1 409 Conflict [message:Unable to upload files...\"\n- I execute \"./gradlew bintrayUpload\" in the repository root (you don't have to be in the library folder or specify the library project) and automatically creates the aar and the jar for the sources and uploads them to bintray.\n\nI'm a bit lost about why it could be failing in your machine, can you post the full stacktrace of the error? I tried before with the parallel computation. The stack you posted is missing a lot of steps, do you have a specific gradle configuration?\n\nCan you try \"./gradlew bintrayUpload\" in the root of the repository or in a new cloned repo?\n. Great :) Let's hope everything is fine :D\n. I'm afraid not.\n\nI can generate the source jars for the other versions and send them to you (should be apply those commits after the tags of each version and generate).\n\nSometimes it takes more to link and they send you a notification in bintray when they've finished, I would wait at least a day, hopefully they can link just from 0.5.2 version...\n. I saw that you uploaded all the versions (sorry for the troubles) and the library is now synced (https://jcenter.bintray.com/com/tbruyelle/rxpermissions/rxpermissions/).\n\nThank you very much! :)\n. ",
    "ReginFell": "Nope, i used it in this way https://gist.github.com/ReginFell/49538a7edfed90a6639a\n\nParrent activity is AppCompatActivity. \n. Nope, i used it in this way https://gist.github.com/ReginFell/49538a7edfed90a6639a\n\nParrent activity is AppCompatActivity. \n. ",
    "shayanzoro": "I have the same problem on Android 4.1.1\nRxPermissions v0.5.2\n\nFatal Exception: java.lang.NoSuchMethodError\ncom.tbruyelle.rxpermissions.ShadowActivity.requestPermissions\ncom.tbruyelle.rxpermissions.ShadowActivity.handleIntent (ShadowActivity.java:27)\ncom.tbruyelle.rxpermissions.ShadowActivity.onCreate (ShadowActivity.java:16)\n. I have the same problem on Android 4.1.1\nRxPermissions v0.5.2\n\nFatal Exception: java.lang.NoSuchMethodError\ncom.tbruyelle.rxpermissions.ShadowActivity.requestPermissions\ncom.tbruyelle.rxpermissions.ShadowActivity.handleIntent (ShadowActivity.java:27)\ncom.tbruyelle.rxpermissions.ShadowActivity.onCreate (ShadowActivity.java:16)\n. ",
    "xingrz": "@tbruyelle tested works, of course.\n\nSee also: [Don't break the chain: use RxJava's compose() operator](http://blog.danlew.net/2015/03/02/dont-break-the-chain/)\n. This may be great:\n\n```\nRxView.clicks(myButton)\n        .compose(RxPermissions.ensure(this, Manifest.permission.WRITE_EXTERNAL_STORAGE))\n        .subscribe();\n```\n. It's ok, cool!\n\nAccording to the [design guidelines](https://www.google.com/design/spec/patterns/permissions.html#permissions-request-patterns), permissions are requested usually just before they're needed. So immediately trigger is not always needed.\n. @tbruyelle tested works, of course.\n\nSee also: [Don't break the chain: use RxJava's compose() operator](http://blog.danlew.net/2015/03/02/dont-break-the-chain/)\n. This may be great:\n\n```\nRxView.clicks(myButton)\n        .compose(RxPermissions.ensure(this, Manifest.permission.WRITE_EXTERNAL_STORAGE))\n        .subscribe();\n```\n. It's ok, cool!\n\nAccording to the [design guidelines](https://www.google.com/design/spec/patterns/permissions.html#permissions-request-patterns), permissions are requested usually just before they're needed. So immediately trigger is not always needed.\n. ",
    "PingForward": "@tbruyelle It shows gray background and appear animation for activity when dialog triggered.\nNexus 5 and emulator tested. \n![screenshot_20160316-134959](https://cloud.githubusercontent.com/assets/17492722/13810050/cbafbb90-eb7e-11e5-8d8e-c62521dd433e.png)\n. Here is my code implementation. It is v4.support fragment inside AppCompatActivity with Theme.AppCompat.Light.DarkActionBar theme\n\n```\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState == null) {\n            requestGpsPermission();\n        }\n    }\n\n    private void requestGpsPermission() {\n        RxPermissions.getInstance(getActivity())\n                .request(Manifest.permission.ACCESS_FINE_LOCATION)\n                .subscribe(granted -> {\n                    if (granted) { // Always true pre-M\n                      // start service\n                    } else {\n                        requestGpsPermission();\n                    }\n                });\n    }\n```\n\nAlso I tried to start it with timer to ensure that UI created but the same result gray backgroud.\nI think the issue in the used theme. You set for shadow activity not app compat theme and on M devides it is not working.\n. I will try it in a few days...\nMigration to 0.6.x\n..... and ensureEach(permission...). Read the*\\* second example*\\* to see how to use them.\n\nWhere is examples with ensure??\n. @tbruyelle no result on v0.7.0. Gray background on the shadow activity\n. Sorry man it seems my fault. I set theme to the shadow activity manually and it start working. I did that before but no luck. Now it is working. Thanks!\n\n```\n <activity\n            android:name=\"com.tbruyelle.rxpermissions.ShadowActivity\"\n            android:theme=\"@android:style/Theme.Translucent.NoTitleBar.Fullscreen\" />\n```\n. @tbruyelle It shows gray background and appear animation for activity when dialog triggered.\nNexus 5 and emulator tested. \n![screenshot_20160316-134959](https://cloud.githubusercontent.com/assets/17492722/13810050/cbafbb90-eb7e-11e5-8d8e-c62521dd433e.png)\n. Here is my code implementation. It is v4.support fragment inside AppCompatActivity with Theme.AppCompat.Light.DarkActionBar theme\n\n```\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState == null) {\n            requestGpsPermission();\n        }\n    }\n\n    private void requestGpsPermission() {\n        RxPermissions.getInstance(getActivity())\n                .request(Manifest.permission.ACCESS_FINE_LOCATION)\n                .subscribe(granted -> {\n                    if (granted) { // Always true pre-M\n                      // start service\n                    } else {\n                        requestGpsPermission();\n                    }\n                });\n    }\n```\n\nAlso I tried to start it with timer to ensure that UI created but the same result gray backgroud.\nI think the issue in the used theme. You set for shadow activity not app compat theme and on M devides it is not working.\n. I will try it in a few days...\nMigration to 0.6.x\n..... and ensureEach(permission...). Read the*\\* second example*\\* to see how to use them.\n\nWhere is examples with ensure??\n. @tbruyelle no result on v0.7.0. Gray background on the shadow activity\n. Sorry man it seems my fault. I set theme to the shadow activity manually and it start working. I did that before but no luck. Now it is working. Thanks!\n\n```\n <activity\n            android:name=\"com.tbruyelle.rxpermissions.ShadowActivity\"\n            android:theme=\"@android:style/Theme.Translucent.NoTitleBar.Fullscreen\" />\n```\n. ",
    "grimmy0": "According to documentation of onDestroy() method - \"Note: do not count on this method being called as a place for saving data!\" (http://developer.android.com/reference/android/app/Activity.html#onDestroy()). Also there is no guaranty that system actually will call onDestroy(). So may be you should move that code to any other place?\n. According to documentation of onDestroy() method - \"Note: do not count on this method being called as a place for saving data!\" (http://developer.android.com/reference/android/app/Activity.html#onDestroy()). Also there is no guaranty that system actually will call onDestroy(). So may be you should move that code to any other place?\n. ",
    "ashalmawia": "Checked - now works as expected.\nThank you!\n. Looks like problem has appeared due to some changes in the null publish subjects handling. When I changed the part of request_() method (lines 193-205) to the following, the bug stopped to appear:\n\n```\nPublishSubject<Permission> subject = mSubjects.get(permission);\n            // Request the permission to the framework only if not already done\n            // and if there's no request without result (occurs on configuration\n            // change, see onDestroy method).\n            if (subject == null) {                                           // sic!\n                unrequestedPermissions.add(permission);\n            }\n\n            // Create a new subject if not exists\n            if (subject == null || subject.hasCompleted()) {    // sic!\n                subject = PublishSubject.create();\n                mSubjects.put(permission, subject);\n            }\n```\n\nThis is actually how it was in one of the previous versions (to be precise, before the commit e205f9dd5669073731b2deed293fcc02ecee69d3). I'm not sure, however, if such a change would now have any side-effects.\n\nMaybe it would be helpful.\n. Does not reproduce now with the steps above. \nThank you!\n. Is it really important to do \n`mSubjects.clear();`\nin the `onShadowActivityStop()`? If the activity dies, this list will be just dropped with it, otherwise, if the activity survives and continues its lifecycle, we need this list untouched (bug is actually caused by its emptiness after onStop()).\n\nI removed it and checked the main cases, everything works as expected.\n. I am using it :) We are requesting android.permission.CAMERA and android.permission.RECORD_AUDIO at the same point.\n\nAha, I see - there is a case, when I request two permissions simultaneously, DNKA on, I press \"Allow\" on the first dialog, then fold the app up, retrieve it back, press \"Allow\" on the second dialog. Without this line of code, result would not be delivered.\nIn the current implementation of the library, however, it produces the same crash as in the description of the issue.\n\nI'll look for some ways to handle it.\n. That one no (and, honestly speaking, I can hardly imagine a case when it could be inevitably needed).\n. Checked - no crash now, with one permission it works as expected.\n\nFor two permissions, requested simultaneously, there is no more crash as well and all works good with DNKA off. With DNKA on, there stays the case when result is not delivered (\"Allow\" on the first dialog, fold up, retrieve, \"Allow\" on the second dialog). But I suppose it to be extremely rare, probably not worth wasting time.\n\nAlso checked the two previous cases - none reproduces.\n\nThat's great :)\n\nThank you very much for the fixes and quick reaction! You helped us a lot.\n. > When you said requested simultaneously you mean by passing more than one parameter ?\n\nYes. Maybe it's somehow device-specific, I'm testing on Nexus 5, 6.0.1.\n\nWould you please deploy a new version of the library, for us to receive updates?\n. @jaydeep17 Sounds interesting. Could you please provide more detailed steps which you can reproduce it with? (Does not happen for me when using both `request()` and `ensure()`).\n. Not sure that 202 users, who've faced that crash so far in our app, will agree with you :)\n. @tbruyelle Ok, let's think of it more generally. Android can kill our process and then recreate it in three cases:\n1. App crashes\n2. Memory pressure, if all activities are already destroyed\n3. User goes to the settings and changes permissions, and then returns to the app.\n\nObviously, we are not interested int the case 1. Case 3 also seems by and large low-probable. However, case 2 still may be probable enough to be the reason.\n\n202 users is a low number for our auditory, but it's much higher than we expected.\n. I totally agree, that it's far from the best solution. However, according to the conception of Safe-driven development, it's a good decision to hide all crashes in production, keeping them in development builds. So, it may be better that nothing.\n\nThe problem with this crash is that it happens in library's insides, so we get no chance to even wrap it in try-catch until the solution will be found. The single option is to fork the library and add it as a third-party project.\nMaybe we can add a log or non-fatal report instead of a strict crash there? Thus library's safety will be improved with killing two birds -- we'll have a marker of the issue to further return to it (as we already know the steps), and we'll protect users from facing crashes in production.\n. Checked - now works as expected.\nThank you!\n. Looks like problem has appeared due to some changes in the null publish subjects handling. When I changed the part of request_() method (lines 193-205) to the following, the bug stopped to appear:\n\n```\nPublishSubject<Permission> subject = mSubjects.get(permission);\n            // Request the permission to the framework only if not already done\n            // and if there's no request without result (occurs on configuration\n            // change, see onDestroy method).\n            if (subject == null) {                                           // sic!\n                unrequestedPermissions.add(permission);\n            }\n\n            // Create a new subject if not exists\n            if (subject == null || subject.hasCompleted()) {    // sic!\n                subject = PublishSubject.create();\n                mSubjects.put(permission, subject);\n            }\n```\n\nThis is actually how it was in one of the previous versions (to be precise, before the commit e205f9dd5669073731b2deed293fcc02ecee69d3). I'm not sure, however, if such a change would now have any side-effects.\n\nMaybe it would be helpful.\n. Does not reproduce now with the steps above. \nThank you!\n. Is it really important to do \n`mSubjects.clear();`\nin the `onShadowActivityStop()`? If the activity dies, this list will be just dropped with it, otherwise, if the activity survives and continues its lifecycle, we need this list untouched (bug is actually caused by its emptiness after onStop()).\n\nI removed it and checked the main cases, everything works as expected.\n. I am using it :) We are requesting android.permission.CAMERA and android.permission.RECORD_AUDIO at the same point.\n\nAha, I see - there is a case, when I request two permissions simultaneously, DNKA on, I press \"Allow\" on the first dialog, then fold the app up, retrieve it back, press \"Allow\" on the second dialog. Without this line of code, result would not be delivered.\nIn the current implementation of the library, however, it produces the same crash as in the description of the issue.\n\nI'll look for some ways to handle it.\n. That one no (and, honestly speaking, I can hardly imagine a case when it could be inevitably needed).\n. Checked - no crash now, with one permission it works as expected.\n\nFor two permissions, requested simultaneously, there is no more crash as well and all works good with DNKA off. With DNKA on, there stays the case when result is not delivered (\"Allow\" on the first dialog, fold up, retrieve, \"Allow\" on the second dialog). But I suppose it to be extremely rare, probably not worth wasting time.\n\nAlso checked the two previous cases - none reproduces.\n\nThat's great :)\n\nThank you very much for the fixes and quick reaction! You helped us a lot.\n. > When you said requested simultaneously you mean by passing more than one parameter ?\n\nYes. Maybe it's somehow device-specific, I'm testing on Nexus 5, 6.0.1.\n\nWould you please deploy a new version of the library, for us to receive updates?\n. @jaydeep17 Sounds interesting. Could you please provide more detailed steps which you can reproduce it with? (Does not happen for me when using both `request()` and `ensure()`).\n. Not sure that 202 users, who've faced that crash so far in our app, will agree with you :)\n. @tbruyelle Ok, let's think of it more generally. Android can kill our process and then recreate it in three cases:\n1. App crashes\n2. Memory pressure, if all activities are already destroyed\n3. User goes to the settings and changes permissions, and then returns to the app.\n\nObviously, we are not interested int the case 1. Case 3 also seems by and large low-probable. However, case 2 still may be probable enough to be the reason.\n\n202 users is a low number for our auditory, but it's much higher than we expected.\n. I totally agree, that it's far from the best solution. However, according to the conception of Safe-driven development, it's a good decision to hide all crashes in production, keeping them in development builds. So, it may be better that nothing.\n\nThe problem with this crash is that it happens in library's insides, so we get no chance to even wrap it in try-catch until the solution will be found. The single option is to fork the library and add it as a third-party project.\nMaybe we can add a log or non-fatal report instead of a strict crash there? Thus library's safety will be improved with killing two birds -- we'll have a marker of the issue to further return to it (as we already know the steps), and we'll protect users from facing crashes in production.\n. ",
    "JLLK": "Fine, I'll close this pr.\n. Fine, I'll close this pr.\n. ",
    "pelotasplus": "this problem is back in `master`. just checked out sources, switched to branch `2.x` and was able to reproduce it with sample app on Nexus 6P running 7.1.2.\r\n\r\nwhat i noticed, that with \"don't keep activities\" enabled, when app is put into background, then `onDestroy()` method of `RxPermissionsFragment` is being called. It's not called when phone is being rotated ...\r\n\r\nwas able to reproduce on emulator running 6.0. this problem is back in `master`. just checked out sources, switched to branch `2.x` and was able to reproduce it with sample app on Nexus 6P running 7.1.2.\r\n\r\nwhat i noticed, that with \"don't keep activities\" enabled, when app is put into background, then `onDestroy()` method of `RxPermissionsFragment` is being called. It's not called when phone is being rotated ...\r\n\r\nwas able to reproduce on emulator running 6.0. ",
    "jaydp17": "I tried the new version, but it's still the same, it doesn't show up the second time\n. Here's a very simplified form of the calls to RxPermissions I have\n\n``` java\nRxPermissions.getInstance(this)\n        .request(Manifest.permission.ACCESS_FINE_LOCATION)\n        .flatMap(granted -> RxPermissions.getInstance(this)\n            .request(Manifest.permission.ACCESS_FINE_LOCATION))\n        .subscribe(...);\n```\n\nI don't have it exactly the same way as shown here, the second call to `request` is deep down in a sub function.\n. We have this utility class called RxGoogleMaps that carries out specific operations on Google Maps and every method inside that class that requires location permission asks for the permission before carrying out the operation. For example, `showMyLocationButton()`, `moveToLastKnownLocation()`, etc.\nUnfortunately, once the permission is asked, then 2 levels deep we have a `.flatMap()`, that calls another of these RxGoogleMaps method, and thus permission is requested again.\n. True that's a problem on my side, but don't you think RxPermissions should work, even if I request it twice.\n. I tried the new version, but it's still the same, it doesn't show up the second time\n. Here's a very simplified form of the calls to RxPermissions I have\n\n``` java\nRxPermissions.getInstance(this)\n        .request(Manifest.permission.ACCESS_FINE_LOCATION)\n        .flatMap(granted -> RxPermissions.getInstance(this)\n            .request(Manifest.permission.ACCESS_FINE_LOCATION))\n        .subscribe(...);\n```\n\nI don't have it exactly the same way as shown here, the second call to `request` is deep down in a sub function.\n. We have this utility class called RxGoogleMaps that carries out specific operations on Google Maps and every method inside that class that requires location permission asks for the permission before carrying out the operation. For example, `showMyLocationButton()`, `moveToLastKnownLocation()`, etc.\nUnfortunately, once the permission is asked, then 2 levels deep we have a `.flatMap()`, that calls another of these RxGoogleMaps method, and thus permission is requested again.\n. True that's a problem on my side, but don't you think RxPermissions should work, even if I request it twice.\n. ",
    "BruceeWang": "I have the same the question for that. If I want to deny this permission again. How can I get to change this permission?\n. I mean that when I request the permission again. If the user have granted the permission. the dialog(Permission) is not appear .How can I get the dialog appear again?\n(English is not very well,please excuse me)\n. I have the same the question for that. If I want to deny this permission again. How can I get to change this permission?\n. I mean that when I request the permission again. If the user have granted the permission. the dialog(Permission) is not appear .How can I get the dialog appear again?\n(English is not very well,please excuse me)\n. ",
    "tarasantoshchuk": "@BruceeWang \n\n> If the user have granted the permission. the dialog(Permission) is not appear .How can I get the dialog appear again?\n\nAfter the user have granted the permission, the only way for user to revoke permission is via App Settings. Otherwise dialog won't appear again.\n. @toidv \ncan you post some code?\n. no, I leave app while dialog is shown\n. Yes, it is weird.\nBut our crash reporter shows that this crash happens in production\n. java.lang.RuntimeException: Failure delivering result ResultInfo{who=@android:requestPermissions:, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS (has extras) }} to activity {.../com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\nat android.app.ActivityThread.deliverResults(ActivityThread.java:3699)\nat android.app.ActivityThread.handleSendResult(ActivityThread.java:3742)\nat android.app.ActivityThread.-wrap16(ActivityThread.java)\nat android.app.ActivityThread$H.handleMessage(ActivityThread.java:1393)\nat android.os.Handler.dispatchMessage(Handler.java:102)\nat android.os.Looper.loop(Looper.java:148)\nat android.app.ActivityThread.main(ActivityThread.java:5417)\nat java.lang.reflect.Method.invoke(Native Method)\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\nCaused by: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\nat com.tbruyelle.rxpermissions.RxPermissions.onRequestPermissionsResult(RxPermissions.java:286)\nat com.tbruyelle.rxpermissions.ShadowActivity.onRequestPermissionsResult(ShadowActivity.java:32)\nat android.app.Activity.dispatchRequestPermissionsResult(Activity.java:6582)\nat android.app.Activity.dispatchActivityResult(Activity.java:6460)\nat android.app.ActivityThread.deliverResults(ActivityThread.java:3695)\nat android.app.ActivityThread.handleSendResult(ActivityThread.java:3742)\u00a0\nat android.app.ActivityThread.-wrap16(ActivityThread.java)\u00a0\nat android.app.ActivityThread$H.handleMessage(ActivityThread.java:1393)\u00a0\nat android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\nat android.os.Looper.loop(Looper.java:148)\u00a0\nat android.app.ActivityThread.main(ActivityThread.java:5417)\u00a0\nat java.lang.reflect.Method.invoke(Native Method)\u00a0\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\u00a0\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\u00a0\n. @tbruyelle \nplease, review my pull request\n. @tbruyelle \nI added new pull request that fixes crash, please review\n. @tbruyelle \nI've tried to save pending permissions in Shared preferences, to restore RxPermissions.mSubjects when app is recreated in another process.\nThis fixed crash, but another problem occurred. \n\nSteps:\n1. User removes our app from recent apps, while permission request is in process.\n2. User reopens our app - we restore pending permissions subjects.\n3. But actually Android System won't restore ShadowActivity.\n4. We end up thinking that we ARE requesting some permissions while we are NOT.\n\nThat causes lot of bugs - i. e.:\nAll subsequent requests of that permissions won't do anything, because we think that we are already requesting them - so we should not start ShadowActivity.\n\nWe could handle described situation only if we know whether user closed our app, or system closed our app. But as far as I know Android doesn't provide us with this kind of information.\n. @tbruyelle \n\n> So I should have about 40 instances of this exception. What I mean is\n> there's maybe something wrong with how you use the library.\n\nI think the amount of crashes depends a lot on how much app uses rx_permissions lib, so you can't make extrapolations like this.\n\nBy the way, this crash can be reproduced even on rx_permissions sample app, therefore you can't blame developers for misusing the lib too.\n. @tbruyelle \nI've rechecked the fix and reviewed your refactoring commit.\nEverything is ok.\n\nWhen we can expect the new version of lib (with this fix)?\n. @huahongyang \nare you starting ShadowActivity directly in your code?\nBecause normally RxPermissions wouldn't start it on devices with API < 23.\n. @awhgwqpeogh any updates?\n. @tbruyelle \nthere are 2 instances of this crash in my app, but both are on emulators with Android version 4.1.1\n\nHowever, since ShadowActivity is public class (and not package-protected) some of library users might start ShadowActivity directly in their code - which will cause NoSuchMethodException on API <23.\n\nMaybe we should make ShadowActivity package-protected?\n. @PaulWoitaschek \ncan you check whether the device is rooted or not?\n. @selmanon \nlooks like you forgot to put \n\n<uses-permission android:name=\"android.permission.SEND_SMS\"/>\n\ninto AndroidManifest.xml\n. @selmanon generally popup won't show up in two cases :\n\n1) user already granted that permission\n2) user denied permission and checked \"do not ask me again\" checkbox.\n. @dreamhb can you provide full stacktrace with exception name?\nor at least part of it, above \"at com.tbruyelle.rxpermissions.RxPermissions...\"\n. if you get **false** in onNext() (permission was denied) you can call \n\n`ActivityCompat.shouldShowRequestPermissionRationale(activity, permission);`\n\nif it returns false - permission was denied with \"Never show again\" checked.\n. > and this is making my application crash\n\nCan you provide stack trace?\n. @Malikkhoja any updates?\n. this would be convenient for library users\n\n@tbruyelle \nWhat do you think about this?\n. > So basically when calling request, ensure or the methods alike of RxPermission I need to have an activity that is visible?\n\nMain point is not that your activity should be visible, but that you have to invoke these methods during initialization phase (i.e. onCreate()/onStart() in Activity, etc.)\n\nFor example, if you call **request()** and subscribe to observable in  OnClickListener of some button.\nUser taps button, and permissions request is started.\nIf during permissions request activity is recreated (i.e. due to configuration changes), then code in you click listener is not executed again and you don't subscribe to observable - permissions request result is lost.\n\nBut if you subscribe to observable during init phase, then in case of activity recreation, you'll resubscribe, and receive result from observable.\n. > That's basically the way to go. Also RxAndroid does it that way 2 branches (1.x and 2.x) with different package ids + artifact ids.\n\nI think this approach should be accepted, because:\n1) RxPermissions shouldn't force users to switch to Rx2\n2) We still want users of Rx1 to use updated versions of lib with bugfixes,  etc. Which is not the case, if we switch to Rx2.\n. duplicate of https://github.com/tbruyelle/RxPermissions/issues/46\n. @vanniktech @tbruyelle \n\nFrom my experience `shouldShowRequestPermissionRationale` has following behaviour:\n1. before the first time we asked for permission, **it returns false**\n2. if we already asked user for permission and he denied it, **but didn't check** \"Never ask again\", **it return true**\n3. if user once denied permission request with \"Never ask again\" checked, **it returns false**\n4. if permission is already granted, **it returns false**\n\nWhat this behaviour means for us:\n1. `shouldShowRequestPermissionRationale` returns false **AND** we already asked for permission **AND** permission was denied **is the only condition** when we can tell for sure that user denied permission with \"Never ask again\" checked\n2. from 1 follows, that we **must** check if user denied permissions forever **after** permission request, because before permission request, value returned by 'shouldShowRequest...', is ambiguous for us. \n. > Well it's not ambiguous before the request. If you have checked \"don't ask again\" you'll still end up in onPermissionResult and will get a granted of false.\n\nAnd if call 'shouldShowRequest...' before request and it returns false, it may be that user denied permission with \"don't ask again\", but it also may be that we never requested this permission before\n. @tbruyelle \nalso we should rename Permission#shouldShowRequestPermissionRationale to something like Permission#deniedForever. This way the meaning of the field will be obvious for user.\n. @renegens \nCan you show example of code where you encounter troubles?\n. which permission are you requesting?\n. have you tried to run the same code on Android M?\ncan you post your code here?\n. Indeed, as well as my pool request  (https://github.com/tbruyelle/RxPermissions/pull/53), this is only a workaround\n\nHowever, there is difference between two pool requests:\n\nmy pull request **handles specific case** when app was recreated by system,\nwhile this pull request **disables \"subject == null\" check at all**, possibly hiding some other cases when this exception is thrown.\n. @Gregliest \ncan you post some code, where you're requesting permissions?\nwe might be able to provide workaround for you\n. @BruceeWang \n\n> If the user have granted the permission. the dialog(Permission) is not appear .How can I get the dialog appear again?\n\nAfter the user have granted the permission, the only way for user to revoke permission is via App Settings. Otherwise dialog won't appear again.\n. @toidv \ncan you post some code?\n. no, I leave app while dialog is shown\n. Yes, it is weird.\nBut our crash reporter shows that this crash happens in production\n. java.lang.RuntimeException: Failure delivering result ResultInfo{who=@android:requestPermissions:, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS (has extras) }} to activity {.../com.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\nat android.app.ActivityThread.deliverResults(ActivityThread.java:3699)\nat android.app.ActivityThread.handleSendResult(ActivityThread.java:3742)\nat android.app.ActivityThread.-wrap16(ActivityThread.java)\nat android.app.ActivityThread$H.handleMessage(ActivityThread.java:1393)\nat android.os.Handler.dispatchMessage(Handler.java:102)\nat android.os.Looper.loop(Looper.java:148)\nat android.app.ActivityThread.main(ActivityThread.java:5417)\nat java.lang.reflect.Method.invoke(Native Method)\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\nCaused by: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\nat com.tbruyelle.rxpermissions.RxPermissions.onRequestPermissionsResult(RxPermissions.java:286)\nat com.tbruyelle.rxpermissions.ShadowActivity.onRequestPermissionsResult(ShadowActivity.java:32)\nat android.app.Activity.dispatchRequestPermissionsResult(Activity.java:6582)\nat android.app.Activity.dispatchActivityResult(Activity.java:6460)\nat android.app.ActivityThread.deliverResults(ActivityThread.java:3695)\nat android.app.ActivityThread.handleSendResult(ActivityThread.java:3742)\u00a0\nat android.app.ActivityThread.-wrap16(ActivityThread.java)\u00a0\nat android.app.ActivityThread$H.handleMessage(ActivityThread.java:1393)\u00a0\nat android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\nat android.os.Looper.loop(Looper.java:148)\u00a0\nat android.app.ActivityThread.main(ActivityThread.java:5417)\u00a0\nat java.lang.reflect.Method.invoke(Native Method)\u00a0\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\u00a0\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\u00a0\n. @tbruyelle \nplease, review my pull request\n. @tbruyelle \nI added new pull request that fixes crash, please review\n. @tbruyelle \nI've tried to save pending permissions in Shared preferences, to restore RxPermissions.mSubjects when app is recreated in another process.\nThis fixed crash, but another problem occurred. \n\nSteps:\n1. User removes our app from recent apps, while permission request is in process.\n2. User reopens our app - we restore pending permissions subjects.\n3. But actually Android System won't restore ShadowActivity.\n4. We end up thinking that we ARE requesting some permissions while we are NOT.\n\nThat causes lot of bugs - i. e.:\nAll subsequent requests of that permissions won't do anything, because we think that we are already requesting them - so we should not start ShadowActivity.\n\nWe could handle described situation only if we know whether user closed our app, or system closed our app. But as far as I know Android doesn't provide us with this kind of information.\n. @tbruyelle \n\n> So I should have about 40 instances of this exception. What I mean is\n> there's maybe something wrong with how you use the library.\n\nI think the amount of crashes depends a lot on how much app uses rx_permissions lib, so you can't make extrapolations like this.\n\nBy the way, this crash can be reproduced even on rx_permissions sample app, therefore you can't blame developers for misusing the lib too.\n. @tbruyelle \nI've rechecked the fix and reviewed your refactoring commit.\nEverything is ok.\n\nWhen we can expect the new version of lib (with this fix)?\n. @huahongyang \nare you starting ShadowActivity directly in your code?\nBecause normally RxPermissions wouldn't start it on devices with API < 23.\n. @awhgwqpeogh any updates?\n. @tbruyelle \nthere are 2 instances of this crash in my app, but both are on emulators with Android version 4.1.1\n\nHowever, since ShadowActivity is public class (and not package-protected) some of library users might start ShadowActivity directly in their code - which will cause NoSuchMethodException on API <23.\n\nMaybe we should make ShadowActivity package-protected?\n. @PaulWoitaschek \ncan you check whether the device is rooted or not?\n. @selmanon \nlooks like you forgot to put \n\n<uses-permission android:name=\"android.permission.SEND_SMS\"/>\n\ninto AndroidManifest.xml\n. @selmanon generally popup won't show up in two cases :\n\n1) user already granted that permission\n2) user denied permission and checked \"do not ask me again\" checkbox.\n. @dreamhb can you provide full stacktrace with exception name?\nor at least part of it, above \"at com.tbruyelle.rxpermissions.RxPermissions...\"\n. if you get **false** in onNext() (permission was denied) you can call \n\n`ActivityCompat.shouldShowRequestPermissionRationale(activity, permission);`\n\nif it returns false - permission was denied with \"Never show again\" checked.\n. > and this is making my application crash\n\nCan you provide stack trace?\n. @Malikkhoja any updates?\n. this would be convenient for library users\n\n@tbruyelle \nWhat do you think about this?\n. > So basically when calling request, ensure or the methods alike of RxPermission I need to have an activity that is visible?\n\nMain point is not that your activity should be visible, but that you have to invoke these methods during initialization phase (i.e. onCreate()/onStart() in Activity, etc.)\n\nFor example, if you call **request()** and subscribe to observable in  OnClickListener of some button.\nUser taps button, and permissions request is started.\nIf during permissions request activity is recreated (i.e. due to configuration changes), then code in you click listener is not executed again and you don't subscribe to observable - permissions request result is lost.\n\nBut if you subscribe to observable during init phase, then in case of activity recreation, you'll resubscribe, and receive result from observable.\n. > That's basically the way to go. Also RxAndroid does it that way 2 branches (1.x and 2.x) with different package ids + artifact ids.\n\nI think this approach should be accepted, because:\n1) RxPermissions shouldn't force users to switch to Rx2\n2) We still want users of Rx1 to use updated versions of lib with bugfixes,  etc. Which is not the case, if we switch to Rx2.\n. duplicate of https://github.com/tbruyelle/RxPermissions/issues/46\n. @vanniktech @tbruyelle \n\nFrom my experience `shouldShowRequestPermissionRationale` has following behaviour:\n1. before the first time we asked for permission, **it returns false**\n2. if we already asked user for permission and he denied it, **but didn't check** \"Never ask again\", **it return true**\n3. if user once denied permission request with \"Never ask again\" checked, **it returns false**\n4. if permission is already granted, **it returns false**\n\nWhat this behaviour means for us:\n1. `shouldShowRequestPermissionRationale` returns false **AND** we already asked for permission **AND** permission was denied **is the only condition** when we can tell for sure that user denied permission with \"Never ask again\" checked\n2. from 1 follows, that we **must** check if user denied permissions forever **after** permission request, because before permission request, value returned by 'shouldShowRequest...', is ambiguous for us. \n. > Well it's not ambiguous before the request. If you have checked \"don't ask again\" you'll still end up in onPermissionResult and will get a granted of false.\n\nAnd if call 'shouldShowRequest...' before request and it returns false, it may be that user denied permission with \"don't ask again\", but it also may be that we never requested this permission before\n. @tbruyelle \nalso we should rename Permission#shouldShowRequestPermissionRationale to something like Permission#deniedForever. This way the meaning of the field will be obvious for user.\n. @renegens \nCan you show example of code where you encounter troubles?\n. which permission are you requesting?\n. have you tried to run the same code on Android M?\ncan you post your code here?\n. Indeed, as well as my pool request  (https://github.com/tbruyelle/RxPermissions/pull/53), this is only a workaround\n\nHowever, there is difference between two pool requests:\n\nmy pull request **handles specific case** when app was recreated by system,\nwhile this pull request **disables \"subject == null\" check at all**, possibly hiding some other cases when this exception is thrown.\n. @Gregliest \ncan you post some code, where you're requesting permissions?\nwe might be able to provide workaround for you\n. ",
    "ngoctranfire": "Yea, I actually think this is by design. After the dialog has appeared once, if the user granted or denied the permission, the permission, in theory should not appear again.\n\n---\n\nEdit:\nI take that back. Unless they check never ask again, it should keep asking if they ever access whatever needs the permissions again.\n. Yes, you can clear your data and that should allow you to receive the dialog again.\n. Yea, I actually think this is by design. After the dialog has appeared once, if the user granted or denied the permission, the permission, in theory should not appear again.\n\n---\n\nEdit:\nI take that back. Unless they check never ask again, it should keep asking if they ever access whatever needs the permissions again.\n. Yes, you can clear your data and that should allow you to receive the dialog again.\n. ",
    "vekexasia": "Just to know if there is a way to trigger the dialog ot show again.\n. Any chance for that to be done programmatically? So that i cant ask\npermission till that gets granted?\n\nIl 09 set 2016 6:35 PM, \"Ngoc Buu Tran\" notifications@github.com ha\nscritto:\n\n> Yes, you can clear your data and that should allow you to receive the\n> dialog again.\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/44#issuecomment-245967302,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAMPS4DLhlYJ5li7VfLa9ekCPuSs4xBRks5qoYregaJpZM4H7EEm\n> .\n. Just to know if there is a way to trigger the dialog ot show again.\n. Any chance for that to be done programmatically? So that i cant ask\npermission till that gets granted?\n\nIl 09 set 2016 6:35 PM, \"Ngoc Buu Tran\" notifications@github.com ha\nscritto:\n\n> Yes, you can clear your data and that should allow you to receive the\n> dialog again.\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/44#issuecomment-245967302,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAMPS4DLhlYJ5li7VfLa9ekCPuSs4xBRks5qoYregaJpZM4H7EEm\n> .\n. ",
    "toidv": "Any update on this issue, I have the same issue here. Firstly, I request CAMERA permission (`Manifest.permission.CAMERA`). If a user grants the permissionI then request WRITE_EXTERNAL_STORAGE permission (`Manifest.permission.WRITE_EXTERNAL_STORAGE`). Depending on User grant/decline WRITE_EXTERNAL_STORAGE permission the captured Image will be located at ExternalStorageDirectory/ExternalFilesDir but the request for `WRITE_EXTERNAL_STORAGE` never get callback (`onNext, onError, onComplete`)\n. This is demonstration code @tarasantoshchuk \nFirstly, request camera permission\n\n```\nprivate void requestCameraPermission() {\n        mSubscription = rxPermissions.request(Manifest.permission.CAMERA)\n                    .subscribe(new Subscriber<Boolean>() {\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                            e.printStackTrace();\n                        }\n\n                        @Override\n                        public void onNext(Boolean aBoolean) {\n                            if (aBoolean) {\n                                 requestWriteExternalStoragePermission(MEDIA_TYPE_IMAGE.getMediaType());\n                            } else {\n                                InploiUtils.showSnackbar(view, R.string.permissions_not_granted);\n                            }\n                        }\n                    });\n    }\n```\n\nThen request write external storage permission\n\n```\nprivate void requestWriteExternalStoragePermission(final String mediaTpe) {\n        if(mSubscription != null) {\n            mSubscription.unsubscribe();\n        }\n        mSubscription = rxPermissions.request(Manifest.permission.WRITE_EXTERNAL_STORAGE)\n                .subscribe(new Subscriber<Boolean>() {\n                    @Override\n                    public void onCompleted() {\n                        Timber.e(\"onCompleted\");\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        Timber.e(\"onCompleted\");\n                        e.printStackTrace();\n                    }\n\n                    @Override\n                    public void onNext(Boolean aBoolean) {\n                        if (!aBoolean) {\n                            showSnackbarWarning(aBoolean, mediaTpe);\n                        } else {\n                            showMediaType(aBoolean, mediaTpe);\n                        }\n                    }\n                });\n    }\n```\n. Any update on this issue, I have the same issue here. Firstly, I request CAMERA permission (`Manifest.permission.CAMERA`). If a user grants the permissionI then request WRITE_EXTERNAL_STORAGE permission (`Manifest.permission.WRITE_EXTERNAL_STORAGE`). Depending on User grant/decline WRITE_EXTERNAL_STORAGE permission the captured Image will be located at ExternalStorageDirectory/ExternalFilesDir but the request for `WRITE_EXTERNAL_STORAGE` never get callback (`onNext, onError, onComplete`)\n. This is demonstration code @tarasantoshchuk \nFirstly, request camera permission\n\n```\nprivate void requestCameraPermission() {\n        mSubscription = rxPermissions.request(Manifest.permission.CAMERA)\n                    .subscribe(new Subscriber<Boolean>() {\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                            e.printStackTrace();\n                        }\n\n                        @Override\n                        public void onNext(Boolean aBoolean) {\n                            if (aBoolean) {\n                                 requestWriteExternalStoragePermission(MEDIA_TYPE_IMAGE.getMediaType());\n                            } else {\n                                InploiUtils.showSnackbar(view, R.string.permissions_not_granted);\n                            }\n                        }\n                    });\n    }\n```\n\nThen request write external storage permission\n\n```\nprivate void requestWriteExternalStoragePermission(final String mediaTpe) {\n        if(mSubscription != null) {\n            mSubscription.unsubscribe();\n        }\n        mSubscription = rxPermissions.request(Manifest.permission.WRITE_EXTERNAL_STORAGE)\n                .subscribe(new Subscriber<Boolean>() {\n                    @Override\n                    public void onCompleted() {\n                        Timber.e(\"onCompleted\");\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        Timber.e(\"onCompleted\");\n                        e.printStackTrace();\n                    }\n\n                    @Override\n                    public void onNext(Boolean aBoolean) {\n                        if (!aBoolean) {\n                            showSnackbarWarning(aBoolean, mediaTpe);\n                        } else {\n                            showMediaType(aBoolean, mediaTpe);\n                        }\n                    }\n                });\n    }\n```\n. ",
    "afaucogney": "Especially with obfuscation, this will not work. I used it with RxBinding,\nbut from them nothing is necessary.\n\nI had to insert the RxJava rules found on the web to make it running. But\nno idea if this is optimal or not !\n\n```\n# rxjava\n-keep class rx.schedulers.Schedulers {\n    public static <methods>;\n}\n-keep class rx.schedulers.ImmediateScheduler {\n    public <methods>;\n}\n-keep class rx.schedulers.TestScheduler {\n    public <methods>;\n}\n-keep class rx.schedulers.Schedulers {\n    public static ** test();\n}\n-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* {\n    long producerIndex;\n    long consumerIndex;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef {\n    long producerNode;\n    long consumerNode;\n}\n```\n. Yes and No. As I'm not using directly use RxJava, I had to search and check\na while until I found a solution. I think refer to RxJava is a minimun\n\u1427\n\n2016-04-23 11:01 GMT+02:00 Thomas Bruyelle notifications@github.com:\n\n> It seems the rules are not specific to rx-permissions but more to rx-java,\n> in that case I don't think I should document them. Users simply refer to\n> the rx-java documentation for that purpose.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/45#issuecomment-213697653\n. Especially with obfuscation, this will not work. I used it with RxBinding,\nbut from them nothing is necessary.\n\nI had to insert the RxJava rules found on the web to make it running. But\nno idea if this is optimal or not !\n\n```\n# rxjava\n-keep class rx.schedulers.Schedulers {\n    public static <methods>;\n}\n-keep class rx.schedulers.ImmediateScheduler {\n    public <methods>;\n}\n-keep class rx.schedulers.TestScheduler {\n    public <methods>;\n}\n-keep class rx.schedulers.Schedulers {\n    public static ** test();\n}\n-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* {\n    long producerIndex;\n    long consumerIndex;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef {\n    long producerNode;\n    long consumerNode;\n}\n```\n. Yes and No. As I'm not using directly use RxJava, I had to search and check\na while until I found a solution. I think refer to RxJava is a minimun\n\u1427\n\n2016-04-23 11:01 GMT+02:00 Thomas Bruyelle notifications@github.com:\n\n> It seems the rules are not specific to rx-permissions but more to rx-java,\n> in that case I don't think I should document them. Users simply refer to\n> the rx-java documentation for that purpose.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/45#issuecomment-213697653\n. ",
    "ysnows": "for rxpermissions,just add `-dontwarn com.tbruyelle.rxpermissions.**` to your app progurard-rules.pro file\u3002. for rxpermissions,just add `-dontwarn com.tbruyelle.rxpermissions.**` to your app progurard-rules.pro file\u3002. ",
    "tushar-acharya": "+1 Got the same issue in production.\n. @tbruyelle I agree it's not the perfect fix, but until the time such a fix is developed this will serve as a placeholder at the least. I have 113 unique instances of this crash in my production, so either the number of weird users are high or this is a pretty common scenario \ud83d\ude04 \n. +1 Got the same issue in production.\n. @tbruyelle I agree it's not the perfect fix, but until the time such a fix is developed this will serve as a placeholder at the least. I have 113 unique instances of this crash in my production, so either the number of weird users are high or this is a pretty common scenario \ud83d\ude04 \n. ",
    "Dwite": "@tbruyelle so what do you think about PR?\n. @tbruyelle so what do you think about PR?\n. ",
    "AAverin": "I have just started open beta for my app, have some 500 users, maybe half of them active at best.\nGot 1 instance of this exception already. The only permission I ask for is Location.\nThat means that STR are wrong \u2013 my users can't \"go to settings and revoke some other permission\", because I have only one available, and revoking or granting it while dialog shows on the screen doesn't break the app\n. @tbruyelle yes, you're right, my bug is on 6.0.1.\nWell, that's a bit more reassuring, but probably should be resolved nevertheless\n. @tbruyelle 0.8.0 is tag on github, but not marked as latest release. Is it safe to grab it and use?\n. SO far managed with\n`Observable.just(true).compose(rxPermissions.ensureEach(Manifest.permission.ACCESS_FINE_LOCATION)).subscribe()`\nIs it the right way?\n. I have just started open beta for my app, have some 500 users, maybe half of them active at best.\nGot 1 instance of this exception already. The only permission I ask for is Location.\nThat means that STR are wrong \u2013 my users can't \"go to settings and revoke some other permission\", because I have only one available, and revoking or granting it while dialog shows on the screen doesn't break the app\n. @tbruyelle yes, you're right, my bug is on 6.0.1.\nWell, that's a bit more reassuring, but probably should be resolved nevertheless\n. @tbruyelle 0.8.0 is tag on github, but not marked as latest release. Is it safe to grab it and use?\n. SO far managed with\n`Observable.just(true).compose(rxPermissions.ensureEach(Manifest.permission.ACCESS_FINE_LOCATION)).subscribe()`\nIs it the right way?\n. ",
    "SjAndy88": "I don't think the issue can be resolved. \n. I don't think the issue can be resolved. \n. ",
    "gotev": "@flztsj if you request permissions without rx, even if you try the described steps, your app will not crash. I request permissions with this helper I wrote and it works: https://gist.github.com/gotev/67c300c563bdf68a502c\n\nMaybe it can be useful to figure out what is going wrong with RxPermissions\n. @flztsj if you request permissions without rx, even if you try the described steps, your app will not crash. I request permissions with this helper I wrote and it works: https://gist.github.com/gotev/67c300c563bdf68a502c\n\nMaybe it can be useful to figure out what is going wrong with RxPermissions\n. ",
    "YellFunGit": "I found that app will crash while mutil RxPermission request at one time. @tbruyelle caused by the same issue.. I found that app will crash while mutil RxPermission request at one time. @tbruyelle caused by the same issue.. ",
    "epool": "@YellFunGit what version are you using?. probably version `0.9.0` solve the problem, but now sure. let us know if that version solves the problem.. @mengdd could you please provide us a basic project with the deep link configuration you are trying, to reproduce this issue?. @KushtrimPacaj could you please resolve the conflicts for merging this PR?. @Gregliest you could try `0.9.0` to verify if that version fixes you problem.. @tbruyelle I was getting a issue on the emulator, when I tap on request permission and permission dialog was shown and then I rotate the display and accept the permission the application demo was crashing. (I couldn't reproduce it again, I'll remove that from description). Fixes #44.\n\nThe benefit of `setRetainInstance(true);` is that the fragment will live along with the activity even after rotation, so once the activity is recreated the fragment still alive and re-attached to the new activity, so no more rotation issues. Without this the fragment dies along with the activity and the permission request process is lost. Also since `RxPermissions` is a singleton with a fragment reference it should refer the same fragment a no a new one to avoid memory leaks and unexpected behaviors.\n. @tbruyelle sure feel free to suggest me changes.\n. @tbruyelle I just fixed the NPE and moved all the permissions state from `RxPermissions` to `RxPermissionsFragment` since it is a retained fragment and the singleton on `RxPermissions` is no more required.\n. @tbruyelle Issue fixed, thanks for taking your time for testing those scenarios. \ud83d\ude04 \n. @tbruyelle let me know if you need any change for  this PR please.\n. @tbruyelle not sure but looks like this PR could fix #96 also.\n. @tbruyelle I can rollback the renaming from `RxPermissions.newInstance(activity)` to `RxPermissions.getInstance(activity)` if you prefer, but it is getting a new instance just the fragment is acting as singleton, but if you prefer I can name it `RxPermissions.getInstance()` back again.\n\nRegarding `2.x` I can create a new branch from `2.x`, apply these changes on that branch and create another PR against `2.x` branch.\n. @tbruyelle I just removed `RxPermissions.newInstance` in favor of a public constructor. I Hope to be applying all this PR changes on `2.x` branch this weekend.\n. @tbruyelle should we wait for `2.x` implementation for merging this PR?\n. @tbruyelle actually I would prefer to merge this PR and release this PR in an independent way of the `2.x` version. But it's up to you take the decision.\n. @tbruyelle NP actually I was planing to create a library like this one, but I didn't know about `RxPermissions` but when I know it I better decided to create this PR \ud83d\ude03 . BTW I think the git release tagging is pending for `0.9.0` version.\n. I totally agree with @tbruyelle . But @matejhacin you could try the latest `0.9.0` version.. @RonTt Could you try the latest `0.9.0` version please? probably this new release fixed this issue.\n. @onlybeyond How do you disable permissions manually on Android 5.0? That feature was introduced on Android 6.0+ api 23 marshmallow. In previous version the permissions are accepted on installation time, but as far as I know there is not a way to disable them manually. If I'm wrong please share us a screenshot of how you are disabling the permissions manually and another one with the android version please. . @tinylpc what is happening when you request some permission on the `onResume()` method is that android OS displays the permission dialog, then your activity is paused as you can see on [this diagram](https://developer.android.com/images/training/basics/basic-lifecycle-paused.png), and when you accept or reject the permission the permission dialog is closed and then your activity call the `onResume()` method again, and if you rejected the permission the permission is requested again because is on the `onResume()` method. Doesn't look like a bug, probably you should avoid requesting permissions on your `onResume()` method to avoid this behavior.. I just could reproduce this putting a breakpoint on `requestPermissions(permissions, PERMISSIONS_REQUEST_CODE);` from `RxPermissionsFragment`:\r\n```java\r\n@TargetApi(Build.VERSION_CODES.M)\r\nvoid requestPermissions(@NonNull String[] permissions) {\r\n    requestPermissions(permissions, PERMISSIONS_REQUEST_CODE);\r\n}\r\n```\r\nWhen the breakpoint is reached(the permission dialog is not displayed yet), then I re-run the app on debug mode and there is where the dialog is shown. I couldn't find another way to reproduce this, so I'm not sure if it's a bug or something related with the app relaunching stuff.\r\n\r\nBut looks like it's not related with `android:noHistory=\"true|false\"` that didn't affect my test flow.. It's weird, I haven't seen that configuration before on a device, my Nexus device doesn't have that option and I couldn't reproduce it \ud83d\ude1e  . But if you set allowed or refused the behavior is the expected?. Also we don't need to \"hack\" a transparent/shadow activity for managing permissions since we can make it from a fragment without view and we could retain the permission status through activity lifecycle. But I'd like to know what do you think about that also.. > On first glance the idea seems smart although I'm not so sure whether this can have any drawbacks since it's still a Fragment and they behave oddly. At least that's how I feel about them. I try to avoid them as much as I can.\r\n\r\nI agree that fragments behave oddly sometimes, but it's due his async nature, actually I try to avoid them too, but the way we are using them here is forcing the fragment to be sync on setup time, so we shouldn't worry about this from my point of view.\r\n\r\n> Also this 'hack' of a transparent activity is quite common, no? I've seen it already in a few other places as well.\r\n\r\nNot sure, but could be useful in some scenarios.\r\n\r\n> Also before I was able to use RxPermissions regardless of an activity being present or not which means I was able to use it in Services and other places where no activity is present.\r\n\r\nAn Activity is always required to request permissions so I don't this that the library should support asking permissions from a Services but I agree that that feature is really useful, but that feature could be a extension/module or perhaps another library, but again that is my humble opinion.\r\n\r\n> Now even for checking whether a permission is granted or not it needs a fragment.\r\n\r\nI don't see this like a problem, but we could retain a reference to the activity on `RxPermission` class and then use that reference for checking permissions and make the fragment building lazy perhaps.\r\n\r\n> Also I'm not sure whether the library should use the 'real' fragments or v4 fragments and whether or not by using both as a consumer things could get mingled up.\r\n\r\nI'm ok with using the 'real' fragments, v4 are used to support backward compatibility with old android versions, but since runtime permissions were introduced in API 23 I can't see any drawback regarding using 'real' fragments.\r\n\r\n> Another thing that I've seen often times is that devs are manually manipulating the fragment stack e.g. via pushing or popping fragments. So in theory could this change go and break if someone suddenly tries to pop the fragment while the permission request is in process or was just recently started?\r\n\r\nIn theory this couldn't since we are not adding the retained fragment on the fragment back stack.. Yeah I hope to do it this weekend, I haven't had free time these days, sorry.. @tbruyelle not yet but next week I'll be taking vacations and I will work on 2.x branch. @teresaholfeld that action is pretty straightforward to do with a context reference like a service I guess, you can take a look at #111 where that PR is adding static methods for doing what you are looking for.. Awesome! \ud83d\ude03 . @bxqgit RxJava 2 is currently supported through `compile 'com.tbruyelle.rxpermissions2:rxpermissions:0.9.1@aar'`. Actually I'm thinking that could be 23 since this version is where the library is useful. @tbruyelle I'm not sure seems like the library it's being used in a activity and then the activity is finished quickly or something like that. @ar-g could you please tell us how are you using the library and/or share us a project to reproduce this issue please? In advance thanks. . @ar-g what is your current architecture or from where are you calling `requestWriteExternalStoragePermission(activity)`? Why are you doing a `new RxPermissions(activity)...` inside that method and not keep a `RxPermissions` instance on your class with the same scope of your activity?. @MinkiPan could you please share us a project example to reproduce this error? I have tried to reproduce it but I wasn't lucky, I was able to request permissions inside of a fragment in the onActivityCreated method.. @afiqiqmal you don't need to request permissions again inside of the the `.subscribe()`, you can do a new Observable from `rxPermissions.requestEach(permissions)` something like:\r\n```java\r\nrxPermissions.requestEach(permissions)\r\n                .filter(permission -> permission.granted || permission.shouldShowRequestPermissionRationale)\r\n                .takeFirst()\r\n                .map(permission -> false)\r\n                .defaultIfEmpty(true)\r\n                .subscribe(wereAllPermissionsRejectedPermanent -> ...);\r\n```\r\nwith this approach we are taking the first granted permission and mapping it to `true` so at least one permission was granted, and if all the permissions were rejected with `never ask again` we will get a empty observable and in that case we are mapping it to `true` and with this we can know if all the permissions were rejected permanently. Let us know if we can help you some better or perhaps I could not understand your problem at all.. @afiqiqmal Feel free to reopen this issue if you consider it necessary.. @cat1024 could you please provide us more information about this issue? some pieces of code, stack trace and steps to reproduce it could be helpful.. @boomstack I'm not sure to figure out what case you are trying to consider as a potential bug. Since the fragments are totally independents between them there shouldn't be any problem between other fragments, each fragment just depends on the Activity lifecycle. I have seen your demo project but wasn't able to get your point, could you please explain your point better or even better update your demo project to show us the case you are considering  as a potential bug?. @boomstack Feel free to reopen this issue if you consider it necessary.. @yuxinLi @ChinaDragon01 do you have some example project for reproducing it?. @isVoid actually this library doesn't require Java 8 to works, you could still using anonymous classes instead of lamdas, but if you really want to take advantage of the lamda syntax, you could use [Retrolambda](https://github.com/evant/gradle-retrolambda) or even still using Java 8 directly from Android Studio, google deprecated Jack toolchain but not Java 8 support, take a look [here](https://developer.android.com/studio/preview/features/java8-support.html).. also you could take a look at the sample project [here](https://github.com/tbruyelle/RxPermissions/blob/2.x/sample/src/main/java/com/tbruyelle/rxpermissions2/sample/MainActivity.java#L46). totally agree with @mrArtCore. closing due not much information for this issue, @jianwenzhou feel free to reopen it with a clearer description of the issue thanks!. @xchengDroid could you share a project where we can be able to reproduce this issue?. @SeaMyC It's not possible to request permissions from an `Application` class in Android, that is why `RxPermission` requires an `Activity` instead of an `Application` or `Context` class.. @YellFunGit what version are you using?. probably version `0.9.0` solve the problem, but now sure. let us know if that version solves the problem.. @mengdd could you please provide us a basic project with the deep link configuration you are trying, to reproduce this issue?. @KushtrimPacaj could you please resolve the conflicts for merging this PR?. @Gregliest you could try `0.9.0` to verify if that version fixes you problem.. @tbruyelle I was getting a issue on the emulator, when I tap on request permission and permission dialog was shown and then I rotate the display and accept the permission the application demo was crashing. (I couldn't reproduce it again, I'll remove that from description). Fixes #44.\n\nThe benefit of `setRetainInstance(true);` is that the fragment will live along with the activity even after rotation, so once the activity is recreated the fragment still alive and re-attached to the new activity, so no more rotation issues. Without this the fragment dies along with the activity and the permission request process is lost. Also since `RxPermissions` is a singleton with a fragment reference it should refer the same fragment a no a new one to avoid memory leaks and unexpected behaviors.\n. @tbruyelle sure feel free to suggest me changes.\n. @tbruyelle I just fixed the NPE and moved all the permissions state from `RxPermissions` to `RxPermissionsFragment` since it is a retained fragment and the singleton on `RxPermissions` is no more required.\n. @tbruyelle Issue fixed, thanks for taking your time for testing those scenarios. \ud83d\ude04 \n. @tbruyelle let me know if you need any change for  this PR please.\n. @tbruyelle not sure but looks like this PR could fix #96 also.\n. @tbruyelle I can rollback the renaming from `RxPermissions.newInstance(activity)` to `RxPermissions.getInstance(activity)` if you prefer, but it is getting a new instance just the fragment is acting as singleton, but if you prefer I can name it `RxPermissions.getInstance()` back again.\n\nRegarding `2.x` I can create a new branch from `2.x`, apply these changes on that branch and create another PR against `2.x` branch.\n. @tbruyelle I just removed `RxPermissions.newInstance` in favor of a public constructor. I Hope to be applying all this PR changes on `2.x` branch this weekend.\n. @tbruyelle should we wait for `2.x` implementation for merging this PR?\n. @tbruyelle actually I would prefer to merge this PR and release this PR in an independent way of the `2.x` version. But it's up to you take the decision.\n. @tbruyelle NP actually I was planing to create a library like this one, but I didn't know about `RxPermissions` but when I know it I better decided to create this PR \ud83d\ude03 . BTW I think the git release tagging is pending for `0.9.0` version.\n. I totally agree with @tbruyelle . But @matejhacin you could try the latest `0.9.0` version.. @RonTt Could you try the latest `0.9.0` version please? probably this new release fixed this issue.\n. @onlybeyond How do you disable permissions manually on Android 5.0? That feature was introduced on Android 6.0+ api 23 marshmallow. In previous version the permissions are accepted on installation time, but as far as I know there is not a way to disable them manually. If I'm wrong please share us a screenshot of how you are disabling the permissions manually and another one with the android version please. . @tinylpc what is happening when you request some permission on the `onResume()` method is that android OS displays the permission dialog, then your activity is paused as you can see on [this diagram](https://developer.android.com/images/training/basics/basic-lifecycle-paused.png), and when you accept or reject the permission the permission dialog is closed and then your activity call the `onResume()` method again, and if you rejected the permission the permission is requested again because is on the `onResume()` method. Doesn't look like a bug, probably you should avoid requesting permissions on your `onResume()` method to avoid this behavior.. I just could reproduce this putting a breakpoint on `requestPermissions(permissions, PERMISSIONS_REQUEST_CODE);` from `RxPermissionsFragment`:\r\n```java\r\n@TargetApi(Build.VERSION_CODES.M)\r\nvoid requestPermissions(@NonNull String[] permissions) {\r\n    requestPermissions(permissions, PERMISSIONS_REQUEST_CODE);\r\n}\r\n```\r\nWhen the breakpoint is reached(the permission dialog is not displayed yet), then I re-run the app on debug mode and there is where the dialog is shown. I couldn't find another way to reproduce this, so I'm not sure if it's a bug or something related with the app relaunching stuff.\r\n\r\nBut looks like it's not related with `android:noHistory=\"true|false\"` that didn't affect my test flow.. It's weird, I haven't seen that configuration before on a device, my Nexus device doesn't have that option and I couldn't reproduce it \ud83d\ude1e  . But if you set allowed or refused the behavior is the expected?. Also we don't need to \"hack\" a transparent/shadow activity for managing permissions since we can make it from a fragment without view and we could retain the permission status through activity lifecycle. But I'd like to know what do you think about that also.. > On first glance the idea seems smart although I'm not so sure whether this can have any drawbacks since it's still a Fragment and they behave oddly. At least that's how I feel about them. I try to avoid them as much as I can.\r\n\r\nI agree that fragments behave oddly sometimes, but it's due his async nature, actually I try to avoid them too, but the way we are using them here is forcing the fragment to be sync on setup time, so we shouldn't worry about this from my point of view.\r\n\r\n> Also this 'hack' of a transparent activity is quite common, no? I've seen it already in a few other places as well.\r\n\r\nNot sure, but could be useful in some scenarios.\r\n\r\n> Also before I was able to use RxPermissions regardless of an activity being present or not which means I was able to use it in Services and other places where no activity is present.\r\n\r\nAn Activity is always required to request permissions so I don't this that the library should support asking permissions from a Services but I agree that that feature is really useful, but that feature could be a extension/module or perhaps another library, but again that is my humble opinion.\r\n\r\n> Now even for checking whether a permission is granted or not it needs a fragment.\r\n\r\nI don't see this like a problem, but we could retain a reference to the activity on `RxPermission` class and then use that reference for checking permissions and make the fragment building lazy perhaps.\r\n\r\n> Also I'm not sure whether the library should use the 'real' fragments or v4 fragments and whether or not by using both as a consumer things could get mingled up.\r\n\r\nI'm ok with using the 'real' fragments, v4 are used to support backward compatibility with old android versions, but since runtime permissions were introduced in API 23 I can't see any drawback regarding using 'real' fragments.\r\n\r\n> Another thing that I've seen often times is that devs are manually manipulating the fragment stack e.g. via pushing or popping fragments. So in theory could this change go and break if someone suddenly tries to pop the fragment while the permission request is in process or was just recently started?\r\n\r\nIn theory this couldn't since we are not adding the retained fragment on the fragment back stack.. Yeah I hope to do it this weekend, I haven't had free time these days, sorry.. @tbruyelle not yet but next week I'll be taking vacations and I will work on 2.x branch. @teresaholfeld that action is pretty straightforward to do with a context reference like a service I guess, you can take a look at #111 where that PR is adding static methods for doing what you are looking for.. Awesome! \ud83d\ude03 . @bxqgit RxJava 2 is currently supported through `compile 'com.tbruyelle.rxpermissions2:rxpermissions:0.9.1@aar'`. Actually I'm thinking that could be 23 since this version is where the library is useful. @tbruyelle I'm not sure seems like the library it's being used in a activity and then the activity is finished quickly or something like that. @ar-g could you please tell us how are you using the library and/or share us a project to reproduce this issue please? In advance thanks. . @ar-g what is your current architecture or from where are you calling `requestWriteExternalStoragePermission(activity)`? Why are you doing a `new RxPermissions(activity)...` inside that method and not keep a `RxPermissions` instance on your class with the same scope of your activity?. @MinkiPan could you please share us a project example to reproduce this error? I have tried to reproduce it but I wasn't lucky, I was able to request permissions inside of a fragment in the onActivityCreated method.. @afiqiqmal you don't need to request permissions again inside of the the `.subscribe()`, you can do a new Observable from `rxPermissions.requestEach(permissions)` something like:\r\n```java\r\nrxPermissions.requestEach(permissions)\r\n                .filter(permission -> permission.granted || permission.shouldShowRequestPermissionRationale)\r\n                .takeFirst()\r\n                .map(permission -> false)\r\n                .defaultIfEmpty(true)\r\n                .subscribe(wereAllPermissionsRejectedPermanent -> ...);\r\n```\r\nwith this approach we are taking the first granted permission and mapping it to `true` so at least one permission was granted, and if all the permissions were rejected with `never ask again` we will get a empty observable and in that case we are mapping it to `true` and with this we can know if all the permissions were rejected permanently. Let us know if we can help you some better or perhaps I could not understand your problem at all.. @afiqiqmal Feel free to reopen this issue if you consider it necessary.. @cat1024 could you please provide us more information about this issue? some pieces of code, stack trace and steps to reproduce it could be helpful.. @boomstack I'm not sure to figure out what case you are trying to consider as a potential bug. Since the fragments are totally independents between them there shouldn't be any problem between other fragments, each fragment just depends on the Activity lifecycle. I have seen your demo project but wasn't able to get your point, could you please explain your point better or even better update your demo project to show us the case you are considering  as a potential bug?. @boomstack Feel free to reopen this issue if you consider it necessary.. @yuxinLi @ChinaDragon01 do you have some example project for reproducing it?. @isVoid actually this library doesn't require Java 8 to works, you could still using anonymous classes instead of lamdas, but if you really want to take advantage of the lamda syntax, you could use [Retrolambda](https://github.com/evant/gradle-retrolambda) or even still using Java 8 directly from Android Studio, google deprecated Jack toolchain but not Java 8 support, take a look [here](https://developer.android.com/studio/preview/features/java8-support.html).. also you could take a look at the sample project [here](https://github.com/tbruyelle/RxPermissions/blob/2.x/sample/src/main/java/com/tbruyelle/rxpermissions2/sample/MainActivity.java#L46). totally agree with @mrArtCore. closing due not much information for this issue, @jianwenzhou feel free to reopen it with a clearer description of the issue thanks!. @xchengDroid could you share a project where we can be able to reproduce this issue?. @SeaMyC It's not possible to request permissions from an `Application` class in Android, that is why `RxPermission` requires an `Activity` instead of an `Application` or `Context` class.. ",
    "zhengzhou": "after request permission, i just choose the activity from recently use, and it crash.\n\ncom.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n\n Caused by: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n:   at com.tbruyelle.rxpermissions.b.a(RxPermissions.java:286)\n:   at com.tbruyelle.rxpermissions.ShadowActivity.onRequestPermissionsResult(ShadowActivity.java:32)\n. @tbruyelle , my activity is a launcher(android:excludeFromRecents=\"true\"), so i can see it.\n. after request permission, i just choose the activity from recently use, and it crash.\n\ncom.tbruyelle.rxpermissions.ShadowActivity}: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n\n Caused by: java.lang.IllegalStateException: RxPermissions.onRequestPermissionsResult invoked but didn't find the corresponding permission request.\n:   at com.tbruyelle.rxpermissions.b.a(RxPermissions.java:286)\n:   at com.tbruyelle.rxpermissions.ShadowActivity.onRequestPermissionsResult(ShadowActivity.java:32)\n. @tbruyelle , my activity is a launcher(android:excludeFromRecents=\"true\"), so i can see it.\n. ",
    "Nilzor": "Ok I was a bit unclear. I wasn't asking for UI, but callbacks / flow for triggering rationale UI.  \n\nI have looked a bit more at the source and see that you have a method `RxPermissions.shouldShowRequestPermissionRationale` which is partly what I'm looking for, but it doesn't utilize ShadowActivity, so it's more bound to the consumer's activity. \n\nedit: I guess I'd be happy if you could document in the README how to use `shouldShowRequestPermissionRationale` \n. Ok I was a bit unclear. I wasn't asking for UI, but callbacks / flow for triggering rationale UI.  \n\nI have looked a bit more at the source and see that you have a method `RxPermissions.shouldShowRequestPermissionRationale` which is partly what I'm looking for, but it doesn't utilize ShadowActivity, so it's more bound to the consumer's activity. \n\nedit: I guess I'd be happy if you could document in the README how to use `shouldShowRequestPermissionRationale` \n. ",
    "MFlisar": "I had the same idea and am using it that way currently... just thought you have a better idea as this somehow makes the usage a little unintuitive...\n\nSo no need for an example, thanks for your thoughts on this\n. One general question:\n\nIs it necessary to REUSE the subject? Or can I create a new subject whenever the activity is created? In the end it comes to following question: Should I use a static subject or not?\n. I had the same idea and am using it that way currently... just thought you have a better idea as this somehow makes the usage a little unintuitive...\n\nSo no need for an example, thanks for your thoughts on this\n. One general question:\n\nIs it necessary to REUSE the subject? Or can I create a new subject whenever the activity is created? In the end it comes to following question: Should I use a static subject or not?\n. ",
    "maxxx": "Same issue for that permission (defined in manifest also). Let's try to re-open issue.\r\nmy test code inside of onCreate in activity:\r\n\r\n```\r\n\t\tnew RxPermissions(this)\r\n\t\t\t\t.requestEach(Manifest.permission.CHANGE_NETWORK_STATE, Manifest.permission.WRITE_SETTINGS, Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION)\r\n\t\t\t\t.subscribe(permission -> {\r\n\t\t\t\t\tif (permission.granted) {\r\n\t\t\t\t\t\t// granted\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tToast.makeText(this, \"You must allow required permission \" + permission.name, Toast.LENGTH_LONG).show();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n```\r\nYou will see not granted toast. tested on android emulators - api 23/24 and on asus zenfone max 3 api 24.\r\nOnly location request dialog is visible to user.. Same issue for that permission (defined in manifest also). Let's try to re-open issue.\r\nmy test code inside of onCreate in activity:\r\n\r\n```\r\n\t\tnew RxPermissions(this)\r\n\t\t\t\t.requestEach(Manifest.permission.CHANGE_NETWORK_STATE, Manifest.permission.WRITE_SETTINGS, Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION)\r\n\t\t\t\t.subscribe(permission -> {\r\n\t\t\t\t\tif (permission.granted) {\r\n\t\t\t\t\t\t// granted\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tToast.makeText(this, \"You must allow required permission \" + permission.name, Toast.LENGTH_LONG).show();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n```\r\nYou will see not granted toast. tested on android emulators - api 23/24 and on asus zenfone max 3 api 24.\r\nOnly location request dialog is visible to user.. ",
    "micHar": "If the lib calls onCompleted on the subscriber, then it is perfectly safe not to unsubscribe. After onCompleted the subscriber will be garbage collected.\nAnd I assume it calls onCompleted, because there is no reason not to (but have not checked it in the code).\n. If the lib calls onCompleted on the subscriber, then it is perfectly safe not to unsubscribe. After onCompleted the subscriber will be garbage collected.\nAnd I assume it calls onCompleted, because there is no reason not to (but have not checked it in the code).\n. ",
    "o-antsiferov": "I'm also using LeakCanary to detect possible leaks and it detects them after changing orientation back and forth for some times when permission dialog is shown: \r\n![device-150152](https://user-images.githubusercontent.com/1282126/28267051-eb953392-6b00-11e7-8c92-3f232f1753fa.png)\r\nDo the following inside `MapActivity#onStart`:\r\n`rxPermissions.request(Manifest.permission.ACCESS_FINE_LOCATION).subscribe(granted -> { /*...*/ });`\r\n\r\n. I'm also using LeakCanary to detect possible leaks and it detects them after changing orientation back and forth for some times when permission dialog is shown: \r\n![device-150152](https://user-images.githubusercontent.com/1282126/28267051-eb953392-6b00-11e7-8c92-3f232f1753fa.png)\r\nDo the following inside `MapActivity#onStart`:\r\n`rxPermissions.request(Manifest.permission.ACCESS_FINE_LOCATION).subscribe(granted -> { /*...*/ });`\r\n\r\n. ",
    "NitroXenon": "Well... I have 444 unique instances of this crash in my production.\n. @tbruyelle I have 20k of active users daily...\n. Well... I have 444 unique instances of this crash in my production.\n. @tbruyelle I have 20k of active users daily...\n. ",
    "imcloud": "thanks for your help\n. thanks for your help\n. ",
    "lovejjfg": "```\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.7.0@aar'\ncompile 'com.jakewharton.rxbinding:rxbinding:0.4.0' \n```\n. ```\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.7.0@aar'\ncompile 'com.jakewharton.rxbinding:rxbinding:0.4.0' \n```\n. ",
    "jvbreen1": "@huahongyang What is your targetSdkVersion and compileSdkVersion in your build.gradle? \n. What are you trying to do when the crash happens? Do you have any other\nlibraries in your app? Can you reproduce on a sample app?\n\nOn Mon, Jul 11, 2016, 8:05 PM huahongyang notifications@github.com wrote:\n\n> @jvbreen1 https://github.com/jvbreen1 targetSdkVersion 23\n> ,compileSdkVersion 23 and the crash api level is 19\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/59#issuecomment-231901709,\n> or mute the thread\n> https://github.com/notifications/unsubscribe/AE5U9n6l67M7Hh1570sE9Y2TWoBPIoL1ks5qUtpWgaJpZM4JI9h_\n> .\n. @huahongyang What is your targetSdkVersion and compileSdkVersion in your build.gradle? \n. What are you trying to do when the crash happens? Do you have any other\nlibraries in your app? Can you reproduce on a sample app?\n\nOn Mon, Jul 11, 2016, 8:05 PM huahongyang notifications@github.com wrote:\n\n> @jvbreen1 https://github.com/jvbreen1 targetSdkVersion 23\n> ,compileSdkVersion 23 and the crash api level is 19\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/59#issuecomment-231901709,\n> or mute the thread\n> https://github.com/notifications/unsubscribe/AE5U9n6l67M7Hh1570sE9Y2TWoBPIoL1ks5qUtpWgaJpZM4JI9h_\n> .\n. ",
    "awhgwqpeogh": "@jvbreen1 targetSdkVersion 23 ,compileSdkVersion 23 and the crash api level is 19 \n. @jvbreen1 i don't have the crash device,i test my app in cloud testing,so i can't debug it to analyze the problem,i only have is the crash monitoring log \n. @jvbreen1 targetSdkVersion 23 ,compileSdkVersion 23 and the crash api level is 19 \n. @jvbreen1 i don't have the crash device,i test my app in cloud testing,so i can't debug it to analyze the problem,i only have is the crash monitoring log \n. ",
    "dkhmelenko": "@huahongyang API level should be min 23 (Android 6 Marshmallow). And you are using API level 19, where `requestPermissions` method doesn't exist.\nWhenever you use in code this library, the calls will be highlighted by Android Studio that the methods are available only in API level 23.\n. @PaulWoitaschek `Single` and `Completable` are still in Beta.\nAlso, as @tbruyelle suggested those changes can break compatibility, because they do not implement `Observable`.\n. @ShivamDev31 AppCompatActivity requires appcompat-v7 dependency. I don't see any reason to have it and prefer to keep the library more lightweight\n. @huahongyang API level should be min 23 (Android 6 Marshmallow). And you are using API level 19, where `requestPermissions` method doesn't exist.\nWhenever you use in code this library, the calls will be highlighted by Android Studio that the methods are available only in API level 23.\n. @PaulWoitaschek `Single` and `Completable` are still in Beta.\nAlso, as @tbruyelle suggested those changes can break compatibility, because they do not implement `Observable`.\n. @ShivamDev31 AppCompatActivity requires appcompat-v7 dependency. I don't see any reason to have it and prefer to keep the library more lightweight\n. ",
    "boyw165": "Could reference the following sample to maximize the compatibility.\n\n``` java\n// Here, thisActivity is the current activity\nif (ContextCompat.checkSelfPermission(thisActivity,\n                Manifest.permission.READ_CONTACTS)\n        != PackageManager.PERMISSION_GRANTED) {\n\n    // Should we show an explanation?\n    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,\n            Manifest.permission.READ_CONTACTS)) {\n\n        // Show an expanation to the user *asynchronously* -- don't block\n        // this thread waiting for the user's response! After the user\n        // sees the explanation, try again to request the permission.\n\n    } else {\n\n        // No explanation needed, we can request the permission.\n\n        ActivityCompat.requestPermissions(thisActivity,\n                new String[]{Manifest.permission.READ_CONTACTS},\n                MY_PERMISSIONS_REQUEST_READ_CONTACTS);\n\n        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an\n        // app-defined int constant. The callback method gets the\n        // result of the request.\n    }\n}\n```\n\nI created a **PR**, https://github.com/tbruyelle/RxPermissions/pull/76 .\n. I don't know if lightweight is that important over the compatibility. Please check out the [issue](https://github.com/tbruyelle/RxPermissions/issues/59) thread. I personally think it's necessary to have this library support API of <21.\n. Could reference the following sample to maximize the compatibility.\n\n``` java\n// Here, thisActivity is the current activity\nif (ContextCompat.checkSelfPermission(thisActivity,\n                Manifest.permission.READ_CONTACTS)\n        != PackageManager.PERMISSION_GRANTED) {\n\n    // Should we show an explanation?\n    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,\n            Manifest.permission.READ_CONTACTS)) {\n\n        // Show an expanation to the user *asynchronously* -- don't block\n        // this thread waiting for the user's response! After the user\n        // sees the explanation, try again to request the permission.\n\n    } else {\n\n        // No explanation needed, we can request the permission.\n\n        ActivityCompat.requestPermissions(thisActivity,\n                new String[]{Manifest.permission.READ_CONTACTS},\n                MY_PERMISSIONS_REQUEST_READ_CONTACTS);\n\n        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an\n        // app-defined int constant. The callback method gets the\n        // result of the request.\n    }\n}\n```\n\nI created a **PR**, https://github.com/tbruyelle/RxPermissions/pull/76 .\n. I don't know if lightweight is that important over the compatibility. Please check out the [issue](https://github.com/tbruyelle/RxPermissions/issues/59) thread. I personally think it's necessary to have this library support API of <21.\n. ",
    "mengdd": "Sorry I was wrong about the analysis, the task part.\nAfter some reading about the launch mode and the new task flags, I think the ShadowActivity is still in the same task.\nI'm still doing some experiments to find out a good way to fix the problem.\n. Just tried the version 0.9.4, the issue still exists.. @epool Hi, I just create a sample project here: https://github.com/mengdd/RxPermissionsSample\r\n\r\nMaybe it's because it involves two activities here. \r\nWhen there is one activity, the deep link works well. \r\n\r\nBut in my sample project, it shows the bug.\r\n\r\nI also tried the issue only exist with these lines present:\r\n```\r\n        newIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);\r\n        newIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n```\r\n\r\nSo it may be a too special case here.. Sorry I was wrong about the analysis, the task part.\nAfter some reading about the launch mode and the new task flags, I think the ShadowActivity is still in the same task.\nI'm still doing some experiments to find out a good way to fix the problem.\n. Just tried the version 0.9.4, the issue still exists.. @epool Hi, I just create a sample project here: https://github.com/mengdd/RxPermissionsSample\r\n\r\nMaybe it's because it involves two activities here. \r\nWhen there is one activity, the deep link works well. \r\n\r\nBut in my sample project, it shows the bug.\r\n\r\nI also tried the issue only exist with these lines present:\r\n```\r\n        newIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);\r\n        newIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n```\r\n\r\nSo it may be a too special case here.. ",
    "dreamcontinue": "Is there a good way to resolved? I just got the same problem as well. \n. Is there a good way to resolved? I just got the same problem as well. \n. ",
    "simformsolutions": "i am facing same issue.. can you please provide solution ?\n. i am facing same issue.. can you please provide solution ?\n. ",
    "hijamoya": "Still encounter the issue in current master.. Still encounter the issue in current master.. ",
    "selmanon": "@tbruyelle the new problem is that the popup isn't showing up .. any clue ?\n. **OnErrorNotImplementedException**\r\nThis indicates that an Observable tried to call its observer\u2019s onError() method, but that no such method existed. You can eliminate this by either fixing the Observable so that it no longer reaches an error condition, by implementing an onError handler in the observer, or by intercepting the onError notification before it reaches the observer by using one of the operators described elsewhere on this page.. @tbruyelle the new problem is that the popup isn't showing up .. any clue ?\n. **OnErrorNotImplementedException**\r\nThis indicates that an Observable tried to call its observer\u2019s onError() method, but that no such method existed. You can eliminate this by either fixing the Observable so that it no longer reaches an error condition, by implementing an onError handler in the observer, or by intercepting the onError notification before it reaches the observer by using one of the operators described elsewhere on this page.. ",
    "dreamhb": "on Android 4.2.2\n. It is the multidex problem, which cause rxjava exception, not this project, thanks for your work!\nThe problem is described here: https://github.com/square/retrofit/issues/1628\n. on Android 4.2.2\n. It is the multidex problem, which cause rxjava exception, not this project, thanks for your work!\nThe problem is described here: https://github.com/square/retrofit/issues/1628\n. ",
    "PopTudor": "I forgot that info about not being able to mock static methods even though was obvious that it's not mocked when followed with the debugger so thanks for reminding me !\nI was hoping I can just send true/false through direct access of the singleton but this way is better since now it doesn't depend on the internals of RxPermissions.\nThanks again and good luck !\n. I forgot that info about not being able to mock static methods even though was obvious that it's not mocked when followed with the debugger so thanks for reminding me !\nI was hoping I can just send true/false through direct access of the singleton but this way is better since now it doesn't depend on the internals of RxPermissions.\nThanks again and good luck !\n. ",
    "votruk": "@tarasantoshchuk nice! Thank you!\n. @tarasantoshchuk nice! Thank you!\n. ",
    "ramanbranavitski": "Hi there, how much time you need to implement this feature?\n. Hi there, how much time you need to implement this feature?\n. ",
    "GrahamBorland": "The sample app has the subscription in `onCreate()` but no corresponding call to `unsubscribe()`. Does it matter that the subscription is leaked here?. The sample app has the subscription in `onCreate()` but no corresponding call to `unsubscribe()`. Does it matter that the subscription is leaked here?. ",
    "santaevpavel": "Permission dialog opened twice when calling method `request()` in `onCreate()` .\r\nI enabled \"don't save activity\" mode in developers options in settings.\r\nHow i can resolve this problem?. Permission dialog opened twice when calling method `request()` in `onCreate()` .\r\nI enabled \"don't save activity\" mode in developers options in settings.\r\nHow i can resolve this problem?. ",
    "ShivamDev31": "Shouldn't ShadowActivity extends AppCompatActivity for backward compatibility. I know it won't effect the library user. Just keen to know. \n. So this is the gist of my class : https://gist.github.com/ShivamDev31/1144a06fce8dd19fe2ecc29cdac7271e\n\nIf I keep line 55 commented then once the user allowed for permission and comes for the second time it wont get executed. For me it seems like \nRxPermissions.getInstance(this).request(Manifest.permission.ACCESS_FINE_LOCATION)\n.subscribe(granted -> {\n\nthis checks if granted then skips the block as the code in if (granted) doesn't gets executed for the second time.\n. Oops I think something got messed up there. I'll make a new gist once I got back home, will update it here. Thanks for prompt reply.\n. So this is the updated [code gist](https://gist.github.com/ShivamDev31/f5941abe0c036e90663fefaf316f4a89)\n\nI've made a util method now to handle permissions. But it crashes sometimes giving permission error only.\nMoreover while the permission box is there is shows the 'else' case snackbar too \"Permission Denied\".\n\nPlease let me know if I'm doing something wrong, or my implementation is wrong or something as its not working everytime. Sometimes (if I stay at dialog permission dialog for few seconds) in the Log on even allowing it give false (CommonUtils log) and after that screen overlay detected go to settings. Strange behavior is happening.  \n\nAlso I would like to know once the user has granted the permission still the code under 'if' at line  25 will be executed everytime?\n. Everyone is in their learning phase, can you atleast tell me what I'm doing wrong there?\nI've been working with rxjava for few months now. Atleast redirect me to an article where I can see what I'm doing wrong?\nI got the permissions part working but would really like to know what went wrong with CommonUtils approach so that I can learn from my mistakes.\n. Shouldn't ShadowActivity extends AppCompatActivity for backward compatibility. I know it won't effect the library user. Just keen to know. \n. So this is the gist of my class : https://gist.github.com/ShivamDev31/1144a06fce8dd19fe2ecc29cdac7271e\n\nIf I keep line 55 commented then once the user allowed for permission and comes for the second time it wont get executed. For me it seems like \nRxPermissions.getInstance(this).request(Manifest.permission.ACCESS_FINE_LOCATION)\n.subscribe(granted -> {\n\nthis checks if granted then skips the block as the code in if (granted) doesn't gets executed for the second time.\n. Oops I think something got messed up there. I'll make a new gist once I got back home, will update it here. Thanks for prompt reply.\n. So this is the updated [code gist](https://gist.github.com/ShivamDev31/f5941abe0c036e90663fefaf316f4a89)\n\nI've made a util method now to handle permissions. But it crashes sometimes giving permission error only.\nMoreover while the permission box is there is shows the 'else' case snackbar too \"Permission Denied\".\n\nPlease let me know if I'm doing something wrong, or my implementation is wrong or something as its not working everytime. Sometimes (if I stay at dialog permission dialog for few seconds) in the Log on even allowing it give false (CommonUtils log) and after that screen overlay detected go to settings. Strange behavior is happening.  \n\nAlso I would like to know once the user has granted the permission still the code under 'if' at line  25 will be executed everytime?\n. Everyone is in their learning phase, can you atleast tell me what I'm doing wrong there?\nI've been working with rxjava for few months now. Atleast redirect me to an article where I can see what I'm doing wrong?\nI got the permissions part working but would really like to know what went wrong with CommonUtils approach so that I can learn from my mistakes.\n. ",
    "gengjiawen": "@vanniktech Are you working on this ?\n. @tbruyelle It seems that the rxjava2 version are not available in the jcenter.\n\n```\n* What went wrong:\nA problem occurred configuring project ':app'.\n> A problem occurred configuring project ':commonLibrary'.\n   > Could not resolve all dependencies for configuration ':commonLibrary:_debugPublishCopy'.\n      > Could not find com.tbruyelle.rxpermissions2:rxpermissions:0.7.1.\n```\n. The file not in here https://jcenter.bintray.com/com/tbruyelle/rxpermissions2/rxpermissions/0.7.1/rxpermissions-0.7.1.pom. Gradle will look for this url.Maybe something wrong with your local.properties file.\n. It worked :)\n\nOn Sat, Oct 1, 2016 at 3:31 AM, Thomas Bruyelle notifications@github.com\nwrote:\n\n> @gengjiawen https://github.com/gengjiawen Request approved by bintray,\n> please retry (I can't be myself for the moment)\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/71#issuecomment-250832705,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/ADleyCUItCtYX7iSKFVuTt9gqRbfCLCAks5qvWOmgaJpZM4Ju7LI\n> .\n. @tbruyelle @vanniktech \nIt's seems that rxpermission not compatibale with Rxjava2 rc4.\n\n```\njava.lang.NoSuchMethodError: No virtual method compose(Lio/reactivex/functions/Function;)\nLio/reactivex/Observable; in class Lio/reactivex/Observable; or its super classes (declaration of 'io.reactivex.Observable' appears in /data/app/com.shundaojia.travel.driver-2/base.apk)\n                                                                                at com.tbruyelle.rxpermissions2.RxPermissions.request(RxPermissions.java:125)\n```\n. @vanniktech get time to send a pr?\n. Any progress for compatibility issue?\n. Retrolamda also works fine with Repermissions. Already using it.\n. So many rom manufacters provide an option for users to `ignore the same permission request`, this will result in endless cycle. I fix the problem using the system permission with an boolean value to prevent repeat dialog show.. In short, it can result in keep calling `onRequestPermissionsResult`.\r\n\r\nFixed by put the check login in Activity onStart using RxPermissions.. @vanniktech Are you working on this ?\n. @tbruyelle It seems that the rxjava2 version are not available in the jcenter.\n\n```\n* What went wrong:\nA problem occurred configuring project ':app'.\n> A problem occurred configuring project ':commonLibrary'.\n   > Could not resolve all dependencies for configuration ':commonLibrary:_debugPublishCopy'.\n      > Could not find com.tbruyelle.rxpermissions2:rxpermissions:0.7.1.\n```\n. The file not in here https://jcenter.bintray.com/com/tbruyelle/rxpermissions2/rxpermissions/0.7.1/rxpermissions-0.7.1.pom. Gradle will look for this url.Maybe something wrong with your local.properties file.\n. It worked :)\n\nOn Sat, Oct 1, 2016 at 3:31 AM, Thomas Bruyelle notifications@github.com\nwrote:\n\n> @gengjiawen https://github.com/gengjiawen Request approved by bintray,\n> please retry (I can't be myself for the moment)\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/71#issuecomment-250832705,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/ADleyCUItCtYX7iSKFVuTt9gqRbfCLCAks5qvWOmgaJpZM4Ju7LI\n> .\n. @tbruyelle @vanniktech \nIt's seems that rxpermission not compatibale with Rxjava2 rc4.\n\n```\njava.lang.NoSuchMethodError: No virtual method compose(Lio/reactivex/functions/Function;)\nLio/reactivex/Observable; in class Lio/reactivex/Observable; or its super classes (declaration of 'io.reactivex.Observable' appears in /data/app/com.shundaojia.travel.driver-2/base.apk)\n                                                                                at com.tbruyelle.rxpermissions2.RxPermissions.request(RxPermissions.java:125)\n```\n. @vanniktech get time to send a pr?\n. Any progress for compatibility issue?\n. Retrolamda also works fine with Repermissions. Already using it.\n. So many rom manufacters provide an option for users to `ignore the same permission request`, this will result in endless cycle. I fix the problem using the system permission with an boolean value to prevent repeat dialog show.. In short, it can result in keep calling `onRequestPermissionsResult`.\r\n\r\nFixed by put the check login in Activity onStart using RxPermissions.. ",
    "thekalinga": "Any plan to close this issue? This has been sitting idle for quite sometime now.\n. Does it work with Rx 1.+ as well?\n. Any plan to close this issue? This has been sitting idle for quite sometime now.\n. Does it work with Rx 1.+ as well?\n. ",
    "renegens": "``` java\nsubscription = rxPermissions.request(Manifest.permission.ACCESS_FINE_LOCATION)\n.flatMap(new Func1<Boolean, Observable<Location>>() {\n            @Override\n            public Observable<Location> call(Boolean granted) {\n                if (granted){\n                    return lastKnownLocationObservable;\n                }else {\n                    return null;\n                }\n            }\n        })\n.switchIfEmpty(locationUpdatesObservable)\n.doOnNext(new Action1<Location>() {\n            @Override\n            public void call(Location location) {\n                goToLocationOnMap(location);\n                mapView.onResume();\n            }\n        })\n.flatMap(new Func1<Location, Observable<List<Address>>>() {\n            @Override\n            public Observable<List<Address>> call(Location location) {\n                return locationProvider.getReverseGeocodeObservable(location.getLatitude(), location.getLongitude(), 1);\n            }\n        })\n.subscribeOn(Schedulers.io())\n.observeOn(AndroidSchedulers.mainThread())\n.subscribe(new Observer<List<Address>>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n                Toast.makeText(context, \"Error getting address and location\", Toast.LENGTH_SHORT).show();\n\n            }\n\n            @Override\n            public void onNext(List<Address> addresses) {\n\n                if (addresses.size() > 0) {\n                    address.setText(locationToAddress(addresses));\n                }\n            }\n        });\n```\n\nThis is the code, if I press deny then I am being asked again. If I hit don't ask again it's like in a infinite loop where onNext is called always.  \n. Ok so another question then. How would you structure the code (or what operator would you use)that if the boolean returned from the permission is true the stream should continue, if not it should exit. \n. ``` java\n rxPermissions.request(Manifest.permission.ACCESS_FINE_LOCATION).filter(new Func1<Boolean, Boolean>() {\n            @Override\n            public Boolean call(Boolean aBoolean) {\n                return aBoolean;\n            }\n        }).flatMap(new Func1<Boolean, Observable<Location>>() {\n            @Override\n            public Observable<Location> call(Boolean granted) {\n                return lastKnownLocationObservable;\n\n            }\n        }).switchIfEmpty(locationUpdatesObservable).doOnNext(new Action1<Location>() {\n            @Override\n            public void call(Location location) {\n                goToLocationOnMap(location);\n                mapView.onResume();\n\n            }\n        }).flatMap(new Func1<Location, Observable<List<Address>>>() {\n            @Override\n            public Observable<List<Address>> call(Location location) {\n                return locationProvider.getReverseGeocodeObservable(location.getLatitude(), location.getLongitude(), 1);\n            }\n        }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<List<Address>>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n                Toast.makeText(context, \"Error getting address and location\", Toast.LENGTH_SHORT).show();\n\n            }\n\n            @Override\n            public void onNext(List<Address> addresses) {\n\n                if (addresses.size() > 0) {\n                    address.setText(locationToAddress(addresses));\n                }\n            }\n        });\n```\n\nI am getting the same behaviour. When pressing deny it doesn't end the stream so it asking again and again. If I hit allow it is continuing the stream and working. \n. ``` java\nsubscription = rxPermissions.request(Manifest.permission.ACCESS_FINE_LOCATION)\n.flatMap(new Func1<Boolean, Observable<Location>>() {\n            @Override\n            public Observable<Location> call(Boolean granted) {\n                if (granted){\n                    return lastKnownLocationObservable;\n                }else {\n                    return null;\n                }\n            }\n        })\n.switchIfEmpty(locationUpdatesObservable)\n.doOnNext(new Action1<Location>() {\n            @Override\n            public void call(Location location) {\n                goToLocationOnMap(location);\n                mapView.onResume();\n            }\n        })\n.flatMap(new Func1<Location, Observable<List<Address>>>() {\n            @Override\n            public Observable<List<Address>> call(Location location) {\n                return locationProvider.getReverseGeocodeObservable(location.getLatitude(), location.getLongitude(), 1);\n            }\n        })\n.subscribeOn(Schedulers.io())\n.observeOn(AndroidSchedulers.mainThread())\n.subscribe(new Observer<List<Address>>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n                Toast.makeText(context, \"Error getting address and location\", Toast.LENGTH_SHORT).show();\n\n            }\n\n            @Override\n            public void onNext(List<Address> addresses) {\n\n                if (addresses.size() > 0) {\n                    address.setText(locationToAddress(addresses));\n                }\n            }\n        });\n```\n\nThis is the code, if I press deny then I am being asked again. If I hit don't ask again it's like in a infinite loop where onNext is called always.  \n. Ok so another question then. How would you structure the code (or what operator would you use)that if the boolean returned from the permission is true the stream should continue, if not it should exit. \n. ``` java\n rxPermissions.request(Manifest.permission.ACCESS_FINE_LOCATION).filter(new Func1<Boolean, Boolean>() {\n            @Override\n            public Boolean call(Boolean aBoolean) {\n                return aBoolean;\n            }\n        }).flatMap(new Func1<Boolean, Observable<Location>>() {\n            @Override\n            public Observable<Location> call(Boolean granted) {\n                return lastKnownLocationObservable;\n\n            }\n        }).switchIfEmpty(locationUpdatesObservable).doOnNext(new Action1<Location>() {\n            @Override\n            public void call(Location location) {\n                goToLocationOnMap(location);\n                mapView.onResume();\n\n            }\n        }).flatMap(new Func1<Location, Observable<List<Address>>>() {\n            @Override\n            public Observable<List<Address>> call(Location location) {\n                return locationProvider.getReverseGeocodeObservable(location.getLatitude(), location.getLongitude(), 1);\n            }\n        }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<List<Address>>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n                Toast.makeText(context, \"Error getting address and location\", Toast.LENGTH_SHORT).show();\n\n            }\n\n            @Override\n            public void onNext(List<Address> addresses) {\n\n                if (addresses.size() > 0) {\n                    address.setText(locationToAddress(addresses));\n                }\n            }\n        });\n```\n\nI am getting the same behaviour. When pressing deny it doesn't end the stream so it asking again and again. If I hit allow it is continuing the stream and working. \n. ",
    "KushtrimPacaj": "@epool Just did.. @epool Just did.. ",
    "ZakTaccardi": "Sorry - I should have specified that I was looking for a hot observable, that would emit when it subscribes initially and when a permission changes. Observing this hot observable should NOT request the permission, but just emit its granted/not granted state.\n\nThis should be doable as long as long as the request is made through your `RxPermissions.request` API, where events can be forwarded to the hot observable by sharing some state behind the scenes\n. I have an `AudioJackDevice` that can have `open()` or `close()` called on it based on the microphone permission. Calling `open()` when permission is not granted would throw an exception. I would like to observe the microphone permission stream and combine it with an intent received from a microphone broadcast receiver. Here's a small kotlin excerpt:\n\n```\nObservable.combineLatest(intentObservable, permissionIsGrantedObservable) { intent, isGranted ->  AudioJackIntentInterpreter(intent, isGranted)})\n                .map { interpreter -> if (interpreter.shouldOpen) device.open() else device.close}\n```\n. You're right. But I mostly care about the use case when it goes from not\ngranted to granted, and I want that part to be independent on the UI. Your\nexisting request API is dependent on the UI (because initializing in an\nactivity lifecycle method is a requirement). This poses a problem when I\nwant to observe (note, not request) a permission in my data layer, which is\noutside the scope of the activity.\n\nOn Wed, Oct 12, 2016, 3:27 PM Thomas Bruyelle notifications@github.com\nwrote:\n\n> I don't see how the permission could be revoked at runtime. When you\n> revoke a permission for an app in the settings, the app is killed by the\n> framework.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/83#issuecomment-253313173,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAcJOl3f2Qj_E5KHfWbjIHmn_9su3mggks5qzTSPgaJpZM4KTCuo\n> .\n. Sorry - I should have specified that I was looking for a hot observable, that would emit when it subscribes initially and when a permission changes. Observing this hot observable should NOT request the permission, but just emit its granted/not granted state.\n\nThis should be doable as long as long as the request is made through your `RxPermissions.request` API, where events can be forwarded to the hot observable by sharing some state behind the scenes\n. I have an `AudioJackDevice` that can have `open()` or `close()` called on it based on the microphone permission. Calling `open()` when permission is not granted would throw an exception. I would like to observe the microphone permission stream and combine it with an intent received from a microphone broadcast receiver. Here's a small kotlin excerpt:\n\n```\nObservable.combineLatest(intentObservable, permissionIsGrantedObservable) { intent, isGranted ->  AudioJackIntentInterpreter(intent, isGranted)})\n                .map { interpreter -> if (interpreter.shouldOpen) device.open() else device.close}\n```\n. You're right. But I mostly care about the use case when it goes from not\ngranted to granted, and I want that part to be independent on the UI. Your\nexisting request API is dependent on the UI (because initializing in an\nactivity lifecycle method is a requirement). This poses a problem when I\nwant to observe (note, not request) a permission in my data layer, which is\noutside the scope of the activity.\n\nOn Wed, Oct 12, 2016, 3:27 PM Thomas Bruyelle notifications@github.com\nwrote:\n\n> I don't see how the permission could be revoked at runtime. When you\n> revoke a permission for an app in the settings, the app is killed by the\n> framework.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/tbruyelle/RxPermissions/issues/83#issuecomment-253313173,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAcJOl3f2Qj_E5KHfWbjIHmn_9su3mggks5qzTSPgaJpZM4KTCuo\n> .\n. ",
    "saksofonists": "@tarasantoshchuk Yep, I read your fix and was actually very impressed by the idea of storing and comparing PIDs \ud83d\udc4d - never seen that before.\nBut I am aware of this slight difference as mentioned in the PR description and I've chosen to handle it like this intentionally.\n\nAlso, now that I think of further development of the library, a switch like `if (BuildConfig.DEBUG) throw anyways;` and maybe some logging could be added for debug reasons. Not sure how well that works in a library though. What do you think @tbruyelle ?\n. @tarasantoshchuk Yep, I read your fix and was actually very impressed by the idea of storing and comparing PIDs \ud83d\udc4d - never seen that before.\nBut I am aware of this slight difference as mentioned in the PR description and I've chosen to handle it like this intentionally.\n\nAlso, now that I think of further development of the library, a switch like `if (BuildConfig.DEBUG) throw anyways;` and maybe some logging could be added for debug reasons. Not sure how well that works in a library though. What do you think @tbruyelle ?\n. ",
    "dreamlivemeng": "![image](https://cloud.githubusercontent.com/assets/18185775/19726580/2f5acfaa-9bbe-11e6-9bae-b65dffff2656.png)\nHi, I'm sorry, my reply has been some late. When a permission is requested, a shadow flashes quickly at the toolbar. \n. ![image](https://cloud.githubusercontent.com/assets/18185775/19726580/2f5acfaa-9bbe-11e6-9bae-b65dffff2656.png)\nHi, I'm sorry, my reply has been some late. When a permission is requested, a shadow flashes quickly at the toolbar. \n. ",
    "AriaWang": "got  the same question  and   sovled.  \n0.8.0   needs  rxjava  1.x version,  while  0.8.1  needs  rxjava   2.x version.\n. got  the same question  and   sovled.  \n0.8.0   needs  rxjava  1.x version,  while  0.8.1  needs  rxjava   2.x version.\n. ",
    "sinhpn92": "I tried with `rxpermissions` and `rxpermissions2`. But I can not found `subscribe` method. I tried restart and rebuild project on android studio, too.\n. I tried with `rxpermissions` and `rxpermissions2`. But I can not found `subscribe` method. I tried restart and rebuild project on android studio, too.\n. ",
    "ThanosFisherman": "I'm having the same issue both with RxJava 1 and 2. After Rebuilding the project I got the following error\n`error: cannot access Observable\nclass file for rx.Observable not found`\nI guess I need to include the rxJava itself as a dependency?\n. >  No, that's not required, Gradle do it for you.\n\nI guess it should but there was no subscribe methods in neither of the two package names of the lib.\nAfter adding the following manually\n\n```\ncompile 'io.reactivex:rxjava:1.2.1'\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.8.0@aar'\n```\n\nIt worked as expected. (Image below shows the non existent subscribe method before I added rxjava dependency itself)\n\n![nosubscribe](https://cloud.githubusercontent.com/assets/4888330/19960331/d26de5b4-a1b4-11e6-9c10-f104390d3bc5.JPG)\n. I'm having the same issue both with RxJava 1 and 2. After Rebuilding the project I got the following error\n`error: cannot access Observable\nclass file for rx.Observable not found`\nI guess I need to include the rxJava itself as a dependency?\n. >  No, that's not required, Gradle do it for you.\n\nI guess it should but there was no subscribe methods in neither of the two package names of the lib.\nAfter adding the following manually\n\n```\ncompile 'io.reactivex:rxjava:1.2.1'\ncompile 'com.tbruyelle.rxpermissions:rxpermissions:0.8.0@aar'\n```\n\nIt worked as expected. (Image below shows the non existent subscribe method before I added rxjava dependency itself)\n\n![nosubscribe](https://cloud.githubusercontent.com/assets/4888330/19960331/d26de5b4-a1b4-11e6-9c10-f104390d3bc5.JPG)\n. ",
    "Gregliest": "Thanks for the quick response.  Yes, I'm going off the rails a little bit here.  As I said, I don't care if some of the responses get dropped if the activity gets recreated.  Also, I'm triggering the permissions request from an event, and  I can't easily make the element reactive.  I ran into this exception as I was experimenting with how RxPermissions would handle the permissions request in this case.  \n\nI read through https://github.com/tbruyelle/RxPermissions/issues/3, and I think that the tradeoff of flexibility (requiring the permissions request in the initialization) for completeness is perfectly reasonable, for cases where you need to guarantee that the result is emitted to the subscriber.  However, it would also seem reasonable for the library to support cases where it doesn't matter if the occasional request gets dropped.  At least, I didn't expect the library to crash.  I also have no way to catch the exception and act on it, since it's thrown completely internally to the library.  Is there a way to emit the error to the observable?  \n. I'm requesting permissions inside of an `OnClickListener` inside of a Dialog.  The code itself is pretty generic, let me know if you actually want to see it.  I'm testing by setting the developer option \"Don't keep activities\", triggering the system permissions dialog, exiting the app, re-entering the app, and then clicking \"allow\".  \n\nI did a little more digging, since the system permissions dialog is popping up twice.  The first dialog is attached to the old observable from the destroyed activity, and the second dialog must be spawned when the `ShadowActivity` gets recreated.  The app crashes when I click allow on the second dialog.  \n. Thanks for the quick response.  Yes, I'm going off the rails a little bit here.  As I said, I don't care if some of the responses get dropped if the activity gets recreated.  Also, I'm triggering the permissions request from an event, and  I can't easily make the element reactive.  I ran into this exception as I was experimenting with how RxPermissions would handle the permissions request in this case.  \n\nI read through https://github.com/tbruyelle/RxPermissions/issues/3, and I think that the tradeoff of flexibility (requiring the permissions request in the initialization) for completeness is perfectly reasonable, for cases where you need to guarantee that the result is emitted to the subscriber.  However, it would also seem reasonable for the library to support cases where it doesn't matter if the occasional request gets dropped.  At least, I didn't expect the library to crash.  I also have no way to catch the exception and act on it, since it's thrown completely internally to the library.  Is there a way to emit the error to the observable?  \n. I'm requesting permissions inside of an `OnClickListener` inside of a Dialog.  The code itself is pretty generic, let me know if you actually want to see it.  I'm testing by setting the developer option \"Don't keep activities\", triggering the system permissions dialog, exiting the app, re-entering the app, and then clicking \"allow\".  \n\nI did a little more digging, since the system permissions dialog is popping up twice.  The first dialog is attached to the old observable from the destroyed activity, and the second dialog must be spawned when the `ShadowActivity` gets recreated.  The app crashes when I click allow on the second dialog.  \n. ",
    "tianshaokai": "@TVGSoft  \u4f60\u5f53\u521d\u63d0\u4ea4\u8fd9\u4e2acommit \u7684\u65f6\u5019\u662f\u5728\u4e09\u661f\u624b\u673a\u505a\u8fc7\u6d4b\u8bd5\u5417\uff0c\u6211\u73b0\u5728\u7528\u7684\u65e7\u7248\u672c\u4ee3\u7801\uff0c\u5728\u4e09\u661f\u624b\u673a\u4e00\u76f4\u62b1\u8fd9\u4e2a\u95ee\u9898. @TVGSoft  \u4f60\u5f53\u521d\u63d0\u4ea4\u8fd9\u4e2acommit \u7684\u65f6\u5019\u662f\u5728\u4e09\u661f\u624b\u673a\u505a\u8fc7\u6d4b\u8bd5\u5417\uff0c\u6211\u73b0\u5728\u7528\u7684\u65e7\u7248\u672c\u4ee3\u7801\uff0c\u5728\u4e09\u661f\u624b\u673a\u4e00\u76f4\u62b1\u8fd9\u4e2a\u95ee\u9898. ",
    "RonTt": "@epool @tbruyelle I've checked version 0.9.0, issue is fixed. But now library has lost one important (for me) function. Previous version required context only, now - requires activity. I don't have activity for checking permissions (I'm using it from service). . @epool @tbruyelle I've checked version 0.9.0, issue is fixed. But now library has lost one important (for me) function. Previous version required context only, now - requires activity. I don't have activity for checking permissions (I'm using it from service). . ",
    "tinylpc": "thx @epool .. thx @epool .. ",
    "ersin-ertan": "Sorry for the confusion, this problem occurs during both run and debug.\r\n\r\nI wanted to emphasize that I have debugged to the point prior to when the app closes.. `MyActivity` extends from `BaseActivity`, which extends from `AppCompatActivity`\r\n\r\n`MyActivity` only overrides `onBackPressed` and `onCreate`\r\n\r\nThe `rx.request` is located in `onCreate` and is the last thing called.\r\n\r\n`MyActivity` does not override `onPaused`, nor does `BaseActivity`\r\n\r\n`BaseActivity` only overrides `attachBaseContext` using `    super.attachBaseContext(CalligraphyContextWrapper.wrap(newBase));`\r\n\r\n\r\n\r\n. I can verify that this error occurs in both versions, 0.8.2 and 0.9.0, however:\r\n\r\nthe problem is:\r\n``` xml\r\n    <activity\r\n        android:noHistory=\"true\"\r\n```\r\n\r\nWhen set to false, this problem does not occur.. I wouldn't think so, but I'm not sure what you as a library developer could do to prevent this problem. \r\n\r\nHaving the noHistory option is important for some apps, would you know of any possible solutions?. Sorry for the confusion, this problem occurs during both run and debug.\r\n\r\nI wanted to emphasize that I have debugged to the point prior to when the app closes.. `MyActivity` extends from `BaseActivity`, which extends from `AppCompatActivity`\r\n\r\n`MyActivity` only overrides `onBackPressed` and `onCreate`\r\n\r\nThe `rx.request` is located in `onCreate` and is the last thing called.\r\n\r\n`MyActivity` does not override `onPaused`, nor does `BaseActivity`\r\n\r\n`BaseActivity` only overrides `attachBaseContext` using `    super.attachBaseContext(CalligraphyContextWrapper.wrap(newBase));`\r\n\r\n\r\n\r\n. I can verify that this error occurs in both versions, 0.8.2 and 0.9.0, however:\r\n\r\nthe problem is:\r\n``` xml\r\n    <activity\r\n        android:noHistory=\"true\"\r\n```\r\n\r\nWhen set to false, this problem does not occur.. I wouldn't think so, but I'm not sure what you as a library developer could do to prevent this problem. \r\n\r\nHaving the noHistory option is important for some apps, would you know of any possible solutions?. ",
    "Liverm0r": "I mean phone's general settings. I've made a screen.\r\nhttp://joxi.ru/Vm6y1QdcDVlN4r. Yes, If I set \"allowed\" or \"refused\" the behavior is as it should be.. I mean phone's general settings. I've made a screen.\r\nhttp://joxi.ru/Vm6y1QdcDVlN4r. Yes, If I set \"allowed\" or \"refused\" the behavior is as it should be.. ",
    "EddieRingle": "@vanniktech @epool You should almost always be using the support library Fragments. As the platform evolves, enhancements and fixes to the Fragment APIs are backported to the support libraries. If you use the platform Fragments, you're at the mercy of whatever version of Android your application is running on.. @vanniktech @epool You should almost always be using the support library Fragments. As the platform evolves, enhancements and fixes to the Fragment APIs are backported to the support libraries. If you use the platform Fragments, you're at the mercy of whatever version of Android your application is running on.. ",
    "luca992": "I am not a fan of the update using a retained fragment instead of a shadow activity. Now I can't do a permission check from a service running in the background easily.. Well, basically I have an ongoing location sharing service. And if a user goes to the app's settings and disables the location permission, I want the app to prompt the user to re-enable the location permission. Yeah it would just popup in front of any other app. Probably not the best practice but it is the easiest way to do it.. Yeah, I probably should launch my own activity from the service explaining the need for the permission when the user goes into app settings and revokes it.. I am not a fan of the update using a retained fragment instead of a shadow activity. Now I can't do a permission check from a service running in the background easily.. Well, basically I have an ongoing location sharing service. And if a user goes to the app's settings and disables the location permission, I want the app to prompt the user to re-enable the location permission. Yeah it would just popup in front of any other app. Probably not the best practice but it is the easiest way to do it.. Yeah, I probably should launch my own activity from the service explaining the need for the permission when the user goes into app settings and revokes it.. ",
    "teresaholfeld": "We check if a permission is granted in a service. If not, the service just skips the task it would do otherwise. This is a normal use case without UI interaction, where we need to check permissions from a context that is not an Activity.. We check if a permission is granted in a service. If not, the service just skips the task it would do otherwise. This is a normal use case without UI interaction, where we need to check permissions from a context that is not an Activity.. ",
    "StanislavChumarin": "That is not hard, but having all done in one place is preferable way - library that states for rxfying permissions. \r\nThis is my suggestion for the improvement. I can try to create Pull Request for it.. \ud83d\udc4d . That is not hard, but having all done in one place is preferable way - library that states for rxfying permissions. \r\nThis is my suggestion for the improvement. I can try to create Pull Request for it.. \ud83d\udc4d . ",
    "agustinsivoplas": "The solution I was searching was somethig like this:\r\n\r\n```\r\nRxPermissions\r\n      .getInstance(getActivity())\r\n      .requestEach(Manifest.permission.WRITE_EXTERNAL_STORAGE, \r\n         Manifest.permission.READ_EXTERNAL_STORAGE, \r\n         Manifest.permission.CAMERA)\r\n      .takeWhile(permission -> permission.granted)\r\n      //or use take untill if you want to get permission.granted == false event\r\n      //.takeUntil(permission -> !permission.granted)\r\n      .subscribe(granted -> {\r\n        if (granted) {\r\n           dispatchCamera();\r\n        } else {\r\n           showError();\r\n        }\r\n      });\r\n```. The solution I was searching was somethig like this:\r\n\r\n```\r\nRxPermissions\r\n      .getInstance(getActivity())\r\n      .requestEach(Manifest.permission.WRITE_EXTERNAL_STORAGE, \r\n         Manifest.permission.READ_EXTERNAL_STORAGE, \r\n         Manifest.permission.CAMERA)\r\n      .takeWhile(permission -> permission.granted)\r\n      //or use take untill if you want to get permission.granted == false event\r\n      //.takeUntil(permission -> !permission.granted)\r\n      .subscribe(granted -> {\r\n        if (granted) {\r\n           dispatchCamera();\r\n        } else {\r\n           showError();\r\n        }\r\n      });\r\n```. ",
    "bxqgit": "Nice!. Nice!. ",
    "ar-g": "@epool I use the lib as in the example, strangely I get these crashes only below M. \r\n\r\nI don't think it's appropriate to add additional fragment for the android version lower than M. I currently handle this manually, but I can send PR for the common fix. What do you think?\r\n\r\n```java\r\npublic static Observable<Boolean> requestWriteExternalStoragePermission(Activity activity) {\r\n    if (VERSION.SDK_INT >= VERSION_CODES.M) {\r\n      return new RxPermissions(activity).request(Manifest.permission.WRITE_EXTERNAL_STORAGE);\r\n    } else {\r\n      boolean writeExternalStoragePermissionGranted =\r\n          ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)\r\n              == PackageManager.PERMISSION_GRANTED;\r\n      return Observable.just(writeExternalStoragePermissionGranted);\r\n    }\r\n  }\r\n```. @epool This method gets called in the use-case method and triggers a long chain of operations; also use-case method can be triggered from different activity/fragment.. @epool getting, even more, such crashes now. It is very weird creating new instances of `RxPermissions` shouldn't matter because, in the end, we are looking for the same fragment. \r\n```java\r\nprivate RxPermissionsFragment findRxPermissionsFragment(Activity activity) {\r\n        return (RxPermissionsFragment) activity.getFragmentManager().findFragmentByTag(TAG);\r\n}\r\n```\r\nAlso the other thing I noticed that it happens only on one screen.\r\n. @mrArtCore it works with `commitAllowingStateLoss` but not with commit. \r\n\r\nYes, I'm using nested fragments and `getChildFragmentManager` doesn't help. \r\n\r\nWell, this code works just fine without requesting permissions via this library\r\n\r\nHere is stacktrace\r\n```\r\njava.lang.RuntimeException: Failure delivering result ResultInfo{who=@android:requestPermissions:android:fragment:0, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS (has extras) }} to activity {com.lalafo/classifieds.yalla.features.ad.postingv2.PostingActivity}: rx.exceptions.OnErrorNotImplementedException: Can not perform this action after onSaveInstanceState\r\n                                                              at android.app.ActivityThread.deliverResults(ActivityThread.java:3699)\r\n                                                              at android.app.ActivityThread.handleSendResult(ActivityThread.java:3742)\r\n                                                              at android.app.ActivityThread.-wrap16(ActivityThread.java)\r\n                                                              at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1393)\r\n                                                              at android.os.Handler.dispatchMessage(Handler.java:102)\r\n                                                              at android.os.Looper.loop(Looper.java:148)\r\n                                                              at android.app.ActivityThread.main(ActivityThread.java:5417)\r\n                                                              at java.lang.reflect.Method.invoke(Native Method)\r\n                                                              at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\r\n                                                              at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\r\n                                                           Caused by: rx.exceptions.OnErrorNotImplementedException: Can not perform this action after onSaveInstanceState\r\n                                                              at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:386)\r\n                                                              at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:383)\r\n                                                              at rx.internal.util.ActionSubscriber.onError(ActionSubscriber.java:44)\r\n                                                              at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:153)\r\n                                                              at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\r\n                                                              at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:216)\r\n                                                              at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)\r\n                                                              at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:511)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:466)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:244)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\r\n                                                              at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n                                                              at rx.internal.operators.OperatorBufferWithSize$BufferExact.onNext(OperatorBufferWithSize.java:114)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\r\n                                                              at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\r\n                                                              at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\r\n                                                              at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\r\n                                                              at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerNext(OnSubscribeConcatMap.java:182)\r\n                                                              at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onNext(OnSubscribeConcatMap.java:335)\r\n                                                              at rx.subjects.PublishSubject$PublishSubjectProducer.onNext(PublishSubject.java:304)\r\n                                                              at rx.subjects.PublishSubject$PublishSubjectState.onNext(PublishSubject.java:219)\r\n                                                              at rx.subjects.PublishSubject.onNext(PublishSubject.java:72)\r\n                                                              at com.tbruyelle.rxpermissions.RxPermissionsFragment.onRequestPermissionsResult(RxPermissionsFragment.java:66)\r\n                                                              at com.tbruyelle.rxpermissions.RxPermissionsFragment.onRequestPermissionsResult(RxPermissionsFragment.java:51)\r\n                                                              at android.app.Activity.dispatchRequestPermissionsResultToFragment(Activity.java:6563)\r\n                                                              at android.app.Activity.dispatchActivityResult(Activity.java:6436)\r\n                                                              at android.app.ActivityThread.deliverResults(ActivityThread.java:3695)\r\n                                                              at android.app.ActivityThread.handleSendResult(ActivityThread.java:3742)\u00a0\r\n                                                              at android.app.ActivityThread.-wrap16(ActivityThread.java)\u00a0\r\n                                                              at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1393)\u00a0\r\n                                                              at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n                                                              at android.os.Looper.loop(Looper.java:148)\u00a0\r\n                                                              at android.app.ActivityThread.main(ActivityThread.java:5417)\u00a0\r\n                                                              at java.lang.reflect.Method.invoke(Native Method)\u00a0\r\n                                                              at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\u00a0\r\n                                                              at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\u00a0\r\n                                                           Caused by: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\r\n                                                              at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1842)\r\n                                                              at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1860)\r\n                                                          \tat android.support.v4.app.BackStackRecord.commitInternal(BackSta\r\n```. @mrArtCore \r\nMy point is that library creates a scenario when the normal code doesn't work. Mb you can point out in docs that library use fragment inside and we should account for all issues related to it, i.e. it might not work ok when replacing nested fragment.. @epool I use the lib as in the example, strangely I get these crashes only below M. \r\n\r\nI don't think it's appropriate to add additional fragment for the android version lower than M. I currently handle this manually, but I can send PR for the common fix. What do you think?\r\n\r\n```java\r\npublic static Observable<Boolean> requestWriteExternalStoragePermission(Activity activity) {\r\n    if (VERSION.SDK_INT >= VERSION_CODES.M) {\r\n      return new RxPermissions(activity).request(Manifest.permission.WRITE_EXTERNAL_STORAGE);\r\n    } else {\r\n      boolean writeExternalStoragePermissionGranted =\r\n          ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)\r\n              == PackageManager.PERMISSION_GRANTED;\r\n      return Observable.just(writeExternalStoragePermissionGranted);\r\n    }\r\n  }\r\n```. @epool This method gets called in the use-case method and triggers a long chain of operations; also use-case method can be triggered from different activity/fragment.. @epool getting, even more, such crashes now. It is very weird creating new instances of `RxPermissions` shouldn't matter because, in the end, we are looking for the same fragment. \r\n```java\r\nprivate RxPermissionsFragment findRxPermissionsFragment(Activity activity) {\r\n        return (RxPermissionsFragment) activity.getFragmentManager().findFragmentByTag(TAG);\r\n}\r\n```\r\nAlso the other thing I noticed that it happens only on one screen.\r\n. @mrArtCore it works with `commitAllowingStateLoss` but not with commit. \r\n\r\nYes, I'm using nested fragments and `getChildFragmentManager` doesn't help. \r\n\r\nWell, this code works just fine without requesting permissions via this library\r\n\r\nHere is stacktrace\r\n```\r\njava.lang.RuntimeException: Failure delivering result ResultInfo{who=@android:requestPermissions:android:fragment:0, request=42, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS (has extras) }} to activity {com.lalafo/classifieds.yalla.features.ad.postingv2.PostingActivity}: rx.exceptions.OnErrorNotImplementedException: Can not perform this action after onSaveInstanceState\r\n                                                              at android.app.ActivityThread.deliverResults(ActivityThread.java:3699)\r\n                                                              at android.app.ActivityThread.handleSendResult(ActivityThread.java:3742)\r\n                                                              at android.app.ActivityThread.-wrap16(ActivityThread.java)\r\n                                                              at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1393)\r\n                                                              at android.os.Handler.dispatchMessage(Handler.java:102)\r\n                                                              at android.os.Looper.loop(Looper.java:148)\r\n                                                              at android.app.ActivityThread.main(ActivityThread.java:5417)\r\n                                                              at java.lang.reflect.Method.invoke(Native Method)\r\n                                                              at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\r\n                                                              at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\r\n                                                           Caused by: rx.exceptions.OnErrorNotImplementedException: Can not perform this action after onSaveInstanceState\r\n                                                              at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:386)\r\n                                                              at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:383)\r\n                                                              at rx.internal.util.ActionSubscriber.onError(ActionSubscriber.java:44)\r\n                                                              at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:153)\r\n                                                              at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\r\n                                                              at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:216)\r\n                                                              at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)\r\n                                                              at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:511)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:466)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:244)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\r\n                                                              at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n                                                              at rx.internal.operators.OperatorBufferWithSize$BufferExact.onNext(OperatorBufferWithSize.java:114)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(OperatorMerge.java:395)\r\n                                                              at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:355)\r\n                                                              at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:846)\r\n                                                              at rx.observers.SerializedObserver.onNext(SerializedObserver.java:91)\r\n                                                              at rx.observers.SerializedSubscriber.onNext(SerializedSubscriber.java:94)\r\n                                                              at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerNext(OnSubscribeConcatMap.java:182)\r\n                                                              at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onNext(OnSubscribeConcatMap.java:335)\r\n                                                              at rx.subjects.PublishSubject$PublishSubjectProducer.onNext(PublishSubject.java:304)\r\n                                                              at rx.subjects.PublishSubject$PublishSubjectState.onNext(PublishSubject.java:219)\r\n                                                              at rx.subjects.PublishSubject.onNext(PublishSubject.java:72)\r\n                                                              at com.tbruyelle.rxpermissions.RxPermissionsFragment.onRequestPermissionsResult(RxPermissionsFragment.java:66)\r\n                                                              at com.tbruyelle.rxpermissions.RxPermissionsFragment.onRequestPermissionsResult(RxPermissionsFragment.java:51)\r\n                                                              at android.app.Activity.dispatchRequestPermissionsResultToFragment(Activity.java:6563)\r\n                                                              at android.app.Activity.dispatchActivityResult(Activity.java:6436)\r\n                                                              at android.app.ActivityThread.deliverResults(ActivityThread.java:3695)\r\n                                                              at android.app.ActivityThread.handleSendResult(ActivityThread.java:3742)\u00a0\r\n                                                              at android.app.ActivityThread.-wrap16(ActivityThread.java)\u00a0\r\n                                                              at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1393)\u00a0\r\n                                                              at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n                                                              at android.os.Looper.loop(Looper.java:148)\u00a0\r\n                                                              at android.app.ActivityThread.main(ActivityThread.java:5417)\u00a0\r\n                                                              at java.lang.reflect.Method.invoke(Native Method)\u00a0\r\n                                                              at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\u00a0\r\n                                                              at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\u00a0\r\n                                                           Caused by: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\r\n                                                              at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1842)\r\n                                                              at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1860)\r\n                                                          \tat android.support.v4.app.BackStackRecord.commitInternal(BackSta\r\n```. @mrArtCore \r\nMy point is that library creates a scenario when the normal code doesn't work. Mb you can point out in docs that library use fragment inside and we should account for all issues related to it, i.e. it might not work ok when replacing nested fragment.. ",
    "mrArtCore": "@ar-g \r\n\r\nCould you describe from what exactly 'view' you requested permissions ? Was it fragment, nested fragment or an activity ???  And could you give full error stacktrace? \r\nBecause while you aint providing full stackTrace with java.lang.IllegalStateException \"HERE WAS ERROR Message\" we can only wondering what was got wrong.\r\n\r\nBut may be, just maybe If you requesting permissions from your fragment, you get crash that have described [on Stackowerflow](http://stackoverflow.com/questions/7575921/illegalstateexception-can-not-perform-this-action-after-onsaveinstancestate-wit)  or maybe you used  [wrong 'commit' method instead of commitAllowingStateLoss ](http://stackoverflow.com/questions/14860239/checking-if-state-is-saved-before-committing-a-fragmenttransaction)\r\n\r\nIf so, this is not library issue, this is yours, and you're allowed to fix it without any problems =)  \r\n\r\nAlso I tried to reproduce this crash with lib v0.9.1 on 4.4, 5.1 and 6.0 android devices and I couldn't... \r\n. Hello, how about more information?. https://github.com/tbruyelle/RxPermissions/issues/106\r\nPlease, do some research before copy paste stacktrace.. First of all, If it really cause crash, give verbose stackTrace here, please.\r\n\r\nI can only imagine that you do so inside other fragment. If so, you should use \"getChildFragmentManager()\" inside this fragment.\r\nAnd if the problem is only in \"commitAllowingStateLoss\" why don't you change your \"commit\" method to \"commitAllowingStateLoss\" in your chain ???\r\n\r\nIMHO, if you don't mind, this is NOT library problem, only yours. Library work was done in the right way, and problems, that goes in \"subscribe(...)\"  only yours. \r\n. @ar-g I just miss something =)) if it works fine with `commitAllowingStateLoss` why don't you just use it ? ))\r\nAnd your stacktrace clearly defined cause of crash \r\n...\r\n`Caused by: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState`\r\nI still can't get it, why did you open this issue ???\r\n\r\nSo, I want to give you advise. If You have some problem, crash or whatever, try to, maybe google it first and do not create issues on any repository so far, as you really sure, that this problem caused by library code. Not cooll at all !\r\n\r\n@tbruyelle maybe you should close this issue now =) ?\r\n \r\n. @ar-g \r\nConception of **_normal code_** may vary for different persons. And as developer you are not beign forced to use any library or something. And you don't have to have nested fragments and request permissions inside one of them. Who told you that is **_normal_** to do like you did ? =))\r\nAll scenarious are created by developer, and developer define where exactly he want library do work for him/her. He/She define own \"architecture\", code structure and so on. Every of us get in troubles because of lacking knowleges, time, because of our laziness etc. \r\n\r\nPlease, try to understand different between opening issue on lib repository and asking question on \r\nStackOverflow. Its not shameful to misknow something. \r\n\r\nHave a good coding! \r\nCheers!\r\n. @alexey-rabets \r\nHello, so you think it is bug ?\r\nBut I dont think so. I try to explain below.\r\n\r\nYour code is uncorrect. If you dont want your listeners being invoked twice or more, you MUST unsubscrbe from them in, for instance, `onDestroy()` activity callback.\r\n\r\nIn your current realization I have seen that you're subscribing to different observables, giving references to your UI elements and activity. But, as you probably know, after screen roation, activity destroys and recreates. And in your realization it couldn't be destroyed, cause your have references to activity in RxJavaEnviroment. So after rotation you have 1 activity in memory and another one that rectreates. \r\nAnd all callbacks such as `onCreate(...), onStart() etc` are called again. And you again subscribe to all rx stuff and give away references to new Activity )))\r\nSo you have now 2 (or more, depend of how many times you rotate phone) references to your activity after screen rotation and memory leak =)) lol =)\r\n\r\nHow to fix:\r\nadd all `Subscriptions` to `CompositeSubscription` and in some Activity's callback like `(onPause())` call `compositeSubscription.clear()`. Those magic things unsubscribe all your listeners and avoid memory leaks and multiple _firing_ of `subscribe()` method \r\n\r\nPS your listeners will show 2 toast cause you listen same things in different places. So you have something task like below :\r\nI want `doSomeWork()` being called if(and when) 1st **OR** 2nd buttons get  permission allowed in `onSubscribe` \r\nBut you do `doSomeWork()` when 1st button get event **AND** when 2nd get. You share this event between 2 subscribers, you know, and nothing strange didn't happen. You received it and display 2 times in general.\r\nYou should use Combined observables in this case. Read [here](https://github.com/ReactiveX/RxJava/wiki/Combining-Observables), pls  \r\n\r\n . Hello guys! @DroidNinja @ck227 @yzcheng90 \r\nCould you please provide more information about your problem ? In ideal test project, where this problem can be recreated by somebody else ???\r\nAnd there is no full information about Device ! You are developers, and my device is Android 7.0.0 it is not description from developer. That description could give my grandma, for example. \r\nDevice Brand. Manufacture, Build \u2116, etc will be brilliant ! \r\n\r\nHow you create and manage RxPermission ? Where are you do so? How are you manage lifecycle and permisisons request? Frequency of issue ?\r\n\r\nOf, course If you interested in fix of this problem. \r\nThanks !. Hello. \r\nI think this is not realy cool, what you talkink about. Just IMHO. \r\nPass an activity to somewhere, where there reference may be saved in static context? No-o, not for me. \r\nI don't see the problem in recreating activity while orientation change. Just subscribe RxPermition in `onStart()`, unsubscribe chain in `onStop()`, and you're good to go, aren't you ? Permission dialog will be showed again. No problems\r\n\r\nAnd thigs, that you do in your example, not so obvious for me ...\r\n\r\n\r\n. Lol. @gengjiawen \r\nYou answered to question of this issue? Could you please translate the original text? What I could understand that was something wrong with note5 \u263a\ufe0f. Hello @priyakar @trueangle !!!\r\n\r\nI think if you provide test project where I could get same error, I'll be able to fix it.\r\nI tried to get same error, but without success =( And now I haven't time to find this bug, just interesting to fix it =). Hi @prazjain \r\nMaybe you should to read error carefully ??? Looks like you are using RxJava1 and Rxjava2 in the project. And at line (177, 56) you try to use rx.Scheduler instead of  io.reactivex.Scheduler ??? . And what is the version of this library do you use? And why don't you use version with Rx java2 support? Check out main page of the project. @prazjain \r\nYou just use wrong scheduler with whatever RxPermission instance version you have. \r\nProfile your imports, dependencies and use correct versions of RxJava and RxAndroid.\r\n\r\nBTW, there is no Observable from rxjava-1.1.6 In \"com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar\" dependency. You doing something wrong. Library works fine !\r\n. @akidee \r\nHello! Read README.md carefully, pls. \r\nhttp://prntscr.com/g87tgt. How would you like to use, for example, standard mechanims of runtime permissions within the Service ???. Just google it, man. This is not an issue of library! . I think problem could be in wrong logic of invocation permissions request regards to lifecycle. When dialog shows, onPause() called. Than dialog canceled, called onResume(), than permission requested one more time and so on. This not an issue of lib, this problem of programmer. \r\nYou should Request permission in onCreate for example, and all will be ok, I suppose. Super cool description of problem ! \r\n. Why do you  think this lib is guilty in crash? Did you even try to figure out whats went wrong ? I think you  have to learn read logs. And learn to google. Googling in the right way might be very helpfull in our deal. \r\n. @ar-g \r\n\r\nCould you describe from what exactly 'view' you requested permissions ? Was it fragment, nested fragment or an activity ???  And could you give full error stacktrace? \r\nBecause while you aint providing full stackTrace with java.lang.IllegalStateException \"HERE WAS ERROR Message\" we can only wondering what was got wrong.\r\n\r\nBut may be, just maybe If you requesting permissions from your fragment, you get crash that have described [on Stackowerflow](http://stackoverflow.com/questions/7575921/illegalstateexception-can-not-perform-this-action-after-onsaveinstancestate-wit)  or maybe you used  [wrong 'commit' method instead of commitAllowingStateLoss ](http://stackoverflow.com/questions/14860239/checking-if-state-is-saved-before-committing-a-fragmenttransaction)\r\n\r\nIf so, this is not library issue, this is yours, and you're allowed to fix it without any problems =)  \r\n\r\nAlso I tried to reproduce this crash with lib v0.9.1 on 4.4, 5.1 and 6.0 android devices and I couldn't... \r\n. Hello, how about more information?. https://github.com/tbruyelle/RxPermissions/issues/106\r\nPlease, do some research before copy paste stacktrace.. First of all, If it really cause crash, give verbose stackTrace here, please.\r\n\r\nI can only imagine that you do so inside other fragment. If so, you should use \"getChildFragmentManager()\" inside this fragment.\r\nAnd if the problem is only in \"commitAllowingStateLoss\" why don't you change your \"commit\" method to \"commitAllowingStateLoss\" in your chain ???\r\n\r\nIMHO, if you don't mind, this is NOT library problem, only yours. Library work was done in the right way, and problems, that goes in \"subscribe(...)\"  only yours. \r\n. @ar-g I just miss something =)) if it works fine with `commitAllowingStateLoss` why don't you just use it ? ))\r\nAnd your stacktrace clearly defined cause of crash \r\n...\r\n`Caused by: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState`\r\nI still can't get it, why did you open this issue ???\r\n\r\nSo, I want to give you advise. If You have some problem, crash or whatever, try to, maybe google it first and do not create issues on any repository so far, as you really sure, that this problem caused by library code. Not cooll at all !\r\n\r\n@tbruyelle maybe you should close this issue now =) ?\r\n \r\n. @ar-g \r\nConception of **_normal code_** may vary for different persons. And as developer you are not beign forced to use any library or something. And you don't have to have nested fragments and request permissions inside one of them. Who told you that is **_normal_** to do like you did ? =))\r\nAll scenarious are created by developer, and developer define where exactly he want library do work for him/her. He/She define own \"architecture\", code structure and so on. Every of us get in troubles because of lacking knowleges, time, because of our laziness etc. \r\n\r\nPlease, try to understand different between opening issue on lib repository and asking question on \r\nStackOverflow. Its not shameful to misknow something. \r\n\r\nHave a good coding! \r\nCheers!\r\n. @alexey-rabets \r\nHello, so you think it is bug ?\r\nBut I dont think so. I try to explain below.\r\n\r\nYour code is uncorrect. If you dont want your listeners being invoked twice or more, you MUST unsubscrbe from them in, for instance, `onDestroy()` activity callback.\r\n\r\nIn your current realization I have seen that you're subscribing to different observables, giving references to your UI elements and activity. But, as you probably know, after screen roation, activity destroys and recreates. And in your realization it couldn't be destroyed, cause your have references to activity in RxJavaEnviroment. So after rotation you have 1 activity in memory and another one that rectreates. \r\nAnd all callbacks such as `onCreate(...), onStart() etc` are called again. And you again subscribe to all rx stuff and give away references to new Activity )))\r\nSo you have now 2 (or more, depend of how many times you rotate phone) references to your activity after screen rotation and memory leak =)) lol =)\r\n\r\nHow to fix:\r\nadd all `Subscriptions` to `CompositeSubscription` and in some Activity's callback like `(onPause())` call `compositeSubscription.clear()`. Those magic things unsubscribe all your listeners and avoid memory leaks and multiple _firing_ of `subscribe()` method \r\n\r\nPS your listeners will show 2 toast cause you listen same things in different places. So you have something task like below :\r\nI want `doSomeWork()` being called if(and when) 1st **OR** 2nd buttons get  permission allowed in `onSubscribe` \r\nBut you do `doSomeWork()` when 1st button get event **AND** when 2nd get. You share this event between 2 subscribers, you know, and nothing strange didn't happen. You received it and display 2 times in general.\r\nYou should use Combined observables in this case. Read [here](https://github.com/ReactiveX/RxJava/wiki/Combining-Observables), pls  \r\n\r\n . Hello guys! @DroidNinja @ck227 @yzcheng90 \r\nCould you please provide more information about your problem ? In ideal test project, where this problem can be recreated by somebody else ???\r\nAnd there is no full information about Device ! You are developers, and my device is Android 7.0.0 it is not description from developer. That description could give my grandma, for example. \r\nDevice Brand. Manufacture, Build \u2116, etc will be brilliant ! \r\n\r\nHow you create and manage RxPermission ? Where are you do so? How are you manage lifecycle and permisisons request? Frequency of issue ?\r\n\r\nOf, course If you interested in fix of this problem. \r\nThanks !. Hello. \r\nI think this is not realy cool, what you talkink about. Just IMHO. \r\nPass an activity to somewhere, where there reference may be saved in static context? No-o, not for me. \r\nI don't see the problem in recreating activity while orientation change. Just subscribe RxPermition in `onStart()`, unsubscribe chain in `onStop()`, and you're good to go, aren't you ? Permission dialog will be showed again. No problems\r\n\r\nAnd thigs, that you do in your example, not so obvious for me ...\r\n\r\n\r\n. Lol. @gengjiawen \r\nYou answered to question of this issue? Could you please translate the original text? What I could understand that was something wrong with note5 \u263a\ufe0f. Hello @priyakar @trueangle !!!\r\n\r\nI think if you provide test project where I could get same error, I'll be able to fix it.\r\nI tried to get same error, but without success =( And now I haven't time to find this bug, just interesting to fix it =). Hi @prazjain \r\nMaybe you should to read error carefully ??? Looks like you are using RxJava1 and Rxjava2 in the project. And at line (177, 56) you try to use rx.Scheduler instead of  io.reactivex.Scheduler ??? . And what is the version of this library do you use? And why don't you use version with Rx java2 support? Check out main page of the project. @prazjain \r\nYou just use wrong scheduler with whatever RxPermission instance version you have. \r\nProfile your imports, dependencies and use correct versions of RxJava and RxAndroid.\r\n\r\nBTW, there is no Observable from rxjava-1.1.6 In \"com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar\" dependency. You doing something wrong. Library works fine !\r\n. @akidee \r\nHello! Read README.md carefully, pls. \r\nhttp://prntscr.com/g87tgt. How would you like to use, for example, standard mechanims of runtime permissions within the Service ???. Just google it, man. This is not an issue of library! . I think problem could be in wrong logic of invocation permissions request regards to lifecycle. When dialog shows, onPause() called. Than dialog canceled, called onResume(), than permission requested one more time and so on. This not an issue of lib, this problem of programmer. \r\nYou should Request permission in onCreate for example, and all will be ok, I suppose. Super cool description of problem ! \r\n. Why do you  think this lib is guilty in crash? Did you even try to figure out whats went wrong ? I think you  have to learn read logs. And learn to google. Googling in the right way might be very helpfull in our deal. \r\n. ",
    "GitACDreamer": "thx,using 0.82 version `RxPermission.getInstance()` I solved this problem. because my project using MVP structure , I want coding request permission in the P Layer ,but activity/fragment.. thx,using 0.82 version `RxPermission.getInstance()` I solved this problem. because my project using MVP structure , I want coding request permission in the P Layer ,but activity/fragment.. ",
    "khaledkhj": "Yes That is what I was looking for.\r\n\r\nThank you @tbruyelle \r\n. Yes That is what I was looking for.\r\n\r\nThank you @tbruyelle \r\n. ",
    "Jadyli": "because i need to gemerate a new version of rxpermission for use\uff0cbut i don't know whether the develop id affects when i upload my  package to jack.io,i'm sorry for that ,later i will fix it. i don't know why the build.gradle was commit to here \uff0ci only want to commit the Rxpermissions.java. because i need to gemerate a new version of rxpermission for use\uff0cbut i don't know whether the develop id affects when i upload my  package to jack.io,i'm sorry for that ,later i will fix it. i don't know why the build.gradle was commit to here \uff0ci only want to commit the Rxpermissions.java. ",
    "friederbluemle": "I rebased and amended my commits. The now latest version of Gradle wrapper is `3.4`, and the stable version of Android Studio 2.3.0 and the matching Android Gradle plugin `2.3.0` were released today.\r\n\r\nhttps://android-developers.googleblog.com/2017/03/android-studio-2-3.html. :+1: . I rebased and amended my commits. The now latest version of Gradle wrapper is `3.4`, and the stable version of Android Studio 2.3.0 and the matching Android Gradle plugin `2.3.0` were released today.\r\n\r\nhttps://android-developers.googleblog.com/2017/03/android-studio-2-3.html. :+1: . ",
    "ding33211": "think so. think so. ",
    "lovetomatoo": "I use 0.9.1, so the problem occurred.Upgrade now. thank you !!. I use 0.9.1, so the problem occurred.Upgrade now. thank you !!. ",
    "myhcqgithub": "resolved thanks!\r\n. resolved thanks!\r\n. ",
    "kjsolo": "@myhcqgithub How to solve?. @myhcqgithub How to solve?. ",
    "gloushkov": "It is using `import android.app.FragmentManager` and `activity.getFragmentManager()`\r\n. It is using `import android.app.FragmentManager` and `activity.getFragmentManager()`\r\n. ",
    "agramian": "I have a use case for this. I need to use `FragmentManager.FragmentLifecycleCallbacks` to register callbacks for certain fragment events.  To use this on versions of Android below Oreo the `android.support.v4.app.FragmentManager` support version of the class must be used.  Since `RxPermissions` is not implemented using the support library versions of the `Fragment` and `FragmentManager` classes, I am unable to receive the callbacks for it.. PR #138 is up. I have a use case for this. I need to use `FragmentManager.FragmentLifecycleCallbacks` to register callbacks for certain fragment events.  To use this on versions of Android below Oreo the `android.support.v4.app.FragmentManager` support version of the class must be used.  Since `RxPermissions` is not implemented using the support library versions of the `Fragment` and `FragmentManager` classes, I am unable to receive the callbacks for it.. PR #138 is up. ",
    "naivor": "oh,the RxPermission is ok,it's mine  fault .I spent  severial hours and  found that error occoured in the block after  the  permission  granted,but  the  exception was  captured by  RxPermission.  Thanks !. oh,the RxPermission is ok,it's mine  fault .I spent  severial hours and  found that error occoured in the block after  the  permission  granted,but  the  exception was  captured by  RxPermission.  Thanks !. ",
    "hsiunien": "i can't modify library code, how to force the version 0.9.3 for the library safetly?   0.7 is using rxjava1.x, if i force use 0.9.3 ,it cannot find com.tbruyelle.rxpermissions.Permission . i think you shouldn't package BuildConfig.java in 0.9.3 or later,is it necessary? or you can rename package of  BuildConfig.java to com.tbruyelle.rxpermissions2.\r\n\r\n \r\n<img width=\"1482\" alt=\"qq20170406-155132 2x\" src=\"https://cloud.githubusercontent.com/assets/5487535/24743546/37bf9c6e-1ae1-11e7-8f03-c78bcbe99442.png\">\r\n\r\n. @iffanmajid  I copied the source code in to my project and removed the BuildConfig \ud83d\ude04 . i can't modify library code, how to force the version 0.9.3 for the library safetly?   0.7 is using rxjava1.x, if i force use 0.9.3 ,it cannot find com.tbruyelle.rxpermissions.Permission . i think you shouldn't package BuildConfig.java in 0.9.3 or later,is it necessary? or you can rename package of  BuildConfig.java to com.tbruyelle.rxpermissions2.\r\n\r\n \r\n<img width=\"1482\" alt=\"qq20170406-155132 2x\" src=\"https://cloud.githubusercontent.com/assets/5487535/24743546/37bf9c6e-1ae1-11e7-8f03-c78bcbe99442.png\">\r\n\r\n. @iffanmajid  I copied the source code in to my project and removed the BuildConfig \ud83d\ude04 . ",
    "iffanmajid": "I have this issue too, how to solve it btw? @hsiunien . I have same issue, already clean it up, but no luck.. I have this issue too, how to solve it btw? @hsiunien . I have same issue, already clean it up, but no luck.. ",
    "BlueYan": "remove the applyPermissions method, the problem figurs out.. Nerver mind.  I have solved the problem.. remove the applyPermissions method, the problem figurs out.. Nerver mind.  I have solved the problem.. ",
    "alexey-rabets": "Understood. Thanks.. Understood. Thanks.. ",
    "designerMichael": "thanks very much, I Have test the code ,and get the result if the user select the \"never ask again\", so I use the rxPermission to get permission again ,but no permission dialog to show, is there another way to do with  this?. thank you for your help! ^_^. thanks very much, I Have test the code ,and get the result if the user select the \"never ask again\", so I use the rxPermission to get permission again ,but no permission dialog to show, is there another way to do with  this?. thank you for your help! ^_^. ",
    "jp1017": "This may be great. so, you have to compile `rxjava` in `app` module.. This may be great. so, you have to compile `rxjava` in `app` module.. ",
    "MinkiPan": "do you think this is somehow fixable? meanwhile I have to post delay the method call. @epool \r\n\r\nokay it doesn't crash with support fragment/manager\r\nseems like the rumours are right that support fragment are less buggy than fragment..... do you think this is somehow fixable? meanwhile I have to post delay the method call. @epool \r\n\r\nokay it doesn't crash with support fragment/manager\r\nseems like the rumours are right that support fragment are less buggy than fragment..... ",
    "Gavin-ZYX": "I have the same problem with Google api.\r\n```java\r\n String[] permission = {Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE};\r\n        ActivityCompat.requestPermissions(this, permission, 200);\r\n```\r\nI found that the first time can only apply for a permission, the second time to apply for multiple permissions.. I have the same problem with Google api.\r\n```java\r\n String[] permission = {Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE};\r\n        ActivityCompat.requestPermissions(this, permission, 200);\r\n```\r\nI found that the first time can only apply for a permission, the second time to apply for multiple permissions.. ",
    "windows771053651": "\u8fd9\u8868\u660e\u5c0f\u7c73\u7cfb\u7edf\u6539\u4e86\u6743\u9650\u6a21\u5757. \u8fd9\u8868\u660e\u5c0f\u7c73\u7cfb\u7edf\u6539\u4e86\u6743\u9650\u6a21\u5757. ",
    "croitor-ivan": "@cat1024 \r\nI can add some details here.\r\nStart the app, allow permission.\r\nSend app to background (Home button).\r\nOpen settings, go to app details and disable permission.\r\nResume the application.\r\n\r\n` Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'int android.app.Activity.checkSelfPermission(java.lang.String)' on a null object reference\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissionsFragment.isGranted(RxPermissionsFragment.java:71)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions.isGranted(RxPermissions.java:251)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions.requestImplementation(RxPermissions.java:177)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions.access$100(RxPermissions.java:33)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions$3.apply(RxPermissions.java:147)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions$3.apply(RxPermissions.java:144)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:121)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(ObservableFlatMap.java:234)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:146)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java:107)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java:36)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableBuffer.subscribeActual(ObservableBuffer.java:44)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:162)\r\n                                                            \tat io.reactivex.internal.operators.observable.ObservableFlatMap$`\r\n. In my case, seems like it is before.... @cat1024 \r\nI can add some details here.\r\nStart the app, allow permission.\r\nSend app to background (Home button).\r\nOpen settings, go to app details and disable permission.\r\nResume the application.\r\n\r\n` Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'int android.app.Activity.checkSelfPermission(java.lang.String)' on a null object reference\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissionsFragment.isGranted(RxPermissionsFragment.java:71)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions.isGranted(RxPermissions.java:251)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions.requestImplementation(RxPermissions.java:177)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions.access$100(RxPermissions.java:33)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions$3.apply(RxPermissions.java:147)\r\n                                                                at com.tbruyelle.rxpermissions2.RxPermissions$3.apply(RxPermissions.java:144)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:121)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(ObservableFlatMap.java:234)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:146)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java:107)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java:36)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableBuffer.subscribeActual(ObservableBuffer.java:44)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\r\n                                                                at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                                at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:162)\r\n                                                            \tat io.reactivex.internal.operators.observable.ObservableFlatMap$`\r\n. In my case, seems like it is before.... ",
    "douo": "@cat1024 @croitor-ivan  Where did you instantiate RxPermission? Before `super.onCreate` or after?\r\n. @croitor-ivan Maybe you should try instantiated after `super.onCreate`, this cause by [`RxPermissionsFragment.setRetainInstance(true)`](https://github.com/tbruyelle/RxPermissions/blob/master/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissionsFragment.java#L31) Activity will replace the new `RxPermissionsFragment` with old one in `super.onCreate`. So your fragment became isolated and `getActivity` returne `null`\r\n\r\nIf after `super.onCreate`, RxPermissions will use existed Fragment instead of create new Fragment see [RxPermissions/RxPermissions.java#L42](https://github.com/tbruyelle/RxPermissions/blob/master/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L42). @cat1024 @croitor-ivan  Where did you instantiate RxPermission? Before `super.onCreate` or after?\r\n. @croitor-ivan Maybe you should try instantiated after `super.onCreate`, this cause by [`RxPermissionsFragment.setRetainInstance(true)`](https://github.com/tbruyelle/RxPermissions/blob/master/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissionsFragment.java#L31) Activity will replace the new `RxPermissionsFragment` with old one in `super.onCreate`. So your fragment became isolated and `getActivity` returne `null`\r\n\r\nIf after `super.onCreate`, RxPermissions will use existed Fragment instead of create new Fragment see [RxPermissions/RxPermissions.java#L42](https://github.com/tbruyelle/RxPermissions/blob/master/lib/src/main/java/com/tbruyelle/rxpermissions/RxPermissions.java#L42). ",
    "RKuanysh": "you may use Lazy with Dagger. you may use Lazy with Dagger. ",
    "boomstack": "\r\n[PermissionBug.zip](https://github.com/tbruyelle/RxPermissions/files/991790/PermissionBug.zip)\r\nthis little project explains well. My devices run android 7.1.1. \r\n[PermissionBug.zip](https://github.com/tbruyelle/RxPermissions/files/991790/PermissionBug.zip)\r\nthis little project explains well. My devices run android 7.1.1. ",
    "dylanhuang88": "    private boolean shouldShowRequestPermissionRationaleImplementation(final Activity activity, final String... permissions) {\r\n        for (String p : permissions) {\r\n            if (!isGranted(p) && !activity.shouldShowRequestPermissionRationale(p)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\nI think when permission is granted\uff0cthis method will always return true.  In fact, it shouldn't be like this.\r\nSo, I suggest code like this:\r\n\r\n```\r\nprivate boolean shouldShowRequestPermissionRationaleImplementation(final Activity activity, final String... permissions) {\r\n        for (String p : permissions) {\r\n            if (isGranted(p) || !ActivityCompat.shouldShowRequestPermissionRationale(activity, p)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n```\r\n .     private boolean shouldShowRequestPermissionRationaleImplementation(final Activity activity, final String... permissions) {\r\n        for (String p : permissions) {\r\n            if (!isGranted(p) && !activity.shouldShowRequestPermissionRationale(p)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\nI think when permission is granted\uff0cthis method will always return true.  In fact, it shouldn't be like this.\r\nSo, I suggest code like this:\r\n\r\n```\r\nprivate boolean shouldShowRequestPermissionRationaleImplementation(final Activity activity, final String... permissions) {\r\n        for (String p : permissions) {\r\n            if (isGranted(p) || !ActivityCompat.shouldShowRequestPermissionRationale(activity, p)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n```\r\n . ",
    "alouanemed": "Duplicate of #45 \r\n\r\nAdd this to your file : \r\n`-dontwarn com.tbruyelle.rxpermissions.**`. Duplicate of #45 \r\n\r\nAdd this to your file : \r\n`-dontwarn com.tbruyelle.rxpermissions.**`. ",
    "yuxinLi": "the android os version is  :  6.0.1. the android os version is  :  6.0.1. ",
    "ChinaDragon01": " I have encountered the same problem, may I ask this question solved?.  I have encountered the same problem, may I ask this question solved?. ",
    "neosdong": "I had encountered the same problem.Then I changed the targetSdkVersion to be great than or equal to 23, It solved. . I had encountered the same problem.Then I changed the targetSdkVersion to be great than or equal to 23, It solved. . ",
    "ck227": "same issue here.. same issue here.. ",
    "DroidNinja": "same issue here.. Okk I got the fix. My issue was due to not including the required permission in manifest file. \r\nAnyway thanks! . same issue here.. Okk I got the fix. My issue was due to not including the required permission in manifest file. \r\nAnyway thanks! . ",
    "liwentao19881010": "I met the same problem,at last,i found that i did not request permission in Manifest.When id requested the permission in manifest, it work well. . I met the same problem,at last,i found that i did not request permission in Manifest.When id requested the permission in manifest, it work well. . ",
    "isVoid": "Thanks. Specifically, what anonymous class should I pass to .subscribe() function? I just switched from a legacy version, it seems like Action1 is no longer accessible in the new RxJava.. Ah, as per [Rx API Docs](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0), Action1 has been renamed to Consumer. Thus it should be `.subscribe(new Consumer<Boolean>)`, the function to implement is `accept(Boolean)`. Thanks. Specifically, what anonymous class should I pass to .subscribe() function? I just switched from a legacy version, it seems like Action1 is no longer accessible in the new RxJava.. Ah, as per [Rx API Docs](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0), Action1 has been renamed to Consumer. Thus it should be `.subscribe(new Consumer<Boolean>)`, the function to implement is `accept(Boolean)`. ",
    "lopspower": "Ahaha ^^. Personally I would be glad if there was no Samsung.. But the applications I develop are not just for me.\r\n\r\nMore seriously, the bug is strange since [the classic implementation of the management of the permissions](https://developer.android.com/training/permissions/requesting.html) works well on this device. I think the problem comes from the library and not from the device.. That's it. When permission is accepted and I make the request I have the true callback. I have been using your library for a while this is the first time I have a problem like this.\r\nIf you need to do a test on an S7 do not hesitate.. I run the request after clicking a button. This same code works well on all other devices. And this same code works fine if I restart the app and the permission is already validated.. Ahaha ^^. Personally I would be glad if there was no Samsung.. But the applications I develop are not just for me.\r\n\r\nMore seriously, the bug is strange since [the classic implementation of the management of the permissions](https://developer.android.com/training/permissions/requesting.html) works well on this device. I think the problem comes from the library and not from the device.. That's it. When permission is accepted and I make the request I have the true callback. I have been using your library for a while this is the first time I have a problem like this.\r\nIf you need to do a test on an S7 do not hesitate.. I run the request after clicking a button. This same code works well on all other devices. And this same code works fine if I restart the app and the permission is already validated.. ",
    "trueangle": "Same problem, when I create new RxPermissions instance in fragment. This is  because android doesn't allow to call one fragment from another within the same FragmentManager. We need to use fragment.getChildFragmentManager() instead of activity.getFragmentManager() if we want to create RxPermissions instance from fragment.. Same problem, when I create new RxPermissions instance in fragment. This is  because android doesn't allow to call one fragment from another within the same FragmentManager. We need to use fragment.getChildFragmentManager() instead of activity.getFragmentManager() if we want to create RxPermissions instance from fragment.. ",
    "Walker-ZHAO": "Same error.\r\nI use TabLayout and ViewPager.  This is my Activity code(Kotlin):\r\n`\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    val PAGER_COUNT = 1\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        setSupportActionBar(tool_bar)\r\n\r\n        view_pager.adapter = object : FragmentPagerAdapter(fragmentManager) {\r\n            override fun getItem(position: Int) =\r\n                    when (position) {\r\n                        0 -> SimpleFragment()\r\n                        else -> SimpleFragment()\r\n                    }\r\n\r\n            override fun getCount() = PAGER_COUNT\r\n\r\n            override fun getPageTitle(position: Int) =\r\n                when (position) {\r\n                    0 -> \"Simple\"\r\n                    else -> \"None\"\r\n                }\r\n        }\r\n\r\n        tabs.setupWithViewPager(view_pager)\r\n    }\r\n}\r\n`\r\n\r\nFragment code:\r\n`\r\noverride fun onAttach(context: Context?) {\r\n        super.onAttach(context)\r\n        rxPermission = RxPermissions(activity)\r\n}\r\n`\r\n\r\n\r\n. Same error.\r\nI use TabLayout and ViewPager.  This is my Activity code(Kotlin):\r\n`\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    val PAGER_COUNT = 1\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        setSupportActionBar(tool_bar)\r\n\r\n        view_pager.adapter = object : FragmentPagerAdapter(fragmentManager) {\r\n            override fun getItem(position: Int) =\r\n                    when (position) {\r\n                        0 -> SimpleFragment()\r\n                        else -> SimpleFragment()\r\n                    }\r\n\r\n            override fun getCount() = PAGER_COUNT\r\n\r\n            override fun getPageTitle(position: Int) =\r\n                when (position) {\r\n                    0 -> \"Simple\"\r\n                    else -> \"None\"\r\n                }\r\n        }\r\n\r\n        tabs.setupWithViewPager(view_pager)\r\n    }\r\n}\r\n`\r\n\r\nFragment code:\r\n`\r\noverride fun onAttach(context: Context?) {\r\n        super.onAttach(context)\r\n        rxPermission = RxPermissions(activity)\r\n}\r\n`\r\n\r\n\r\n. ",
    "scm573": "I'm facing the same trouble. And as @trueangle said, I tried adding some codes in the RxPermissions class as below:\r\n```java\r\n    public RxPermissions(@NonNull Fragment fragment) {\r\n        mRxPermissionsFragment = getRxPermissionsFragment(fragment);\r\n    }\r\n\r\n    private RxPermissionsFragment getRxPermissionsFragment(Fragment fragment) {\r\n        RxPermissionsFragment rxPermissionsFragment = findRxPermissionsFragment(fragment);\r\n        boolean isNewInstance = rxPermissionsFragment == null;\r\n        if (isNewInstance) {\r\n            rxPermissionsFragment = new RxPermissionsFragment();\r\n            FragmentManager fragmentManager = fragment.getChildFragmentManager();\r\n            fragmentManager\r\n                    .beginTransaction()\r\n                    .add(rxPermissionsFragment, TAG)\r\n                    .commitAllowingStateLoss();\r\n            fragmentManager.executePendingTransactions();\r\n        }\r\n        return rxPermissionsFragment;\r\n    }\r\n\r\n    private RxPermissionsFragment findRxPermissionsFragment(Fragment fragment) {\r\n        return (RxPermissionsFragment) fragment.getChildFragmentManager().findFragmentByTag(TAG);\r\n    }\r\n```\r\nAnd it works like a charm. However getChildFragmentManager() isn't supported before API 17, also I'm not sure whether this handling meets your expectations.\r\nIf you could accept this or provide any better solutions, it'll be great appreciated since I really need it in my project.\r\n\r\nBest,. I'm facing the same trouble. And as @trueangle said, I tried adding some codes in the RxPermissions class as below:\r\n```java\r\n    public RxPermissions(@NonNull Fragment fragment) {\r\n        mRxPermissionsFragment = getRxPermissionsFragment(fragment);\r\n    }\r\n\r\n    private RxPermissionsFragment getRxPermissionsFragment(Fragment fragment) {\r\n        RxPermissionsFragment rxPermissionsFragment = findRxPermissionsFragment(fragment);\r\n        boolean isNewInstance = rxPermissionsFragment == null;\r\n        if (isNewInstance) {\r\n            rxPermissionsFragment = new RxPermissionsFragment();\r\n            FragmentManager fragmentManager = fragment.getChildFragmentManager();\r\n            fragmentManager\r\n                    .beginTransaction()\r\n                    .add(rxPermissionsFragment, TAG)\r\n                    .commitAllowingStateLoss();\r\n            fragmentManager.executePendingTransactions();\r\n        }\r\n        return rxPermissionsFragment;\r\n    }\r\n\r\n    private RxPermissionsFragment findRxPermissionsFragment(Fragment fragment) {\r\n        return (RxPermissionsFragment) fragment.getChildFragmentManager().findFragmentByTag(TAG);\r\n    }\r\n```\r\nAnd it works like a charm. However getChildFragmentManager() isn't supported before API 17, also I'm not sure whether this handling meets your expectations.\r\nIf you could accept this or provide any better solutions, it'll be great appreciated since I really need it in my project.\r\n\r\nBest,. ",
    "tribbianiwang": "There are so many nullpointerexception,once i dont use lambda ,then code works fine. There are so many nullpointerexception,once i dont use lambda ,then code works fine. ",
    "prazjain": "my project is using: \r\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n    compile 'io.reactivex.rxjava2:rxjava:2.0.1'\r\n\r\nWhen I look at build.gradle for rxpermissions then I see this : \r\nrxJava = 'io.reactivex:rxjava:1.2.9'\r\n\r\n. I am using this : \r\n'com.tbruyelle.rxpermissions:rxpermissions:0.9.4@aar'\r\n\r\nI have just noticed there is a rxjava2 support version as well :\r\n'com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar'\r\n\r\nI will give it a try tonight.\r\n\r\n. I have tried rxjava2 version and it still fails.\r\nI think the problem here is that RxPermissions.request(...) method is returning a Observable from rxjava-1.1.6, and thats why chained observeOn method which passes AndroidScheduler.mainThread() is not compatible with that object.\r\n. my project is using: \r\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n    compile 'io.reactivex.rxjava2:rxjava:2.0.1'\r\n\r\nWhen I look at build.gradle for rxpermissions then I see this : \r\nrxJava = 'io.reactivex:rxjava:1.2.9'\r\n\r\n. I am using this : \r\n'com.tbruyelle.rxpermissions:rxpermissions:0.9.4@aar'\r\n\r\nI have just noticed there is a rxjava2 support version as well :\r\n'com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar'\r\n\r\nI will give it a try tonight.\r\n\r\n. I have tried rxjava2 version and it still fails.\r\nI think the problem here is that RxPermissions.request(...) method is returning a Observable from rxjava-1.1.6, and thats why chained observeOn method which passes AndroidScheduler.mainThread() is not compatible with that object.\r\n. ",
    "akidee": "I did that, but there is surely a way to compile my app with minSdkVersion=9 anyway, as it is documented in many examples like this: https://stackoverflow.com/questions/27095077/how-do-i-use-toolsoverridelibrary-in-a-build-gradle-file. I did that, but there is surely a way to compile my app with minSdkVersion=9 anyway, as it is documented in many examples like this: https://stackoverflow.com/questions/27095077/how-do-i-use-toolsoverridelibrary-in-a-build-gradle-file. ",
    "saket": "@sungerk what are the changes?. @sungerk what are the changes?. ",
    "super-hu": "The system only grants permission to apply explicit requests. Rather than the same permission group in the list of other permissions are also granted to the application\r\nso,Can you put a set of permissions or provide requestEach (String [] ... deinedPermissions)?. The system only grants permission to apply explicit requests. Rather than the same permission group in the list of other permissions are also granted to the application\r\nso,Can you put a set of permissions or provide requestEach (String [] ... deinedPermissions)?. ",
    "nmulcahey": "Yes, there are instructions here: https://www.apache.org/licenses/LICENSE-2.0#apply. Yes, there are instructions here: https://www.apache.org/licenses/LICENSE-2.0#apply. ",
    "yuzhongrong": "\u4ec0\u4e48\u60c5\u51b5\r\n. \u95ee\u9898\u6bd4\u8f83\u7d27\u6025\u8bf7\u544a\u77e5\u4ec0\u4e48\u95ee\u9898 \u6211\u662f\u5728\u4e00\u4e2aactivitie\u4e2d\u5f39\u4e00\u4e2apopwindow \u9009\u62e9\u76f8\u518c\u76f8\u673a\u7b49 \u70b9\u51fb\u76f8\u673aitem\u65f6\u5019\u6302\u4e86 10\u6b21\u67095\u52306\u6b21\u662f\u8fd9\u6837. \u62b1\u9519\u4e0a\u8bf4\u6211\u7684activiti \u4e3a\u7a7a \u53ef\u662f\u6211\u7684activitie\u4e0a\u4e0b\u6587\u662f\u4f20\u5230popwindow \u7684. \u4ec0\u4e48\u60c5\u51b5\r\n. \u95ee\u9898\u6bd4\u8f83\u7d27\u6025\u8bf7\u544a\u77e5\u4ec0\u4e48\u95ee\u9898 \u6211\u662f\u5728\u4e00\u4e2aactivitie\u4e2d\u5f39\u4e00\u4e2apopwindow \u9009\u62e9\u76f8\u518c\u76f8\u673a\u7b49 \u70b9\u51fb\u76f8\u673aitem\u65f6\u5019\u6302\u4e86 10\u6b21\u67095\u52306\u6b21\u662f\u8fd9\u6837. \u62b1\u9519\u4e0a\u8bf4\u6211\u7684activiti \u4e3a\u7a7a \u53ef\u662f\u6211\u7684activitie\u4e0a\u4e0b\u6587\u662f\u4f20\u5230popwindow \u7684. ",
    "MKevin3": "Handling this:\r\nshouldShowRequestPermissionRationale()\r\n\r\nSee the docs here\r\nhttps://developer.android.com/training/permissions/requesting.html. Handling this:\r\nshouldShowRequestPermissionRationale()\r\n\r\nSee the docs here\r\nhttps://developer.android.com/training/permissions/requesting.html. ",
    "09ae9c": "Fix it...\r\nbecause I have another module used the old version...\r\njust upgrade and clean project. Fix it...\r\nbecause I have another module used the old version...\r\njust upgrade and clean project. ",
    "AndroidDeveloperLB": "I'm not aware of such a class from the framework.. I can, but the logic is missing in the library, to use this class.\r\nThe logic should perform a check in the manifest. it will return \"permission-not-granted\" result, if a permission that's in the permission group AND is in the manifest - is not granted.\r\n\r\nThe reason that I ask about permission group, is that the user sees a single permission dialog, of the entire permission group. He sees \"contacts\", and not \"READ_CONTACTS\" , \"WRITE_CONTACTS\". They are merged together. \r\nSo, it makes sense for us developers to also not care about specifying the permissions in such a way, and it's enough to just request \"contacts\" permission group instead, via the code.. BTW, I've requested this in the past, here:\r\nhttps://issuetracker.google.com/issues/67883533\r\nPlease consider starring it.. It's only for auto-completion. This means that using a newly created permission will still work. Just not auto-completed.. No idea. I've requested it here:\r\nhttps://issuetracker.google.com/issues/67883533\r\n\r\nand maybe in the past. I don't remember. \r\nPlease consider starring it.. So how should we do it?\r\nThe only solution I can think of, is to create a function \"onPermissionsGranted\", that will be called in both \"onActivityResult\" (after it checks for permissions again) and here:\r\n\r\n```\r\nrxPermissions\r\n    .requestEach(...)\r\n    .subscribe(permission -> { \r\n        if (permission.granted) {\r\n            onPermissionsGranted\r\n        } else ...\r\n    });\r\n```\r\n\r\nCan you please recommend of what's the best way to handle this?\r\n. I'm not aware of such a class from the framework.. I can, but the logic is missing in the library, to use this class.\r\nThe logic should perform a check in the manifest. it will return \"permission-not-granted\" result, if a permission that's in the permission group AND is in the manifest - is not granted.\r\n\r\nThe reason that I ask about permission group, is that the user sees a single permission dialog, of the entire permission group. He sees \"contacts\", and not \"READ_CONTACTS\" , \"WRITE_CONTACTS\". They are merged together. \r\nSo, it makes sense for us developers to also not care about specifying the permissions in such a way, and it's enough to just request \"contacts\" permission group instead, via the code.. BTW, I've requested this in the past, here:\r\nhttps://issuetracker.google.com/issues/67883533\r\nPlease consider starring it.. It's only for auto-completion. This means that using a newly created permission will still work. Just not auto-completed.. No idea. I've requested it here:\r\nhttps://issuetracker.google.com/issues/67883533\r\n\r\nand maybe in the past. I don't remember. \r\nPlease consider starring it.. So how should we do it?\r\nThe only solution I can think of, is to create a function \"onPermissionsGranted\", that will be called in both \"onActivityResult\" (after it checks for permissions again) and here:\r\n\r\n```\r\nrxPermissions\r\n    .requestEach(...)\r\n    .subscribe(permission -> { \r\n        if (permission.granted) {\r\n            onPermissionsGranted\r\n        } else ...\r\n    });\r\n```\r\n\r\nCan you please recommend of what's the best way to handle this?\r\n. ",
    "xchengDroid": "In  `RxPermissions.class` ,the method `requestImplementation(final String... permissions)` has a bug that will always reference Activity instance when activity recreate\r\n\r\n    PublishSubject<Permission> subject = mRxPermissionsFragment.getSubjectByPermission(permission);\r\n    // Create a new subject if not exists\r\n    if (subject == null) {\r\n        unrequestedPermissions.add(permission);\r\n        subject = PublishSubject.create();\r\n        mRxPermissionsFragment.setSubjectForPermission(permission, subject);\r\n    }\r\n    \r\n    list.add(subject);\r\n\r\n   ### you can change it like this\r\n\r\n    PublishSubject<Permission> subject = mRxPermissionsFragment.getSubjectByPermission(permission);\r\n    // Create a new subject if not exists\r\n    if (subject == null) {\r\n        unrequestedPermissions.add(permission);\r\n    }\r\n    subject = PublishSubject.create();\r\n    mRxPermissionsFragment.setSubjectForPermission(permission, subject);\r\n\r\n    list.add(subject);\r\n\r\nIt will override next same permission that not reference the Activity instance  and never called  callback more than once when it destroyed\r\n\r\nsorry for my bad english\r\n### Thank you for your perusal\r\n\r\n\r\n\r\n\r\n\r\n. @epool It is very simple to reproduce this issue!\r\nyou just start an activity that make request permission at onCreate method then make it change screen orientation ,it will recreate, and click allow permission, the callback will be called more than once.. In  `RxPermissions.class` ,the method `requestImplementation(final String... permissions)` has a bug that will always reference Activity instance when activity recreate\r\n\r\n    PublishSubject<Permission> subject = mRxPermissionsFragment.getSubjectByPermission(permission);\r\n    // Create a new subject if not exists\r\n    if (subject == null) {\r\n        unrequestedPermissions.add(permission);\r\n        subject = PublishSubject.create();\r\n        mRxPermissionsFragment.setSubjectForPermission(permission, subject);\r\n    }\r\n    \r\n    list.add(subject);\r\n\r\n   ### you can change it like this\r\n\r\n    PublishSubject<Permission> subject = mRxPermissionsFragment.getSubjectByPermission(permission);\r\n    // Create a new subject if not exists\r\n    if (subject == null) {\r\n        unrequestedPermissions.add(permission);\r\n    }\r\n    subject = PublishSubject.create();\r\n    mRxPermissionsFragment.setSubjectForPermission(permission, subject);\r\n\r\n    list.add(subject);\r\n\r\nIt will override next same permission that not reference the Activity instance  and never called  callback more than once when it destroyed\r\n\r\nsorry for my bad english\r\n### Thank you for your perusal\r\n\r\n\r\n\r\n\r\n\r\n. @epool It is very simple to reproduce this issue!\r\nyou just start an activity that make request permission at onCreate method then make it change screen orientation ,it will recreate, and click allow permission, the callback will be called more than once.. ",
    "yleyvag": "The problem get solved adding\r\n`implementation 'org.reactivestreams:reactive-streams:1.0.1'`. The problem get solved adding\r\n`implementation 'org.reactivestreams:reactive-streams:1.0.1'`. ",
    "jcloquell": "Ok, my bad, I'm retarded, I forgot to add the permission to the manifest :man_facepalming: . Ok, my bad, I'm retarded, I forgot to add the permission to the manifest :man_facepalming: . ",
    "gurmeet-global": "@tbruyelle : Is above issue is due to  compile '**com.tbruyelle.rxpermissions:rxpermissions:0.7.0@aar**' old version gradle or we have to implement an extra check in over implementation?. @tbruyelle : Is above issue is due to  compile '**com.tbruyelle.rxpermissions:rxpermissions:0.7.0@aar**' old version gradle or we have to implement an extra check in over implementation?. "
}